(self["webpackChunkbrowser_extension"] = self["webpackChunkbrowser_extension"] || []).push([[737],{

/***/ 85220:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const ipRegex = __webpack_require__(35140);

const defaultOpts = {exact: false};

const v4str = `${ipRegex.v4().source}\\/(3[0-2]|[12]?[0-9])`;
const v6str = `${ipRegex.v6().source}\\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])`;

// can not precompile the non-exact regexes because global flag makes the regex object stateful
// which would require the user to reset .lastIndex on subsequent calls
const v4exact = new RegExp(`^${v4str}$`);
const v6exact = new RegExp(`^${v6str}$`);
const v46exact = new RegExp(`(?:^${v4str}$)|(?:^${v6str}$)`);

module.exports = ({exact} = defaultOpts) => exact ? v46exact : new RegExp(`(?:${v4str})|(?:${v6str})`, "g");
module.exports.v4 = ({exact} = defaultOpts) => exact ? v4exact : new RegExp(v4str, "g");
module.exports.v6 = ({exact} = defaultOpts) => exact ? v6exact : new RegExp(v6str, "g");


/***/ }),

/***/ 51258:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


/**
 * Module dependenices
 */

const clone = __webpack_require__(4031);
const typeOf = __webpack_require__(17884);
const isPlainObject = __webpack_require__(18093);

function cloneDeep(val, instanceClone) {
  switch (typeOf(val)) {
    case 'object':
      return cloneObjectDeep(val, instanceClone);
    case 'array':
      return cloneArrayDeep(val, instanceClone);
    default: {
      return clone(val);
    }
  }
}

function cloneObjectDeep(val, instanceClone) {
  if (typeof instanceClone === 'function') {
    return instanceClone(val);
  }
  if (instanceClone || isPlainObject(val)) {
    const res = new val.constructor();
    for (let key in val) {
      res[key] = cloneDeep(val[key], instanceClone);
    }
    return res;
  }
  return val;
}

function cloneArrayDeep(val, instanceClone) {
  const res = new val.constructor(val.length);
  for (let i = 0; i < val.length; i++) {
    res[i] = cloneDeep(val[i], instanceClone);
  }
  return res;
}

/**
 * Expose `cloneDeep`
 */

module.exports = cloneDeep;


/***/ }),

/***/ 35140:
/***/ ((module) => {

"use strict";


const word = '[a-fA-F\\d:]';
const b = options => options && options.includeBoundaries ?
	`(?:(?<=\\s|^)(?=${word})|(?<=${word})(?=\\s|$))` :
	'';

const v4 = '(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}';

const v6seg = '[a-fA-F\\d]{1,4}';
const v6 = `
(?:
(?:${v6seg}:){7}(?:${v6seg}|:)|                                    // 1:2:3:4:5:6:7::  1:2:3:4:5:6:7:8
(?:${v6seg}:){6}(?:${v4}|:${v6seg}|:)|                             // 1:2:3:4:5:6::    1:2:3:4:5:6::8   1:2:3:4:5:6::8  1:2:3:4:5:6::1.2.3.4
(?:${v6seg}:){5}(?::${v4}|(?::${v6seg}){1,2}|:)|                   // 1:2:3:4:5::      1:2:3:4:5::7:8   1:2:3:4:5::8    1:2:3:4:5::7:1.2.3.4
(?:${v6seg}:){4}(?:(?::${v6seg}){0,1}:${v4}|(?::${v6seg}){1,3}|:)| // 1:2:3:4::        1:2:3:4::6:7:8   1:2:3:4::8      1:2:3:4::6:7:1.2.3.4
(?:${v6seg}:){3}(?:(?::${v6seg}){0,2}:${v4}|(?::${v6seg}){1,4}|:)| // 1:2:3::          1:2:3::5:6:7:8   1:2:3::8        1:2:3::5:6:7:1.2.3.4
(?:${v6seg}:){2}(?:(?::${v6seg}){0,3}:${v4}|(?::${v6seg}){1,5}|:)| // 1:2::            1:2::4:5:6:7:8   1:2::8          1:2::4:5:6:7:1.2.3.4
(?:${v6seg}:){1}(?:(?::${v6seg}){0,4}:${v4}|(?::${v6seg}){1,6}|:)| // 1::              1::3:4:5:6:7:8   1::8            1::3:4:5:6:7:1.2.3.4
(?::(?:(?::${v6seg}){0,5}:${v4}|(?::${v6seg}){1,7}|:))             // ::2:3:4:5:6:7:8  ::2:3:4:5:6:7:8  ::8             ::1.2.3.4
)(?:%[0-9a-zA-Z]{1,})?                                             // %eth0            %1
`.replace(/\s*\/\/.*$/gm, '').replace(/\n/g, '').trim();

// Pre-compile only the exact regexes because adding a global flag make regexes stateful
const v46Exact = new RegExp(`(?:^${v4}$)|(?:^${v6}$)`);
const v4exact = new RegExp(`^${v4}$`);
const v6exact = new RegExp(`^${v6}$`);

const ip = options => options && options.exact ?
	v46Exact :
	new RegExp(`(?:${b(options)}${v4}${b(options)})|(?:${b(options)}${v6}${b(options)})`, 'g');

ip.v4 = options => options && options.exact ? v4exact : new RegExp(`${b(options)}${v4}${b(options)}`, 'g');
ip.v6 = options => options && options.exact ? v6exact : new RegExp(`${b(options)}${v6}${b(options)}`, 'g');

module.exports = ip;


/***/ }),

/***/ 32537:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const {v4, v6} = __webpack_require__(85220);

const re4 = v4({exact: true});
const re6 = v6({exact: true});

module.exports = str => re4.test(str) ? 4 : (re6.test(str) ? 6 : 0);
module.exports.v4 = str => re4.test(str);
module.exports.v6 = str => re6.test(str);


/***/ }),

/***/ 85183:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const ipRegex = __webpack_require__(35140);

const isIp = string => ipRegex({exact: true}).test(string);
isIp.v4 = string => ipRegex.v4({exact: true}).test(string);
isIp.v6 = string => ipRegex.v6({exact: true}).test(string);
isIp.version = string => isIp(string) ? (isIp.v4(string) ? 4 : 6) : undefined;

module.exports = isIp;


/***/ }),

/***/ 18093:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/*!
 * is-plain-object <https://github.com/jonschlinkert/is-plain-object>
 *
 * Copyright (c) 2014-2017, Jon Schlinkert.
 * Released under the MIT License.
 */



var isObject = __webpack_require__(85439);

function isObjectObject(o) {
  return isObject(o) === true
    && Object.prototype.toString.call(o) === '[object Object]';
}

module.exports = function isPlainObject(o) {
  var ctor,prot;

  if (isObjectObject(o) === false) return false;

  // If has modified constructor
  ctor = o.constructor;
  if (typeof ctor !== 'function') return false;

  // If has modified prototype
  prot = ctor.prototype;
  if (isObjectObject(prot) === false) return false;

  // If constructor does not have an Object-specific method
  if (prot.hasOwnProperty('isPrototypeOf') === false) {
    return false;
  }

  // Most likely a plain Object
  return true;
};


/***/ }),

/***/ 85439:
/***/ ((module) => {

"use strict";
/*!
 * isobject <https://github.com/jonschlinkert/isobject>
 *
 * Copyright (c) 2014-2017, Jon Schlinkert.
 * Released under the MIT License.
 */



module.exports = function isObject(val) {
  return val != null && typeof val === 'object' && Array.isArray(val) === false;
};


/***/ }),

/***/ 91801:
/***/ (function(module) {

(function (global, factory) {
	 true ? module.exports = factory() :
	0;
}(this, (function () { 'use strict';

	function createCommonjsModule(fn, module) {
		return module = { exports: {} }, fn(module, module.exports), module.exports;
	}

	var _global = createCommonjsModule(function (module) {
	// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
	var global = module.exports = typeof window != 'undefined' && window.Math == Math
	  ? window : typeof self != 'undefined' && self.Math == Math ? self
	  // eslint-disable-next-line no-new-func
	  : Function('return this')();
	if (typeof __g == 'number') { __g = global; } // eslint-disable-line no-undef
	});

	var _core = createCommonjsModule(function (module) {
	var core = module.exports = { version: '2.6.5' };
	if (typeof __e == 'number') { __e = core; } // eslint-disable-line no-undef
	});
	var _core_1 = _core.version;

	var _isObject = function (it) {
	  return typeof it === 'object' ? it !== null : typeof it === 'function';
	};

	var _anObject = function (it) {
	  if (!_isObject(it)) { throw TypeError(it + ' is not an object!'); }
	  return it;
	};

	var _fails = function (exec) {
	  try {
	    return !!exec();
	  } catch (e) {
	    return true;
	  }
	};

	// Thank's IE8 for his funny defineProperty
	var _descriptors = !_fails(function () {
	  return Object.defineProperty({}, 'a', { get: function () { return 7; } }).a != 7;
	});

	var document = _global.document;
	// typeof document.createElement is 'object' in old IE
	var is = _isObject(document) && _isObject(document.createElement);
	var _domCreate = function (it) {
	  return is ? document.createElement(it) : {};
	};

	var _ie8DomDefine = !_descriptors && !_fails(function () {
	  return Object.defineProperty(_domCreate('div'), 'a', { get: function () { return 7; } }).a != 7;
	});

	// 7.1.1 ToPrimitive(input [, PreferredType])

	// instead of the ES6 spec version, we didn't implement @@toPrimitive case
	// and the second argument - flag - preferred type is a string
	var _toPrimitive = function (it, S) {
	  if (!_isObject(it)) { return it; }
	  var fn, val;
	  if (S && typeof (fn = it.toString) == 'function' && !_isObject(val = fn.call(it))) { return val; }
	  if (typeof (fn = it.valueOf) == 'function' && !_isObject(val = fn.call(it))) { return val; }
	  if (!S && typeof (fn = it.toString) == 'function' && !_isObject(val = fn.call(it))) { return val; }
	  throw TypeError("Can't convert object to primitive value");
	};

	var dP = Object.defineProperty;

	var f = _descriptors ? Object.defineProperty : function defineProperty(O, P, Attributes) {
	  _anObject(O);
	  P = _toPrimitive(P, true);
	  _anObject(Attributes);
	  if (_ie8DomDefine) { try {
	    return dP(O, P, Attributes);
	  } catch (e) { /* empty */ } }
	  if ('get' in Attributes || 'set' in Attributes) { throw TypeError('Accessors not supported!'); }
	  if ('value' in Attributes) { O[P] = Attributes.value; }
	  return O;
	};

	var _objectDp = {
		f: f
	};

	var _propertyDesc = function (bitmap, value) {
	  return {
	    enumerable: !(bitmap & 1),
	    configurable: !(bitmap & 2),
	    writable: !(bitmap & 4),
	    value: value
	  };
	};

	var _hide = _descriptors ? function (object, key, value) {
	  return _objectDp.f(object, key, _propertyDesc(1, value));
	} : function (object, key, value) {
	  object[key] = value;
	  return object;
	};

	var hasOwnProperty = {}.hasOwnProperty;
	var _has = function (it, key) {
	  return hasOwnProperty.call(it, key);
	};

	var id = 0;
	var px = Math.random();
	var _uid = function (key) {
	  return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));
	};

	var _library = false;

	var _shared = createCommonjsModule(function (module) {
	var SHARED = '__core-js_shared__';
	var store = _global[SHARED] || (_global[SHARED] = {});

	(module.exports = function (key, value) {
	  return store[key] || (store[key] = value !== undefined ? value : {});
	})('versions', []).push({
	  version: _core.version,
	  mode: _library ? 'pure' : 'global',
	  copyright: '© 2019 Denis Pushkarev (zloirock.ru)'
	});
	});

	var _functionToString = _shared('native-function-to-string', Function.toString);

	var _redefine = createCommonjsModule(function (module) {
	var SRC = _uid('src');

	var TO_STRING = 'toString';
	var TPL = ('' + _functionToString).split(TO_STRING);

	_core.inspectSource = function (it) {
	  return _functionToString.call(it);
	};

	(module.exports = function (O, key, val, safe) {
	  var isFunction = typeof val == 'function';
	  if (isFunction) { _has(val, 'name') || _hide(val, 'name', key); }
	  if (O[key] === val) { return; }
	  if (isFunction) { _has(val, SRC) || _hide(val, SRC, O[key] ? '' + O[key] : TPL.join(String(key))); }
	  if (O === _global) {
	    O[key] = val;
	  } else if (!safe) {
	    delete O[key];
	    _hide(O, key, val);
	  } else if (O[key]) {
	    O[key] = val;
	  } else {
	    _hide(O, key, val);
	  }
	// add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative
	})(Function.prototype, TO_STRING, function toString() {
	  return typeof this == 'function' && this[SRC] || _functionToString.call(this);
	});
	});

	var _aFunction = function (it) {
	  if (typeof it != 'function') { throw TypeError(it + ' is not a function!'); }
	  return it;
	};

	// optional / simple context binding

	var _ctx = function (fn, that, length) {
	  _aFunction(fn);
	  if (that === undefined) { return fn; }
	  switch (length) {
	    case 1: return function (a) {
	      return fn.call(that, a);
	    };
	    case 2: return function (a, b) {
	      return fn.call(that, a, b);
	    };
	    case 3: return function (a, b, c) {
	      return fn.call(that, a, b, c);
	    };
	  }
	  return function (/* ...args */) {
	    return fn.apply(that, arguments);
	  };
	};

	var PROTOTYPE = 'prototype';

	var $export = function (type, name, source) {
	  var IS_FORCED = type & $export.F;
	  var IS_GLOBAL = type & $export.G;
	  var IS_STATIC = type & $export.S;
	  var IS_PROTO = type & $export.P;
	  var IS_BIND = type & $export.B;
	  var target = IS_GLOBAL ? _global : IS_STATIC ? _global[name] || (_global[name] = {}) : (_global[name] || {})[PROTOTYPE];
	  var exports = IS_GLOBAL ? _core : _core[name] || (_core[name] = {});
	  var expProto = exports[PROTOTYPE] || (exports[PROTOTYPE] = {});
	  var key, own, out, exp;
	  if (IS_GLOBAL) { source = name; }
	  for (key in source) {
	    // contains in native
	    own = !IS_FORCED && target && target[key] !== undefined;
	    // export native or passed
	    out = (own ? target : source)[key];
	    // bind timers to global for call from export context
	    exp = IS_BIND && own ? _ctx(out, _global) : IS_PROTO && typeof out == 'function' ? _ctx(Function.call, out) : out;
	    // extend global
	    if (target) { _redefine(target, key, out, type & $export.U); }
	    // export
	    if (exports[key] != out) { _hide(exports, key, exp); }
	    if (IS_PROTO && expProto[key] != out) { expProto[key] = out; }
	  }
	};
	_global.core = _core;
	// type bitmap
	$export.F = 1;   // forced
	$export.G = 2;   // global
	$export.S = 4;   // static
	$export.P = 8;   // proto
	$export.B = 16;  // bind
	$export.W = 32;  // wrap
	$export.U = 64;  // safe
	$export.R = 128; // real proto method for `library`
	var _export = $export;

	// 7.1.4 ToInteger
	var ceil = Math.ceil;
	var floor = Math.floor;
	var _toInteger = function (it) {
	  return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);
	};

	// 7.2.1 RequireObjectCoercible(argument)
	var _defined = function (it) {
	  if (it == undefined) { throw TypeError("Can't call method on  " + it); }
	  return it;
	};

	// true  -> String#at
	// false -> String#codePointAt
	var _stringAt = function (TO_STRING) {
	  return function (that, pos) {
	    var s = String(_defined(that));
	    var i = _toInteger(pos);
	    var l = s.length;
	    var a, b;
	    if (i < 0 || i >= l) { return TO_STRING ? '' : undefined; }
	    a = s.charCodeAt(i);
	    return a < 0xd800 || a > 0xdbff || i + 1 === l || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff
	      ? TO_STRING ? s.charAt(i) : a
	      : TO_STRING ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;
	  };
	};

	var $at = _stringAt(false);
	_export(_export.P, 'String', {
	  // 21.1.3.3 String.prototype.codePointAt(pos)
	  codePointAt: function codePointAt(pos) {
	    return $at(this, pos);
	  }
	});

	var codePointAt = _core.String.codePointAt;

	var max = Math.max;
	var min = Math.min;
	var _toAbsoluteIndex = function (index, length) {
	  index = _toInteger(index);
	  return index < 0 ? max(index + length, 0) : min(index, length);
	};

	var fromCharCode = String.fromCharCode;
	var $fromCodePoint = String.fromCodePoint;

	// length should be 1, old FF problem
	_export(_export.S + _export.F * (!!$fromCodePoint && $fromCodePoint.length != 1), 'String', {
	  // 21.1.2.2 String.fromCodePoint(...codePoints)
	  fromCodePoint: function fromCodePoint(x) {
	    var arguments$1 = arguments;
	 // eslint-disable-line no-unused-vars
	    var res = [];
	    var aLen = arguments.length;
	    var i = 0;
	    var code;
	    while (aLen > i) {
	      code = +arguments$1[i++];
	      if (_toAbsoluteIndex(code, 0x10ffff) !== code) { throw RangeError(code + ' is not a valid code point'); }
	      res.push(code < 0x10000
	        ? fromCharCode(code)
	        : fromCharCode(((code -= 0x10000) >> 10) + 0xd800, code % 0x400 + 0xdc00)
	      );
	    } return res.join('');
	  }
	});

	var fromCodePoint = _core.String.fromCodePoint;

	// This is a generated file. Do not edit.
	var Space_Separator = /[\u1680\u2000-\u200A\u202F\u205F\u3000]/;
	var ID_Start = /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u08A0-\u08B4\u08B6-\u08BD\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312E\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FEA\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF2D-\uDF4A\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC03-\uDC37\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDF00-\uDF19]|\uD806[\uDCA0-\uDCDF\uDCFF\uDE00\uDE0B-\uDE32\uDE3A\uDE50\uDE5C-\uDE83\uDE86-\uDE89\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC72-\uDC8F\uDD00-\uDD06\uDD08\uDD09\uDD0B-\uDD30\uDD46]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872\uD874-\uD879][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50\uDF93-\uDF9F\uDFE0\uDFE1]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00-\uDD1E\uDD70-\uDEFB]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD83A[\uDC00-\uDCC4\uDD00-\uDD43]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0]|\uD87E[\uDC00-\uDE1D]/;
	var ID_Continue = /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u0860-\u086A\u08A0-\u08B4\u08B6-\u08BD\u08D4-\u08E1\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u09FC\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9-\u0AFF\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C80-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D00-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D54-\u0D57\u0D5F-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19D9\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1C80-\u1C88\u1CD0-\u1CD2\u1CD4-\u1CF9\u1D00-\u1DF9\u1DFB-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u2E2F\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099\u309A\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312E\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FEA\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDDFD\uDE80-\uDE9C\uDEA0-\uDED0\uDEE0\uDF00-\uDF1F\uDF2D-\uDF4A\uDF50-\uDF7A\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCA0-\uDCA9\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00-\uDE03\uDE05\uDE06\uDE0C-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE38-\uDE3A\uDE3F\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE6\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC00-\uDC46\uDC66-\uDC6F\uDC7F-\uDCBA\uDCD0-\uDCE8\uDCF0-\uDCF9\uDD00-\uDD34\uDD36-\uDD3F\uDD50-\uDD73\uDD76\uDD80-\uDDC4\uDDCA-\uDDCC\uDDD0-\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE37\uDE3E\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEEA\uDEF0-\uDEF9\uDF00-\uDF03\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3C-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF50\uDF57\uDF5D-\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC00-\uDC4A\uDC50-\uDC59\uDC80-\uDCC5\uDCC7\uDCD0-\uDCD9\uDD80-\uDDB5\uDDB8-\uDDC0\uDDD8-\uDDDD\uDE00-\uDE40\uDE44\uDE50-\uDE59\uDE80-\uDEB7\uDEC0-\uDEC9\uDF00-\uDF19\uDF1D-\uDF2B\uDF30-\uDF39]|\uD806[\uDCA0-\uDCE9\uDCFF\uDE00-\uDE3E\uDE47\uDE50-\uDE83\uDE86-\uDE99\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC36\uDC38-\uDC40\uDC50-\uDC59\uDC72-\uDC8F\uDC92-\uDCA7\uDCA9-\uDCB6\uDD00-\uDD06\uDD08\uDD09\uDD0B-\uDD36\uDD3A\uDD3C\uDD3D\uDD3F-\uDD47\uDD50-\uDD59]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872\uD874-\uD879][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE60-\uDE69\uDED0-\uDEED\uDEF0-\uDEF4\uDF00-\uDF36\uDF40-\uDF43\uDF50-\uDF59\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50-\uDF7E\uDF8F-\uDF9F\uDFE0\uDFE1]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00-\uDD1E\uDD70-\uDEFB]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99\uDC9D\uDC9E]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB\uDFCE-\uDFFF]|\uD836[\uDE00-\uDE36\uDE3B-\uDE6C\uDE75\uDE84\uDE9B-\uDE9F\uDEA1-\uDEAF]|\uD838[\uDC00-\uDC06\uDC08-\uDC18\uDC1B-\uDC21\uDC23\uDC24\uDC26-\uDC2A]|\uD83A[\uDC00-\uDCC4\uDCD0-\uDCD6\uDD00-\uDD4A\uDD50-\uDD59]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0]|\uD87E[\uDC00-\uDE1D]|\uDB40[\uDD00-\uDDEF]/;

	var unicode = {
		Space_Separator: Space_Separator,
		ID_Start: ID_Start,
		ID_Continue: ID_Continue
	};

	var util = {
	    isSpaceSeparator: function isSpaceSeparator (c) {
	        return typeof c === 'string' && unicode.Space_Separator.test(c)
	    },

	    isIdStartChar: function isIdStartChar (c) {
	        return typeof c === 'string' && (
	            (c >= 'a' && c <= 'z') ||
	        (c >= 'A' && c <= 'Z') ||
	        (c === '$') || (c === '_') ||
	        unicode.ID_Start.test(c)
	        )
	    },

	    isIdContinueChar: function isIdContinueChar (c) {
	        return typeof c === 'string' && (
	            (c >= 'a' && c <= 'z') ||
	        (c >= 'A' && c <= 'Z') ||
	        (c >= '0' && c <= '9') ||
	        (c === '$') || (c === '_') ||
	        (c === '\u200C') || (c === '\u200D') ||
	        unicode.ID_Continue.test(c)
	        )
	    },

	    isDigit: function isDigit (c) {
	        return typeof c === 'string' && /[0-9]/.test(c)
	    },

	    isHexDigit: function isHexDigit (c) {
	        return typeof c === 'string' && /[0-9A-Fa-f]/.test(c)
	    },
	};

	var source;
	var parseState;
	var stack;
	var pos;
	var line;
	var column;
	var token;
	var key;
	var root;

	var parse = function parse (text, reviver) {
	    source = String(text);
	    parseState = 'start';
	    stack = [];
	    pos = 0;
	    line = 1;
	    column = 0;
	    token = undefined;
	    key = undefined;
	    root = undefined;

	    do {
	        token = lex();

	        // This code is unreachable.
	        // if (!parseStates[parseState]) {
	        //     throw invalidParseState()
	        // }

	        parseStates[parseState]();
	    } while (token.type !== 'eof')

	    if (typeof reviver === 'function') {
	        return internalize({'': root}, '', reviver)
	    }

	    return root
	};

	function internalize (holder, name, reviver) {
	    var value = holder[name];
	    if (value != null && typeof value === 'object') {
	        if (Array.isArray(value)) {
	            for (var i = 0; i < value.length; i++) {
	                var key = String(i);
	                var replacement = internalize(value, key, reviver);
	                if (replacement === undefined) {
	                    delete value[key];
	                } else {
	                    Object.defineProperty(value, key, {
	                        value: replacement,
	                        writable: true,
	                        enumerable: true,
	                        configurable: true,
	                    });
	                }
	            }
	        } else {
	            for (var key$1 in value) {
	                var replacement$1 = internalize(value, key$1, reviver);
	                if (replacement$1 === undefined) {
	                    delete value[key$1];
	                } else {
	                    Object.defineProperty(value, key$1, {
	                        value: replacement$1,
	                        writable: true,
	                        enumerable: true,
	                        configurable: true,
	                    });
	                }
	            }
	        }
	    }

	    return reviver.call(holder, name, value)
	}

	var lexState;
	var buffer;
	var doubleQuote;
	var sign;
	var c;

	function lex () {
	    lexState = 'default';
	    buffer = '';
	    doubleQuote = false;
	    sign = 1;

	    for (;;) {
	        c = peek();

	        // This code is unreachable.
	        // if (!lexStates[lexState]) {
	        //     throw invalidLexState(lexState)
	        // }

	        var token = lexStates[lexState]();
	        if (token) {
	            return token
	        }
	    }
	}

	function peek () {
	    if (source[pos]) {
	        return String.fromCodePoint(source.codePointAt(pos))
	    }
	}

	function read () {
	    var c = peek();

	    if (c === '\n') {
	        line++;
	        column = 0;
	    } else if (c) {
	        column += c.length;
	    } else {
	        column++;
	    }

	    if (c) {
	        pos += c.length;
	    }

	    return c
	}

	var lexStates = {
	    default: function default$1 () {
	        switch (c) {
	        case '\t':
	        case '\v':
	        case '\f':
	        case ' ':
	        case '\u00A0':
	        case '\uFEFF':
	        case '\n':
	        case '\r':
	        case '\u2028':
	        case '\u2029':
	            read();
	            return

	        case '/':
	            read();
	            lexState = 'comment';
	            return

	        case undefined:
	            read();
	            return newToken('eof')
	        }

	        if (util.isSpaceSeparator(c)) {
	            read();
	            return
	        }

	        // This code is unreachable.
	        // if (!lexStates[parseState]) {
	        //     throw invalidLexState(parseState)
	        // }

	        return lexStates[parseState]()
	    },

	    comment: function comment () {
	        switch (c) {
	        case '*':
	            read();
	            lexState = 'multiLineComment';
	            return

	        case '/':
	            read();
	            lexState = 'singleLineComment';
	            return
	        }

	        throw invalidChar(read())
	    },

	    multiLineComment: function multiLineComment () {
	        switch (c) {
	        case '*':
	            read();
	            lexState = 'multiLineCommentAsterisk';
	            return

	        case undefined:
	            throw invalidChar(read())
	        }

	        read();
	    },

	    multiLineCommentAsterisk: function multiLineCommentAsterisk () {
	        switch (c) {
	        case '*':
	            read();
	            return

	        case '/':
	            read();
	            lexState = 'default';
	            return

	        case undefined:
	            throw invalidChar(read())
	        }

	        read();
	        lexState = 'multiLineComment';
	    },

	    singleLineComment: function singleLineComment () {
	        switch (c) {
	        case '\n':
	        case '\r':
	        case '\u2028':
	        case '\u2029':
	            read();
	            lexState = 'default';
	            return

	        case undefined:
	            read();
	            return newToken('eof')
	        }

	        read();
	    },

	    value: function value () {
	        switch (c) {
	        case '{':
	        case '[':
	            return newToken('punctuator', read())

	        case 'n':
	            read();
	            literal('ull');
	            return newToken('null', null)

	        case 't':
	            read();
	            literal('rue');
	            return newToken('boolean', true)

	        case 'f':
	            read();
	            literal('alse');
	            return newToken('boolean', false)

	        case '-':
	        case '+':
	            if (read() === '-') {
	                sign = -1;
	            }

	            lexState = 'sign';
	            return

	        case '.':
	            buffer = read();
	            lexState = 'decimalPointLeading';
	            return

	        case '0':
	            buffer = read();
	            lexState = 'zero';
	            return

	        case '1':
	        case '2':
	        case '3':
	        case '4':
	        case '5':
	        case '6':
	        case '7':
	        case '8':
	        case '9':
	            buffer = read();
	            lexState = 'decimalInteger';
	            return

	        case 'I':
	            read();
	            literal('nfinity');
	            return newToken('numeric', Infinity)

	        case 'N':
	            read();
	            literal('aN');
	            return newToken('numeric', NaN)

	        case '"':
	        case "'":
	            doubleQuote = (read() === '"');
	            buffer = '';
	            lexState = 'string';
	            return
	        }

	        throw invalidChar(read())
	    },

	    identifierNameStartEscape: function identifierNameStartEscape () {
	        if (c !== 'u') {
	            throw invalidChar(read())
	        }

	        read();
	        var u = unicodeEscape();
	        switch (u) {
	        case '$':
	        case '_':
	            break

	        default:
	            if (!util.isIdStartChar(u)) {
	                throw invalidIdentifier()
	            }

	            break
	        }

	        buffer += u;
	        lexState = 'identifierName';
	    },

	    identifierName: function identifierName () {
	        switch (c) {
	        case '$':
	        case '_':
	        case '\u200C':
	        case '\u200D':
	            buffer += read();
	            return

	        case '\\':
	            read();
	            lexState = 'identifierNameEscape';
	            return
	        }

	        if (util.isIdContinueChar(c)) {
	            buffer += read();
	            return
	        }

	        return newToken('identifier', buffer)
	    },

	    identifierNameEscape: function identifierNameEscape () {
	        if (c !== 'u') {
	            throw invalidChar(read())
	        }

	        read();
	        var u = unicodeEscape();
	        switch (u) {
	        case '$':
	        case '_':
	        case '\u200C':
	        case '\u200D':
	            break

	        default:
	            if (!util.isIdContinueChar(u)) {
	                throw invalidIdentifier()
	            }

	            break
	        }

	        buffer += u;
	        lexState = 'identifierName';
	    },

	    sign: function sign$1 () {
	        switch (c) {
	        case '.':
	            buffer = read();
	            lexState = 'decimalPointLeading';
	            return

	        case '0':
	            buffer = read();
	            lexState = 'zero';
	            return

	        case '1':
	        case '2':
	        case '3':
	        case '4':
	        case '5':
	        case '6':
	        case '7':
	        case '8':
	        case '9':
	            buffer = read();
	            lexState = 'decimalInteger';
	            return

	        case 'I':
	            read();
	            literal('nfinity');
	            return newToken('numeric', sign * Infinity)

	        case 'N':
	            read();
	            literal('aN');
	            return newToken('numeric', NaN)
	        }

	        throw invalidChar(read())
	    },

	    zero: function zero () {
	        switch (c) {
	        case '.':
	            buffer += read();
	            lexState = 'decimalPoint';
	            return

	        case 'e':
	        case 'E':
	            buffer += read();
	            lexState = 'decimalExponent';
	            return

	        case 'x':
	        case 'X':
	            buffer += read();
	            lexState = 'hexadecimal';
	            return
	        }

	        return newToken('numeric', sign * 0)
	    },

	    decimalInteger: function decimalInteger () {
	        switch (c) {
	        case '.':
	            buffer += read();
	            lexState = 'decimalPoint';
	            return

	        case 'e':
	        case 'E':
	            buffer += read();
	            lexState = 'decimalExponent';
	            return
	        }

	        if (util.isDigit(c)) {
	            buffer += read();
	            return
	        }

	        return newToken('numeric', sign * Number(buffer))
	    },

	    decimalPointLeading: function decimalPointLeading () {
	        if (util.isDigit(c)) {
	            buffer += read();
	            lexState = 'decimalFraction';
	            return
	        }

	        throw invalidChar(read())
	    },

	    decimalPoint: function decimalPoint () {
	        switch (c) {
	        case 'e':
	        case 'E':
	            buffer += read();
	            lexState = 'decimalExponent';
	            return
	        }

	        if (util.isDigit(c)) {
	            buffer += read();
	            lexState = 'decimalFraction';
	            return
	        }

	        return newToken('numeric', sign * Number(buffer))
	    },

	    decimalFraction: function decimalFraction () {
	        switch (c) {
	        case 'e':
	        case 'E':
	            buffer += read();
	            lexState = 'decimalExponent';
	            return
	        }

	        if (util.isDigit(c)) {
	            buffer += read();
	            return
	        }

	        return newToken('numeric', sign * Number(buffer))
	    },

	    decimalExponent: function decimalExponent () {
	        switch (c) {
	        case '+':
	        case '-':
	            buffer += read();
	            lexState = 'decimalExponentSign';
	            return
	        }

	        if (util.isDigit(c)) {
	            buffer += read();
	            lexState = 'decimalExponentInteger';
	            return
	        }

	        throw invalidChar(read())
	    },

	    decimalExponentSign: function decimalExponentSign () {
	        if (util.isDigit(c)) {
	            buffer += read();
	            lexState = 'decimalExponentInteger';
	            return
	        }

	        throw invalidChar(read())
	    },

	    decimalExponentInteger: function decimalExponentInteger () {
	        if (util.isDigit(c)) {
	            buffer += read();
	            return
	        }

	        return newToken('numeric', sign * Number(buffer))
	    },

	    hexadecimal: function hexadecimal () {
	        if (util.isHexDigit(c)) {
	            buffer += read();
	            lexState = 'hexadecimalInteger';
	            return
	        }

	        throw invalidChar(read())
	    },

	    hexadecimalInteger: function hexadecimalInteger () {
	        if (util.isHexDigit(c)) {
	            buffer += read();
	            return
	        }

	        return newToken('numeric', sign * Number(buffer))
	    },

	    string: function string () {
	        switch (c) {
	        case '\\':
	            read();
	            buffer += escape();
	            return

	        case '"':
	            if (doubleQuote) {
	                read();
	                return newToken('string', buffer)
	            }

	            buffer += read();
	            return

	        case "'":
	            if (!doubleQuote) {
	                read();
	                return newToken('string', buffer)
	            }

	            buffer += read();
	            return

	        case '\n':
	        case '\r':
	            throw invalidChar(read())

	        case '\u2028':
	        case '\u2029':
	            separatorChar(c);
	            break

	        case undefined:
	            throw invalidChar(read())
	        }

	        buffer += read();
	    },

	    start: function start () {
	        switch (c) {
	        case '{':
	        case '[':
	            return newToken('punctuator', read())

	        // This code is unreachable since the default lexState handles eof.
	        // case undefined:
	        //     return newToken('eof')
	        }

	        lexState = 'value';
	    },

	    beforePropertyName: function beforePropertyName () {
	        switch (c) {
	        case '$':
	        case '_':
	            buffer = read();
	            lexState = 'identifierName';
	            return

	        case '\\':
	            read();
	            lexState = 'identifierNameStartEscape';
	            return

	        case '}':
	            return newToken('punctuator', read())

	        case '"':
	        case "'":
	            doubleQuote = (read() === '"');
	            lexState = 'string';
	            return
	        }

	        if (util.isIdStartChar(c)) {
	            buffer += read();
	            lexState = 'identifierName';
	            return
	        }

	        throw invalidChar(read())
	    },

	    afterPropertyName: function afterPropertyName () {
	        if (c === ':') {
	            return newToken('punctuator', read())
	        }

	        throw invalidChar(read())
	    },

	    beforePropertyValue: function beforePropertyValue () {
	        lexState = 'value';
	    },

	    afterPropertyValue: function afterPropertyValue () {
	        switch (c) {
	        case ',':
	        case '}':
	            return newToken('punctuator', read())
	        }

	        throw invalidChar(read())
	    },

	    beforeArrayValue: function beforeArrayValue () {
	        if (c === ']') {
	            return newToken('punctuator', read())
	        }

	        lexState = 'value';
	    },

	    afterArrayValue: function afterArrayValue () {
	        switch (c) {
	        case ',':
	        case ']':
	            return newToken('punctuator', read())
	        }

	        throw invalidChar(read())
	    },

	    end: function end () {
	        // This code is unreachable since it's handled by the default lexState.
	        // if (c === undefined) {
	        //     read()
	        //     return newToken('eof')
	        // }

	        throw invalidChar(read())
	    },
	};

	function newToken (type, value) {
	    return {
	        type: type,
	        value: value,
	        line: line,
	        column: column,
	    }
	}

	function literal (s) {
	    for (var i = 0, list = s; i < list.length; i += 1) {
	        var c = list[i];

	        var p = peek();

	        if (p !== c) {
	            throw invalidChar(read())
	        }

	        read();
	    }
	}

	function escape () {
	    var c = peek();
	    switch (c) {
	    case 'b':
	        read();
	        return '\b'

	    case 'f':
	        read();
	        return '\f'

	    case 'n':
	        read();
	        return '\n'

	    case 'r':
	        read();
	        return '\r'

	    case 't':
	        read();
	        return '\t'

	    case 'v':
	        read();
	        return '\v'

	    case '0':
	        read();
	        if (util.isDigit(peek())) {
	            throw invalidChar(read())
	        }

	        return '\0'

	    case 'x':
	        read();
	        return hexEscape()

	    case 'u':
	        read();
	        return unicodeEscape()

	    case '\n':
	    case '\u2028':
	    case '\u2029':
	        read();
	        return ''

	    case '\r':
	        read();
	        if (peek() === '\n') {
	            read();
	        }

	        return ''

	    case '1':
	    case '2':
	    case '3':
	    case '4':
	    case '5':
	    case '6':
	    case '7':
	    case '8':
	    case '9':
	        throw invalidChar(read())

	    case undefined:
	        throw invalidChar(read())
	    }

	    return read()
	}

	function hexEscape () {
	    var buffer = '';
	    var c = peek();

	    if (!util.isHexDigit(c)) {
	        throw invalidChar(read())
	    }

	    buffer += read();

	    c = peek();
	    if (!util.isHexDigit(c)) {
	        throw invalidChar(read())
	    }

	    buffer += read();

	    return String.fromCodePoint(parseInt(buffer, 16))
	}

	function unicodeEscape () {
	    var buffer = '';
	    var count = 4;

	    while (count-- > 0) {
	        var c = peek();
	        if (!util.isHexDigit(c)) {
	            throw invalidChar(read())
	        }

	        buffer += read();
	    }

	    return String.fromCodePoint(parseInt(buffer, 16))
	}

	var parseStates = {
	    start: function start () {
	        if (token.type === 'eof') {
	            throw invalidEOF()
	        }

	        push();
	    },

	    beforePropertyName: function beforePropertyName () {
	        switch (token.type) {
	        case 'identifier':
	        case 'string':
	            key = token.value;
	            parseState = 'afterPropertyName';
	            return

	        case 'punctuator':
	            // This code is unreachable since it's handled by the lexState.
	            // if (token.value !== '}') {
	            //     throw invalidToken()
	            // }

	            pop();
	            return

	        case 'eof':
	            throw invalidEOF()
	        }

	        // This code is unreachable since it's handled by the lexState.
	        // throw invalidToken()
	    },

	    afterPropertyName: function afterPropertyName () {
	        // This code is unreachable since it's handled by the lexState.
	        // if (token.type !== 'punctuator' || token.value !== ':') {
	        //     throw invalidToken()
	        // }

	        if (token.type === 'eof') {
	            throw invalidEOF()
	        }

	        parseState = 'beforePropertyValue';
	    },

	    beforePropertyValue: function beforePropertyValue () {
	        if (token.type === 'eof') {
	            throw invalidEOF()
	        }

	        push();
	    },

	    beforeArrayValue: function beforeArrayValue () {
	        if (token.type === 'eof') {
	            throw invalidEOF()
	        }

	        if (token.type === 'punctuator' && token.value === ']') {
	            pop();
	            return
	        }

	        push();
	    },

	    afterPropertyValue: function afterPropertyValue () {
	        // This code is unreachable since it's handled by the lexState.
	        // if (token.type !== 'punctuator') {
	        //     throw invalidToken()
	        // }

	        if (token.type === 'eof') {
	            throw invalidEOF()
	        }

	        switch (token.value) {
	        case ',':
	            parseState = 'beforePropertyName';
	            return

	        case '}':
	            pop();
	        }

	        // This code is unreachable since it's handled by the lexState.
	        // throw invalidToken()
	    },

	    afterArrayValue: function afterArrayValue () {
	        // This code is unreachable since it's handled by the lexState.
	        // if (token.type !== 'punctuator') {
	        //     throw invalidToken()
	        // }

	        if (token.type === 'eof') {
	            throw invalidEOF()
	        }

	        switch (token.value) {
	        case ',':
	            parseState = 'beforeArrayValue';
	            return

	        case ']':
	            pop();
	        }

	        // This code is unreachable since it's handled by the lexState.
	        // throw invalidToken()
	    },

	    end: function end () {
	        // This code is unreachable since it's handled by the lexState.
	        // if (token.type !== 'eof') {
	        //     throw invalidToken()
	        // }
	    },
	};

	function push () {
	    var value;

	    switch (token.type) {
	    case 'punctuator':
	        switch (token.value) {
	        case '{':
	            value = {};
	            break

	        case '[':
	            value = [];
	            break
	        }

	        break

	    case 'null':
	    case 'boolean':
	    case 'numeric':
	    case 'string':
	        value = token.value;
	        break

	    // This code is unreachable.
	    // default:
	    //     throw invalidToken()
	    }

	    if (root === undefined) {
	        root = value;
	    } else {
	        var parent = stack[stack.length - 1];
	        if (Array.isArray(parent)) {
	            parent.push(value);
	        } else {
	            Object.defineProperty(parent, key, {
	                value: value,
	                writable: true,
	                enumerable: true,
	                configurable: true,
	            });
	        }
	    }

	    if (value !== null && typeof value === 'object') {
	        stack.push(value);

	        if (Array.isArray(value)) {
	            parseState = 'beforeArrayValue';
	        } else {
	            parseState = 'beforePropertyName';
	        }
	    } else {
	        var current = stack[stack.length - 1];
	        if (current == null) {
	            parseState = 'end';
	        } else if (Array.isArray(current)) {
	            parseState = 'afterArrayValue';
	        } else {
	            parseState = 'afterPropertyValue';
	        }
	    }
	}

	function pop () {
	    stack.pop();

	    var current = stack[stack.length - 1];
	    if (current == null) {
	        parseState = 'end';
	    } else if (Array.isArray(current)) {
	        parseState = 'afterArrayValue';
	    } else {
	        parseState = 'afterPropertyValue';
	    }
	}

	// This code is unreachable.
	// function invalidParseState () {
	//     return new Error(`JSON5: invalid parse state '${parseState}'`)
	// }

	// This code is unreachable.
	// function invalidLexState (state) {
	//     return new Error(`JSON5: invalid lex state '${state}'`)
	// }

	function invalidChar (c) {
	    if (c === undefined) {
	        return syntaxError(("JSON5: invalid end of input at " + line + ":" + column))
	    }

	    return syntaxError(("JSON5: invalid character '" + (formatChar(c)) + "' at " + line + ":" + column))
	}

	function invalidEOF () {
	    return syntaxError(("JSON5: invalid end of input at " + line + ":" + column))
	}

	// This code is unreachable.
	// function invalidToken () {
	//     if (token.type === 'eof') {
	//         return syntaxError(`JSON5: invalid end of input at ${line}:${column}`)
	//     }

	//     const c = String.fromCodePoint(token.value.codePointAt(0))
	//     return syntaxError(`JSON5: invalid character '${formatChar(c)}' at ${line}:${column}`)
	// }

	function invalidIdentifier () {
	    column -= 5;
	    return syntaxError(("JSON5: invalid identifier character at " + line + ":" + column))
	}

	function separatorChar (c) {
	    console.warn(("JSON5: '" + (formatChar(c)) + "' in strings is not valid ECMAScript; consider escaping"));
	}

	function formatChar (c) {
	    var replacements = {
	        "'": "\\'",
	        '"': '\\"',
	        '\\': '\\\\',
	        '\b': '\\b',
	        '\f': '\\f',
	        '\n': '\\n',
	        '\r': '\\r',
	        '\t': '\\t',
	        '\v': '\\v',
	        '\0': '\\0',
	        '\u2028': '\\u2028',
	        '\u2029': '\\u2029',
	    };

	    if (replacements[c]) {
	        return replacements[c]
	    }

	    if (c < ' ') {
	        var hexString = c.charCodeAt(0).toString(16);
	        return '\\x' + ('00' + hexString).substring(hexString.length)
	    }

	    return c
	}

	function syntaxError (message) {
	    var err = new SyntaxError(message);
	    err.lineNumber = line;
	    err.columnNumber = column;
	    return err
	}

	var stringify = function stringify (value, replacer, space) {
	    var stack = [];
	    var indent = '';
	    var propertyList;
	    var replacerFunc;
	    var gap = '';
	    var quote;

	    if (
	        replacer != null &&
	        typeof replacer === 'object' &&
	        !Array.isArray(replacer)
	    ) {
	        space = replacer.space;
	        quote = replacer.quote;
	        replacer = replacer.replacer;
	    }

	    if (typeof replacer === 'function') {
	        replacerFunc = replacer;
	    } else if (Array.isArray(replacer)) {
	        propertyList = [];
	        for (var i = 0, list = replacer; i < list.length; i += 1) {
	            var v = list[i];

	            var item = (void 0);

	            if (typeof v === 'string') {
	                item = v;
	            } else if (
	                typeof v === 'number' ||
	                v instanceof String ||
	                v instanceof Number
	            ) {
	                item = String(v);
	            }

	            if (item !== undefined && propertyList.indexOf(item) < 0) {
	                propertyList.push(item);
	            }
	        }
	    }

	    if (space instanceof Number) {
	        space = Number(space);
	    } else if (space instanceof String) {
	        space = String(space);
	    }

	    if (typeof space === 'number') {
	        if (space > 0) {
	            space = Math.min(10, Math.floor(space));
	            gap = '          '.substr(0, space);
	        }
	    } else if (typeof space === 'string') {
	        gap = space.substr(0, 10);
	    }

	    return serializeProperty('', {'': value})

	    function serializeProperty (key, holder) {
	        var value = holder[key];
	        if (value != null) {
	            if (typeof value.toJSON5 === 'function') {
	                value = value.toJSON5(key);
	            } else if (typeof value.toJSON === 'function') {
	                value = value.toJSON(key);
	            }
	        }

	        if (replacerFunc) {
	            value = replacerFunc.call(holder, key, value);
	        }

	        if (value instanceof Number) {
	            value = Number(value);
	        } else if (value instanceof String) {
	            value = String(value);
	        } else if (value instanceof Boolean) {
	            value = value.valueOf();
	        }

	        switch (value) {
	        case null: return 'null'
	        case true: return 'true'
	        case false: return 'false'
	        }

	        if (typeof value === 'string') {
	            return quoteString(value, false)
	        }

	        if (typeof value === 'number') {
	            return String(value)
	        }

	        if (typeof value === 'object') {
	            return Array.isArray(value) ? serializeArray(value) : serializeObject(value)
	        }

	        return undefined
	    }

	    function quoteString (value) {
	        var quotes = {
	            "'": 0.1,
	            '"': 0.2,
	        };

	        var replacements = {
	            "'": "\\'",
	            '"': '\\"',
	            '\\': '\\\\',
	            '\b': '\\b',
	            '\f': '\\f',
	            '\n': '\\n',
	            '\r': '\\r',
	            '\t': '\\t',
	            '\v': '\\v',
	            '\0': '\\0',
	            '\u2028': '\\u2028',
	            '\u2029': '\\u2029',
	        };

	        var product = '';

	        for (var i = 0; i < value.length; i++) {
	            var c = value[i];
	            switch (c) {
	            case "'":
	            case '"':
	                quotes[c]++;
	                product += c;
	                continue

	            case '\0':
	                if (util.isDigit(value[i + 1])) {
	                    product += '\\x00';
	                    continue
	                }
	            }

	            if (replacements[c]) {
	                product += replacements[c];
	                continue
	            }

	            if (c < ' ') {
	                var hexString = c.charCodeAt(0).toString(16);
	                product += '\\x' + ('00' + hexString).substring(hexString.length);
	                continue
	            }

	            product += c;
	        }

	        var quoteChar = quote || Object.keys(quotes).reduce(function (a, b) { return (quotes[a] < quotes[b]) ? a : b; });

	        product = product.replace(new RegExp(quoteChar, 'g'), replacements[quoteChar]);

	        return quoteChar + product + quoteChar
	    }

	    function serializeObject (value) {
	        if (stack.indexOf(value) >= 0) {
	            throw TypeError('Converting circular structure to JSON5')
	        }

	        stack.push(value);

	        var stepback = indent;
	        indent = indent + gap;

	        var keys = propertyList || Object.keys(value);
	        var partial = [];
	        for (var i = 0, list = keys; i < list.length; i += 1) {
	            var key = list[i];

	            var propertyString = serializeProperty(key, value);
	            if (propertyString !== undefined) {
	                var member = serializeKey(key) + ':';
	                if (gap !== '') {
	                    member += ' ';
	                }
	                member += propertyString;
	                partial.push(member);
	            }
	        }

	        var final;
	        if (partial.length === 0) {
	            final = '{}';
	        } else {
	            var properties;
	            if (gap === '') {
	                properties = partial.join(',');
	                final = '{' + properties + '}';
	            } else {
	                var separator = ',\n' + indent;
	                properties = partial.join(separator);
	                final = '{\n' + indent + properties + ',\n' + stepback + '}';
	            }
	        }

	        stack.pop();
	        indent = stepback;
	        return final
	    }

	    function serializeKey (key) {
	        if (key.length === 0) {
	            return quoteString(key, true)
	        }

	        var firstChar = String.fromCodePoint(key.codePointAt(0));
	        if (!util.isIdStartChar(firstChar)) {
	            return quoteString(key, true)
	        }

	        for (var i = firstChar.length; i < key.length; i++) {
	            if (!util.isIdContinueChar(String.fromCodePoint(key.codePointAt(i)))) {
	                return quoteString(key, true)
	            }
	        }

	        return key
	    }

	    function serializeArray (value) {
	        if (stack.indexOf(value) >= 0) {
	            throw TypeError('Converting circular structure to JSON5')
	        }

	        stack.push(value);

	        var stepback = indent;
	        indent = indent + gap;

	        var partial = [];
	        for (var i = 0; i < value.length; i++) {
	            var propertyString = serializeProperty(String(i), value);
	            partial.push((propertyString !== undefined) ? propertyString : 'null');
	        }

	        var final;
	        if (partial.length === 0) {
	            final = '[]';
	        } else {
	            if (gap === '') {
	                var properties = partial.join(',');
	                final = '[' + properties + ']';
	            } else {
	                var separator = ',\n' + indent;
	                var properties$1 = partial.join(separator);
	                final = '[\n' + indent + properties$1 + ',\n' + stepback + ']';
	            }
	        }

	        stack.pop();
	        indent = stepback;
	        return final
	    }
	};

	var JSON5 = {
	    parse: parse,
	    stringify: stringify,
	};

	var lib = JSON5;

	var es5 = lib;

	return es5;

})));


/***/ }),

/***/ 17884:
/***/ ((module) => {

var toString = Object.prototype.toString;

module.exports = function kindOf(val) {
  if (val === void 0) return 'undefined';
  if (val === null) return 'null';

  var type = typeof val;
  if (type === 'boolean') return 'boolean';
  if (type === 'string') return 'string';
  if (type === 'number') return 'number';
  if (type === 'symbol') return 'symbol';
  if (type === 'function') {
    return isGeneratorFn(val) ? 'generatorfunction' : 'function';
  }

  if (isArray(val)) return 'array';
  if (isBuffer(val)) return 'buffer';
  if (isArguments(val)) return 'arguments';
  if (isDate(val)) return 'date';
  if (isError(val)) return 'error';
  if (isRegexp(val)) return 'regexp';

  switch (ctorName(val)) {
    case 'Symbol': return 'symbol';
    case 'Promise': return 'promise';

    // Set, Map, WeakSet, WeakMap
    case 'WeakMap': return 'weakmap';
    case 'WeakSet': return 'weakset';
    case 'Map': return 'map';
    case 'Set': return 'set';

    // 8-bit typed arrays
    case 'Int8Array': return 'int8array';
    case 'Uint8Array': return 'uint8array';
    case 'Uint8ClampedArray': return 'uint8clampedarray';

    // 16-bit typed arrays
    case 'Int16Array': return 'int16array';
    case 'Uint16Array': return 'uint16array';

    // 32-bit typed arrays
    case 'Int32Array': return 'int32array';
    case 'Uint32Array': return 'uint32array';
    case 'Float32Array': return 'float32array';
    case 'Float64Array': return 'float64array';
  }

  if (isGeneratorObj(val)) {
    return 'generator';
  }

  // Non-plain objects
  type = toString.call(val);
  switch (type) {
    case '[object Object]': return 'object';
    // iterators
    case '[object Map Iterator]': return 'mapiterator';
    case '[object Set Iterator]': return 'setiterator';
    case '[object String Iterator]': return 'stringiterator';
    case '[object Array Iterator]': return 'arrayiterator';
  }

  // other
  return type.slice(8, -1).toLowerCase().replace(/\s/g, '');
};

function ctorName(val) {
  return typeof val.constructor === 'function' ? val.constructor.name : null;
}

function isArray(val) {
  if (Array.isArray) return Array.isArray(val);
  return val instanceof Array;
}

function isError(val) {
  return val instanceof Error || (typeof val.message === 'string' && val.constructor && typeof val.constructor.stackTraceLimit === 'number');
}

function isDate(val) {
  if (val instanceof Date) return true;
  return typeof val.toDateString === 'function'
    && typeof val.getDate === 'function'
    && typeof val.setDate === 'function';
}

function isRegexp(val) {
  if (val instanceof RegExp) return true;
  return typeof val.flags === 'string'
    && typeof val.ignoreCase === 'boolean'
    && typeof val.multiline === 'boolean'
    && typeof val.global === 'boolean';
}

function isGeneratorFn(name, val) {
  return ctorName(name) === 'GeneratorFunction';
}

function isGeneratorObj(val) {
  return typeof val.throw === 'function'
    && typeof val.return === 'function'
    && typeof val.next === 'function';
}

function isArguments(val) {
  try {
    if (typeof val.length === 'number' && typeof val.callee === 'function') {
      return true;
    }
  } catch (err) {
    if (err.message.indexOf('callee') !== -1) {
      return true;
    }
  }
  return false;
}

/**
 * If you need to support Safari 5-7 (8-10 yr-old browser),
 * take a look at https://github.com/feross/is-buffer
 */

function isBuffer(val) {
  if (val.constructor && typeof val.constructor.isBuffer === 'function') {
    return val.constructor.isBuffer(val);
  }
  return false;
}


/***/ }),

/***/ 4031:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/*!
 * shallow-clone <https://github.com/jonschlinkert/shallow-clone>
 *
 * Copyright (c) 2015-present, Jon Schlinkert.
 * Released under the MIT License.
 */



const valueOf = Symbol.prototype.valueOf;
const typeOf = __webpack_require__(17884);

function clone(val, deep) {
  switch (typeOf(val)) {
    case 'array':
      return val.slice();
    case 'object':
      return Object.assign({}, val);
    case 'date':
      return new val.constructor(Number(val));
    case 'map':
      return new Map(val);
    case 'set':
      return new Set(val);
    case 'buffer':
      return cloneBuffer(val);
    case 'symbol':
      return cloneSymbol(val);
    case 'arraybuffer':
      return cloneArrayBuffer(val);
    case 'float32array':
    case 'float64array':
    case 'int16array':
    case 'int32array':
    case 'int8array':
    case 'uint16array':
    case 'uint32array':
    case 'uint8clampedarray':
    case 'uint8array':
      return cloneTypedArray(val);
    case 'regexp':
      return cloneRegExp(val);
    case 'error':
      return Object.create(val);
    default: {
      return val;
    }
  }
}

function cloneRegExp(val) {
  const flags = val.flags !== void 0 ? val.flags : (/\w+$/.exec(val) || void 0);
  const re = new val.constructor(val.source, flags);
  re.lastIndex = val.lastIndex;
  return re;
}

function cloneArrayBuffer(val) {
  const res = new val.constructor(val.byteLength);
  new Uint8Array(res).set(new Uint8Array(val));
  return res;
}

function cloneTypedArray(val, deep) {
  return new val.constructor(val.buffer, val.byteOffset, val.length);
}

function cloneBuffer(val) {
  const len = val.length;
  const buf = Buffer.allocUnsafe ? Buffer.allocUnsafe(len) : Buffer.from(len);
  val.copy(buf);
  return buf;
}

function cloneSymbol(val) {
  return valueOf ? Object(valueOf.call(val)) : {};
}

/**
 * Expose `clone`
 */

module.exports = clone;


/***/ }),

/***/ 63607:
/***/ ((module, exports, __webpack_require__) => {

var __WEBPACK_AMD_DEFINE_RESULT__;/* global window, exports, define */

!function() {
    'use strict'

    var re = {
        not_string: /[^s]/,
        not_bool: /[^t]/,
        not_type: /[^T]/,
        not_primitive: /[^v]/,
        number: /[diefg]/,
        numeric_arg: /[bcdiefguxX]/,
        json: /[j]/,
        not_json: /[^j]/,
        text: /^[^\x25]+/,
        modulo: /^\x25{2}/,
        placeholder: /^\x25(?:([1-9]\d*)\$|\(([^)]+)\))?(\+)?(0|'[^$])?(-)?(\d+)?(?:\.(\d+))?([b-gijostTuvxX])/,
        key: /^([a-z_][a-z_\d]*)/i,
        key_access: /^\.([a-z_][a-z_\d]*)/i,
        index_access: /^\[(\d+)\]/,
        sign: /^[+-]/
    }

    function sprintf(key) {
        // `arguments` is not an array, but should be fine for this call
        return sprintf_format(sprintf_parse(key), arguments)
    }

    function vsprintf(fmt, argv) {
        return sprintf.apply(null, [fmt].concat(argv || []))
    }

    function sprintf_format(parse_tree, argv) {
        var cursor = 1, tree_length = parse_tree.length, arg, output = '', i, k, ph, pad, pad_character, pad_length, is_positive, sign
        for (i = 0; i < tree_length; i++) {
            if (typeof parse_tree[i] === 'string') {
                output += parse_tree[i]
            }
            else if (typeof parse_tree[i] === 'object') {
                ph = parse_tree[i] // convenience purposes only
                if (ph.keys) { // keyword argument
                    arg = argv[cursor]
                    for (k = 0; k < ph.keys.length; k++) {
                        if (arg == undefined) {
                            throw new Error(sprintf('[sprintf] Cannot access property "%s" of undefined value "%s"', ph.keys[k], ph.keys[k-1]))
                        }
                        arg = arg[ph.keys[k]]
                    }
                }
                else if (ph.param_no) { // positional argument (explicit)
                    arg = argv[ph.param_no]
                }
                else { // positional argument (implicit)
                    arg = argv[cursor++]
                }

                if (re.not_type.test(ph.type) && re.not_primitive.test(ph.type) && arg instanceof Function) {
                    arg = arg()
                }

                if (re.numeric_arg.test(ph.type) && (typeof arg !== 'number' && isNaN(arg))) {
                    throw new TypeError(sprintf('[sprintf] expecting number but found %T', arg))
                }

                if (re.number.test(ph.type)) {
                    is_positive = arg >= 0
                }

                switch (ph.type) {
                    case 'b':
                        arg = parseInt(arg, 10).toString(2)
                        break
                    case 'c':
                        arg = String.fromCharCode(parseInt(arg, 10))
                        break
                    case 'd':
                    case 'i':
                        arg = parseInt(arg, 10)
                        break
                    case 'j':
                        arg = JSON.stringify(arg, null, ph.width ? parseInt(ph.width) : 0)
                        break
                    case 'e':
                        arg = ph.precision ? parseFloat(arg).toExponential(ph.precision) : parseFloat(arg).toExponential()
                        break
                    case 'f':
                        arg = ph.precision ? parseFloat(arg).toFixed(ph.precision) : parseFloat(arg)
                        break
                    case 'g':
                        arg = ph.precision ? String(Number(arg.toPrecision(ph.precision))) : parseFloat(arg)
                        break
                    case 'o':
                        arg = (parseInt(arg, 10) >>> 0).toString(8)
                        break
                    case 's':
                        arg = String(arg)
                        arg = (ph.precision ? arg.substring(0, ph.precision) : arg)
                        break
                    case 't':
                        arg = String(!!arg)
                        arg = (ph.precision ? arg.substring(0, ph.precision) : arg)
                        break
                    case 'T':
                        arg = Object.prototype.toString.call(arg).slice(8, -1).toLowerCase()
                        arg = (ph.precision ? arg.substring(0, ph.precision) : arg)
                        break
                    case 'u':
                        arg = parseInt(arg, 10) >>> 0
                        break
                    case 'v':
                        arg = arg.valueOf()
                        arg = (ph.precision ? arg.substring(0, ph.precision) : arg)
                        break
                    case 'x':
                        arg = (parseInt(arg, 10) >>> 0).toString(16)
                        break
                    case 'X':
                        arg = (parseInt(arg, 10) >>> 0).toString(16).toUpperCase()
                        break
                }
                if (re.json.test(ph.type)) {
                    output += arg
                }
                else {
                    if (re.number.test(ph.type) && (!is_positive || ph.sign)) {
                        sign = is_positive ? '+' : '-'
                        arg = arg.toString().replace(re.sign, '')
                    }
                    else {
                        sign = ''
                    }
                    pad_character = ph.pad_char ? ph.pad_char === '0' ? '0' : ph.pad_char.charAt(1) : ' '
                    pad_length = ph.width - (sign + arg).length
                    pad = ph.width ? (pad_length > 0 ? pad_character.repeat(pad_length) : '') : ''
                    output += ph.align ? sign + arg + pad : (pad_character === '0' ? sign + pad + arg : pad + sign + arg)
                }
            }
        }
        return output
    }

    var sprintf_cache = Object.create(null)

    function sprintf_parse(fmt) {
        if (sprintf_cache[fmt]) {
            return sprintf_cache[fmt]
        }

        var _fmt = fmt, match, parse_tree = [], arg_names = 0
        while (_fmt) {
            if ((match = re.text.exec(_fmt)) !== null) {
                parse_tree.push(match[0])
            }
            else if ((match = re.modulo.exec(_fmt)) !== null) {
                parse_tree.push('%')
            }
            else if ((match = re.placeholder.exec(_fmt)) !== null) {
                if (match[2]) {
                    arg_names |= 1
                    var field_list = [], replacement_field = match[2], field_match = []
                    if ((field_match = re.key.exec(replacement_field)) !== null) {
                        field_list.push(field_match[1])
                        while ((replacement_field = replacement_field.substring(field_match[0].length)) !== '') {
                            if ((field_match = re.key_access.exec(replacement_field)) !== null) {
                                field_list.push(field_match[1])
                            }
                            else if ((field_match = re.index_access.exec(replacement_field)) !== null) {
                                field_list.push(field_match[1])
                            }
                            else {
                                throw new SyntaxError('[sprintf] failed to parse named argument key')
                            }
                        }
                    }
                    else {
                        throw new SyntaxError('[sprintf] failed to parse named argument key')
                    }
                    match[2] = field_list
                }
                else {
                    arg_names |= 2
                }
                if (arg_names === 3) {
                    throw new Error('[sprintf] mixing positional and named placeholders is not (yet) supported')
                }

                parse_tree.push(
                    {
                        placeholder: match[0],
                        param_no:    match[1],
                        keys:        match[2],
                        sign:        match[3],
                        pad_char:    match[4],
                        align:       match[5],
                        width:       match[6],
                        precision:   match[7],
                        type:        match[8]
                    }
                )
            }
            else {
                throw new SyntaxError('[sprintf] unexpected placeholder')
            }
            _fmt = _fmt.substring(match[0].length)
        }
        return sprintf_cache[fmt] = parse_tree
    }

    /**
     * export to either browser or node.js
     */
    /* eslint-disable quote-props */
    if (true) {
        exports.sprintf = sprintf
        exports.vsprintf = vsprintf
    }
    if (typeof window !== 'undefined') {
        window['sprintf'] = sprintf
        window['vsprintf'] = vsprintf

        if (true) {
            !(__WEBPACK_AMD_DEFINE_RESULT__ = (function() {
                return {
                    'sprintf': sprintf,
                    'vsprintf': vsprintf
                }
            }).call(exports, __webpack_require__, exports, module),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
        }
    }
    /* eslint-enable quote-props */
}(); // eslint-disable-line


/***/ }),

/***/ 34156:
/***/ ((module) => {

"use strict";


const defaultAlphabetIndexMap = [];

function isNumberCode(code) {
  return code >= 48/* '0' */ && code <= 57/* '9' */;
}

function naturalCompare(a, b, opts) {
  if (typeof a !== 'string') {
    throw new TypeError(`The first argument must be a string. Received type '${typeof a}'`);
  }
  if (typeof b !== 'string') {
    throw new TypeError(`The second argument must be a string. Received type '${typeof b}'`);
  }

  const lengthA = a.length;
  const lengthB = b.length;
  let indexA = 0;
  let indexB = 0;
  let alphabetIndexMap = defaultAlphabetIndexMap;
  let firstDifferenceInLeadingZeros = 0;

  if (opts) {
    if (opts.caseInsensitive) {
      a = a.toLowerCase();
      b = b.toLowerCase();
    }

    if (opts.alphabet) {
      alphabetIndexMap = buildAlphabetIndexMap(opts.alphabet);
    }
  }

  while (indexA < lengthA && indexB < lengthB) {
    let charCodeA = a.charCodeAt(indexA);
    let charCodeB = b.charCodeAt(indexB);

    if (isNumberCode(charCodeA)) {
      if (!isNumberCode(charCodeB)) {
        return charCodeA - charCodeB;
      }

      let numStartA = indexA;
      let numStartB = indexB;

      while (charCodeA === 48/* '0' */ && ++numStartA < lengthA) {
        charCodeA = a.charCodeAt(numStartA);
      }
      while (charCodeB === 48/* '0' */ && ++numStartB < lengthB) {
        charCodeB = b.charCodeAt(numStartB);
      }

      if (numStartA !== numStartB && firstDifferenceInLeadingZeros === 0) {
        firstDifferenceInLeadingZeros = numStartA - numStartB;
      }

      let numEndA = numStartA;
      let numEndB = numStartB;

      while (numEndA < lengthA && isNumberCode(a.charCodeAt(numEndA))) {
        ++numEndA;
      }
      while (numEndB < lengthB && isNumberCode(b.charCodeAt(numEndB))) {
        ++numEndB;
      }

      let difference = numEndA - numStartA - numEndB + numStartB; // numA length - numB length
      if (difference !== 0) {
        return difference;
      }

      while (numStartA < numEndA) {
        difference = a.charCodeAt(numStartA++) - b.charCodeAt(numStartB++);
        if (difference !== 0) {
          return difference;
        }
      }

      indexA = numEndA;
      indexB = numEndB;
      continue;
    }

    if (charCodeA !== charCodeB) {
      if (
        charCodeA < alphabetIndexMap.length &&
        charCodeB < alphabetIndexMap.length &&
        alphabetIndexMap[charCodeA] !== -1 &&
        alphabetIndexMap[charCodeB] !== -1
      ) {
        return alphabetIndexMap[charCodeA] - alphabetIndexMap[charCodeB];
      }

      return charCodeA - charCodeB;
    }

    ++indexA;
    ++indexB;
  }

  if (indexA < lengthA) { // `b` is a substring of `a`
    return 1;
  }

  if (indexB < lengthB) { // `a` is a substring of `b`
    return -1;
  }

  return firstDifferenceInLeadingZeros;
}

const alphabetIndexMapCache = {};

function buildAlphabetIndexMap(alphabet) {
  const existingMap = alphabetIndexMapCache[alphabet];
  if (existingMap !== undefined) {
    return existingMap;
  }

  const indexMap = [];
  const maxCharCode = alphabet.split('').reduce((maxCode, char) => {
    return Math.max(maxCode, char.charCodeAt(0));
  }, 0);

  for (let i = 0; i <= maxCharCode; i++) {
    indexMap.push(-1);
  }

  for (let i = 0; i < alphabet.length; i++) {
    indexMap[alphabet.charCodeAt(i)] = i;
  }

  alphabetIndexMapCache[alphabet] = indexMap;

  return indexMap;
}

module.exports = naturalCompare;


/***/ }),

/***/ 13548:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  FB: () => (/* binding */ es6_getDomain),
  EW: () => (/* binding */ getHostname),
  pj: () => (/* binding */ getPublicSuffix),
  qg: () => (/* binding */ parse)
});

// UNUSED EXPORTS: getDomainWithoutSuffix, getSubdomain

;// ./node_modules/.pnpm/tldts-core@5.7.112/node_modules/tldts-core/dist/es6/src/domain.js
/**
 * Check if `vhost` is a valid suffix of `hostname` (top-domain)
 *
 * It means that `vhost` needs to be a suffix of `hostname` and we then need to
 * make sure that: either they are equal, or the character preceding `vhost` in
 * `hostname` is a '.' (it should not be a partial label).
 *
 * * hostname = 'not.evil.com' and vhost = 'vil.com'      => not ok
 * * hostname = 'not.evil.com' and vhost = 'evil.com'     => ok
 * * hostname = 'not.evil.com' and vhost = 'not.evil.com' => ok
 */
function shareSameDomainSuffix(hostname, vhost) {
    if (hostname.endsWith(vhost)) {
        return (hostname.length === vhost.length ||
            hostname[hostname.length - vhost.length - 1] === '.');
    }
    return false;
}
/**
 * Given a hostname and its public suffix, extract the general domain.
 */
function extractDomainWithSuffix(hostname, publicSuffix) {
    // Locate the index of the last '.' in the part of the `hostname` preceding
    // the public suffix.
    //
    // examples:
    //   1. not.evil.co.uk  => evil.co.uk
    //         ^    ^
    //         |    | start of public suffix
    //         | index of the last dot
    //
    //   2. example.co.uk   => example.co.uk
    //     ^       ^
    //     |       | start of public suffix
    //     |
    //     | (-1) no dot found before the public suffix
    const publicSuffixIndex = hostname.length - publicSuffix.length - 2;
    const lastDotBeforeSuffixIndex = hostname.lastIndexOf('.', publicSuffixIndex);
    // No '.' found, then `hostname` is the general domain (no sub-domain)
    if (lastDotBeforeSuffixIndex === -1) {
        return hostname;
    }
    // Extract the part between the last '.'
    return hostname.slice(lastDotBeforeSuffixIndex + 1);
}
/**
 * Detects the domain based on rules and upon and a host string
 */
function getDomain(suffix, hostname, options) {
    // Check if `hostname` ends with a member of `validHosts`.
    if (options.validHosts !== null) {
        const validHosts = options.validHosts;
        for (let i = 0; i < validHosts.length; i += 1) {
            const vhost = validHosts[i];
            if ( /*@__INLINE__*/shareSameDomainSuffix(hostname, vhost) === true) {
                return vhost;
            }
        }
    }
    // If `hostname` is a valid public suffix, then there is no domain to return.
    // Since we already know that `getPublicSuffix` returns a suffix of `hostname`
    // there is no need to perform a string comparison and we only compare the
    // size.
    if (suffix.length === hostname.length) {
        return null;
    }
    // To extract the general domain, we start by identifying the public suffix
    // (if any), then consider the domain to be the public suffix with one added
    // level of depth. (e.g.: if hostname is `not.evil.co.uk` and public suffix:
    // `co.uk`, then we take one more level: `evil`, giving the final result:
    // `evil.co.uk`).
    return /*@__INLINE__*/ extractDomainWithSuffix(hostname, suffix);
}

;// ./node_modules/.pnpm/tldts-core@5.7.112/node_modules/tldts-core/dist/es6/src/domain-without-suffix.js
/**
 * Return the part of domain without suffix.
 *
 * Example: for domain 'foo.com', the result would be 'foo'.
 */
function getDomainWithoutSuffix(domain, suffix) {
    // Note: here `domain` and `suffix` cannot have the same length because in
    // this case we set `domain` to `null` instead. It is thus safe to assume
    // that `suffix` is shorter than `domain`.
    return domain.slice(0, -suffix.length - 1);
}

;// ./node_modules/.pnpm/tldts-core@5.7.112/node_modules/tldts-core/dist/es6/src/extract-hostname.js
/**
 * @param url - URL we want to extract a hostname from.
 * @param urlIsValidHostname - hint from caller; true if `url` is already a valid hostname.
 */
function extractHostname(url, urlIsValidHostname) {
    let start = 0;
    let end = url.length;
    let hasUpper = false;
    // If url is not already a valid hostname, then try to extract hostname.
    if (urlIsValidHostname === false) {
        // Special handling of data URLs
        if (url.startsWith('data:') === true) {
            return null;
        }
        // Trim leading spaces
        while (start < url.length && url.charCodeAt(start) <= 32) {
            start += 1;
        }
        // Trim trailing spaces
        while (end > start + 1 && url.charCodeAt(end - 1) <= 32) {
            end -= 1;
        }
        // Skip scheme.
        if (url.charCodeAt(start) === 47 /* '/' */ &&
            url.charCodeAt(start + 1) === 47 /* '/' */) {
            start += 2;
        }
        else {
            const indexOfProtocol = url.indexOf(':/', start);
            if (indexOfProtocol !== -1) {
                // Implement fast-path for common protocols. We expect most protocols
                // should be one of these 4 and thus we will not need to perform the
                // more expansive validity check most of the time.
                const protocolSize = indexOfProtocol - start;
                const c0 = url.charCodeAt(start);
                const c1 = url.charCodeAt(start + 1);
                const c2 = url.charCodeAt(start + 2);
                const c3 = url.charCodeAt(start + 3);
                const c4 = url.charCodeAt(start + 4);
                if (protocolSize === 5 &&
                    c0 === 104 /* 'h' */ &&
                    c1 === 116 /* 't' */ &&
                    c2 === 116 /* 't' */ &&
                    c3 === 112 /* 'p' */ &&
                    c4 === 115 /* 's' */) {
                    // https
                }
                else if (protocolSize === 4 &&
                    c0 === 104 /* 'h' */ &&
                    c1 === 116 /* 't' */ &&
                    c2 === 116 /* 't' */ &&
                    c3 === 112 /* 'p' */) {
                    // http
                }
                else if (protocolSize === 3 &&
                    c0 === 119 /* 'w' */ &&
                    c1 === 115 /* 's' */ &&
                    c2 === 115 /* 's' */) {
                    // wss
                }
                else if (protocolSize === 2 &&
                    c0 === 119 /* 'w' */ &&
                    c1 === 115 /* 's' */) {
                    // ws
                }
                else {
                    // Check that scheme is valid
                    for (let i = start; i < indexOfProtocol; i += 1) {
                        const lowerCaseCode = url.charCodeAt(i) | 32;
                        if (((lowerCaseCode >= 97 && lowerCaseCode <= 122) || // [a, z]
                            (lowerCaseCode >= 48 && lowerCaseCode <= 57) || // [0, 9]
                            lowerCaseCode === 46 || // '.'
                            lowerCaseCode === 45 || // '-'
                            lowerCaseCode === 43) === false // '+'
                        ) {
                            return null;
                        }
                    }
                }
                // Skip 0, 1 or more '/' after ':/'
                start = indexOfProtocol + 2;
                while (url.charCodeAt(start) === 47 /* '/' */) {
                    start += 1;
                }
            }
        }
        // Detect first occurrence of '/', '?' or '#'. We also keep track of the
        // last occurrence of '@', ']' or ':' to speed-up subsequent parsing of
        // (respectively), identifier, ipv6 or port.
        let indexOfIdentifier = -1;
        let indexOfClosingBracket = -1;
        let indexOfPort = -1;
        for (let i = start; i < end; i += 1) {
            const code = url.charCodeAt(i);
            if (code === 35 || // '#'
                code === 47 || // '/'
                code === 63 // '?'
            ) {
                end = i;
                break;
            }
            else if (code === 64) {
                // '@'
                indexOfIdentifier = i;
            }
            else if (code === 93) {
                // ']'
                indexOfClosingBracket = i;
            }
            else if (code === 58) {
                // ':'
                indexOfPort = i;
            }
            else if (code >= 65 && code <= 90) {
                hasUpper = true;
            }
        }
        // Detect identifier: '@'
        if (indexOfIdentifier !== -1 &&
            indexOfIdentifier > start &&
            indexOfIdentifier < end) {
            start = indexOfIdentifier + 1;
        }
        // Handle ipv6 addresses
        if (url.charCodeAt(start) === 91 /* '[' */) {
            if (indexOfClosingBracket !== -1) {
                return url.slice(start + 1, indexOfClosingBracket).toLowerCase();
            }
            return null;
        }
        else if (indexOfPort !== -1 && indexOfPort > start && indexOfPort < end) {
            // Detect port: ':'
            end = indexOfPort;
        }
    }
    // Trim trailing dots
    while (end > start + 1 && url.charCodeAt(end - 1) === 46 /* '.' */) {
        end -= 1;
    }
    const hostname = start !== 0 || end !== url.length ? url.slice(start, end) : url;
    if (hasUpper) {
        return hostname.toLowerCase();
    }
    return hostname;
}

;// ./node_modules/.pnpm/tldts-core@5.7.112/node_modules/tldts-core/dist/es6/src/is-ip.js
/**
 * Check if a hostname is an IP. You should be aware that this only works
 * because `hostname` is already garanteed to be a valid hostname!
 */
function isProbablyIpv4(hostname) {
    // Cannot be shorted than 1.1.1.1
    if (hostname.length < 7) {
        return false;
    }
    // Cannot be longer than: 255.255.255.255
    if (hostname.length > 15) {
        return false;
    }
    let numberOfDots = 0;
    for (let i = 0; i < hostname.length; i += 1) {
        const code = hostname.charCodeAt(i);
        if (code === 46 /* '.' */) {
            numberOfDots += 1;
        }
        else if (code < 48 /* '0' */ || code > 57 /* '9' */) {
            return false;
        }
    }
    return (numberOfDots === 3 &&
        hostname.charCodeAt(0) !== 46 /* '.' */ &&
        hostname.charCodeAt(hostname.length - 1) !== 46 /* '.' */);
}
/**
 * Similar to isProbablyIpv4.
 */
function isProbablyIpv6(hostname) {
    if (hostname.length < 3) {
        return false;
    }
    let start = hostname[0] === '[' ? 1 : 0;
    let end = hostname.length;
    if (hostname[end - 1] === ']') {
        end -= 1;
    }
    // We only consider the maximum size of a normal IPV6. Note that this will
    // fail on so-called "IPv4 mapped IPv6 addresses" but this is a corner-case
    // and a proper validation library should be used for these.
    if (end - start > 39) {
        return false;
    }
    let hasColon = false;
    for (; start < end; start += 1) {
        const code = hostname.charCodeAt(start);
        if (code === 58 /* ':' */) {
            hasColon = true;
        }
        else if (((code >= 48 && code <= 57) || // 0-9
            (code >= 97 && code <= 102) || // a-f
            (code >= 65 && code <= 90)) === // A-F
            false) {
            return false;
        }
    }
    return hasColon;
}
/**
 * Check if `hostname` is *probably* a valid ip addr (either ipv6 or ipv4).
 * This *will not* work on any string. We need `hostname` to be a valid
 * hostname.
 */
function isIp(hostname) {
    return isProbablyIpv6(hostname) || isProbablyIpv4(hostname);
}

;// ./node_modules/.pnpm/tldts-core@5.7.112/node_modules/tldts-core/dist/es6/src/is-valid.js
/**
 * Implements fast shallow verification of hostnames. This does not perform a
 * struct check on the content of labels (classes of Unicode characters, etc.)
 * but instead check that the structure is valid (number of labels, length of
 * labels, etc.).
 *
 * If you need stricter validation, consider using an external library.
 */
function isValidAscii(code) {
    return ((code >= 97 && code <= 122) || (code >= 48 && code <= 57) || code > 127);
}
/**
 * Check if a hostname string is valid. It's usually a preliminary check before
 * trying to use getDomain or anything else.
 *
 * Beware: it does not check if the TLD exists.
 */
/* harmony default export */ function is_valid(hostname) {
    if (hostname.length > 255) {
        return false;
    }
    if (hostname.length === 0) {
        return false;
    }
    if ( /*@__INLINE__*/isValidAscii(hostname.charCodeAt(0)) === false) {
        return false;
    }
    // Validate hostname according to RFC
    let lastDotIndex = -1;
    let lastCharCode = -1;
    const len = hostname.length;
    for (let i = 0; i < len; i += 1) {
        const code = hostname.charCodeAt(i);
        if (code === 46 /* '.' */) {
            if (
            // Check that previous label is < 63 bytes long (64 = 63 + '.')
            i - lastDotIndex > 64 ||
                // Check that previous character was not already a '.'
                lastCharCode === 46 ||
                // Check that the previous label does not end with a '-' (dash)
                lastCharCode === 45 ||
                // Check that the previous label does not end with a '_' (underscore)
                lastCharCode === 95) {
                return false;
            }
            lastDotIndex = i;
        }
        else if (( /*@__INLINE__*/isValidAscii(code) || code === 45 || code === 95) ===
            false) {
            // Check if there is a forbidden character in the label
            return false;
        }
        lastCharCode = code;
    }
    return (
    // Check that last label is shorter than 63 chars
    len - lastDotIndex - 1 <= 63 &&
        // Check that the last character is an allowed trailing label character.
        // Since we already checked that the char is a valid hostname character,
        // we only need to check that it's different from '-'.
        lastCharCode !== 45);
}

;// ./node_modules/.pnpm/tldts-core@5.7.112/node_modules/tldts-core/dist/es6/src/options.js
function setDefaultsImpl({ allowIcannDomains = true, allowPrivateDomains = false, detectIp = true, extractHostname = true, mixedInputs = true, validHosts = null, validateHostname = true, }) {
    return {
        allowIcannDomains,
        allowPrivateDomains,
        detectIp,
        extractHostname,
        mixedInputs,
        validHosts,
        validateHostname,
    };
}
const DEFAULT_OPTIONS = /*@__INLINE__*/ setDefaultsImpl({});
function setDefaults(options) {
    if (options === undefined) {
        return DEFAULT_OPTIONS;
    }
    return /*@__INLINE__*/ setDefaultsImpl(options);
}

;// ./node_modules/.pnpm/tldts-core@5.7.112/node_modules/tldts-core/dist/es6/src/subdomain.js
/**
 * Returns the subdomain of a hostname string
 */
function getSubdomain(hostname, domain) {
    // If `hostname` and `domain` are the same, then there is no sub-domain
    if (domain.length === hostname.length) {
        return '';
    }
    return hostname.slice(0, -domain.length - 1);
}

;// ./node_modules/.pnpm/tldts-core@5.7.112/node_modules/tldts-core/dist/es6/src/factory.js
/**
 * Implement a factory allowing to plug different implementations of suffix
 * lookup (e.g.: using a trie or the packed hashes datastructures). This is used
 * and exposed in `tldts.ts` and `tldts-experimental.ts` bundle entrypoints.
 */







function getEmptyResult() {
    return {
        domain: null,
        domainWithoutSuffix: null,
        hostname: null,
        isIcann: null,
        isIp: null,
        isPrivate: null,
        publicSuffix: null,
        subdomain: null,
    };
}
function factory_resetResult(result) {
    result.domain = null;
    result.domainWithoutSuffix = null;
    result.hostname = null;
    result.isIcann = null;
    result.isIp = null;
    result.isPrivate = null;
    result.publicSuffix = null;
    result.subdomain = null;
}
function factory_parseImpl(url, step, suffixLookup, partialOptions, result) {
    const options = /*@__INLINE__*/ setDefaults(partialOptions);
    // Very fast approximate check to make sure `url` is a string. This is needed
    // because the library will not necessarily be used in a typed setup and
    // values of arbitrary types might be given as argument.
    if (typeof url !== 'string') {
        return result;
    }
    // Extract hostname from `url` only if needed. This can be made optional
    // using `options.extractHostname`. This option will typically be used
    // whenever we are sure the inputs to `parse` are already hostnames and not
    // arbitrary URLs.
    //
    // `mixedInput` allows to specify if we expect a mix of URLs and hostnames
    // as input. If only hostnames are expected then `extractHostname` can be
    // set to `false` to speed-up parsing. If only URLs are expected then
    // `mixedInputs` can be set to `false`. The `mixedInputs` is only a hint
    // and will not change the behavior of the library.
    if (options.extractHostname === false) {
        result.hostname = url;
    }
    else if (options.mixedInputs === true) {
        result.hostname = extractHostname(url, is_valid(url));
    }
    else {
        result.hostname = extractHostname(url, false);
    }
    if (step === 0 /* FLAG.HOSTNAME */ || result.hostname === null) {
        return result;
    }
    // Check if `hostname` is a valid ip address
    if (options.detectIp === true) {
        result.isIp = isIp(result.hostname);
        if (result.isIp === true) {
            return result;
        }
    }
    // Perform optional hostname validation. If hostname is not valid, no need to
    // go further as there will be no valid domain or sub-domain.
    if (options.validateHostname === true &&
        options.extractHostname === true &&
        is_valid(result.hostname) === false) {
        result.hostname = null;
        return result;
    }
    // Extract public suffix
    suffixLookup(result.hostname, options, result);
    if (step === 2 /* FLAG.PUBLIC_SUFFIX */ || result.publicSuffix === null) {
        return result;
    }
    // Extract domain
    result.domain = getDomain(result.publicSuffix, result.hostname, options);
    if (step === 3 /* FLAG.DOMAIN */ || result.domain === null) {
        return result;
    }
    // Extract subdomain
    result.subdomain = getSubdomain(result.hostname, result.domain);
    if (step === 4 /* FLAG.SUB_DOMAIN */) {
        return result;
    }
    // Extract domain without suffix
    result.domainWithoutSuffix = getDomainWithoutSuffix(result.domain, result.publicSuffix);
    return result;
}

;// ./node_modules/.pnpm/tldts-core@5.7.112/node_modules/tldts-core/dist/es6/src/lookup/fast-path.js
/* harmony default export */ function fast_path(hostname, options, out) {
    // Fast path for very popular suffixes; this allows to by-pass lookup
    // completely as well as any extra allocation or string manipulation.
    if (options.allowPrivateDomains === false && hostname.length > 3) {
        const last = hostname.length - 1;
        const c3 = hostname.charCodeAt(last);
        const c2 = hostname.charCodeAt(last - 1);
        const c1 = hostname.charCodeAt(last - 2);
        const c0 = hostname.charCodeAt(last - 3);
        if (c3 === 109 /* 'm' */ &&
            c2 === 111 /* 'o' */ &&
            c1 === 99 /* 'c' */ &&
            c0 === 46 /* '.' */) {
            out.isIcann = true;
            out.isPrivate = false;
            out.publicSuffix = 'com';
            return true;
        }
        else if (c3 === 103 /* 'g' */ &&
            c2 === 114 /* 'r' */ &&
            c1 === 111 /* 'o' */ &&
            c0 === 46 /* '.' */) {
            out.isIcann = true;
            out.isPrivate = false;
            out.publicSuffix = 'org';
            return true;
        }
        else if (c3 === 117 /* 'u' */ &&
            c2 === 100 /* 'd' */ &&
            c1 === 101 /* 'e' */ &&
            c0 === 46 /* '.' */) {
            out.isIcann = true;
            out.isPrivate = false;
            out.publicSuffix = 'edu';
            return true;
        }
        else if (c3 === 118 /* 'v' */ &&
            c2 === 111 /* 'o' */ &&
            c1 === 103 /* 'g' */ &&
            c0 === 46 /* '.' */) {
            out.isIcann = true;
            out.isPrivate = false;
            out.publicSuffix = 'gov';
            return true;
        }
        else if (c3 === 116 /* 't' */ &&
            c2 === 101 /* 'e' */ &&
            c1 === 110 /* 'n' */ &&
            c0 === 46 /* '.' */) {
            out.isIcann = true;
            out.isPrivate = false;
            out.publicSuffix = 'net';
            return true;
        }
        else if (c3 === 101 /* 'e' */ &&
            c2 === 100 /* 'd' */ &&
            c1 === 46 /* '.' */) {
            out.isIcann = true;
            out.isPrivate = false;
            out.publicSuffix = 'de';
            return true;
        }
    }
    return false;
}

;// ./node_modules/.pnpm/tldts-core@5.7.112/node_modules/tldts-core/dist/es6/index.js




;// ./node_modules/.pnpm/tldts@5.7.112/node_modules/tldts/dist/es6/src/data/trie.js
const exceptions = (function () {
    const _0 = { "$": 1, "succ": {} }, _1 = { "$": 0, "succ": { "city": _0 } };
    const exceptions = { "$": 0, "succ": { "ck": { "$": 0, "succ": { "www": _0 } }, "jp": { "$": 0, "succ": { "kawasaki": _1, "kitakyushu": _1, "kobe": _1, "nagoya": _1, "sapporo": _1, "sendai": _1, "yokohama": _1 } } } };
    ;
    return exceptions;
})();
const rules = (function () {
    const _2 = { "$": 1, "succ": {} }, _3 = { "$": 2, "succ": {} }, _4 = { "$": 1, "succ": { "gov": _2, "com": _2, "org": _2, "net": _2, "edu": _2 } }, _5 = { "$": 0, "succ": { "*": _3 } }, _6 = { "$": 1, "succ": { "blogspot": _3 } }, _7 = { "$": 1, "succ": { "gov": _2 } }, _8 = { "$": 0, "succ": { "*": _2 } }, _9 = { "$": 0, "succ": { "cloud": _3 } }, _10 = { "$": 1, "succ": { "co": _3 } }, _11 = { "$": 2, "succ": { "nodes": _3 } }, _12 = { "$": 0, "succ": { "s3": _3 } }, _13 = { "$": 0, "succ": { "direct": _3 } }, _14 = { "$": 2, "succ": { "id": _3 } }, _15 = { "$": 0, "succ": { "vfs": _3, "webview-assets": _3 } }, _16 = { "$": 0, "succ": { "cloud9": _15 } }, _17 = { "$": 0, "succ": { "dualstack": _12, "cloud9": _15 } }, _18 = { "$": 0, "succ": { "dualstack": _12, "s3": _3, "s3-website": _3, "cloud9": _15 } }, _19 = { "$": 0, "succ": { "apps": _3 } }, _20 = { "$": 0, "succ": { "paas": _3 } }, _21 = { "$": 0, "succ": { "app": _3 } }, _22 = { "$": 2, "succ": { "eu": _3 } }, _23 = { "$": 0, "succ": { "site": _3 } }, _24 = { "$": 0, "succ": { "pages": _3 } }, _25 = { "$": 1, "succ": { "com": _2, "edu": _2, "net": _2, "org": _2 } }, _26 = { "$": 0, "succ": { "j": _3 } }, _27 = { "$": 0, "succ": { "jelastic": _3 } }, _28 = { "$": 0, "succ": { "user": _3 } }, _29 = { "$": 1, "succ": { "ybo": _3 } }, _30 = { "$": 0, "succ": { "cust": _3, "reservd": _3 } }, _31 = { "$": 0, "succ": { "cust": _3 } }, _32 = { "$": 1, "succ": { "gov": _2, "edu": _2, "mil": _2, "com": _2, "org": _2, "net": _2 } }, _33 = { "$": 1, "succ": { "edu": _2, "biz": _2, "net": _2, "org": _2, "gov": _2, "info": _2, "com": _2 } }, _34 = { "$": 1, "succ": { "gov": _2, "blogspot": _3 } }, _35 = { "$": 1, "succ": { "framer": _3 } }, _36 = { "$": 1, "succ": { "barsy": _3 } }, _37 = { "$": 0, "succ": { "forgot": _3 } }, _38 = { "$": 1, "succ": { "gs": _2 } }, _39 = { "$": 0, "succ": { "nes": _2 } }, _40 = { "$": 1, "succ": { "k12": _2, "cc": _2, "lib": _2 } }, _41 = { "$": 1, "succ": { "cc": _2, "lib": _2 } };
    const rules = { "$": 0, "succ": { "ac": { "$": 1, "succ": { "com": _2, "edu": _2, "gov": _2, "net": _2, "mil": _2, "org": _2, "drr": _3 } }, "ad": { "$": 1, "succ": { "nom": _2 } }, "ae": { "$": 1, "succ": { "co": _2, "net": _2, "org": _2, "sch": _2, "ac": _2, "gov": _2, "mil": _2, "blogspot": _3 } }, "aero": { "$": 1, "succ": { "accident-investigation": _2, "accident-prevention": _2, "aerobatic": _2, "aeroclub": _2, "aerodrome": _2, "agents": _2, "aircraft": _2, "airline": _2, "airport": _2, "air-surveillance": _2, "airtraffic": _2, "air-traffic-control": _2, "ambulance": _2, "amusement": _2, "association": _2, "author": _2, "ballooning": _2, "broker": _2, "caa": _2, "cargo": _2, "catering": _2, "certification": _2, "championship": _2, "charter": _2, "civilaviation": _2, "club": _2, "conference": _2, "consultant": _2, "consulting": _2, "control": _2, "council": _2, "crew": _2, "design": _2, "dgca": _2, "educator": _2, "emergency": _2, "engine": _2, "engineer": _2, "entertainment": _2, "equipment": _2, "exchange": _2, "express": _2, "federation": _2, "flight": _2, "fuel": _2, "gliding": _2, "government": _2, "groundhandling": _2, "group": _2, "hanggliding": _2, "homebuilt": _2, "insurance": _2, "journal": _2, "journalist": _2, "leasing": _2, "logistics": _2, "magazine": _2, "maintenance": _2, "media": _2, "microlight": _2, "modelling": _2, "navigation": _2, "parachuting": _2, "paragliding": _2, "passenger-association": _2, "pilot": _2, "press": _2, "production": _2, "recreation": _2, "repbody": _2, "res": _2, "research": _2, "rotorcraft": _2, "safety": _2, "scientist": _2, "services": _2, "show": _2, "skydiving": _2, "software": _2, "student": _2, "trader": _2, "trading": _2, "trainer": _2, "union": _2, "workinggroup": _2, "works": _2 } }, "af": _4, "ag": { "$": 1, "succ": { "com": _2, "org": _2, "net": _2, "co": _2, "nom": _2 } }, "ai": { "$": 1, "succ": { "off": _2, "com": _2, "net": _2, "org": _2, "uwu": _3 } }, "al": { "$": 1, "succ": { "com": _2, "edu": _2, "gov": _2, "mil": _2, "net": _2, "org": _2, "blogspot": _3 } }, "am": { "$": 1, "succ": { "co": _2, "com": _2, "commune": _2, "net": _2, "org": _2, "radio": _3, "blogspot": _3, "neko": _3, "nyaa": _3 } }, "ao": { "$": 1, "succ": { "ed": _2, "gv": _2, "og": _2, "co": _2, "pb": _2, "it": _2 } }, "aq": _2, "ar": { "$": 1, "succ": { "bet": _2, "com": _6, "coop": _2, "edu": _2, "gob": _2, "gov": _2, "int": _2, "mil": _2, "musica": _2, "mutual": _2, "net": _2, "org": _2, "senasa": _2, "tur": _2 } }, "arpa": { "$": 1, "succ": { "e164": _2, "in-addr": _2, "ip6": _2, "iris": _2, "uri": _2, "urn": _2 } }, "as": _7, "asia": { "$": 1, "succ": { "cloudns": _3 } }, "at": { "$": 1, "succ": { "ac": { "$": 1, "succ": { "sth": _2 } }, "co": _6, "gv": _2, "or": _2, "funkfeuer": { "$": 0, "succ": { "wien": _3 } }, "futurecms": { "$": 0, "succ": { "*": _3, "ex": _5, "in": _5 } }, "futurehosting": _3, "futuremailing": _3, "ortsinfo": { "$": 0, "succ": { "ex": _5, "kunden": _5 } }, "biz": _3, "info": _3, "123webseite": _3, "priv": _3, "myspreadshop": _3, "12hp": _3, "2ix": _3, "4lima": _3, "lima-city": _3 } }, "au": { "$": 1, "succ": { "com": { "$": 1, "succ": { "blogspot": _3, "cloudlets": { "$": 0, "succ": { "mel": _3 } }, "myspreadshop": _3 } }, "net": _2, "org": _2, "edu": { "$": 1, "succ": { "act": _2, "catholic": _2, "nsw": { "$": 1, "succ": { "schools": _2 } }, "nt": _2, "qld": _2, "sa": _2, "tas": _2, "vic": _2, "wa": _2 } }, "gov": { "$": 1, "succ": { "qld": _2, "sa": _2, "tas": _2, "vic": _2, "wa": _2 } }, "asn": _2, "id": _2, "info": _2, "conf": _2, "oz": _2, "act": _2, "nsw": _2, "nt": _2, "qld": _2, "sa": _2, "tas": _2, "vic": _2, "wa": _2 } }, "aw": { "$": 1, "succ": { "com": _2 } }, "ax": { "$": 1, "succ": { "be": _3, "cat": _3, "es": _3, "eu": _3, "gg": _3, "mc": _3, "us": _3, "xy": _3 } }, "az": { "$": 1, "succ": { "com": _2, "net": _2, "int": _2, "gov": _2, "org": _2, "edu": _2, "info": _2, "pp": _2, "mil": _2, "name": _2, "pro": _2, "biz": _2 } }, "ba": { "$": 1, "succ": { "com": _2, "edu": _2, "gov": _2, "mil": _2, "net": _2, "org": _2, "rs": _3, "blogspot": _3 } }, "bb": { "$": 1, "succ": { "biz": _2, "co": _2, "com": _2, "edu": _2, "gov": _2, "info": _2, "net": _2, "org": _2, "store": _2, "tv": _2 } }, "bd": _8, "be": { "$": 1, "succ": { "ac": _2, "webhosting": _3, "blogspot": _3, "interhostsolutions": _9, "kuleuven": { "$": 0, "succ": { "ezproxy": _3 } }, "123website": _3, "myspreadshop": _3, "transurl": _5 } }, "bf": _7, "bg": { "$": 1, "succ": { "0": _2, "1": _2, "2": _2, "3": _2, "4": _2, "5": _2, "6": _2, "7": _2, "8": _2, "9": _2, "a": _2, "b": _2, "c": _2, "d": _2, "e": _2, "f": _2, "g": _2, "h": _2, "i": _2, "j": _2, "k": _2, "l": _2, "m": _2, "n": _2, "o": _2, "p": _2, "q": _2, "r": _2, "s": _2, "t": _2, "u": _2, "v": _2, "w": _2, "x": _2, "y": _2, "z": _2, "blogspot": _3, "barsy": _3 } }, "bh": _4, "bi": { "$": 1, "succ": { "co": _2, "com": _2, "edu": _2, "or": _2, "org": _2 } }, "biz": { "$": 1, "succ": { "activetrail": _3, "cloudns": _3, "jozi": _3, "dyndns": _3, "for-better": _3, "for-more": _3, "for-some": _3, "for-the": _3, "selfip": _3, "webhop": _3, "orx": _3, "mmafan": _3, "myftp": _3, "no-ip": _3, "dscloud": _3 } }, "bj": { "$": 1, "succ": { "africa": _2, "agro": _2, "architectes": _2, "assur": _2, "avocats": _2, "co": _2, "com": _2, "eco": _2, "econo": _2, "edu": _2, "info": _2, "loisirs": _2, "money": _2, "net": _2, "org": _2, "ote": _2, "resto": _2, "restaurant": _2, "tourism": _2, "univ": _2, "blogspot": _3 } }, "bm": _4, "bn": { "$": 1, "succ": { "com": _2, "edu": _2, "gov": _2, "net": _2, "org": _2, "co": _3 } }, "bo": { "$": 1, "succ": { "com": _2, "edu": _2, "gob": _2, "int": _2, "org": _2, "net": _2, "mil": _2, "tv": _2, "web": _2, "academia": _2, "agro": _2, "arte": _2, "blog": _2, "bolivia": _2, "ciencia": _2, "cooperativa": _2, "democracia": _2, "deporte": _2, "ecologia": _2, "economia": _2, "empresa": _2, "indigena": _2, "industria": _2, "info": _2, "medicina": _2, "movimiento": _2, "musica": _2, "natural": _2, "nombre": _2, "noticias": _2, "patria": _2, "politica": _2, "profesional": _2, "plurinacional": _2, "pueblo": _2, "revista": _2, "salud": _2, "tecnologia": _2, "tksat": _2, "transporte": _2, "wiki": _2 } }, "br": { "$": 1, "succ": { "9guacu": _2, "abc": _2, "adm": _2, "adv": _2, "agr": _2, "aju": _2, "am": _2, "anani": _2, "aparecida": _2, "app": _2, "arq": _2, "art": _2, "ato": _2, "b": _2, "barueri": _2, "belem": _2, "bhz": _2, "bib": _2, "bio": _2, "blog": _2, "bmd": _2, "boavista": _2, "bsb": _2, "campinagrande": _2, "campinas": _2, "caxias": _2, "cim": _2, "cng": _2, "cnt": _2, "com": { "$": 1, "succ": { "blogspot": _3, "virtualcloud": { "$": 0, "succ": { "scale": { "$": 0, "succ": { "users": _3 } } } }, "simplesite": _3 } }, "contagem": _2, "coop": _2, "coz": _2, "cri": _2, "cuiaba": _2, "curitiba": _2, "def": _2, "des": _2, "det": _2, "dev": _2, "ecn": _2, "eco": _2, "edu": _2, "emp": _2, "enf": _2, "eng": _2, "esp": _2, "etc": _2, "eti": _2, "far": _2, "feira": _2, "flog": _2, "floripa": _2, "fm": _2, "fnd": _2, "fortal": _2, "fot": _2, "foz": _2, "fst": _2, "g12": _2, "geo": _2, "ggf": _2, "goiania": _2, "gov": { "$": 1, "succ": { "ac": _2, "al": _2, "am": _2, "ap": _2, "ba": _2, "ce": _2, "df": _2, "es": _2, "go": _2, "ma": _2, "mg": _2, "ms": _2, "mt": _2, "pa": _2, "pb": _2, "pe": _2, "pi": _2, "pr": _2, "rj": _2, "rn": _2, "ro": _2, "rr": _2, "rs": _2, "sc": _2, "se": _2, "sp": _2, "to": _2 } }, "gru": _2, "imb": _2, "ind": _2, "inf": _2, "jab": _2, "jampa": _2, "jdf": _2, "joinville": _2, "jor": _2, "jus": _2, "leg": { "$": 1, "succ": { "ac": _3, "al": _3, "am": _3, "ap": _3, "ba": _3, "ce": _3, "df": _3, "es": _3, "go": _3, "ma": _3, "mg": _3, "ms": _3, "mt": _3, "pa": _3, "pb": _3, "pe": _3, "pi": _3, "pr": _3, "rj": _3, "rn": _3, "ro": _3, "rr": _3, "rs": _3, "sc": _3, "se": _3, "sp": _3, "to": _3 } }, "lel": _2, "log": _2, "londrina": _2, "macapa": _2, "maceio": _2, "manaus": _2, "maringa": _2, "mat": _2, "med": _2, "mil": _2, "morena": _2, "mp": _2, "mus": _2, "natal": _2, "net": _2, "niteroi": _2, "nom": _8, "not": _2, "ntr": _2, "odo": _2, "ong": _2, "org": _2, "osasco": _2, "palmas": _2, "poa": _2, "ppg": _2, "pro": _2, "psc": _2, "psi": _2, "pvh": _2, "qsl": _2, "radio": _2, "rec": _2, "recife": _2, "rep": _2, "ribeirao": _2, "rio": _2, "riobranco": _2, "riopreto": _2, "salvador": _2, "sampa": _2, "santamaria": _2, "santoandre": _2, "saobernardo": _2, "saogonca": _2, "seg": _2, "sjc": _2, "slg": _2, "slz": _2, "sorocaba": _2, "srv": _2, "taxi": _2, "tc": _2, "tec": _2, "teo": _2, "the": _2, "tmp": _2, "trd": _2, "tur": _2, "tv": _2, "udi": _2, "vet": _2, "vix": _2, "vlog": _2, "wiki": _2, "zlg": _2 } }, "bs": { "$": 1, "succ": { "com": _2, "net": _2, "org": _2, "edu": _2, "gov": _2, "we": _3 } }, "bt": _4, "bv": _2, "bw": { "$": 1, "succ": { "co": _2, "org": _2 } }, "by": { "$": 1, "succ": { "gov": _2, "mil": _2, "com": _6, "of": _2, "mycloud": _3, "mediatech": _3 } }, "bz": { "$": 1, "succ": { "com": _2, "net": _2, "org": _2, "edu": _2, "gov": _2, "za": _3, "gsj": _3 } }, "ca": { "$": 1, "succ": { "ab": _2, "bc": _2, "mb": _2, "nb": _2, "nf": _2, "nl": _2, "ns": _2, "nt": _2, "nu": _2, "on": _2, "pe": _2, "qc": _2, "sk": _2, "yk": _2, "gc": _2, "barsy": _3, "awdev": _5, "co": _3, "blogspot": _3, "no-ip": _3, "myspreadshop": _3 } }, "cat": _2, "cc": { "$": 1, "succ": { "cloudns": _3, "ftpaccess": _3, "game-server": _3, "myphotos": _3, "scrapping": _3, "twmail": _3, "csx": _3, "fantasyleague": _3, "spawn": { "$": 0, "succ": { "instances": _3 } } } }, "cd": _7, "cf": _6, "cg": _2, "ch": { "$": 1, "succ": { "square7": _3, "blogspot": _3, "flow": { "$": 0, "succ": { "ae": { "$": 0, "succ": { "alp1": _3 } }, "appengine": _3 } }, "linkyard-cloud": _3, "dnsking": _3, "gotdns": _3, "123website": _3, "myspreadshop": _3, "firenet": { "$": 0, "succ": { "*": _3, "svc": _5 } }, "12hp": _3, "2ix": _3, "4lima": _3, "lima-city": _3 } }, "ci": { "$": 1, "succ": { "org": _2, "or": _2, "com": _2, "co": _2, "edu": _2, "ed": _2, "ac": _2, "net": _2, "go": _2, "asso": _2, "xn--aroport-bya": _2, "aéroport": _2, "int": _2, "presse": _2, "md": _2, "gouv": _2, "fin": _3, "nl": _3 } }, "ck": _8, "cl": { "$": 1, "succ": { "co": _2, "gob": _2, "gov": _2, "mil": _2, "blogspot": _3 } }, "cm": { "$": 1, "succ": { "co": _2, "com": _2, "gov": _2, "net": _2 } }, "cn": { "$": 1, "succ": { "ac": _2, "com": { "$": 1, "succ": { "amazonaws": { "$": 0, "succ": { "compute": _5, "cn-north-1": _12, "eb": { "$": 0, "succ": { "cn-north-1": _3, "cn-northwest-1": _3 } }, "elb": _5 } } } }, "edu": _2, "gov": _2, "net": _2, "org": _2, "mil": _2, "xn--55qx5d": _2, "公司": _2, "xn--io0a7i": _2, "网络": _2, "xn--od0alg": _2, "網絡": _2, "ah": _2, "bj": _2, "cq": _2, "fj": _2, "gd": _2, "gs": _2, "gz": _2, "gx": _2, "ha": _2, "hb": _2, "he": _2, "hi": _2, "hl": _2, "hn": _2, "jl": _2, "js": _2, "jx": _2, "ln": _2, "nm": _2, "nx": _2, "qh": _2, "sc": _2, "sd": _2, "sh": _2, "sn": _2, "sx": _2, "tj": _2, "xj": _2, "xz": _2, "yn": _2, "zj": _2, "hk": _2, "mo": _2, "tw": _2, "canva-apps": _3, "instantcloud": _3, "quickconnect": _13 } }, "co": { "$": 1, "succ": { "arts": _2, "com": _6, "edu": _2, "firm": _2, "gov": _2, "info": _2, "int": _2, "mil": _2, "net": _2, "nom": _2, "org": _2, "rec": _2, "web": _2, "carrd": _3, "crd": _3, "otap": _5, "leadpages": _3, "lpages": _3, "mypi": _3, "n4t": _3, "firewalledreplit": _14, "repl": _14, "supabase": _3 } }, "com": { "$": 1, "succ": { "devcdnaccesso": _5, "adobeaemcloud": { "$": 2, "succ": { "dev": _5 } }, "airkitapps": _3, "airkitapps-au": _3, "aivencloud": _3, "kasserver": _3, "amazonaws": { "$": 0, "succ": { "compute": _5, "compute-1": _5, "us-east-1": { "$": 2, "succ": { "dualstack": _12, "cloud9": _15 } }, "ap-northeast-1": _17, "ap-northeast-2": _18, "ap-south-1": _18, "ap-southeast-1": _17, "ap-southeast-2": _17, "ca-central-1": _18, "eu-central-1": _18, "eu-west-1": _17, "eu-west-2": _18, "eu-west-3": _18, "s3": _3, "s3-ap-northeast-1": _3, "s3-ap-northeast-2": _3, "s3-ap-south-1": _3, "s3-ap-southeast-1": _3, "s3-ap-southeast-2": _3, "s3-ca-central-1": _3, "s3-eu-central-1": _3, "s3-eu-west-1": _3, "s3-eu-west-2": _3, "s3-eu-west-3": _3, "s3-external-1": _3, "s3-fips-us-gov-west-1": _3, "s3-sa-east-1": _3, "s3-us-east-2": _3, "s3-us-gov-west-1": _3, "s3-us-west-1": _3, "s3-us-west-2": _3, "s3-website-ap-northeast-1": _3, "s3-website-ap-southeast-1": _3, "s3-website-ap-southeast-2": _3, "s3-website-eu-west-1": _3, "s3-website-sa-east-1": _3, "s3-website-us-east-1": _3, "s3-website-us-west-1": _3, "s3-website-us-west-2": _3, "sa-east-1": _17, "us-east-2": _18, "af-south-1": _16, "ap-east-1": _16, "ap-northeast-3": _16, "eu-north-1": _16, "eu-south-1": _16, "me-south-1": _16, "us-west-1": _16, "us-west-2": _16, "elb": _5 } }, "elasticbeanstalk": { "$": 2, "succ": { "ap-northeast-1": _3, "ap-northeast-2": _3, "ap-northeast-3": _3, "ap-south-1": _3, "ap-southeast-1": _3, "ap-southeast-2": _3, "ca-central-1": _3, "eu-central-1": _3, "eu-west-1": _3, "eu-west-2": _3, "eu-west-3": _3, "sa-east-1": _3, "us-east-1": _3, "us-east-2": _3, "us-gov-west-1": _3, "us-west-1": _3, "us-west-2": _3 } }, "awsglobalaccelerator": _3, "siiites": _3, "appspacehosted": _3, "appspaceusercontent": _3, "on-aptible": _3, "myasustor": _3, "balena-devices": _3, "betainabox": _3, "boutir": _3, "bplaced": _3, "cafjs": _3, "canva-apps": _3, "br": _3, "cn": _3, "de": _3, "eu": _3, "jpn": _3, "mex": _3, "ru": _3, "sa": _3, "uk": _3, "us": _3, "za": _3, "ar": _3, "hu": _3, "kr": _3, "no": _3, "qc": _3, "uy": _3, "africa": _3, "gr": _3, "co": _3, "jdevcloud": _3, "wpdevcloud": _3, "cloudcontrolled": _3, "cloudcontrolapp": _3, "cf-ipfs": _3, "cloudflare-ipfs": _3, "trycloudflare": _3, "customer-oci": { "$": 0, "succ": { "*": _3, "oci": _5, "ocp": _5, "ocs": _5 } }, "dattolocal": _3, "dattorelay": _3, "dattoweb": _3, "mydatto": _3, "builtwithdark": _3, "datadetect": { "$": 0, "succ": { "demo": _3, "instance": _3 } }, "ddns5": _3, "discordsays": _3, "discordsez": _3, "drayddns": _3, "dreamhosters": _3, "mydrobo": _3, "dyndns-at-home": _3, "dyndns-at-work": _3, "dyndns-blog": _3, "dyndns-free": _3, "dyndns-home": _3, "dyndns-ip": _3, "dyndns-mail": _3, "dyndns-office": _3, "dyndns-pics": _3, "dyndns-remote": _3, "dyndns-server": _3, "dyndns-web": _3, "dyndns-wiki": _3, "dyndns-work": _3, "blogdns": _3, "cechire": _3, "dnsalias": _3, "dnsdojo": _3, "doesntexist": _3, "dontexist": _3, "doomdns": _3, "dyn-o-saur": _3, "dynalias": _3, "est-a-la-maison": _3, "est-a-la-masion": _3, "est-le-patron": _3, "est-mon-blogueur": _3, "from-ak": _3, "from-al": _3, "from-ar": _3, "from-ca": _3, "from-ct": _3, "from-dc": _3, "from-de": _3, "from-fl": _3, "from-ga": _3, "from-hi": _3, "from-ia": _3, "from-id": _3, "from-il": _3, "from-in": _3, "from-ks": _3, "from-ky": _3, "from-ma": _3, "from-md": _3, "from-mi": _3, "from-mn": _3, "from-mo": _3, "from-ms": _3, "from-mt": _3, "from-nc": _3, "from-nd": _3, "from-ne": _3, "from-nh": _3, "from-nj": _3, "from-nm": _3, "from-nv": _3, "from-oh": _3, "from-ok": _3, "from-or": _3, "from-pa": _3, "from-pr": _3, "from-ri": _3, "from-sc": _3, "from-sd": _3, "from-tn": _3, "from-tx": _3, "from-ut": _3, "from-va": _3, "from-vt": _3, "from-wa": _3, "from-wi": _3, "from-wv": _3, "from-wy": _3, "getmyip": _3, "gotdns": _3, "hobby-site": _3, "homelinux": _3, "homeunix": _3, "iamallama": _3, "is-a-anarchist": _3, "is-a-blogger": _3, "is-a-bookkeeper": _3, "is-a-bulls-fan": _3, "is-a-caterer": _3, "is-a-chef": _3, "is-a-conservative": _3, "is-a-cpa": _3, "is-a-cubicle-slave": _3, "is-a-democrat": _3, "is-a-designer": _3, "is-a-doctor": _3, "is-a-financialadvisor": _3, "is-a-geek": _3, "is-a-green": _3, "is-a-guru": _3, "is-a-hard-worker": _3, "is-a-hunter": _3, "is-a-landscaper": _3, "is-a-lawyer": _3, "is-a-liberal": _3, "is-a-libertarian": _3, "is-a-llama": _3, "is-a-musician": _3, "is-a-nascarfan": _3, "is-a-nurse": _3, "is-a-painter": _3, "is-a-personaltrainer": _3, "is-a-photographer": _3, "is-a-player": _3, "is-a-republican": _3, "is-a-rockstar": _3, "is-a-socialist": _3, "is-a-student": _3, "is-a-teacher": _3, "is-a-techie": _3, "is-a-therapist": _3, "is-an-accountant": _3, "is-an-actor": _3, "is-an-actress": _3, "is-an-anarchist": _3, "is-an-artist": _3, "is-an-engineer": _3, "is-an-entertainer": _3, "is-certified": _3, "is-gone": _3, "is-into-anime": _3, "is-into-cars": _3, "is-into-cartoons": _3, "is-into-games": _3, "is-leet": _3, "is-not-certified": _3, "is-slick": _3, "is-uberleet": _3, "is-with-theband": _3, "isa-geek": _3, "isa-hockeynut": _3, "issmarterthanyou": _3, "likes-pie": _3, "likescandy": _3, "neat-url": _3, "saves-the-whales": _3, "selfip": _3, "sells-for-less": _3, "sells-for-u": _3, "servebbs": _3, "simple-url": _3, "space-to-rent": _3, "teaches-yoga": _3, "writesthisblog": _3, "digitaloceanspaces": _5, "ddnsfree": _3, "ddnsgeek": _3, "giize": _3, "gleeze": _3, "kozow": _3, "loseyourip": _3, "ooguy": _3, "theworkpc": _3, "mytuleap": _3, "tuleap-partners": _3, "encoreapi": _3, "evennode": { "$": 0, "succ": { "eu-1": _3, "eu-2": _3, "eu-3": _3, "eu-4": _3, "us-1": _3, "us-2": _3, "us-3": _3, "us-4": _3 } }, "onfabrica": _3, "fbsbx": _19, "fastly-edge": _3, "fastly-terrarium": _3, "fastvps-server": _3, "mydobiss": _3, "firebaseapp": _3, "fldrv": _3, "forgeblocks": _3, "framercanvas": _3, "freebox-os": _3, "freeboxos": _3, "freemyip": _3, "gentapps": _3, "gentlentapis": _3, "githubusercontent": _3, "0emm": _5, "appspot": { "$": 2, "succ": { "r": _5 } }, "codespot": _3, "googleapis": _3, "googlecode": _3, "pagespeedmobilizer": _3, "publishproxy": _3, "withgoogle": _3, "withyoutube": _3, "blogspot": _3, "awsmppl": _3, "herokuapp": _3, "herokussl": _3, "impertrixcdn": _3, "impertrix": _3, "smushcdn": _3, "wphostedmail": _3, "wpmucdn": _3, "pixolino": _3, "amscompute": _3, "clicketcloud": _3, "dopaas": _3, "hidora": _3, "hosted-by-previder": _20, "hosteur": { "$": 0, "succ": { "rag-cloud": _3, "rag-cloud-ch": _3 } }, "ik-server": { "$": 0, "succ": { "jcloud": _3, "jcloud-ver-jpc": _3 } }, "jelastic": { "$": 0, "succ": { "demo": _3 } }, "kilatiron": _3, "massivegrid": _20, "wafaicloud": { "$": 0, "succ": { "jed": _3, "lon": _3, "ryd": _3 } }, "joyent": { "$": 0, "succ": { "cns": _5 } }, "ktistory": _3, "lpusercontent": _3, "lmpm": _21, "linode": { "$": 0, "succ": { "members": _3, "nodebalancer": _5 } }, "linodeobjects": _5, "linodeusercontent": { "$": 0, "succ": { "ip": _3 } }, "barsycenter": _3, "barsyonline": _3, "mazeplay": _3, "miniserver": _3, "meteorapp": _22, "hostedpi": _3, "mythic-beasts": { "$": 0, "succ": { "customer": _3, "caracal": _3, "fentiger": _3, "lynx": _3, "ocelot": _3, "oncilla": _3, "onza": _3, "sphinx": _3, "vs": _3, "x": _3, "yali": _3 } }, "nospamproxy": _9, "4u": _3, "nfshost": _3, "001www": _3, "ddnslive": _3, "myiphost": _3, "blogsyte": _3, "ciscofreak": _3, "damnserver": _3, "ditchyourip": _3, "dnsiskinky": _3, "dynns": _3, "geekgalaxy": _3, "health-carereform": _3, "homesecuritymac": _3, "homesecuritypc": _3, "myactivedirectory": _3, "mysecuritycamera": _3, "net-freaks": _3, "onthewifi": _3, "point2this": _3, "quicksytes": _3, "securitytactics": _3, "serveexchange": _3, "servehumour": _3, "servep2p": _3, "servesarcasm": _3, "stufftoread": _3, "unusualperson": _3, "workisboring": _3, "3utilities": _3, "ddnsking": _3, "myvnc": _3, "servebeer": _3, "servecounterstrike": _3, "serveftp": _3, "servegame": _3, "servehalflife": _3, "servehttp": _3, "serveirc": _3, "servemp3": _3, "servepics": _3, "servequake": _3, "observableusercontent": { "$": 0, "succ": { "static": _3 } }, "simplesite": _3, "orsites": _3, "operaunite": _3, "authgear-staging": _3, "authgearapps": _3, "skygearapp": _3, "outsystemscloud": _3, "ownprovider": _3, "pgfog": _3, "pagefrontapp": _3, "pagexl": _3, "paywhirl": _5, "gotpantheon": _3, "platter-app": _3, "pleskns": _3, "postman-echo": _3, "prgmr": { "$": 0, "succ": { "xen": _3 } }, "pythonanywhere": _22, "qualifioapp": _3, "qbuser": _3, "qa2": _3, "dev-myqnapcloud": _3, "alpha-myqnapcloud": _3, "myqnapcloud": _3, "quipelements": _5, "rackmaze": _3, "rhcloud": _3, "render": _21, "onrender": _3, "180r": _3, "dojin": _3, "sakuratan": _3, "sakuraweb": _3, "x0": _3, "code": { "$": 0, "succ": { "builder": _5, "dev-builder": _5, "stg-builder": _5 } }, "logoip": _3, "scrysec": _3, "firewall-gateway": _3, "myshopblocks": _3, "myshopify": _3, "shopitsite": _3, "1kapp": _3, "appchizi": _3, "applinzi": _3, "sinaapp": _3, "vipsinaapp": _3, "bounty-full": { "$": 2, "succ": { "alpha": _3, "beta": _3 } }, "streamlitapp": _3, "try-snowplow": _3, "stackhero-network": _3, "playstation-cloud": _3, "myspreadshop": _3, "stdlib": { "$": 0, "succ": { "api": _3 } }, "temp-dns": _3, "dsmynas": _3, "familyds": _3, "mytabit": _3, "tb-hosting": _23, "reservd": _3, "thingdustdata": _3, "bloxcms": _3, "townnews-staging": _3, "typeform": { "$": 0, "succ": { "pro": _3 } }, "hk": _3, "it": _3, "vultrobjects": _5, "wafflecell": _3, "reserve-online": _3, "hotelwithflight": _3, "remotewd": _3, "wiardweb": _24, "messwithdns": _3, "woltlab-demo": _3, "wpenginepowered": { "$": 2, "succ": { "js": _3 } }, "wixsite": _3, "xnbay": { "$": 2, "succ": { "u2": _3, "u2-local": _3 } }, "yolasite": _3 } }, "coop": _2, "cr": { "$": 1, "succ": { "ac": _2, "co": _2, "ed": _2, "fi": _2, "go": _2, "or": _2, "sa": _2 } }, "cu": { "$": 1, "succ": { "com": _2, "edu": _2, "org": _2, "net": _2, "gov": _2, "inf": _2 } }, "cv": { "$": 1, "succ": { "com": _2, "edu": _2, "int": _2, "nome": _2, "org": _2, "blogspot": _3 } }, "cw": _25, "cx": { "$": 1, "succ": { "gov": _2, "ath": _3, "info": _3 } }, "cy": { "$": 1, "succ": { "ac": _2, "biz": _2, "com": { "$": 1, "succ": { "blogspot": _3, "scaleforce": _26 } }, "ekloges": _2, "gov": _2, "ltd": _2, "mil": _2, "net": _2, "org": _2, "press": _2, "pro": _2, "tm": _2 } }, "cz": { "$": 1, "succ": { "co": _3, "realm": _3, "e4": _3, "blogspot": _3, "metacentrum": { "$": 0, "succ": { "cloud": _5, "custom": _3 } }, "muni": { "$": 0, "succ": { "cloud": { "$": 0, "succ": { "flt": _3, "usr": _3 } } } } } }, "de": { "$": 1, "succ": { "bplaced": _3, "square7": _3, "com": _3, "cosidns": { "$": 0, "succ": { "dyn": _3 } }, "dynamisches-dns": _3, "dnsupdater": _3, "internet-dns": _3, "l-o-g-i-n": _3, "dnshome": _3, "fuettertdasnetz": _3, "isteingeek": _3, "istmein": _3, "lebtimnetz": _3, "leitungsen": _3, "traeumtgerade": _3, "ddnss": { "$": 2, "succ": { "dyn": _3, "dyndns": _3 } }, "dyndns1": _3, "dyn-ip24": _3, "home-webserver": { "$": 2, "succ": { "dyn": _3 } }, "myhome-server": _3, "frusky": _5, "goip": _3, "blogspot": _3, "xn--gnstigbestellen-zvb": _3, "günstigbestellen": _3, "xn--gnstigliefern-wob": _3, "günstigliefern": _3, "hs-heilbronn": { "$": 0, "succ": { "it": _24 } }, "dyn-berlin": _3, "in-berlin": _3, "in-brb": _3, "in-butter": _3, "in-dsl": _3, "in-vpn": _3, "iservschule": _3, "mein-iserv": _3, "schulplattform": _3, "schulserver": _3, "test-iserv": _3, "keymachine": _3, "git-repos": _3, "lcube-server": _3, "svn-repos": _3, "barsy": _3, "123webseite": _3, "logoip": _3, "firewall-gateway": _3, "my-gateway": _3, "my-router": _3, "spdns": _3, "speedpartner": { "$": 0, "succ": { "customer": _3 } }, "myspreadshop": _3, "taifun-dns": _3, "12hp": _3, "2ix": _3, "4lima": _3, "lima-city": _3, "dd-dns": _3, "dray-dns": _3, "draydns": _3, "dyn-vpn": _3, "dynvpn": _3, "mein-vigor": _3, "my-vigor": _3, "my-wan": _3, "syno-ds": _3, "synology-diskstation": _3, "synology-ds": _3, "uberspace": _5, "virtualuser": _3, "virtual-user": _3, "community-pro": _3, "diskussionsbereich": _3 } }, "dj": _2, "dk": { "$": 1, "succ": { "biz": _3, "co": _3, "firm": _3, "reg": _3, "store": _3, "blogspot": _3, "123hjemmeside": _3, "myspreadshop": _3 } }, "dm": _4, "do": { "$": 1, "succ": { "art": _2, "com": _2, "edu": _2, "gob": _2, "gov": _2, "mil": _2, "net": _2, "org": _2, "sld": _2, "web": _2 } }, "dz": { "$": 1, "succ": { "art": _2, "asso": _2, "com": _2, "edu": _2, "gov": _2, "org": _2, "net": _2, "pol": _2, "soc": _2, "tm": _2 } }, "ec": { "$": 1, "succ": { "com": _2, "info": _2, "net": _2, "fin": _2, "k12": _2, "med": _2, "pro": _2, "org": _2, "edu": _2, "gov": _2, "gob": _2, "mil": _2, "base": _3, "official": _3 } }, "edu": { "$": 1, "succ": { "rit": { "$": 0, "succ": { "git-pages": _3 } } } }, "ee": { "$": 1, "succ": { "edu": _2, "gov": _2, "riik": _2, "lib": _2, "med": _2, "com": _6, "pri": _2, "aip": _2, "org": _2, "fie": _2 } }, "eg": { "$": 1, "succ": { "com": _6, "edu": _2, "eun": _2, "gov": _2, "mil": _2, "name": _2, "net": _2, "org": _2, "sci": _2 } }, "er": _8, "es": { "$": 1, "succ": { "com": _6, "nom": _2, "org": _2, "gob": _2, "edu": _2, "123miweb": _3, "myspreadshop": _3 } }, "et": { "$": 1, "succ": { "com": _2, "gov": _2, "org": _2, "edu": _2, "biz": _2, "name": _2, "info": _2, "net": _2 } }, "eu": { "$": 1, "succ": { "airkitapps": _3, "mycd": _3, "cloudns": _3, "dogado": _27, "barsy": _3, "wellbeingzone": _3, "spdns": _3, "transurl": _5, "diskstation": _3 } }, "fi": { "$": 1, "succ": { "aland": _2, "dy": _3, "blogspot": _3, "xn--hkkinen-5wa": _3, "häkkinen": _3, "iki": _3, "cloudplatform": { "$": 0, "succ": { "fi": _3 } }, "datacenter": { "$": 0, "succ": { "demo": _3, "paas": _3 } }, "kapsi": _3, "123kotisivu": _3, "myspreadshop": _3 } }, "fj": { "$": 1, "succ": { "ac": _2, "biz": _2, "com": _2, "gov": _2, "info": _2, "mil": _2, "name": _2, "net": _2, "org": _2, "pro": _2 } }, "fk": _8, "fm": { "$": 1, "succ": { "com": _2, "edu": _2, "net": _2, "org": _2, "radio": _3, "user": _5 } }, "fo": _2, "fr": { "$": 1, "succ": { "asso": _2, "com": _2, "gouv": _2, "nom": _2, "prd": _2, "tm": _2, "aeroport": _2, "avocat": _2, "avoues": _2, "cci": _2, "chambagri": _2, "chirurgiens-dentistes": _2, "experts-comptables": _2, "geometre-expert": _2, "greta": _2, "huissier-justice": _2, "medecin": _2, "notaires": _2, "pharmacien": _2, "port": _2, "veterinaire": _2, "en-root": _3, "fbx-os": _3, "fbxos": _3, "freebox-os": _3, "freeboxos": _3, "blogspot": _3, "goupile": _3, "123siteweb": _3, "on-web": _3, "chirurgiens-dentistes-en-france": _3, "dedibox": _3, "myspreadshop": _3, "ynh": _3 } }, "ga": _2, "gb": _2, "gd": { "$": 1, "succ": { "edu": _2, "gov": _2 } }, "ge": { "$": 1, "succ": { "com": _2, "edu": _2, "gov": _2, "org": _2, "mil": _2, "net": _2, "pvt": _2 } }, "gf": _2, "gg": { "$": 1, "succ": { "co": _2, "net": _2, "org": _2, "kaas": _3, "cya": _3, "panel": { "$": 2, "succ": { "daemon": _3 } } } }, "gh": { "$": 1, "succ": { "com": _2, "edu": _2, "gov": _2, "org": _2, "mil": _2 } }, "gi": { "$": 1, "succ": { "com": _2, "ltd": _2, "gov": _2, "mod": _2, "edu": _2, "org": _2 } }, "gl": { "$": 1, "succ": { "co": _2, "com": _2, "edu": _2, "net": _2, "org": _2, "biz": _3, "xx": _3 } }, "gm": _2, "gn": { "$": 1, "succ": { "ac": _2, "com": _2, "edu": _2, "gov": _2, "org": _2, "net": _2 } }, "gov": _2, "gp": { "$": 1, "succ": { "com": _2, "net": _2, "mobi": _2, "edu": _2, "org": _2, "asso": _2, "app": _3 } }, "gq": _2, "gr": { "$": 1, "succ": { "com": _2, "edu": _2, "net": _2, "org": _2, "gov": _2, "blogspot": _3, "simplesite": _3 } }, "gs": _2, "gt": { "$": 1, "succ": { "com": _2, "edu": _2, "gob": _2, "ind": _2, "mil": _2, "net": _2, "org": _2, "blog": _3, "de": _3, "to": _3 } }, "gu": { "$": 1, "succ": { "com": _2, "edu": _2, "gov": _2, "guam": _2, "info": _2, "net": _2, "org": _2, "web": _2 } }, "gw": _2, "gy": { "$": 1, "succ": { "co": _2, "com": _2, "edu": _2, "gov": _2, "net": _2, "org": _2, "be": _3 } }, "hk": { "$": 1, "succ": { "com": _2, "edu": _2, "gov": _2, "idv": _2, "net": _2, "org": _2, "xn--55qx5d": _2, "公司": _2, "xn--wcvs22d": _2, "教育": _2, "xn--lcvr32d": _2, "敎育": _2, "xn--mxtq1m": _2, "政府": _2, "xn--gmqw5a": _2, "個人": _2, "xn--ciqpn": _2, "个人": _2, "xn--gmq050i": _2, "箇人": _2, "xn--zf0avx": _2, "網络": _2, "xn--io0a7i": _2, "网络": _2, "xn--mk0axi": _2, "组織": _2, "xn--od0alg": _2, "網絡": _2, "xn--od0aq3b": _2, "网絡": _2, "xn--tn0ag": _2, "组织": _2, "xn--uc0atv": _2, "組織": _2, "xn--uc0ay4a": _2, "組织": _2, "blogspot": _3, "secaas": _3, "ltd": _3, "inc": _3 } }, "hm": _2, "hn": { "$": 1, "succ": { "com": _2, "edu": _2, "org": _2, "net": _2, "mil": _2, "gob": _2, "cc": _3 } }, "hr": { "$": 1, "succ": { "iz": _2, "from": _2, "name": _2, "com": _2, "blogspot": _3, "free": _3 } }, "ht": { "$": 1, "succ": { "com": _2, "shop": _2, "firm": _2, "info": _2, "adult": _2, "net": _2, "pro": _2, "org": _2, "med": _2, "art": _2, "coop": _2, "pol": _2, "asso": _2, "edu": _2, "rel": _2, "gouv": _2, "perso": _2 } }, "hu": { "$": 1, "succ": { "2000": _2, "co": _2, "info": _2, "org": _2, "priv": _2, "sport": _2, "tm": _2, "agrar": _2, "bolt": _2, "casino": _2, "city": _2, "erotica": _2, "erotika": _2, "film": _2, "forum": _2, "games": _2, "hotel": _2, "ingatlan": _2, "jogasz": _2, "konyvelo": _2, "lakas": _2, "media": _2, "news": _2, "reklam": _2, "sex": _2, "shop": _2, "suli": _2, "szex": _2, "tozsde": _2, "utazas": _2, "video": _2, "blogspot": _3 } }, "id": { "$": 1, "succ": { "ac": _2, "biz": _2, "co": _6, "desa": _2, "go": _2, "mil": _2, "my": { "$": 1, "succ": { "rss": _5 } }, "net": _2, "or": _2, "ponpes": _2, "sch": _2, "web": _2, "flap": _3, "forte": _3 } }, "ie": { "$": 1, "succ": { "gov": _2, "blogspot": _3, "myspreadshop": _3 } }, "il": { "$": 1, "succ": { "ac": _2, "co": { "$": 1, "succ": { "ravpage": _3, "blogspot": _3, "tabitorder": _3, "mytabit": _3 } }, "gov": _2, "idf": _2, "k12": _2, "muni": _2, "net": _2, "org": _2 } }, "xn--4dbrk0ce": { "$": 1, "succ": { "xn--4dbgdty6c": _2, "xn--5dbhl8d": _2, "xn--8dbq2a": _2, "xn--hebda8b": _2 } }, "ישראל": { "$": 1, "succ": { "אקדמיה": _2, "ישוב": _2, "צהל": _2, "ממשל": _2 } }, "im": { "$": 1, "succ": { "ac": _2, "co": { "$": 1, "succ": { "ltd": _2, "plc": _2 } }, "com": _2, "net": _2, "org": _2, "tt": _2, "tv": _2, "ro": _3 } }, "in": { "$": 1, "succ": { "5g": _2, "6g": _2, "ac": _2, "ai": _2, "am": _2, "bihar": _2, "biz": _2, "business": _2, "ca": _2, "cn": _2, "co": _2, "com": _2, "coop": _2, "cs": _2, "delhi": _2, "dr": _2, "edu": _2, "er": _2, "firm": _2, "gen": _2, "gov": _2, "gujarat": _2, "ind": _2, "info": _2, "int": _2, "internet": _2, "io": _2, "me": _2, "mil": _2, "net": _2, "nic": _2, "org": _2, "pg": _2, "post": _2, "pro": _2, "res": _2, "travel": _2, "tv": _2, "uk": _2, "up": _2, "us": _2, "web": _3, "cloudns": _3, "blogspot": _3, "barsy": _3, "supabase": _3 } }, "info": { "$": 1, "succ": { "cloudns": _3, "dynamic-dns": _3, "dyndns": _3, "barrel-of-knowledge": _3, "barrell-of-knowledge": _3, "for-our": _3, "groks-the": _3, "groks-this": _3, "here-for-more": _3, "knowsitall": _3, "selfip": _3, "webhop": _3, "barsy": _3, "mayfirst": _3, "forumz": _3, "nsupdate": _3, "dvrcam": _3, "ilovecollege": _3, "no-ip": _3, "dnsupdate": _3, "v-info": _3 } }, "int": { "$": 1, "succ": { "eu": _2 } }, "io": { "$": 1, "succ": { "2038": _3, "com": _2, "on-acorn": _5, "apigee": _3, "b-data": _3, "backplaneapp": _3, "banzaicloud": { "$": 0, "succ": { "app": _3, "backyards": _5 } }, "beagleboard": _3, "bitbucket": _3, "bluebite": _3, "boxfuse": _3, "browsersafetymark": _3, "bigv": { "$": 0, "succ": { "uk0": _3 } }, "cleverapps": _3, "dappnode": { "$": 0, "succ": { "dyndns": _3 } }, "dedyn": _3, "drud": _3, "definima": _3, "fh-muenster": _3, "shw": _3, "forgerock": { "$": 0, "succ": { "id": _3 } }, "ghost": _3, "github": _3, "gitlab": _3, "lolipop": _3, "hasura-app": _3, "hostyhosting": _3, "moonscale": _5, "beebyte": _20, "beebyteapp": { "$": 0, "succ": { "sekd1": _3 } }, "jele": _3, "unispace": { "$": 0, "succ": { "cloud-fr1": _3 } }, "webthings": _3, "loginline": _3, "barsy": _3, "azurecontainer": _5, "ngrok": { "$": 2, "succ": { "ap": _3, "au": _3, "eu": _3, "in": _3, "jp": _3, "sa": _3, "us": _3 } }, "nodeart": { "$": 0, "succ": { "stage": _3 } }, "nid": _3, "pantheonsite": _3, "dyn53": _3, "pstmn": { "$": 2, "succ": { "mock": _3 } }, "protonet": _3, "qoto": _3, "qcx": { "$": 2, "succ": { "sys": _5 } }, "vaporcloud": _3, "vbrplsbx": { "$": 0, "succ": { "g": _3 } }, "on-k3s": _5, "on-rio": _5, "readthedocs": _3, "resindevice": _3, "resinstaging": { "$": 0, "succ": { "devices": _3 } }, "hzc": _3, "sandcats": _3, "shiftcrypto": _3, "shiftedit": _3, "mo-siemens": _3, "musician": _3, "lair": _19, "stolos": _5, "spacekit": _3, "utwente": _3, "s5y": _5, "edugit": _3, "telebit": _3, "thingdust": { "$": 0, "succ": { "dev": _30, "disrec": _30, "prod": _31, "testing": _30 } }, "tickets": _3, "upli": _3, "wedeploy": _3, "editorx": _3, "basicserver": _3, "virtualserver": _3 } }, "iq": _32, "ir": { "$": 1, "succ": { "ac": _2, "co": _2, "gov": _2, "id": _2, "net": _2, "org": _2, "sch": _2, "xn--mgba3a4f16a": _2, "ایران": _2, "xn--mgba3a4fra": _2, "ايران": _2 } }, "is": { "$": 1, "succ": { "net": _2, "com": _2, "edu": _2, "gov": _2, "org": _2, "int": _2, "cupcake": _3, "blogspot": _3 } }, "it": { "$": 1, "succ": { "gov": _2, "edu": _2, "abr": _2, "abruzzo": _2, "aosta-valley": _2, "aostavalley": _2, "bas": _2, "basilicata": _2, "cal": _2, "calabria": _2, "cam": _2, "campania": _2, "emilia-romagna": _2, "emiliaromagna": _2, "emr": _2, "friuli-v-giulia": _2, "friuli-ve-giulia": _2, "friuli-vegiulia": _2, "friuli-venezia-giulia": _2, "friuli-veneziagiulia": _2, "friuli-vgiulia": _2, "friuliv-giulia": _2, "friulive-giulia": _2, "friulivegiulia": _2, "friulivenezia-giulia": _2, "friuliveneziagiulia": _2, "friulivgiulia": _2, "fvg": _2, "laz": _2, "lazio": _2, "lig": _2, "liguria": _2, "lom": _2, "lombardia": _2, "lombardy": _2, "lucania": _2, "mar": _2, "marche": _2, "mol": _2, "molise": _2, "piedmont": _2, "piemonte": _2, "pmn": _2, "pug": _2, "puglia": _2, "sar": _2, "sardegna": _2, "sardinia": _2, "sic": _2, "sicilia": _2, "sicily": _2, "taa": _2, "tos": _2, "toscana": _2, "trentin-sud-tirol": _2, "xn--trentin-sd-tirol-rzb": _2, "trentin-süd-tirol": _2, "trentin-sudtirol": _2, "xn--trentin-sdtirol-7vb": _2, "trentin-südtirol": _2, "trentin-sued-tirol": _2, "trentin-suedtirol": _2, "trentino-a-adige": _2, "trentino-aadige": _2, "trentino-alto-adige": _2, "trentino-altoadige": _2, "trentino-s-tirol": _2, "trentino-stirol": _2, "trentino-sud-tirol": _2, "xn--trentino-sd-tirol-c3b": _2, "trentino-süd-tirol": _2, "trentino-sudtirol": _2, "xn--trentino-sdtirol-szb": _2, "trentino-südtirol": _2, "trentino-sued-tirol": _2, "trentino-suedtirol": _2, "trentino": _2, "trentinoa-adige": _2, "trentinoaadige": _2, "trentinoalto-adige": _2, "trentinoaltoadige": _2, "trentinos-tirol": _2, "trentinostirol": _2, "trentinosud-tirol": _2, "xn--trentinosd-tirol-rzb": _2, "trentinosüd-tirol": _2, "trentinosudtirol": _2, "xn--trentinosdtirol-7vb": _2, "trentinosüdtirol": _2, "trentinosued-tirol": _2, "trentinosuedtirol": _2, "trentinsud-tirol": _2, "xn--trentinsd-tirol-6vb": _2, "trentinsüd-tirol": _2, "trentinsudtirol": _2, "xn--trentinsdtirol-nsb": _2, "trentinsüdtirol": _2, "trentinsued-tirol": _2, "trentinsuedtirol": _2, "tuscany": _2, "umb": _2, "umbria": _2, "val-d-aosta": _2, "val-daosta": _2, "vald-aosta": _2, "valdaosta": _2, "valle-aosta": _2, "valle-d-aosta": _2, "valle-daosta": _2, "valleaosta": _2, "valled-aosta": _2, "valledaosta": _2, "vallee-aoste": _2, "xn--valle-aoste-ebb": _2, "vallée-aoste": _2, "vallee-d-aoste": _2, "xn--valle-d-aoste-ehb": _2, "vallée-d-aoste": _2, "valleeaoste": _2, "xn--valleaoste-e7a": _2, "valléeaoste": _2, "valleedaoste": _2, "xn--valledaoste-ebb": _2, "valléedaoste": _2, "vao": _2, "vda": _2, "ven": _2, "veneto": _2, "ag": _2, "agrigento": _2, "al": _2, "alessandria": _2, "alto-adige": _2, "altoadige": _2, "an": _2, "ancona": _2, "andria-barletta-trani": _2, "andria-trani-barletta": _2, "andriabarlettatrani": _2, "andriatranibarletta": _2, "ao": _2, "aosta": _2, "aoste": _2, "ap": _2, "aq": _2, "aquila": _2, "ar": _2, "arezzo": _2, "ascoli-piceno": _2, "ascolipiceno": _2, "asti": _2, "at": _2, "av": _2, "avellino": _2, "ba": _2, "balsan-sudtirol": _2, "xn--balsan-sdtirol-nsb": _2, "balsan-südtirol": _2, "balsan-suedtirol": _2, "balsan": _2, "bari": _2, "barletta-trani-andria": _2, "barlettatraniandria": _2, "belluno": _2, "benevento": _2, "bergamo": _2, "bg": _2, "bi": _2, "biella": _2, "bl": _2, "bn": _2, "bo": _2, "bologna": _2, "bolzano-altoadige": _2, "bolzano": _2, "bozen-sudtirol": _2, "xn--bozen-sdtirol-2ob": _2, "bozen-südtirol": _2, "bozen-suedtirol": _2, "bozen": _2, "br": _2, "brescia": _2, "brindisi": _2, "bs": _2, "bt": _2, "bulsan-sudtirol": _2, "xn--bulsan-sdtirol-nsb": _2, "bulsan-südtirol": _2, "bulsan-suedtirol": _2, "bulsan": _2, "bz": _2, "ca": _2, "cagliari": _2, "caltanissetta": _2, "campidano-medio": _2, "campidanomedio": _2, "campobasso": _2, "carbonia-iglesias": _2, "carboniaiglesias": _2, "carrara-massa": _2, "carraramassa": _2, "caserta": _2, "catania": _2, "catanzaro": _2, "cb": _2, "ce": _2, "cesena-forli": _2, "xn--cesena-forl-mcb": _2, "cesena-forlì": _2, "cesenaforli": _2, "xn--cesenaforl-i8a": _2, "cesenaforlì": _2, "ch": _2, "chieti": _2, "ci": _2, "cl": _2, "cn": _2, "co": _2, "como": _2, "cosenza": _2, "cr": _2, "cremona": _2, "crotone": _2, "cs": _2, "ct": _2, "cuneo": _2, "cz": _2, "dell-ogliastra": _2, "dellogliastra": _2, "en": _2, "enna": _2, "fc": _2, "fe": _2, "fermo": _2, "ferrara": _2, "fg": _2, "fi": _2, "firenze": _2, "florence": _2, "fm": _2, "foggia": _2, "forli-cesena": _2, "xn--forl-cesena-fcb": _2, "forlì-cesena": _2, "forlicesena": _2, "xn--forlcesena-c8a": _2, "forlìcesena": _2, "fr": _2, "frosinone": _2, "ge": _2, "genoa": _2, "genova": _2, "go": _2, "gorizia": _2, "gr": _2, "grosseto": _2, "iglesias-carbonia": _2, "iglesiascarbonia": _2, "im": _2, "imperia": _2, "is": _2, "isernia": _2, "kr": _2, "la-spezia": _2, "laquila": _2, "laspezia": _2, "latina": _2, "lc": _2, "le": _2, "lecce": _2, "lecco": _2, "li": _2, "livorno": _2, "lo": _2, "lodi": _2, "lt": _2, "lu": _2, "lucca": _2, "macerata": _2, "mantova": _2, "massa-carrara": _2, "massacarrara": _2, "matera": _2, "mb": _2, "mc": _2, "me": _2, "medio-campidano": _2, "mediocampidano": _2, "messina": _2, "mi": _2, "milan": _2, "milano": _2, "mn": _2, "mo": _2, "modena": _2, "monza-brianza": _2, "monza-e-della-brianza": _2, "monza": _2, "monzabrianza": _2, "monzaebrianza": _2, "monzaedellabrianza": _2, "ms": _2, "mt": _2, "na": _2, "naples": _2, "napoli": _2, "no": _2, "novara": _2, "nu": _2, "nuoro": _2, "og": _2, "ogliastra": _2, "olbia-tempio": _2, "olbiatempio": _2, "or": _2, "oristano": _2, "ot": _2, "pa": _2, "padova": _2, "padua": _2, "palermo": _2, "parma": _2, "pavia": _2, "pc": _2, "pd": _2, "pe": _2, "perugia": _2, "pesaro-urbino": _2, "pesarourbino": _2, "pescara": _2, "pg": _2, "pi": _2, "piacenza": _2, "pisa": _2, "pistoia": _2, "pn": _2, "po": _2, "pordenone": _2, "potenza": _2, "pr": _2, "prato": _2, "pt": _2, "pu": _2, "pv": _2, "pz": _2, "ra": _2, "ragusa": _2, "ravenna": _2, "rc": _2, "re": _2, "reggio-calabria": _2, "reggio-emilia": _2, "reggiocalabria": _2, "reggioemilia": _2, "rg": _2, "ri": _2, "rieti": _2, "rimini": _2, "rm": _2, "rn": _2, "ro": _2, "roma": _2, "rome": _2, "rovigo": _2, "sa": _2, "salerno": _2, "sassari": _2, "savona": _2, "si": _2, "siena": _2, "siracusa": _2, "so": _2, "sondrio": _2, "sp": _2, "sr": _2, "ss": _2, "suedtirol": _2, "xn--sdtirol-n2a": _2, "südtirol": _2, "sv": _2, "ta": _2, "taranto": _2, "te": _2, "tempio-olbia": _2, "tempioolbia": _2, "teramo": _2, "terni": _2, "tn": _2, "to": _2, "torino": _2, "tp": _2, "tr": _2, "trani-andria-barletta": _2, "trani-barletta-andria": _2, "traniandriabarletta": _2, "tranibarlettaandria": _2, "trapani": _2, "trento": _2, "treviso": _2, "trieste": _2, "ts": _2, "turin": _2, "tv": _2, "ud": _2, "udine": _2, "urbino-pesaro": _2, "urbinopesaro": _2, "va": _2, "varese": _2, "vb": _2, "vc": _2, "ve": _2, "venezia": _2, "venice": _2, "verbania": _2, "vercelli": _2, "verona": _2, "vi": _2, "vibo-valentia": _2, "vibovalentia": _2, "vicenza": _2, "viterbo": _2, "vr": _2, "vs": _2, "vt": _2, "vv": _2, "blogspot": _3, "ibxos": _3, "iliadboxos": _3, "neen": { "$": 0, "succ": { "jc": _3 } }, "tim": { "$": 0, "succ": { "open": { "$": 0, "succ": { "jelastic": _9 } } } }, "16-b": _3, "32-b": _3, "64-b": _3, "123homepage": _3, "myspreadshop": _3, "syncloud": _3 } }, "je": { "$": 1, "succ": { "co": _2, "net": _2, "org": _2, "of": _3 } }, "jm": _8, "jo": { "$": 1, "succ": { "com": _2, "org": _2, "net": _2, "edu": _2, "sch": _2, "gov": _2, "mil": _2, "name": _2 } }, "jobs": _2, "jp": { "$": 1, "succ": { "ac": _2, "ad": _2, "co": _2, "ed": _2, "go": _2, "gr": _2, "lg": _2, "ne": { "$": 1, "succ": { "aseinet": _28, "gehirn": _3, "ivory": _3, "mail-box": _3, "mints": _3, "mokuren": _3, "opal": _3, "sakura": _3, "sumomo": _3, "topaz": _3 } }, "or": _2, "aichi": { "$": 1, "succ": { "aisai": _2, "ama": _2, "anjo": _2, "asuke": _2, "chiryu": _2, "chita": _2, "fuso": _2, "gamagori": _2, "handa": _2, "hazu": _2, "hekinan": _2, "higashiura": _2, "ichinomiya": _2, "inazawa": _2, "inuyama": _2, "isshiki": _2, "iwakura": _2, "kanie": _2, "kariya": _2, "kasugai": _2, "kira": _2, "kiyosu": _2, "komaki": _2, "konan": _2, "kota": _2, "mihama": _2, "miyoshi": _2, "nishio": _2, "nisshin": _2, "obu": _2, "oguchi": _2, "oharu": _2, "okazaki": _2, "owariasahi": _2, "seto": _2, "shikatsu": _2, "shinshiro": _2, "shitara": _2, "tahara": _2, "takahama": _2, "tobishima": _2, "toei": _2, "togo": _2, "tokai": _2, "tokoname": _2, "toyoake": _2, "toyohashi": _2, "toyokawa": _2, "toyone": _2, "toyota": _2, "tsushima": _2, "yatomi": _2 } }, "akita": { "$": 1, "succ": { "akita": _2, "daisen": _2, "fujisato": _2, "gojome": _2, "hachirogata": _2, "happou": _2, "higashinaruse": _2, "honjo": _2, "honjyo": _2, "ikawa": _2, "kamikoani": _2, "kamioka": _2, "katagami": _2, "kazuno": _2, "kitaakita": _2, "kosaka": _2, "kyowa": _2, "misato": _2, "mitane": _2, "moriyoshi": _2, "nikaho": _2, "noshiro": _2, "odate": _2, "oga": _2, "ogata": _2, "semboku": _2, "yokote": _2, "yurihonjo": _2 } }, "aomori": { "$": 1, "succ": { "aomori": _2, "gonohe": _2, "hachinohe": _2, "hashikami": _2, "hiranai": _2, "hirosaki": _2, "itayanagi": _2, "kuroishi": _2, "misawa": _2, "mutsu": _2, "nakadomari": _2, "noheji": _2, "oirase": _2, "owani": _2, "rokunohe": _2, "sannohe": _2, "shichinohe": _2, "shingo": _2, "takko": _2, "towada": _2, "tsugaru": _2, "tsuruta": _2 } }, "chiba": { "$": 1, "succ": { "abiko": _2, "asahi": _2, "chonan": _2, "chosei": _2, "choshi": _2, "chuo": _2, "funabashi": _2, "futtsu": _2, "hanamigawa": _2, "ichihara": _2, "ichikawa": _2, "ichinomiya": _2, "inzai": _2, "isumi": _2, "kamagaya": _2, "kamogawa": _2, "kashiwa": _2, "katori": _2, "katsuura": _2, "kimitsu": _2, "kisarazu": _2, "kozaki": _2, "kujukuri": _2, "kyonan": _2, "matsudo": _2, "midori": _2, "mihama": _2, "minamiboso": _2, "mobara": _2, "mutsuzawa": _2, "nagara": _2, "nagareyama": _2, "narashino": _2, "narita": _2, "noda": _2, "oamishirasato": _2, "omigawa": _2, "onjuku": _2, "otaki": _2, "sakae": _2, "sakura": _2, "shimofusa": _2, "shirako": _2, "shiroi": _2, "shisui": _2, "sodegaura": _2, "sosa": _2, "tako": _2, "tateyama": _2, "togane": _2, "tohnosho": _2, "tomisato": _2, "urayasu": _2, "yachimata": _2, "yachiyo": _2, "yokaichiba": _2, "yokoshibahikari": _2, "yotsukaido": _2 } }, "ehime": { "$": 1, "succ": { "ainan": _2, "honai": _2, "ikata": _2, "imabari": _2, "iyo": _2, "kamijima": _2, "kihoku": _2, "kumakogen": _2, "masaki": _2, "matsuno": _2, "matsuyama": _2, "namikata": _2, "niihama": _2, "ozu": _2, "saijo": _2, "seiyo": _2, "shikokuchuo": _2, "tobe": _2, "toon": _2, "uchiko": _2, "uwajima": _2, "yawatahama": _2 } }, "fukui": { "$": 1, "succ": { "echizen": _2, "eiheiji": _2, "fukui": _2, "ikeda": _2, "katsuyama": _2, "mihama": _2, "minamiechizen": _2, "obama": _2, "ohi": _2, "ono": _2, "sabae": _2, "sakai": _2, "takahama": _2, "tsuruga": _2, "wakasa": _2 } }, "fukuoka": { "$": 1, "succ": { "ashiya": _2, "buzen": _2, "chikugo": _2, "chikuho": _2, "chikujo": _2, "chikushino": _2, "chikuzen": _2, "chuo": _2, "dazaifu": _2, "fukuchi": _2, "hakata": _2, "higashi": _2, "hirokawa": _2, "hisayama": _2, "iizuka": _2, "inatsuki": _2, "kaho": _2, "kasuga": _2, "kasuya": _2, "kawara": _2, "keisen": _2, "koga": _2, "kurate": _2, "kurogi": _2, "kurume": _2, "minami": _2, "miyako": _2, "miyama": _2, "miyawaka": _2, "mizumaki": _2, "munakata": _2, "nakagawa": _2, "nakama": _2, "nishi": _2, "nogata": _2, "ogori": _2, "okagaki": _2, "okawa": _2, "oki": _2, "omuta": _2, "onga": _2, "onojo": _2, "oto": _2, "saigawa": _2, "sasaguri": _2, "shingu": _2, "shinyoshitomi": _2, "shonai": _2, "soeda": _2, "sue": _2, "tachiarai": _2, "tagawa": _2, "takata": _2, "toho": _2, "toyotsu": _2, "tsuiki": _2, "ukiha": _2, "umi": _2, "usui": _2, "yamada": _2, "yame": _2, "yanagawa": _2, "yukuhashi": _2 } }, "fukushima": { "$": 1, "succ": { "aizubange": _2, "aizumisato": _2, "aizuwakamatsu": _2, "asakawa": _2, "bandai": _2, "date": _2, "fukushima": _2, "furudono": _2, "futaba": _2, "hanawa": _2, "higashi": _2, "hirata": _2, "hirono": _2, "iitate": _2, "inawashiro": _2, "ishikawa": _2, "iwaki": _2, "izumizaki": _2, "kagamiishi": _2, "kaneyama": _2, "kawamata": _2, "kitakata": _2, "kitashiobara": _2, "koori": _2, "koriyama": _2, "kunimi": _2, "miharu": _2, "mishima": _2, "namie": _2, "nango": _2, "nishiaizu": _2, "nishigo": _2, "okuma": _2, "omotego": _2, "ono": _2, "otama": _2, "samegawa": _2, "shimogo": _2, "shirakawa": _2, "showa": _2, "soma": _2, "sukagawa": _2, "taishin": _2, "tamakawa": _2, "tanagura": _2, "tenei": _2, "yabuki": _2, "yamato": _2, "yamatsuri": _2, "yanaizu": _2, "yugawa": _2 } }, "gifu": { "$": 1, "succ": { "anpachi": _2, "ena": _2, "gifu": _2, "ginan": _2, "godo": _2, "gujo": _2, "hashima": _2, "hichiso": _2, "hida": _2, "higashishirakawa": _2, "ibigawa": _2, "ikeda": _2, "kakamigahara": _2, "kani": _2, "kasahara": _2, "kasamatsu": _2, "kawaue": _2, "kitagata": _2, "mino": _2, "minokamo": _2, "mitake": _2, "mizunami": _2, "motosu": _2, "nakatsugawa": _2, "ogaki": _2, "sakahogi": _2, "seki": _2, "sekigahara": _2, "shirakawa": _2, "tajimi": _2, "takayama": _2, "tarui": _2, "toki": _2, "tomika": _2, "wanouchi": _2, "yamagata": _2, "yaotsu": _2, "yoro": _2 } }, "gunma": { "$": 1, "succ": { "annaka": _2, "chiyoda": _2, "fujioka": _2, "higashiagatsuma": _2, "isesaki": _2, "itakura": _2, "kanna": _2, "kanra": _2, "katashina": _2, "kawaba": _2, "kiryu": _2, "kusatsu": _2, "maebashi": _2, "meiwa": _2, "midori": _2, "minakami": _2, "naganohara": _2, "nakanojo": _2, "nanmoku": _2, "numata": _2, "oizumi": _2, "ora": _2, "ota": _2, "shibukawa": _2, "shimonita": _2, "shinto": _2, "showa": _2, "takasaki": _2, "takayama": _2, "tamamura": _2, "tatebayashi": _2, "tomioka": _2, "tsukiyono": _2, "tsumagoi": _2, "ueno": _2, "yoshioka": _2 } }, "hiroshima": { "$": 1, "succ": { "asaminami": _2, "daiwa": _2, "etajima": _2, "fuchu": _2, "fukuyama": _2, "hatsukaichi": _2, "higashihiroshima": _2, "hongo": _2, "jinsekikogen": _2, "kaita": _2, "kui": _2, "kumano": _2, "kure": _2, "mihara": _2, "miyoshi": _2, "naka": _2, "onomichi": _2, "osakikamijima": _2, "otake": _2, "saka": _2, "sera": _2, "seranishi": _2, "shinichi": _2, "shobara": _2, "takehara": _2 } }, "hokkaido": { "$": 1, "succ": { "abashiri": _2, "abira": _2, "aibetsu": _2, "akabira": _2, "akkeshi": _2, "asahikawa": _2, "ashibetsu": _2, "ashoro": _2, "assabu": _2, "atsuma": _2, "bibai": _2, "biei": _2, "bifuka": _2, "bihoro": _2, "biratori": _2, "chippubetsu": _2, "chitose": _2, "date": _2, "ebetsu": _2, "embetsu": _2, "eniwa": _2, "erimo": _2, "esan": _2, "esashi": _2, "fukagawa": _2, "fukushima": _2, "furano": _2, "furubira": _2, "haboro": _2, "hakodate": _2, "hamatonbetsu": _2, "hidaka": _2, "higashikagura": _2, "higashikawa": _2, "hiroo": _2, "hokuryu": _2, "hokuto": _2, "honbetsu": _2, "horokanai": _2, "horonobe": _2, "ikeda": _2, "imakane": _2, "ishikari": _2, "iwamizawa": _2, "iwanai": _2, "kamifurano": _2, "kamikawa": _2, "kamishihoro": _2, "kamisunagawa": _2, "kamoenai": _2, "kayabe": _2, "kembuchi": _2, "kikonai": _2, "kimobetsu": _2, "kitahiroshima": _2, "kitami": _2, "kiyosato": _2, "koshimizu": _2, "kunneppu": _2, "kuriyama": _2, "kuromatsunai": _2, "kushiro": _2, "kutchan": _2, "kyowa": _2, "mashike": _2, "matsumae": _2, "mikasa": _2, "minamifurano": _2, "mombetsu": _2, "moseushi": _2, "mukawa": _2, "muroran": _2, "naie": _2, "nakagawa": _2, "nakasatsunai": _2, "nakatombetsu": _2, "nanae": _2, "nanporo": _2, "nayoro": _2, "nemuro": _2, "niikappu": _2, "niki": _2, "nishiokoppe": _2, "noboribetsu": _2, "numata": _2, "obihiro": _2, "obira": _2, "oketo": _2, "okoppe": _2, "otaru": _2, "otobe": _2, "otofuke": _2, "otoineppu": _2, "oumu": _2, "ozora": _2, "pippu": _2, "rankoshi": _2, "rebun": _2, "rikubetsu": _2, "rishiri": _2, "rishirifuji": _2, "saroma": _2, "sarufutsu": _2, "shakotan": _2, "shari": _2, "shibecha": _2, "shibetsu": _2, "shikabe": _2, "shikaoi": _2, "shimamaki": _2, "shimizu": _2, "shimokawa": _2, "shinshinotsu": _2, "shintoku": _2, "shiranuka": _2, "shiraoi": _2, "shiriuchi": _2, "sobetsu": _2, "sunagawa": _2, "taiki": _2, "takasu": _2, "takikawa": _2, "takinoue": _2, "teshikaga": _2, "tobetsu": _2, "tohma": _2, "tomakomai": _2, "tomari": _2, "toya": _2, "toyako": _2, "toyotomi": _2, "toyoura": _2, "tsubetsu": _2, "tsukigata": _2, "urakawa": _2, "urausu": _2, "uryu": _2, "utashinai": _2, "wakkanai": _2, "wassamu": _2, "yakumo": _2, "yoichi": _2 } }, "hyogo": { "$": 1, "succ": { "aioi": _2, "akashi": _2, "ako": _2, "amagasaki": _2, "aogaki": _2, "asago": _2, "ashiya": _2, "awaji": _2, "fukusaki": _2, "goshiki": _2, "harima": _2, "himeji": _2, "ichikawa": _2, "inagawa": _2, "itami": _2, "kakogawa": _2, "kamigori": _2, "kamikawa": _2, "kasai": _2, "kasuga": _2, "kawanishi": _2, "miki": _2, "minamiawaji": _2, "nishinomiya": _2, "nishiwaki": _2, "ono": _2, "sanda": _2, "sannan": _2, "sasayama": _2, "sayo": _2, "shingu": _2, "shinonsen": _2, "shiso": _2, "sumoto": _2, "taishi": _2, "taka": _2, "takarazuka": _2, "takasago": _2, "takino": _2, "tamba": _2, "tatsuno": _2, "toyooka": _2, "yabu": _2, "yashiro": _2, "yoka": _2, "yokawa": _2 } }, "ibaraki": { "$": 1, "succ": { "ami": _2, "asahi": _2, "bando": _2, "chikusei": _2, "daigo": _2, "fujishiro": _2, "hitachi": _2, "hitachinaka": _2, "hitachiomiya": _2, "hitachiota": _2, "ibaraki": _2, "ina": _2, "inashiki": _2, "itako": _2, "iwama": _2, "joso": _2, "kamisu": _2, "kasama": _2, "kashima": _2, "kasumigaura": _2, "koga": _2, "miho": _2, "mito": _2, "moriya": _2, "naka": _2, "namegata": _2, "oarai": _2, "ogawa": _2, "omitama": _2, "ryugasaki": _2, "sakai": _2, "sakuragawa": _2, "shimodate": _2, "shimotsuma": _2, "shirosato": _2, "sowa": _2, "suifu": _2, "takahagi": _2, "tamatsukuri": _2, "tokai": _2, "tomobe": _2, "tone": _2, "toride": _2, "tsuchiura": _2, "tsukuba": _2, "uchihara": _2, "ushiku": _2, "yachiyo": _2, "yamagata": _2, "yawara": _2, "yuki": _2 } }, "ishikawa": { "$": 1, "succ": { "anamizu": _2, "hakui": _2, "hakusan": _2, "kaga": _2, "kahoku": _2, "kanazawa": _2, "kawakita": _2, "komatsu": _2, "nakanoto": _2, "nanao": _2, "nomi": _2, "nonoichi": _2, "noto": _2, "shika": _2, "suzu": _2, "tsubata": _2, "tsurugi": _2, "uchinada": _2, "wajima": _2 } }, "iwate": { "$": 1, "succ": { "fudai": _2, "fujisawa": _2, "hanamaki": _2, "hiraizumi": _2, "hirono": _2, "ichinohe": _2, "ichinoseki": _2, "iwaizumi": _2, "iwate": _2, "joboji": _2, "kamaishi": _2, "kanegasaki": _2, "karumai": _2, "kawai": _2, "kitakami": _2, "kuji": _2, "kunohe": _2, "kuzumaki": _2, "miyako": _2, "mizusawa": _2, "morioka": _2, "ninohe": _2, "noda": _2, "ofunato": _2, "oshu": _2, "otsuchi": _2, "rikuzentakata": _2, "shiwa": _2, "shizukuishi": _2, "sumita": _2, "tanohata": _2, "tono": _2, "yahaba": _2, "yamada": _2 } }, "kagawa": { "$": 1, "succ": { "ayagawa": _2, "higashikagawa": _2, "kanonji": _2, "kotohira": _2, "manno": _2, "marugame": _2, "mitoyo": _2, "naoshima": _2, "sanuki": _2, "tadotsu": _2, "takamatsu": _2, "tonosho": _2, "uchinomi": _2, "utazu": _2, "zentsuji": _2 } }, "kagoshima": { "$": 1, "succ": { "akune": _2, "amami": _2, "hioki": _2, "isa": _2, "isen": _2, "izumi": _2, "kagoshima": _2, "kanoya": _2, "kawanabe": _2, "kinko": _2, "kouyama": _2, "makurazaki": _2, "matsumoto": _2, "minamitane": _2, "nakatane": _2, "nishinoomote": _2, "satsumasendai": _2, "soo": _2, "tarumizu": _2, "yusui": _2 } }, "kanagawa": { "$": 1, "succ": { "aikawa": _2, "atsugi": _2, "ayase": _2, "chigasaki": _2, "ebina": _2, "fujisawa": _2, "hadano": _2, "hakone": _2, "hiratsuka": _2, "isehara": _2, "kaisei": _2, "kamakura": _2, "kiyokawa": _2, "matsuda": _2, "minamiashigara": _2, "miura": _2, "nakai": _2, "ninomiya": _2, "odawara": _2, "oi": _2, "oiso": _2, "sagamihara": _2, "samukawa": _2, "tsukui": _2, "yamakita": _2, "yamato": _2, "yokosuka": _2, "yugawara": _2, "zama": _2, "zushi": _2 } }, "kochi": { "$": 1, "succ": { "aki": _2, "geisei": _2, "hidaka": _2, "higashitsuno": _2, "ino": _2, "kagami": _2, "kami": _2, "kitagawa": _2, "kochi": _2, "mihara": _2, "motoyama": _2, "muroto": _2, "nahari": _2, "nakamura": _2, "nankoku": _2, "nishitosa": _2, "niyodogawa": _2, "ochi": _2, "okawa": _2, "otoyo": _2, "otsuki": _2, "sakawa": _2, "sukumo": _2, "susaki": _2, "tosa": _2, "tosashimizu": _2, "toyo": _2, "tsuno": _2, "umaji": _2, "yasuda": _2, "yusuhara": _2 } }, "kumamoto": { "$": 1, "succ": { "amakusa": _2, "arao": _2, "aso": _2, "choyo": _2, "gyokuto": _2, "kamiamakusa": _2, "kikuchi": _2, "kumamoto": _2, "mashiki": _2, "mifune": _2, "minamata": _2, "minamioguni": _2, "nagasu": _2, "nishihara": _2, "oguni": _2, "ozu": _2, "sumoto": _2, "takamori": _2, "uki": _2, "uto": _2, "yamaga": _2, "yamato": _2, "yatsushiro": _2 } }, "kyoto": { "$": 1, "succ": { "ayabe": _2, "fukuchiyama": _2, "higashiyama": _2, "ide": _2, "ine": _2, "joyo": _2, "kameoka": _2, "kamo": _2, "kita": _2, "kizu": _2, "kumiyama": _2, "kyotamba": _2, "kyotanabe": _2, "kyotango": _2, "maizuru": _2, "minami": _2, "minamiyamashiro": _2, "miyazu": _2, "muko": _2, "nagaokakyo": _2, "nakagyo": _2, "nantan": _2, "oyamazaki": _2, "sakyo": _2, "seika": _2, "tanabe": _2, "uji": _2, "ujitawara": _2, "wazuka": _2, "yamashina": _2, "yawata": _2 } }, "mie": { "$": 1, "succ": { "asahi": _2, "inabe": _2, "ise": _2, "kameyama": _2, "kawagoe": _2, "kiho": _2, "kisosaki": _2, "kiwa": _2, "komono": _2, "kumano": _2, "kuwana": _2, "matsusaka": _2, "meiwa": _2, "mihama": _2, "minamiise": _2, "misugi": _2, "miyama": _2, "nabari": _2, "shima": _2, "suzuka": _2, "tado": _2, "taiki": _2, "taki": _2, "tamaki": _2, "toba": _2, "tsu": _2, "udono": _2, "ureshino": _2, "watarai": _2, "yokkaichi": _2 } }, "miyagi": { "$": 1, "succ": { "furukawa": _2, "higashimatsushima": _2, "ishinomaki": _2, "iwanuma": _2, "kakuda": _2, "kami": _2, "kawasaki": _2, "marumori": _2, "matsushima": _2, "minamisanriku": _2, "misato": _2, "murata": _2, "natori": _2, "ogawara": _2, "ohira": _2, "onagawa": _2, "osaki": _2, "rifu": _2, "semine": _2, "shibata": _2, "shichikashuku": _2, "shikama": _2, "shiogama": _2, "shiroishi": _2, "tagajo": _2, "taiwa": _2, "tome": _2, "tomiya": _2, "wakuya": _2, "watari": _2, "yamamoto": _2, "zao": _2 } }, "miyazaki": { "$": 1, "succ": { "aya": _2, "ebino": _2, "gokase": _2, "hyuga": _2, "kadogawa": _2, "kawaminami": _2, "kijo": _2, "kitagawa": _2, "kitakata": _2, "kitaura": _2, "kobayashi": _2, "kunitomi": _2, "kushima": _2, "mimata": _2, "miyakonojo": _2, "miyazaki": _2, "morotsuka": _2, "nichinan": _2, "nishimera": _2, "nobeoka": _2, "saito": _2, "shiiba": _2, "shintomi": _2, "takaharu": _2, "takanabe": _2, "takazaki": _2, "tsuno": _2 } }, "nagano": { "$": 1, "succ": { "achi": _2, "agematsu": _2, "anan": _2, "aoki": _2, "asahi": _2, "azumino": _2, "chikuhoku": _2, "chikuma": _2, "chino": _2, "fujimi": _2, "hakuba": _2, "hara": _2, "hiraya": _2, "iida": _2, "iijima": _2, "iiyama": _2, "iizuna": _2, "ikeda": _2, "ikusaka": _2, "ina": _2, "karuizawa": _2, "kawakami": _2, "kiso": _2, "kisofukushima": _2, "kitaaiki": _2, "komagane": _2, "komoro": _2, "matsukawa": _2, "matsumoto": _2, "miasa": _2, "minamiaiki": _2, "minamimaki": _2, "minamiminowa": _2, "minowa": _2, "miyada": _2, "miyota": _2, "mochizuki": _2, "nagano": _2, "nagawa": _2, "nagiso": _2, "nakagawa": _2, "nakano": _2, "nozawaonsen": _2, "obuse": _2, "ogawa": _2, "okaya": _2, "omachi": _2, "omi": _2, "ookuwa": _2, "ooshika": _2, "otaki": _2, "otari": _2, "sakae": _2, "sakaki": _2, "saku": _2, "sakuho": _2, "shimosuwa": _2, "shinanomachi": _2, "shiojiri": _2, "suwa": _2, "suzaka": _2, "takagi": _2, "takamori": _2, "takayama": _2, "tateshina": _2, "tatsuno": _2, "togakushi": _2, "togura": _2, "tomi": _2, "ueda": _2, "wada": _2, "yamagata": _2, "yamanouchi": _2, "yasaka": _2, "yasuoka": _2 } }, "nagasaki": { "$": 1, "succ": { "chijiwa": _2, "futsu": _2, "goto": _2, "hasami": _2, "hirado": _2, "iki": _2, "isahaya": _2, "kawatana": _2, "kuchinotsu": _2, "matsuura": _2, "nagasaki": _2, "obama": _2, "omura": _2, "oseto": _2, "saikai": _2, "sasebo": _2, "seihi": _2, "shimabara": _2, "shinkamigoto": _2, "togitsu": _2, "tsushima": _2, "unzen": _2 } }, "nara": { "$": 1, "succ": { "ando": _2, "gose": _2, "heguri": _2, "higashiyoshino": _2, "ikaruga": _2, "ikoma": _2, "kamikitayama": _2, "kanmaki": _2, "kashiba": _2, "kashihara": _2, "katsuragi": _2, "kawai": _2, "kawakami": _2, "kawanishi": _2, "koryo": _2, "kurotaki": _2, "mitsue": _2, "miyake": _2, "nara": _2, "nosegawa": _2, "oji": _2, "ouda": _2, "oyodo": _2, "sakurai": _2, "sango": _2, "shimoichi": _2, "shimokitayama": _2, "shinjo": _2, "soni": _2, "takatori": _2, "tawaramoto": _2, "tenkawa": _2, "tenri": _2, "uda": _2, "yamatokoriyama": _2, "yamatotakada": _2, "yamazoe": _2, "yoshino": _2 } }, "niigata": { "$": 1, "succ": { "aga": _2, "agano": _2, "gosen": _2, "itoigawa": _2, "izumozaki": _2, "joetsu": _2, "kamo": _2, "kariwa": _2, "kashiwazaki": _2, "minamiuonuma": _2, "mitsuke": _2, "muika": _2, "murakami": _2, "myoko": _2, "nagaoka": _2, "niigata": _2, "ojiya": _2, "omi": _2, "sado": _2, "sanjo": _2, "seiro": _2, "seirou": _2, "sekikawa": _2, "shibata": _2, "tagami": _2, "tainai": _2, "tochio": _2, "tokamachi": _2, "tsubame": _2, "tsunan": _2, "uonuma": _2, "yahiko": _2, "yoita": _2, "yuzawa": _2 } }, "oita": { "$": 1, "succ": { "beppu": _2, "bungoono": _2, "bungotakada": _2, "hasama": _2, "hiji": _2, "himeshima": _2, "hita": _2, "kamitsue": _2, "kokonoe": _2, "kuju": _2, "kunisaki": _2, "kusu": _2, "oita": _2, "saiki": _2, "taketa": _2, "tsukumi": _2, "usa": _2, "usuki": _2, "yufu": _2 } }, "okayama": { "$": 1, "succ": { "akaiwa": _2, "asakuchi": _2, "bizen": _2, "hayashima": _2, "ibara": _2, "kagamino": _2, "kasaoka": _2, "kibichuo": _2, "kumenan": _2, "kurashiki": _2, "maniwa": _2, "misaki": _2, "nagi": _2, "niimi": _2, "nishiawakura": _2, "okayama": _2, "satosho": _2, "setouchi": _2, "shinjo": _2, "shoo": _2, "soja": _2, "takahashi": _2, "tamano": _2, "tsuyama": _2, "wake": _2, "yakage": _2 } }, "okinawa": { "$": 1, "succ": { "aguni": _2, "ginowan": _2, "ginoza": _2, "gushikami": _2, "haebaru": _2, "higashi": _2, "hirara": _2, "iheya": _2, "ishigaki": _2, "ishikawa": _2, "itoman": _2, "izena": _2, "kadena": _2, "kin": _2, "kitadaito": _2, "kitanakagusuku": _2, "kumejima": _2, "kunigami": _2, "minamidaito": _2, "motobu": _2, "nago": _2, "naha": _2, "nakagusuku": _2, "nakijin": _2, "nanjo": _2, "nishihara": _2, "ogimi": _2, "okinawa": _2, "onna": _2, "shimoji": _2, "taketomi": _2, "tarama": _2, "tokashiki": _2, "tomigusuku": _2, "tonaki": _2, "urasoe": _2, "uruma": _2, "yaese": _2, "yomitan": _2, "yonabaru": _2, "yonaguni": _2, "zamami": _2 } }, "osaka": { "$": 1, "succ": { "abeno": _2, "chihayaakasaka": _2, "chuo": _2, "daito": _2, "fujiidera": _2, "habikino": _2, "hannan": _2, "higashiosaka": _2, "higashisumiyoshi": _2, "higashiyodogawa": _2, "hirakata": _2, "ibaraki": _2, "ikeda": _2, "izumi": _2, "izumiotsu": _2, "izumisano": _2, "kadoma": _2, "kaizuka": _2, "kanan": _2, "kashiwara": _2, "katano": _2, "kawachinagano": _2, "kishiwada": _2, "kita": _2, "kumatori": _2, "matsubara": _2, "minato": _2, "minoh": _2, "misaki": _2, "moriguchi": _2, "neyagawa": _2, "nishi": _2, "nose": _2, "osakasayama": _2, "sakai": _2, "sayama": _2, "sennan": _2, "settsu": _2, "shijonawate": _2, "shimamoto": _2, "suita": _2, "tadaoka": _2, "taishi": _2, "tajiri": _2, "takaishi": _2, "takatsuki": _2, "tondabayashi": _2, "toyonaka": _2, "toyono": _2, "yao": _2 } }, "saga": { "$": 1, "succ": { "ariake": _2, "arita": _2, "fukudomi": _2, "genkai": _2, "hamatama": _2, "hizen": _2, "imari": _2, "kamimine": _2, "kanzaki": _2, "karatsu": _2, "kashima": _2, "kitagata": _2, "kitahata": _2, "kiyama": _2, "kouhoku": _2, "kyuragi": _2, "nishiarita": _2, "ogi": _2, "omachi": _2, "ouchi": _2, "saga": _2, "shiroishi": _2, "taku": _2, "tara": _2, "tosu": _2, "yoshinogari": _2 } }, "saitama": { "$": 1, "succ": { "arakawa": _2, "asaka": _2, "chichibu": _2, "fujimi": _2, "fujimino": _2, "fukaya": _2, "hanno": _2, "hanyu": _2, "hasuda": _2, "hatogaya": _2, "hatoyama": _2, "hidaka": _2, "higashichichibu": _2, "higashimatsuyama": _2, "honjo": _2, "ina": _2, "iruma": _2, "iwatsuki": _2, "kamiizumi": _2, "kamikawa": _2, "kamisato": _2, "kasukabe": _2, "kawagoe": _2, "kawaguchi": _2, "kawajima": _2, "kazo": _2, "kitamoto": _2, "koshigaya": _2, "kounosu": _2, "kuki": _2, "kumagaya": _2, "matsubushi": _2, "minano": _2, "misato": _2, "miyashiro": _2, "miyoshi": _2, "moroyama": _2, "nagatoro": _2, "namegawa": _2, "niiza": _2, "ogano": _2, "ogawa": _2, "ogose": _2, "okegawa": _2, "omiya": _2, "otaki": _2, "ranzan": _2, "ryokami": _2, "saitama": _2, "sakado": _2, "satte": _2, "sayama": _2, "shiki": _2, "shiraoka": _2, "soka": _2, "sugito": _2, "toda": _2, "tokigawa": _2, "tokorozawa": _2, "tsurugashima": _2, "urawa": _2, "warabi": _2, "yashio": _2, "yokoze": _2, "yono": _2, "yorii": _2, "yoshida": _2, "yoshikawa": _2, "yoshimi": _2 } }, "shiga": { "$": 1, "succ": { "aisho": _2, "gamo": _2, "higashiomi": _2, "hikone": _2, "koka": _2, "konan": _2, "kosei": _2, "koto": _2, "kusatsu": _2, "maibara": _2, "moriyama": _2, "nagahama": _2, "nishiazai": _2, "notogawa": _2, "omihachiman": _2, "otsu": _2, "ritto": _2, "ryuoh": _2, "takashima": _2, "takatsuki": _2, "torahime": _2, "toyosato": _2, "yasu": _2 } }, "shimane": { "$": 1, "succ": { "akagi": _2, "ama": _2, "gotsu": _2, "hamada": _2, "higashiizumo": _2, "hikawa": _2, "hikimi": _2, "izumo": _2, "kakinoki": _2, "masuda": _2, "matsue": _2, "misato": _2, "nishinoshima": _2, "ohda": _2, "okinoshima": _2, "okuizumo": _2, "shimane": _2, "tamayu": _2, "tsuwano": _2, "unnan": _2, "yakumo": _2, "yasugi": _2, "yatsuka": _2 } }, "shizuoka": { "$": 1, "succ": { "arai": _2, "atami": _2, "fuji": _2, "fujieda": _2, "fujikawa": _2, "fujinomiya": _2, "fukuroi": _2, "gotemba": _2, "haibara": _2, "hamamatsu": _2, "higashiizu": _2, "ito": _2, "iwata": _2, "izu": _2, "izunokuni": _2, "kakegawa": _2, "kannami": _2, "kawanehon": _2, "kawazu": _2, "kikugawa": _2, "kosai": _2, "makinohara": _2, "matsuzaki": _2, "minamiizu": _2, "mishima": _2, "morimachi": _2, "nishiizu": _2, "numazu": _2, "omaezaki": _2, "shimada": _2, "shimizu": _2, "shimoda": _2, "shizuoka": _2, "susono": _2, "yaizu": _2, "yoshida": _2 } }, "tochigi": { "$": 1, "succ": { "ashikaga": _2, "bato": _2, "haga": _2, "ichikai": _2, "iwafune": _2, "kaminokawa": _2, "kanuma": _2, "karasuyama": _2, "kuroiso": _2, "mashiko": _2, "mibu": _2, "moka": _2, "motegi": _2, "nasu": _2, "nasushiobara": _2, "nikko": _2, "nishikata": _2, "nogi": _2, "ohira": _2, "ohtawara": _2, "oyama": _2, "sakura": _2, "sano": _2, "shimotsuke": _2, "shioya": _2, "takanezawa": _2, "tochigi": _2, "tsuga": _2, "ujiie": _2, "utsunomiya": _2, "yaita": _2 } }, "tokushima": { "$": 1, "succ": { "aizumi": _2, "anan": _2, "ichiba": _2, "itano": _2, "kainan": _2, "komatsushima": _2, "matsushige": _2, "mima": _2, "minami": _2, "miyoshi": _2, "mugi": _2, "nakagawa": _2, "naruto": _2, "sanagochi": _2, "shishikui": _2, "tokushima": _2, "wajiki": _2 } }, "tokyo": { "$": 1, "succ": { "adachi": _2, "akiruno": _2, "akishima": _2, "aogashima": _2, "arakawa": _2, "bunkyo": _2, "chiyoda": _2, "chofu": _2, "chuo": _2, "edogawa": _2, "fuchu": _2, "fussa": _2, "hachijo": _2, "hachioji": _2, "hamura": _2, "higashikurume": _2, "higashimurayama": _2, "higashiyamato": _2, "hino": _2, "hinode": _2, "hinohara": _2, "inagi": _2, "itabashi": _2, "katsushika": _2, "kita": _2, "kiyose": _2, "kodaira": _2, "koganei": _2, "kokubunji": _2, "komae": _2, "koto": _2, "kouzushima": _2, "kunitachi": _2, "machida": _2, "meguro": _2, "minato": _2, "mitaka": _2, "mizuho": _2, "musashimurayama": _2, "musashino": _2, "nakano": _2, "nerima": _2, "ogasawara": _2, "okutama": _2, "ome": _2, "oshima": _2, "ota": _2, "setagaya": _2, "shibuya": _2, "shinagawa": _2, "shinjuku": _2, "suginami": _2, "sumida": _2, "tachikawa": _2, "taito": _2, "tama": _2, "toshima": _2 } }, "tottori": { "$": 1, "succ": { "chizu": _2, "hino": _2, "kawahara": _2, "koge": _2, "kotoura": _2, "misasa": _2, "nanbu": _2, "nichinan": _2, "sakaiminato": _2, "tottori": _2, "wakasa": _2, "yazu": _2, "yonago": _2 } }, "toyama": { "$": 1, "succ": { "asahi": _2, "fuchu": _2, "fukumitsu": _2, "funahashi": _2, "himi": _2, "imizu": _2, "inami": _2, "johana": _2, "kamiichi": _2, "kurobe": _2, "nakaniikawa": _2, "namerikawa": _2, "nanto": _2, "nyuzen": _2, "oyabe": _2, "taira": _2, "takaoka": _2, "tateyama": _2, "toga": _2, "tonami": _2, "toyama": _2, "unazuki": _2, "uozu": _2, "yamada": _2 } }, "wakayama": { "$": 1, "succ": { "arida": _2, "aridagawa": _2, "gobo": _2, "hashimoto": _2, "hidaka": _2, "hirogawa": _2, "inami": _2, "iwade": _2, "kainan": _2, "kamitonda": _2, "katsuragi": _2, "kimino": _2, "kinokawa": _2, "kitayama": _2, "koya": _2, "koza": _2, "kozagawa": _2, "kudoyama": _2, "kushimoto": _2, "mihama": _2, "misato": _2, "nachikatsuura": _2, "shingu": _2, "shirahama": _2, "taiji": _2, "tanabe": _2, "wakayama": _2, "yuasa": _2, "yura": _2 } }, "yamagata": { "$": 1, "succ": { "asahi": _2, "funagata": _2, "higashine": _2, "iide": _2, "kahoku": _2, "kaminoyama": _2, "kaneyama": _2, "kawanishi": _2, "mamurogawa": _2, "mikawa": _2, "murayama": _2, "nagai": _2, "nakayama": _2, "nanyo": _2, "nishikawa": _2, "obanazawa": _2, "oe": _2, "oguni": _2, "ohkura": _2, "oishida": _2, "sagae": _2, "sakata": _2, "sakegawa": _2, "shinjo": _2, "shirataka": _2, "shonai": _2, "takahata": _2, "tendo": _2, "tozawa": _2, "tsuruoka": _2, "yamagata": _2, "yamanobe": _2, "yonezawa": _2, "yuza": _2 } }, "yamaguchi": { "$": 1, "succ": { "abu": _2, "hagi": _2, "hikari": _2, "hofu": _2, "iwakuni": _2, "kudamatsu": _2, "mitou": _2, "nagato": _2, "oshima": _2, "shimonoseki": _2, "shunan": _2, "tabuse": _2, "tokuyama": _2, "toyota": _2, "ube": _2, "yuu": _2 } }, "yamanashi": { "$": 1, "succ": { "chuo": _2, "doshi": _2, "fuefuki": _2, "fujikawa": _2, "fujikawaguchiko": _2, "fujiyoshida": _2, "hayakawa": _2, "hokuto": _2, "ichikawamisato": _2, "kai": _2, "kofu": _2, "koshu": _2, "kosuge": _2, "minami-alps": _2, "minobu": _2, "nakamichi": _2, "nanbu": _2, "narusawa": _2, "nirasaki": _2, "nishikatsura": _2, "oshino": _2, "otsuki": _2, "showa": _2, "tabayama": _2, "tsuru": _2, "uenohara": _2, "yamanakako": _2, "yamanashi": _2 } }, "xn--4pvxs": _2, "栃木": _2, "xn--vgu402c": _2, "愛知": _2, "xn--c3s14m": _2, "愛媛": _2, "xn--f6qx53a": _2, "兵庫": _2, "xn--8pvr4u": _2, "熊本": _2, "xn--uist22h": _2, "茨城": _2, "xn--djrs72d6uy": _2, "北海道": _2, "xn--mkru45i": _2, "千葉": _2, "xn--0trq7p7nn": _2, "和歌山": _2, "xn--8ltr62k": _2, "長崎": _2, "xn--2m4a15e": _2, "長野": _2, "xn--efvn9s": _2, "新潟": _2, "xn--32vp30h": _2, "青森": _2, "xn--4it797k": _2, "静岡": _2, "xn--1lqs71d": _2, "東京": _2, "xn--5rtp49c": _2, "石川": _2, "xn--5js045d": _2, "埼玉": _2, "xn--ehqz56n": _2, "三重": _2, "xn--1lqs03n": _2, "京都": _2, "xn--qqqt11m": _2, "佐賀": _2, "xn--kbrq7o": _2, "大分": _2, "xn--pssu33l": _2, "大阪": _2, "xn--ntsq17g": _2, "奈良": _2, "xn--uisz3g": _2, "宮城": _2, "xn--6btw5a": _2, "宮崎": _2, "xn--1ctwo": _2, "富山": _2, "xn--6orx2r": _2, "山口": _2, "xn--rht61e": _2, "山形": _2, "xn--rht27z": _2, "山梨": _2, "xn--djty4k": _2, "岩手": _2, "xn--nit225k": _2, "岐阜": _2, "xn--rht3d": _2, "岡山": _2, "xn--klty5x": _2, "島根": _2, "xn--kltx9a": _2, "広島": _2, "xn--kltp7d": _2, "徳島": _2, "xn--uuwu58a": _2, "沖縄": _2, "xn--zbx025d": _2, "滋賀": _2, "xn--ntso0iqx3a": _2, "神奈川": _2, "xn--elqq16h": _2, "福井": _2, "xn--4it168d": _2, "福岡": _2, "xn--klt787d": _2, "福島": _2, "xn--rny31h": _2, "秋田": _2, "xn--7t0a264c": _2, "群馬": _2, "xn--5rtq34k": _2, "香川": _2, "xn--k7yn95e": _2, "高知": _2, "xn--tor131o": _2, "鳥取": _2, "xn--d5qv7z876c": _2, "鹿児島": _2, "kawasaki": _8, "kitakyushu": _8, "kobe": _8, "nagoya": _8, "sapporo": _8, "sendai": _8, "yokohama": _8, "buyshop": _3, "fashionstore": _3, "handcrafted": _3, "kawaiishop": _3, "supersale": _3, "theshop": _3, "usercontent": _3, "angry": _3, "babyblue": _3, "babymilk": _3, "backdrop": _3, "bambina": _3, "bitter": _3, "blush": _3, "boo": _3, "boy": _3, "boyfriend": _3, "but": _3, "candypop": _3, "capoo": _3, "catfood": _3, "cheap": _3, "chicappa": _3, "chillout": _3, "chips": _3, "chowder": _3, "chu": _3, "ciao": _3, "cocotte": _3, "coolblog": _3, "cranky": _3, "cutegirl": _3, "daa": _3, "deca": _3, "deci": _3, "digick": _3, "egoism": _3, "fakefur": _3, "fem": _3, "flier": _3, "floppy": _3, "fool": _3, "frenchkiss": _3, "girlfriend": _3, "girly": _3, "gloomy": _3, "gonna": _3, "greater": _3, "hacca": _3, "heavy": _3, "her": _3, "hiho": _3, "hippy": _3, "holy": _3, "hungry": _3, "icurus": _3, "itigo": _3, "jellybean": _3, "kikirara": _3, "kill": _3, "kilo": _3, "kuron": _3, "littlestar": _3, "lolipopmc": _3, "lolitapunk": _3, "lomo": _3, "lovepop": _3, "lovesick": _3, "main": _3, "mods": _3, "mond": _3, "mongolian": _3, "moo": _3, "namaste": _3, "nikita": _3, "nobushi": _3, "noor": _3, "oops": _3, "parallel": _3, "parasite": _3, "pecori": _3, "peewee": _3, "penne": _3, "pepper": _3, "perma": _3, "pigboat": _3, "pinoko": _3, "punyu": _3, "pupu": _3, "pussycat": _3, "pya": _3, "raindrop": _3, "readymade": _3, "sadist": _3, "schoolbus": _3, "secret": _3, "staba": _3, "stripper": _3, "sub": _3, "sunnyday": _3, "thick": _3, "tonkotsu": _3, "under": _3, "upper": _3, "velvet": _3, "verse": _3, "versus": _3, "vivian": _3, "watson": _3, "weblike": _3, "whitesnow": _3, "zombie": _3, "blogspot": _3, "2-d": _3, "bona": _3, "crap": _3, "daynight": _3, "eek": _3, "flop": _3, "halfmoon": _3, "jeez": _3, "matrix": _3, "mimoza": _3, "netgamers": _3, "nyanta": _3, "o0o0": _3, "rdy": _3, "rgr": _3, "rulez": _3, "sakurastorage": { "$": 0, "succ": { "isk01": _12, "isk02": _12 } }, "saloon": _3, "sblo": _3, "skr": _3, "tank": _3, "uh-oh": _3, "undo": _3, "webaccel": { "$": 0, "succ": { "rs": _3, "user": _3 } }, "websozai": _3, "xii": _3 } }, "ke": { "$": 1, "succ": { "ac": _2, "co": _6, "go": _2, "info": _2, "me": _2, "mobi": _2, "ne": _2, "or": _2, "sc": _2 } }, "kg": { "$": 1, "succ": { "org": _2, "net": _2, "com": _2, "edu": _2, "gov": _2, "mil": _2, "blog": _3, "io": _3, "jp": _3, "tv": _3, "uk": _3, "us": _3 } }, "kh": _8, "ki": _33, "km": { "$": 1, "succ": { "org": _2, "nom": _2, "gov": _2, "prd": _2, "tm": _2, "edu": _2, "mil": _2, "ass": _2, "com": _2, "coop": _2, "asso": _2, "presse": _2, "medecin": _2, "notaires": _2, "pharmaciens": _2, "veterinaire": _2, "gouv": _2 } }, "kn": { "$": 1, "succ": { "net": _2, "org": _2, "edu": _2, "gov": _2 } }, "kp": { "$": 1, "succ": { "com": _2, "edu": _2, "gov": _2, "org": _2, "rep": _2, "tra": _2 } }, "kr": { "$": 1, "succ": { "ac": _2, "co": _2, "es": _2, "go": _2, "hs": _2, "kg": _2, "mil": _2, "ms": _2, "ne": _2, "or": _2, "pe": _2, "re": _2, "sc": _2, "busan": _2, "chungbuk": _2, "chungnam": _2, "daegu": _2, "daejeon": _2, "gangwon": _2, "gwangju": _2, "gyeongbuk": _2, "gyeonggi": _2, "gyeongnam": _2, "incheon": _2, "jeju": _2, "jeonbuk": _2, "jeonnam": _2, "seoul": _2, "ulsan": _2, "blogspot": _3 } }, "kw": { "$": 1, "succ": { "com": _2, "edu": _2, "emb": _2, "gov": _2, "ind": _2, "net": _2, "org": _2 } }, "ky": _25, "kz": { "$": 1, "succ": { "org": _2, "edu": _2, "net": _2, "gov": _2, "mil": _2, "com": _2, "jcloud": _3, "kazteleport": { "$": 0, "succ": { "upaas": _3 } } } }, "la": { "$": 1, "succ": { "int": _2, "net": _2, "info": _2, "edu": _2, "gov": _2, "per": _2, "com": _2, "org": _2, "bnr": _3, "c": _3 } }, "lb": _4, "lc": { "$": 1, "succ": { "com": _2, "net": _2, "co": _2, "org": _2, "edu": _2, "gov": _2, "oy": _3 } }, "li": { "$": 1, "succ": { "blogspot": _3, "caa": _3 } }, "lk": { "$": 1, "succ": { "gov": _2, "sch": _2, "net": _2, "int": _2, "com": _2, "org": _2, "edu": _2, "ngo": _2, "soc": _2, "web": _2, "ltd": _2, "assn": _2, "grp": _2, "hotel": _2, "ac": _2 } }, "lr": _4, "ls": { "$": 1, "succ": { "ac": _2, "biz": _2, "co": _2, "edu": _2, "gov": _2, "info": _2, "net": _2, "org": _2, "sc": _2, "de": _3 } }, "lt": _34, "lu": { "$": 1, "succ": { "blogspot": _3, "123website": _3 } }, "lv": { "$": 1, "succ": { "com": _2, "edu": _2, "gov": _2, "org": _2, "mil": _2, "id": _2, "net": _2, "asn": _2, "conf": _2 } }, "ly": { "$": 1, "succ": { "com": _2, "net": _2, "gov": _2, "plc": _2, "edu": _2, "sch": _2, "med": _2, "org": _2, "id": _2 } }, "ma": { "$": 1, "succ": { "co": _2, "net": _2, "gov": _2, "org": _2, "ac": _2, "press": _2 } }, "mc": { "$": 1, "succ": { "tm": _2, "asso": _2 } }, "md": { "$": 1, "succ": { "blogspot": _3, "at": _3, "de": _3, "jp": _3, "to": _3 } }, "me": { "$": 1, "succ": { "co": _2, "net": _2, "org": _2, "edu": _2, "ac": _2, "gov": _2, "its": _2, "priv": _2, "c66": _3, "daplie": { "$": 2, "succ": { "localhost": _3 } }, "edgestack": _3, "filegear": _3, "filegear-au": _3, "filegear-de": _3, "filegear-gb": _3, "filegear-ie": _3, "filegear-jp": _3, "filegear-sg": _3, "glitch": _3, "ravendb": _3, "lohmus": _3, "barsy": _3, "mcpe": _3, "mcdir": _3, "soundcast": _3, "tcp4": _3, "brasilia": _3, "ddns": _3, "dnsfor": _3, "hopto": _3, "loginto": _3, "noip": _3, "webhop": _3, "vp4": _3, "diskstation": _3, "dscloud": _3, "i234": _3, "myds": _3, "synology": _3, "transip": _23, "wedeploy": _3, "yombo": _3, "nohost": _3 } }, "mg": { "$": 1, "succ": { "org": _2, "nom": _2, "gov": _2, "prd": _2, "tm": _2, "edu": _2, "mil": _2, "com": _2, "co": _2 } }, "mh": _2, "mil": _2, "mk": { "$": 1, "succ": { "com": _2, "org": _2, "net": _2, "edu": _2, "gov": _2, "inf": _2, "name": _2, "blogspot": _3 } }, "ml": { "$": 1, "succ": { "com": _2, "edu": _2, "gouv": _2, "gov": _2, "net": _2, "org": _2, "presse": _2 } }, "mm": _8, "mn": { "$": 1, "succ": { "gov": _2, "edu": _2, "org": _2, "nyc": _3 } }, "mo": _4, "mobi": { "$": 1, "succ": { "barsy": _3, "dscloud": _3 } }, "mp": { "$": 1, "succ": { "ju": _3 } }, "mq": _2, "mr": _34, "ms": { "$": 1, "succ": { "com": _2, "edu": _2, "gov": _2, "net": _2, "org": _2, "lab": _3, "minisite": _3 } }, "mt": { "$": 1, "succ": { "com": _6, "edu": _2, "net": _2, "org": _2 } }, "mu": { "$": 1, "succ": { "com": _2, "net": _2, "org": _2, "gov": _2, "ac": _2, "co": _2, "or": _2 } }, "museum": { "$": 1, "succ": { "academy": _2, "agriculture": _2, "air": _2, "airguard": _2, "alabama": _2, "alaska": _2, "amber": _2, "ambulance": _2, "american": _2, "americana": _2, "americanantiques": _2, "americanart": _2, "amsterdam": _2, "and": _2, "annefrank": _2, "anthro": _2, "anthropology": _2, "antiques": _2, "aquarium": _2, "arboretum": _2, "archaeological": _2, "archaeology": _2, "architecture": _2, "art": _2, "artanddesign": _2, "artcenter": _2, "artdeco": _2, "arteducation": _2, "artgallery": _2, "arts": _2, "artsandcrafts": _2, "asmatart": _2, "assassination": _2, "assisi": _2, "association": _2, "astronomy": _2, "atlanta": _2, "austin": _2, "australia": _2, "automotive": _2, "aviation": _2, "axis": _2, "badajoz": _2, "baghdad": _2, "bahn": _2, "bale": _2, "baltimore": _2, "barcelona": _2, "baseball": _2, "basel": _2, "baths": _2, "bauern": _2, "beauxarts": _2, "beeldengeluid": _2, "bellevue": _2, "bergbau": _2, "berkeley": _2, "berlin": _2, "bern": _2, "bible": _2, "bilbao": _2, "bill": _2, "birdart": _2, "birthplace": _2, "bonn": _2, "boston": _2, "botanical": _2, "botanicalgarden": _2, "botanicgarden": _2, "botany": _2, "brandywinevalley": _2, "brasil": _2, "bristol": _2, "british": _2, "britishcolumbia": _2, "broadcast": _2, "brunel": _2, "brussel": _2, "brussels": _2, "bruxelles": _2, "building": _2, "burghof": _2, "bus": _2, "bushey": _2, "cadaques": _2, "california": _2, "cambridge": _2, "can": _2, "canada": _2, "capebreton": _2, "carrier": _2, "cartoonart": _2, "casadelamoneda": _2, "castle": _2, "castres": _2, "celtic": _2, "center": _2, "chattanooga": _2, "cheltenham": _2, "chesapeakebay": _2, "chicago": _2, "children": _2, "childrens": _2, "childrensgarden": _2, "chiropractic": _2, "chocolate": _2, "christiansburg": _2, "cincinnati": _2, "cinema": _2, "circus": _2, "civilisation": _2, "civilization": _2, "civilwar": _2, "clinton": _2, "clock": _2, "coal": _2, "coastaldefence": _2, "cody": _2, "coldwar": _2, "collection": _2, "colonialwilliamsburg": _2, "coloradoplateau": _2, "columbia": _2, "columbus": _2, "communication": _2, "communications": _2, "community": _2, "computer": _2, "computerhistory": _2, "xn--comunicaes-v6a2o": _2, "comunicações": _2, "contemporary": _2, "contemporaryart": _2, "convent": _2, "copenhagen": _2, "corporation": _2, "xn--correios-e-telecomunicaes-ghc29a": _2, "correios-e-telecomunicações": _2, "corvette": _2, "costume": _2, "countryestate": _2, "county": _2, "crafts": _2, "cranbrook": _2, "creation": _2, "cultural": _2, "culturalcenter": _2, "culture": _2, "cyber": _2, "cymru": _2, "dali": _2, "dallas": _2, "database": _2, "ddr": _2, "decorativearts": _2, "delaware": _2, "delmenhorst": _2, "denmark": _2, "depot": _2, "design": _2, "detroit": _2, "dinosaur": _2, "discovery": _2, "dolls": _2, "donostia": _2, "durham": _2, "eastafrica": _2, "eastcoast": _2, "education": _2, "educational": _2, "egyptian": _2, "eisenbahn": _2, "elburg": _2, "elvendrell": _2, "embroidery": _2, "encyclopedic": _2, "england": _2, "entomology": _2, "environment": _2, "environmentalconservation": _2, "epilepsy": _2, "essex": _2, "estate": _2, "ethnology": _2, "exeter": _2, "exhibition": _2, "family": _2, "farm": _2, "farmequipment": _2, "farmers": _2, "farmstead": _2, "field": _2, "figueres": _2, "filatelia": _2, "film": _2, "fineart": _2, "finearts": _2, "finland": _2, "flanders": _2, "florida": _2, "force": _2, "fortmissoula": _2, "fortworth": _2, "foundation": _2, "francaise": _2, "frankfurt": _2, "franziskaner": _2, "freemasonry": _2, "freiburg": _2, "fribourg": _2, "frog": _2, "fundacio": _2, "furniture": _2, "gallery": _2, "garden": _2, "gateway": _2, "geelvinck": _2, "gemological": _2, "geology": _2, "georgia": _2, "giessen": _2, "glas": _2, "glass": _2, "gorge": _2, "grandrapids": _2, "graz": _2, "guernsey": _2, "halloffame": _2, "hamburg": _2, "handson": _2, "harvestcelebration": _2, "hawaii": _2, "health": _2, "heimatunduhren": _2, "hellas": _2, "helsinki": _2, "hembygdsforbund": _2, "heritage": _2, "histoire": _2, "historical": _2, "historicalsociety": _2, "historichouses": _2, "historisch": _2, "historisches": _2, "history": _2, "historyofscience": _2, "horology": _2, "house": _2, "humanities": _2, "illustration": _2, "imageandsound": _2, "indian": _2, "indiana": _2, "indianapolis": _2, "indianmarket": _2, "intelligence": _2, "interactive": _2, "iraq": _2, "iron": _2, "isleofman": _2, "jamison": _2, "jefferson": _2, "jerusalem": _2, "jewelry": _2, "jewish": _2, "jewishart": _2, "jfk": _2, "journalism": _2, "judaica": _2, "judygarland": _2, "juedisches": _2, "juif": _2, "karate": _2, "karikatur": _2, "kids": _2, "koebenhavn": _2, "koeln": _2, "kunst": _2, "kunstsammlung": _2, "kunstunddesign": _2, "labor": _2, "labour": _2, "lajolla": _2, "lancashire": _2, "landes": _2, "lans": _2, "xn--lns-qla": _2, "läns": _2, "larsson": _2, "lewismiller": _2, "lincoln": _2, "linz": _2, "living": _2, "livinghistory": _2, "localhistory": _2, "london": _2, "losangeles": _2, "louvre": _2, "loyalist": _2, "lucerne": _2, "luxembourg": _2, "luzern": _2, "mad": _2, "madrid": _2, "mallorca": _2, "manchester": _2, "mansion": _2, "mansions": _2, "manx": _2, "marburg": _2, "maritime": _2, "maritimo": _2, "maryland": _2, "marylhurst": _2, "media": _2, "medical": _2, "medizinhistorisches": _2, "meeres": _2, "memorial": _2, "mesaverde": _2, "michigan": _2, "midatlantic": _2, "military": _2, "mill": _2, "miners": _2, "mining": _2, "minnesota": _2, "missile": _2, "missoula": _2, "modern": _2, "moma": _2, "money": _2, "monmouth": _2, "monticello": _2, "montreal": _2, "moscow": _2, "motorcycle": _2, "muenchen": _2, "muenster": _2, "mulhouse": _2, "muncie": _2, "museet": _2, "museumcenter": _2, "museumvereniging": _2, "music": _2, "national": _2, "nationalfirearms": _2, "nationalheritage": _2, "nativeamerican": _2, "naturalhistory": _2, "naturalhistorymuseum": _2, "naturalsciences": _2, "nature": _2, "naturhistorisches": _2, "natuurwetenschappen": _2, "naumburg": _2, "naval": _2, "nebraska": _2, "neues": _2, "newhampshire": _2, "newjersey": _2, "newmexico": _2, "newport": _2, "newspaper": _2, "newyork": _2, "niepce": _2, "norfolk": _2, "north": _2, "nrw": _2, "nyc": _2, "nyny": _2, "oceanographic": _2, "oceanographique": _2, "omaha": _2, "online": _2, "ontario": _2, "openair": _2, "oregon": _2, "oregontrail": _2, "otago": _2, "oxford": _2, "pacific": _2, "paderborn": _2, "palace": _2, "paleo": _2, "palmsprings": _2, "panama": _2, "paris": _2, "pasadena": _2, "pharmacy": _2, "philadelphia": _2, "philadelphiaarea": _2, "philately": _2, "phoenix": _2, "photography": _2, "pilots": _2, "pittsburgh": _2, "planetarium": _2, "plantation": _2, "plants": _2, "plaza": _2, "portal": _2, "portland": _2, "portlligat": _2, "posts-and-telecommunications": _2, "preservation": _2, "presidio": _2, "press": _2, "project": _2, "public": _2, "pubol": _2, "quebec": _2, "railroad": _2, "railway": _2, "research": _2, "resistance": _2, "riodejaneiro": _2, "rochester": _2, "rockart": _2, "roma": _2, "russia": _2, "saintlouis": _2, "salem": _2, "salvadordali": _2, "salzburg": _2, "sandiego": _2, "sanfrancisco": _2, "santabarbara": _2, "santacruz": _2, "santafe": _2, "saskatchewan": _2, "satx": _2, "savannahga": _2, "schlesisches": _2, "schoenbrunn": _2, "schokoladen": _2, "school": _2, "schweiz": _2, "science": _2, "scienceandhistory": _2, "scienceandindustry": _2, "sciencecenter": _2, "sciencecenters": _2, "science-fiction": _2, "sciencehistory": _2, "sciences": _2, "sciencesnaturelles": _2, "scotland": _2, "seaport": _2, "settlement": _2, "settlers": _2, "shell": _2, "sherbrooke": _2, "sibenik": _2, "silk": _2, "ski": _2, "skole": _2, "society": _2, "sologne": _2, "soundandvision": _2, "southcarolina": _2, "southwest": _2, "space": _2, "spy": _2, "square": _2, "stadt": _2, "stalbans": _2, "starnberg": _2, "state": _2, "stateofdelaware": _2, "station": _2, "steam": _2, "steiermark": _2, "stjohn": _2, "stockholm": _2, "stpetersburg": _2, "stuttgart": _2, "suisse": _2, "surgeonshall": _2, "surrey": _2, "svizzera": _2, "sweden": _2, "sydney": _2, "tank": _2, "tcm": _2, "technology": _2, "telekommunikation": _2, "television": _2, "texas": _2, "textile": _2, "theater": _2, "time": _2, "timekeeping": _2, "topology": _2, "torino": _2, "touch": _2, "town": _2, "transport": _2, "tree": _2, "trolley": _2, "trust": _2, "trustee": _2, "uhren": _2, "ulm": _2, "undersea": _2, "university": _2, "usa": _2, "usantiques": _2, "usarts": _2, "uscountryestate": _2, "usculture": _2, "usdecorativearts": _2, "usgarden": _2, "ushistory": _2, "ushuaia": _2, "uslivinghistory": _2, "utah": _2, "uvic": _2, "valley": _2, "vantaa": _2, "versailles": _2, "viking": _2, "village": _2, "virginia": _2, "virtual": _2, "virtuel": _2, "vlaanderen": _2, "volkenkunde": _2, "wales": _2, "wallonie": _2, "war": _2, "washingtondc": _2, "watchandclock": _2, "watch-and-clock": _2, "western": _2, "westfalen": _2, "whaling": _2, "wildlife": _2, "williamsburg": _2, "windmill": _2, "workshop": _2, "york": _2, "yorkshire": _2, "yosemite": _2, "youth": _2, "zoological": _2, "zoology": _2, "xn--9dbhblg6di": _2, "ירושלים": _2, "xn--h1aegh": _2, "иком": _2 } }, "mv": { "$": 1, "succ": { "aero": _2, "biz": _2, "com": _2, "coop": _2, "edu": _2, "gov": _2, "info": _2, "int": _2, "mil": _2, "museum": _2, "name": _2, "net": _2, "org": _2, "pro": _2 } }, "mw": { "$": 1, "succ": { "ac": _2, "biz": _2, "co": _2, "com": _2, "coop": _2, "edu": _2, "gov": _2, "int": _2, "museum": _2, "net": _2, "org": _2 } }, "mx": { "$": 1, "succ": { "com": _2, "org": _2, "gob": _2, "edu": _2, "net": _2, "blogspot": _3 } }, "my": { "$": 1, "succ": { "biz": _2, "com": _2, "edu": _2, "gov": _2, "mil": _2, "name": _2, "net": _2, "org": _2, "blogspot": _3 } }, "mz": { "$": 1, "succ": { "ac": _2, "adv": _2, "co": _2, "edu": _2, "gov": _2, "mil": _2, "net": _2, "org": _2 } }, "na": { "$": 1, "succ": { "info": _2, "pro": _2, "name": _2, "school": _2, "or": _2, "dr": _2, "us": _2, "mx": _2, "ca": _2, "in": _2, "cc": _2, "tv": _2, "ws": _2, "mobi": _2, "co": _2, "com": _2, "org": _2 } }, "name": { "$": 1, "succ": { "her": _37, "his": _37 } }, "nc": { "$": 1, "succ": { "asso": _2, "nom": _2 } }, "ne": _2, "net": { "$": 1, "succ": { "adobeaemcloud": _3, "adobeio-static": _3, "adobeioruntime": _3, "akadns": _3, "akamai": _3, "akamai-staging": _3, "akamaiedge": _3, "akamaiedge-staging": _3, "akamaihd": _3, "akamaihd-staging": _3, "akamaiorigin": _3, "akamaiorigin-staging": _3, "akamaized": _3, "akamaized-staging": _3, "edgekey": _3, "edgekey-staging": _3, "edgesuite": _3, "edgesuite-staging": _3, "alwaysdata": _3, "myamaze": _3, "cloudfront": _3, "t3l3p0rt": _3, "appudo": _3, "atlassian-dev": { "$": 0, "succ": { "prod": { "$": 0, "succ": { "cdn": _3 } } } }, "myfritz": _3, "onavstack": _3, "shopselect": _3, "blackbaudcdn": _3, "boomla": _3, "bplaced": _3, "square7": _3, "gb": _3, "hu": _3, "jp": _3, "se": _3, "uk": _3, "in": _3, "clickrising": _3, "cloudaccess": _3, "cdn77-ssl": _3, "cdn77": { "$": 0, "succ": { "r": _3 } }, "feste-ip": _3, "knx-server": _3, "static-access": _3, "cryptonomic": _5, "dattolocal": _3, "mydatto": _3, "debian": _3, "bitbridge": _3, "at-band-camp": _3, "blogdns": _3, "broke-it": _3, "buyshouses": _3, "dnsalias": _3, "dnsdojo": _3, "does-it": _3, "dontexist": _3, "dynalias": _3, "dynathome": _3, "endofinternet": _3, "from-az": _3, "from-co": _3, "from-la": _3, "from-ny": _3, "gets-it": _3, "ham-radio-op": _3, "homeftp": _3, "homeip": _3, "homelinux": _3, "homeunix": _3, "in-the-band": _3, "is-a-chef": _3, "is-a-geek": _3, "isa-geek": _3, "kicks-ass": _3, "office-on-the": _3, "podzone": _3, "scrapper-site": _3, "selfip": _3, "sells-it": _3, "servebbs": _3, "serveftp": _3, "thruhere": _3, "webhop": _3, "definima": _3, "casacam": _3, "dynu": _3, "dynv6": _3, "twmail": _3, "ru": _3, "channelsdvr": { "$": 2, "succ": { "u": _3 } }, "fastlylb": { "$": 2, "succ": { "map": _3 } }, "fastly": { "$": 0, "succ": { "freetls": _3, "map": _3, "prod": { "$": 0, "succ": { "a": _3, "global": _3 } }, "ssl": { "$": 0, "succ": { "a": _3, "b": _3, "global": _3 } } } }, "edgeapp": _3, "flynnhosting": _3, "cdn-edges": _3, "heteml": _3, "cloudfunctions": _3, "moonscale": _3, "in-dsl": _3, "in-vpn": _3, "ipifony": _3, "iobb": _3, "cloudjiffy": { "$": 2, "succ": { "fra1-de": _3, "west1-us": _3 } }, "elastx": { "$": 0, "succ": { "jls-sto1": _3, "jls-sto2": _3, "jls-sto3": _3 } }, "faststacks": _3, "massivegrid": { "$": 0, "succ": { "paas": { "$": 0, "succ": { "fr-1": _3, "lon-1": _3, "lon-2": _3, "ny-1": _3, "ny-2": _3, "sg-1": _3 } } } }, "saveincloud": { "$": 0, "succ": { "jelastic": _3, "nordeste-idc": _3 } }, "scaleforce": _26, "tsukaeru": _27, "kinghost": _3, "uni5": _3, "krellian": _3, "barsy": _3, "memset": _3, "azurewebsites": _3, "azure-mobile": _3, "cloudapp": _3, "azurestaticapps": { "$": 2, "succ": { "1": _3, "2": _3, "3": _3, "centralus": _3, "eastasia": _3, "eastus2": _3, "westeurope": _3, "westus2": _3 } }, "dnsup": _3, "hicam": _3, "now-dns": _3, "ownip": _3, "vpndns": _3, "eating-organic": _3, "mydissent": _3, "myeffect": _3, "mymediapc": _3, "mypsx": _3, "mysecuritycamera": _3, "nhlfan": _3, "no-ip": _3, "pgafan": _3, "privatizehealthinsurance": _3, "bounceme": _3, "ddns": _3, "redirectme": _3, "serveblog": _3, "serveminecraft": _3, "sytes": _3, "cloudycluster": _3, "ovh": { "$": 0, "succ": { "webpaas": _5, "hosting": _5 } }, "bar0": _3, "bar1": _3, "bar2": _3, "rackmaze": _3, "squares": _3, "schokokeks": _3, "firewall-gateway": _3, "seidat": _3, "senseering": _3, "siteleaf": _3, "vps-host": { "$": 2, "succ": { "jelastic": { "$": 0, "succ": { "atl": _3, "njs": _3, "ric": _3 } } } }, "myspreadshop": _3, "srcf": { "$": 0, "succ": { "soc": _3, "user": _3 } }, "supabase": _3, "dsmynas": _3, "familyds": _3, "tailscale": { "$": 0, "succ": { "beta": _3 } }, "ts": _3, "torproject": { "$": 2, "succ": { "pages": _3 } }, "reserve-online": _3, "community-pro": _3, "meinforum": _3, "yandexcloud": { "$": 2, "succ": { "storage": _3, "website": _3 } }, "za": _3 } }, "nf": { "$": 1, "succ": { "com": _2, "net": _2, "per": _2, "rec": _2, "web": _2, "arts": _2, "firm": _2, "info": _2, "other": _2, "store": _2 } }, "ng": { "$": 1, "succ": { "com": _6, "edu": _2, "gov": _2, "i": _2, "mil": _2, "mobi": _2, "name": _2, "net": _2, "org": _2, "sch": _2, "col": _3, "firm": _3, "gen": _3, "ltd": _3, "ngo": _3 } }, "ni": { "$": 1, "succ": { "ac": _2, "biz": _2, "co": _2, "com": _2, "edu": _2, "gob": _2, "in": _2, "info": _2, "int": _2, "mil": _2, "net": _2, "nom": _2, "org": _2, "web": _2 } }, "nl": { "$": 1, "succ": { "co": _3, "hosting-cluster": _3, "blogspot": _3, "gov": _3, "khplay": _3, "123website": _3, "myspreadshop": _3, "transurl": _5, "cistron": _3, "demon": _3 } }, "no": { "$": 1, "succ": { "fhs": _2, "vgs": _2, "fylkesbibl": _2, "folkebibl": _2, "museum": _2, "idrett": _2, "priv": _2, "mil": _2, "stat": _2, "dep": _2, "kommune": _2, "herad": _2, "aa": _38, "ah": _38, "bu": _38, "fm": _38, "hl": _38, "hm": _38, "jan-mayen": _38, "mr": _38, "nl": _38, "nt": _38, "of": _38, "ol": _38, "oslo": _38, "rl": _38, "sf": _38, "st": _38, "svalbard": _38, "tm": _38, "tr": _38, "va": _38, "vf": _38, "akrehamn": _2, "xn--krehamn-dxa": _2, "åkrehamn": _2, "algard": _2, "xn--lgrd-poac": _2, "ålgård": _2, "arna": _2, "brumunddal": _2, "bryne": _2, "bronnoysund": _2, "xn--brnnysund-m8ac": _2, "brønnøysund": _2, "drobak": _2, "xn--drbak-wua": _2, "drøbak": _2, "egersund": _2, "fetsund": _2, "floro": _2, "xn--flor-jra": _2, "florø": _2, "fredrikstad": _2, "hokksund": _2, "honefoss": _2, "xn--hnefoss-q1a": _2, "hønefoss": _2, "jessheim": _2, "jorpeland": _2, "xn--jrpeland-54a": _2, "jørpeland": _2, "kirkenes": _2, "kopervik": _2, "krokstadelva": _2, "langevag": _2, "xn--langevg-jxa": _2, "langevåg": _2, "leirvik": _2, "mjondalen": _2, "xn--mjndalen-64a": _2, "mjøndalen": _2, "mo-i-rana": _2, "mosjoen": _2, "xn--mosjen-eya": _2, "mosjøen": _2, "nesoddtangen": _2, "orkanger": _2, "osoyro": _2, "xn--osyro-wua": _2, "osøyro": _2, "raholt": _2, "xn--rholt-mra": _2, "råholt": _2, "sandnessjoen": _2, "xn--sandnessjen-ogb": _2, "sandnessjøen": _2, "skedsmokorset": _2, "slattum": _2, "spjelkavik": _2, "stathelle": _2, "stavern": _2, "stjordalshalsen": _2, "xn--stjrdalshalsen-sqb": _2, "stjørdalshalsen": _2, "tananger": _2, "tranby": _2, "vossevangen": _2, "afjord": _2, "xn--fjord-lra": _2, "åfjord": _2, "agdenes": _2, "al": _2, "xn--l-1fa": _2, "ål": _2, "alesund": _2, "xn--lesund-hua": _2, "ålesund": _2, "alstahaug": _2, "alta": _2, "xn--lt-liac": _2, "áltá": _2, "alaheadju": _2, "xn--laheadju-7ya": _2, "álaheadju": _2, "alvdal": _2, "amli": _2, "xn--mli-tla": _2, "åmli": _2, "amot": _2, "xn--mot-tla": _2, "åmot": _2, "andebu": _2, "andoy": _2, "xn--andy-ira": _2, "andøy": _2, "andasuolo": _2, "ardal": _2, "xn--rdal-poa": _2, "årdal": _2, "aremark": _2, "arendal": _2, "xn--s-1fa": _2, "ås": _2, "aseral": _2, "xn--seral-lra": _2, "åseral": _2, "asker": _2, "askim": _2, "askvoll": _2, "askoy": _2, "xn--asky-ira": _2, "askøy": _2, "asnes": _2, "xn--snes-poa": _2, "åsnes": _2, "audnedaln": _2, "aukra": _2, "aure": _2, "aurland": _2, "aurskog-holand": _2, "xn--aurskog-hland-jnb": _2, "aurskog-høland": _2, "austevoll": _2, "austrheim": _2, "averoy": _2, "xn--avery-yua": _2, "averøy": _2, "balestrand": _2, "ballangen": _2, "balat": _2, "xn--blt-elab": _2, "bálát": _2, "balsfjord": _2, "bahccavuotna": _2, "xn--bhccavuotna-k7a": _2, "báhccavuotna": _2, "bamble": _2, "bardu": _2, "beardu": _2, "beiarn": _2, "bajddar": _2, "xn--bjddar-pta": _2, "bájddar": _2, "baidar": _2, "xn--bidr-5nac": _2, "báidár": _2, "berg": _2, "bergen": _2, "berlevag": _2, "xn--berlevg-jxa": _2, "berlevåg": _2, "bearalvahki": _2, "xn--bearalvhki-y4a": _2, "bearalváhki": _2, "bindal": _2, "birkenes": _2, "bjarkoy": _2, "xn--bjarky-fya": _2, "bjarkøy": _2, "bjerkreim": _2, "bjugn": _2, "bodo": _2, "xn--bod-2na": _2, "bodø": _2, "badaddja": _2, "xn--bdddj-mrabd": _2, "bådåddjå": _2, "budejju": _2, "bokn": _2, "bremanger": _2, "bronnoy": _2, "xn--brnny-wuac": _2, "brønnøy": _2, "bygland": _2, "bykle": _2, "barum": _2, "xn--brum-voa": _2, "bærum": _2, "telemark": { "$": 0, "succ": { "bo": _2, "xn--b-5ga": _2, "bø": _2 } }, "nordland": { "$": 0, "succ": { "bo": _2, "xn--b-5ga": _2, "bø": _2, "heroy": _2, "xn--hery-ira": _2, "herøy": _2 } }, "bievat": _2, "xn--bievt-0qa": _2, "bievát": _2, "bomlo": _2, "xn--bmlo-gra": _2, "bømlo": _2, "batsfjord": _2, "xn--btsfjord-9za": _2, "båtsfjord": _2, "bahcavuotna": _2, "xn--bhcavuotna-s4a": _2, "báhcavuotna": _2, "dovre": _2, "drammen": _2, "drangedal": _2, "dyroy": _2, "xn--dyry-ira": _2, "dyrøy": _2, "donna": _2, "xn--dnna-gra": _2, "dønna": _2, "eid": _2, "eidfjord": _2, "eidsberg": _2, "eidskog": _2, "eidsvoll": _2, "eigersund": _2, "elverum": _2, "enebakk": _2, "engerdal": _2, "etne": _2, "etnedal": _2, "evenes": _2, "evenassi": _2, "xn--eveni-0qa01ga": _2, "evenášši": _2, "evje-og-hornnes": _2, "farsund": _2, "fauske": _2, "fuossko": _2, "fuoisku": _2, "fedje": _2, "fet": _2, "finnoy": _2, "xn--finny-yua": _2, "finnøy": _2, "fitjar": _2, "fjaler": _2, "fjell": _2, "flakstad": _2, "flatanger": _2, "flekkefjord": _2, "flesberg": _2, "flora": _2, "fla": _2, "xn--fl-zia": _2, "flå": _2, "folldal": _2, "forsand": _2, "fosnes": _2, "frei": _2, "frogn": _2, "froland": _2, "frosta": _2, "frana": _2, "xn--frna-woa": _2, "fræna": _2, "froya": _2, "xn--frya-hra": _2, "frøya": _2, "fusa": _2, "fyresdal": _2, "forde": _2, "xn--frde-gra": _2, "førde": _2, "gamvik": _2, "gangaviika": _2, "xn--ggaviika-8ya47h": _2, "gáŋgaviika": _2, "gaular": _2, "gausdal": _2, "gildeskal": _2, "xn--gildeskl-g0a": _2, "gildeskål": _2, "giske": _2, "gjemnes": _2, "gjerdrum": _2, "gjerstad": _2, "gjesdal": _2, "gjovik": _2, "xn--gjvik-wua": _2, "gjøvik": _2, "gloppen": _2, "gol": _2, "gran": _2, "grane": _2, "granvin": _2, "gratangen": _2, "grimstad": _2, "grong": _2, "kraanghke": _2, "xn--kranghke-b0a": _2, "kråanghke": _2, "grue": _2, "gulen": _2, "hadsel": _2, "halden": _2, "halsa": _2, "hamar": _2, "hamaroy": _2, "habmer": _2, "xn--hbmer-xqa": _2, "hábmer": _2, "hapmir": _2, "xn--hpmir-xqa": _2, "hápmir": _2, "hammerfest": _2, "hammarfeasta": _2, "xn--hmmrfeasta-s4ac": _2, "hámmárfeasta": _2, "haram": _2, "hareid": _2, "harstad": _2, "hasvik": _2, "aknoluokta": _2, "xn--koluokta-7ya57h": _2, "ákŋoluokta": _2, "hattfjelldal": _2, "aarborte": _2, "haugesund": _2, "hemne": _2, "hemnes": _2, "hemsedal": _2, "more-og-romsdal": { "$": 0, "succ": { "heroy": _2, "sande": _2 } }, "xn--mre-og-romsdal-qqb": { "$": 0, "succ": { "xn--hery-ira": _2, "sande": _2 } }, "møre-og-romsdal": { "$": 0, "succ": { "herøy": _2, "sande": _2 } }, "hitra": _2, "hjartdal": _2, "hjelmeland": _2, "hobol": _2, "xn--hobl-ira": _2, "hobøl": _2, "hof": _2, "hol": _2, "hole": _2, "holmestrand": _2, "holtalen": _2, "xn--holtlen-hxa": _2, "holtålen": _2, "hornindal": _2, "horten": _2, "hurdal": _2, "hurum": _2, "hvaler": _2, "hyllestad": _2, "hagebostad": _2, "xn--hgebostad-g3a": _2, "hægebostad": _2, "hoyanger": _2, "xn--hyanger-q1a": _2, "høyanger": _2, "hoylandet": _2, "xn--hylandet-54a": _2, "høylandet": _2, "ha": _2, "xn--h-2fa": _2, "hå": _2, "ibestad": _2, "inderoy": _2, "xn--indery-fya": _2, "inderøy": _2, "iveland": _2, "jevnaker": _2, "jondal": _2, "jolster": _2, "xn--jlster-bya": _2, "jølster": _2, "karasjok": _2, "karasjohka": _2, "xn--krjohka-hwab49j": _2, "kárášjohka": _2, "karlsoy": _2, "galsa": _2, "xn--gls-elac": _2, "gálsá": _2, "karmoy": _2, "xn--karmy-yua": _2, "karmøy": _2, "kautokeino": _2, "guovdageaidnu": _2, "klepp": _2, "klabu": _2, "xn--klbu-woa": _2, "klæbu": _2, "kongsberg": _2, "kongsvinger": _2, "kragero": _2, "xn--krager-gya": _2, "kragerø": _2, "kristiansand": _2, "kristiansund": _2, "krodsherad": _2, "xn--krdsherad-m8a": _2, "krødsherad": _2, "kvalsund": _2, "rahkkeravju": _2, "xn--rhkkervju-01af": _2, "ráhkkerávju": _2, "kvam": _2, "kvinesdal": _2, "kvinnherad": _2, "kviteseid": _2, "kvitsoy": _2, "xn--kvitsy-fya": _2, "kvitsøy": _2, "kvafjord": _2, "xn--kvfjord-nxa": _2, "kvæfjord": _2, "giehtavuoatna": _2, "kvanangen": _2, "xn--kvnangen-k0a": _2, "kvænangen": _2, "navuotna": _2, "xn--nvuotna-hwa": _2, "návuotna": _2, "kafjord": _2, "xn--kfjord-iua": _2, "kåfjord": _2, "gaivuotna": _2, "xn--givuotna-8ya": _2, "gáivuotna": _2, "larvik": _2, "lavangen": _2, "lavagis": _2, "loabat": _2, "xn--loabt-0qa": _2, "loabát": _2, "lebesby": _2, "davvesiida": _2, "leikanger": _2, "leirfjord": _2, "leka": _2, "leksvik": _2, "lenvik": _2, "leangaviika": _2, "xn--leagaviika-52b": _2, "leaŋgaviika": _2, "lesja": _2, "levanger": _2, "lier": _2, "lierne": _2, "lillehammer": _2, "lillesand": _2, "lindesnes": _2, "lindas": _2, "xn--linds-pra": _2, "lindås": _2, "lom": _2, "loppa": _2, "lahppi": _2, "xn--lhppi-xqa": _2, "láhppi": _2, "lund": _2, "lunner": _2, "luroy": _2, "xn--lury-ira": _2, "lurøy": _2, "luster": _2, "lyngdal": _2, "lyngen": _2, "ivgu": _2, "lardal": _2, "lerdal": _2, "xn--lrdal-sra": _2, "lærdal": _2, "lodingen": _2, "xn--ldingen-q1a": _2, "lødingen": _2, "lorenskog": _2, "xn--lrenskog-54a": _2, "lørenskog": _2, "loten": _2, "xn--lten-gra": _2, "løten": _2, "malvik": _2, "masoy": _2, "xn--msy-ula0h": _2, "måsøy": _2, "muosat": _2, "xn--muost-0qa": _2, "muosát": _2, "mandal": _2, "marker": _2, "marnardal": _2, "masfjorden": _2, "meland": _2, "meldal": _2, "melhus": _2, "meloy": _2, "xn--mely-ira": _2, "meløy": _2, "meraker": _2, "xn--merker-kua": _2, "meråker": _2, "moareke": _2, "xn--moreke-jua": _2, "moåreke": _2, "midsund": _2, "midtre-gauldal": _2, "modalen": _2, "modum": _2, "molde": _2, "moskenes": _2, "moss": _2, "mosvik": _2, "malselv": _2, "xn--mlselv-iua": _2, "målselv": _2, "malatvuopmi": _2, "xn--mlatvuopmi-s4a": _2, "málatvuopmi": _2, "namdalseid": _2, "aejrie": _2, "namsos": _2, "namsskogan": _2, "naamesjevuemie": _2, "xn--nmesjevuemie-tcba": _2, "nååmesjevuemie": _2, "laakesvuemie": _2, "nannestad": _2, "narvik": _2, "narviika": _2, "naustdal": _2, "nedre-eiker": _2, "akershus": _39, "buskerud": _39, "nesna": _2, "nesodden": _2, "nesseby": _2, "unjarga": _2, "xn--unjrga-rta": _2, "unjárga": _2, "nesset": _2, "nissedal": _2, "nittedal": _2, "nord-aurdal": _2, "nord-fron": _2, "nord-odal": _2, "norddal": _2, "nordkapp": _2, "davvenjarga": _2, "xn--davvenjrga-y4a": _2, "davvenjárga": _2, "nordre-land": _2, "nordreisa": _2, "raisa": _2, "xn--risa-5na": _2, "ráisa": _2, "nore-og-uvdal": _2, "notodden": _2, "naroy": _2, "xn--nry-yla5g": _2, "nærøy": _2, "notteroy": _2, "xn--nttery-byae": _2, "nøtterøy": _2, "odda": _2, "oksnes": _2, "xn--ksnes-uua": _2, "øksnes": _2, "oppdal": _2, "oppegard": _2, "xn--oppegrd-ixa": _2, "oppegård": _2, "orkdal": _2, "orland": _2, "xn--rland-uua": _2, "ørland": _2, "orskog": _2, "xn--rskog-uua": _2, "ørskog": _2, "orsta": _2, "xn--rsta-fra": _2, "ørsta": _2, "hedmark": { "$": 0, "succ": { "os": _2, "valer": _2, "xn--vler-qoa": _2, "våler": _2 } }, "hordaland": { "$": 0, "succ": { "os": _2 } }, "osen": _2, "osteroy": _2, "xn--ostery-fya": _2, "osterøy": _2, "ostre-toten": _2, "xn--stre-toten-zcb": _2, "østre-toten": _2, "overhalla": _2, "ovre-eiker": _2, "xn--vre-eiker-k8a": _2, "øvre-eiker": _2, "oyer": _2, "xn--yer-zna": _2, "øyer": _2, "oygarden": _2, "xn--ygarden-p1a": _2, "øygarden": _2, "oystre-slidre": _2, "xn--ystre-slidre-ujb": _2, "øystre-slidre": _2, "porsanger": _2, "porsangu": _2, "xn--porsgu-sta26f": _2, "porsáŋgu": _2, "porsgrunn": _2, "radoy": _2, "xn--rady-ira": _2, "radøy": _2, "rakkestad": _2, "rana": _2, "ruovat": _2, "randaberg": _2, "rauma": _2, "rendalen": _2, "rennebu": _2, "rennesoy": _2, "xn--rennesy-v1a": _2, "rennesøy": _2, "rindal": _2, "ringebu": _2, "ringerike": _2, "ringsaker": _2, "rissa": _2, "risor": _2, "xn--risr-ira": _2, "risør": _2, "roan": _2, "rollag": _2, "rygge": _2, "ralingen": _2, "xn--rlingen-mxa": _2, "rælingen": _2, "rodoy": _2, "xn--rdy-0nab": _2, "rødøy": _2, "romskog": _2, "xn--rmskog-bya": _2, "rømskog": _2, "roros": _2, "xn--rros-gra": _2, "røros": _2, "rost": _2, "xn--rst-0na": _2, "røst": _2, "royken": _2, "xn--ryken-vua": _2, "røyken": _2, "royrvik": _2, "xn--ryrvik-bya": _2, "røyrvik": _2, "rade": _2, "xn--rde-ula": _2, "råde": _2, "salangen": _2, "siellak": _2, "saltdal": _2, "salat": _2, "xn--slt-elab": _2, "sálát": _2, "xn--slat-5na": _2, "sálat": _2, "samnanger": _2, "vestfold": { "$": 0, "succ": { "sande": _2 } }, "sandefjord": _2, "sandnes": _2, "sandoy": _2, "xn--sandy-yua": _2, "sandøy": _2, "sarpsborg": _2, "sauda": _2, "sauherad": _2, "sel": _2, "selbu": _2, "selje": _2, "seljord": _2, "sigdal": _2, "siljan": _2, "sirdal": _2, "skaun": _2, "skedsmo": _2, "ski": _2, "skien": _2, "skiptvet": _2, "skjervoy": _2, "xn--skjervy-v1a": _2, "skjervøy": _2, "skierva": _2, "xn--skierv-uta": _2, "skiervá": _2, "skjak": _2, "xn--skjk-soa": _2, "skjåk": _2, "skodje": _2, "skanland": _2, "xn--sknland-fxa": _2, "skånland": _2, "skanit": _2, "xn--sknit-yqa": _2, "skánit": _2, "smola": _2, "xn--smla-hra": _2, "smøla": _2, "snillfjord": _2, "snasa": _2, "xn--snsa-roa": _2, "snåsa": _2, "snoasa": _2, "snaase": _2, "xn--snase-nra": _2, "snåase": _2, "sogndal": _2, "sokndal": _2, "sola": _2, "solund": _2, "songdalen": _2, "sortland": _2, "spydeberg": _2, "stange": _2, "stavanger": _2, "steigen": _2, "steinkjer": _2, "stjordal": _2, "xn--stjrdal-s1a": _2, "stjørdal": _2, "stokke": _2, "stor-elvdal": _2, "stord": _2, "stordal": _2, "storfjord": _2, "omasvuotna": _2, "strand": _2, "stranda": _2, "stryn": _2, "sula": _2, "suldal": _2, "sund": _2, "sunndal": _2, "surnadal": _2, "sveio": _2, "svelvik": _2, "sykkylven": _2, "sogne": _2, "xn--sgne-gra": _2, "søgne": _2, "somna": _2, "xn--smna-gra": _2, "sømna": _2, "sondre-land": _2, "xn--sndre-land-0cb": _2, "søndre-land": _2, "sor-aurdal": _2, "xn--sr-aurdal-l8a": _2, "sør-aurdal": _2, "sor-fron": _2, "xn--sr-fron-q1a": _2, "sør-fron": _2, "sor-odal": _2, "xn--sr-odal-q1a": _2, "sør-odal": _2, "sor-varanger": _2, "xn--sr-varanger-ggb": _2, "sør-varanger": _2, "matta-varjjat": _2, "xn--mtta-vrjjat-k7af": _2, "mátta-várjjat": _2, "sorfold": _2, "xn--srfold-bya": _2, "sørfold": _2, "sorreisa": _2, "xn--srreisa-q1a": _2, "sørreisa": _2, "sorum": _2, "xn--srum-gra": _2, "sørum": _2, "tana": _2, "deatnu": _2, "time": _2, "tingvoll": _2, "tinn": _2, "tjeldsund": _2, "dielddanuorri": _2, "tjome": _2, "xn--tjme-hra": _2, "tjøme": _2, "tokke": _2, "tolga": _2, "torsken": _2, "tranoy": _2, "xn--trany-yua": _2, "tranøy": _2, "tromso": _2, "xn--troms-zua": _2, "tromsø": _2, "tromsa": _2, "romsa": _2, "trondheim": _2, "troandin": _2, "trysil": _2, "trana": _2, "xn--trna-woa": _2, "træna": _2, "trogstad": _2, "xn--trgstad-r1a": _2, "trøgstad": _2, "tvedestrand": _2, "tydal": _2, "tynset": _2, "tysfjord": _2, "divtasvuodna": _2, "divttasvuotna": _2, "tysnes": _2, "tysvar": _2, "xn--tysvr-vra": _2, "tysvær": _2, "tonsberg": _2, "xn--tnsberg-q1a": _2, "tønsberg": _2, "ullensaker": _2, "ullensvang": _2, "ulvik": _2, "utsira": _2, "vadso": _2, "xn--vads-jra": _2, "vadsø": _2, "cahcesuolo": _2, "xn--hcesuolo-7ya35b": _2, "čáhcesuolo": _2, "vaksdal": _2, "valle": _2, "vang": _2, "vanylven": _2, "vardo": _2, "xn--vard-jra": _2, "vardø": _2, "varggat": _2, "xn--vrggt-xqad": _2, "várggát": _2, "vefsn": _2, "vaapste": _2, "vega": _2, "vegarshei": _2, "xn--vegrshei-c0a": _2, "vegårshei": _2, "vennesla": _2, "verdal": _2, "verran": _2, "vestby": _2, "vestnes": _2, "vestre-slidre": _2, "vestre-toten": _2, "vestvagoy": _2, "xn--vestvgy-ixa6o": _2, "vestvågøy": _2, "vevelstad": _2, "vik": _2, "vikna": _2, "vindafjord": _2, "volda": _2, "voss": _2, "varoy": _2, "xn--vry-yla5g": _2, "værøy": _2, "vagan": _2, "xn--vgan-qoa": _2, "vågan": _2, "voagat": _2, "vagsoy": _2, "xn--vgsy-qoa0j": _2, "vågsøy": _2, "vaga": _2, "xn--vg-yiab": _2, "vågå": _2, "ostfold": { "$": 0, "succ": { "valer": _2 } }, "xn--stfold-9xa": { "$": 0, "succ": { "xn--vler-qoa": _2 } }, "østfold": { "$": 0, "succ": { "våler": _2 } }, "co": _3, "blogspot": _3, "123hjemmeside": _3, "myspreadshop": _3 } }, "np": _8, "nr": _33, "nu": { "$": 1, "succ": { "merseine": _3, "mine": _3, "shacknet": _3, "enterprisecloud": _3 } }, "nz": { "$": 1, "succ": { "ac": _2, "co": _6, "cri": _2, "geek": _2, "gen": _2, "govt": _2, "health": _2, "iwi": _2, "kiwi": _2, "maori": _2, "mil": _2, "xn--mori-qsa": _2, "māori": _2, "net": _2, "org": _2, "parliament": _2, "school": _2 } }, "om": { "$": 1, "succ": { "co": _2, "com": _2, "edu": _2, "gov": _2, "med": _2, "museum": _2, "net": _2, "org": _2, "pro": _2 } }, "onion": _2, "org": { "$": 1, "succ": { "altervista": _3, "amune": { "$": 0, "succ": { "tele": _3 } }, "pimienta": _3, "poivron": _3, "potager": _3, "sweetpepper": _3, "ae": _3, "us": _3, "certmgr": _3, "cdn77": { "$": 0, "succ": { "c": _3, "rsc": _3 } }, "cdn77-secure": { "$": 0, "succ": { "origin": { "$": 0, "succ": { "ssl": _3 } } } }, "cloudns": _3, "duckdns": _3, "tunk": _3, "dyndns": { "$": 2, "succ": { "go": _3, "home": _3 } }, "blogdns": _3, "blogsite": _3, "boldlygoingnowhere": _3, "dnsalias": _3, "dnsdojo": _3, "doesntexist": _3, "dontexist": _3, "doomdns": _3, "dvrdns": _3, "dynalias": _3, "endofinternet": _3, "endoftheinternet": _3, "from-me": _3, "game-host": _3, "gotdns": _3, "hobby-site": _3, "homedns": _3, "homeftp": _3, "homelinux": _3, "homeunix": _3, "is-a-bruinsfan": _3, "is-a-candidate": _3, "is-a-celticsfan": _3, "is-a-chef": _3, "is-a-geek": _3, "is-a-knight": _3, "is-a-linux-user": _3, "is-a-patsfan": _3, "is-a-soxfan": _3, "is-found": _3, "is-lost": _3, "is-saved": _3, "is-very-bad": _3, "is-very-evil": _3, "is-very-good": _3, "is-very-nice": _3, "is-very-sweet": _3, "isa-geek": _3, "kicks-ass": _3, "misconfused": _3, "podzone": _3, "readmyblog": _3, "selfip": _3, "sellsyourhome": _3, "servebbs": _3, "serveftp": _3, "servegame": _3, "stuff-4-sale": _3, "webhop": _3, "ddnss": _3, "accesscam": _3, "camdvr": _3, "freeddns": _3, "mywire": _3, "webredirect": _3, "eu": { "$": 2, "succ": { "al": _3, "asso": _3, "at": _3, "au": _3, "be": _3, "bg": _3, "ca": _3, "cd": _3, "ch": _3, "cn": _3, "cy": _3, "cz": _3, "de": _3, "dk": _3, "edu": _3, "ee": _3, "es": _3, "fi": _3, "fr": _3, "gr": _3, "hr": _3, "hu": _3, "ie": _3, "il": _3, "in": _3, "int": _3, "is": _3, "it": _3, "jp": _3, "kr": _3, "lt": _3, "lu": _3, "lv": _3, "mc": _3, "me": _3, "mk": _3, "mt": _3, "my": _3, "net": _3, "ng": _3, "nl": _3, "no": _3, "nz": _3, "paris": _3, "pl": _3, "pt": _3, "q-a": _3, "ro": _3, "ru": _3, "se": _3, "si": _3, "sk": _3, "tr": _3, "uk": _3, "us": _3 } }, "twmail": _3, "fedorainfracloud": _3, "fedorapeople": _3, "fedoraproject": { "$": 0, "succ": { "cloud": _3, "os": _21, "stg": { "$": 0, "succ": { "os": _21 } } } }, "freedesktop": _3, "hepforge": _3, "in-dsl": _3, "in-vpn": _3, "js": _3, "barsy": _3, "mayfirst": _3, "mozilla-iot": _3, "bmoattachments": _3, "dynserv": _3, "now-dns": _3, "cable-modem": _3, "collegefan": _3, "couchpotatofries": _3, "mlbfan": _3, "mysecuritycamera": _3, "nflfan": _3, "read-books": _3, "ufcfan": _3, "hopto": _3, "myftp": _3, "no-ip": _3, "zapto": _3, "httpbin": _3, "pubtls": _3, "jpn": _3, "my-firewall": _3, "myfirewall": _3, "spdns": _3, "small-web": _3, "dsmynas": _3, "familyds": _3, "teckids": _12, "tuxfamily": _3, "diskstation": _3, "hk": _3, "wmflabs": _3, "toolforge": _3, "wmcloud": _3, "za": _3 } }, "pa": { "$": 1, "succ": { "ac": _2, "gob": _2, "com": _2, "org": _2, "sld": _2, "edu": _2, "net": _2, "ing": _2, "abo": _2, "med": _2, "nom": _2 } }, "pe": { "$": 1, "succ": { "edu": _2, "gob": _2, "nom": _2, "mil": _2, "org": _2, "com": _2, "net": _2, "blogspot": _3 } }, "pf": { "$": 1, "succ": { "com": _2, "org": _2, "edu": _2 } }, "pg": _8, "ph": { "$": 1, "succ": { "com": _2, "net": _2, "org": _2, "gov": _2, "edu": _2, "ngo": _2, "mil": _2, "i": _2 } }, "pk": { "$": 1, "succ": { "com": _2, "net": _2, "edu": _2, "org": _2, "fam": _2, "biz": _2, "web": _2, "gov": _2, "gob": _2, "gok": _2, "gon": _2, "gop": _2, "gos": _2, "info": _2 } }, "pl": { "$": 1, "succ": { "com": _2, "net": _2, "org": _2, "aid": _2, "agro": _2, "atm": _2, "auto": _2, "biz": _2, "edu": _2, "gmina": _2, "gsm": _2, "info": _2, "mail": _2, "miasta": _2, "media": _2, "mil": _2, "nieruchomosci": _2, "nom": _2, "pc": _2, "powiat": _2, "priv": _2, "realestate": _2, "rel": _2, "sex": _2, "shop": _2, "sklep": _2, "sos": _2, "szkola": _2, "targi": _2, "tm": _2, "tourism": _2, "travel": _2, "turystyka": _2, "gov": { "$": 1, "succ": { "ap": _2, "ic": _2, "is": _2, "us": _2, "kmpsp": _2, "kppsp": _2, "kwpsp": _2, "psp": _2, "wskr": _2, "kwp": _2, "mw": _2, "ug": _2, "um": _2, "umig": _2, "ugim": _2, "upow": _2, "uw": _2, "starostwo": _2, "pa": _2, "po": _2, "psse": _2, "pup": _2, "rzgw": _2, "sa": _2, "so": _2, "sr": _2, "wsa": _2, "sko": _2, "uzs": _2, "wiih": _2, "winb": _2, "pinb": _2, "wios": _2, "witd": _2, "wzmiuw": _2, "piw": _2, "wiw": _2, "griw": _2, "wif": _2, "oum": _2, "sdn": _2, "zp": _2, "uppo": _2, "mup": _2, "wuoz": _2, "konsulat": _2, "oirm": _2 } }, "augustow": _2, "babia-gora": _2, "bedzin": _2, "beskidy": _2, "bialowieza": _2, "bialystok": _2, "bielawa": _2, "bieszczady": _2, "boleslawiec": _2, "bydgoszcz": _2, "bytom": _2, "cieszyn": _2, "czeladz": _2, "czest": _2, "dlugoleka": _2, "elblag": _2, "elk": _2, "glogow": _2, "gniezno": _2, "gorlice": _2, "grajewo": _2, "ilawa": _2, "jaworzno": _2, "jelenia-gora": _2, "jgora": _2, "kalisz": _2, "kazimierz-dolny": _2, "karpacz": _2, "kartuzy": _2, "kaszuby": _2, "katowice": _2, "kepno": _2, "ketrzyn": _2, "klodzko": _2, "kobierzyce": _2, "kolobrzeg": _2, "konin": _2, "konskowola": _2, "kutno": _2, "lapy": _2, "lebork": _2, "legnica": _2, "lezajsk": _2, "limanowa": _2, "lomza": _2, "lowicz": _2, "lubin": _2, "lukow": _2, "malbork": _2, "malopolska": _2, "mazowsze": _2, "mazury": _2, "mielec": _2, "mielno": _2, "mragowo": _2, "naklo": _2, "nowaruda": _2, "nysa": _2, "olawa": _2, "olecko": _2, "olkusz": _2, "olsztyn": _2, "opoczno": _2, "opole": _2, "ostroda": _2, "ostroleka": _2, "ostrowiec": _2, "ostrowwlkp": _2, "pila": _2, "pisz": _2, "podhale": _2, "podlasie": _2, "polkowice": _2, "pomorze": _2, "pomorskie": _2, "prochowice": _2, "pruszkow": _2, "przeworsk": _2, "pulawy": _2, "radom": _2, "rawa-maz": _2, "rybnik": _2, "rzeszow": _2, "sanok": _2, "sejny": _2, "slask": _2, "slupsk": _2, "sosnowiec": _2, "stalowa-wola": _2, "skoczow": _2, "starachowice": _2, "stargard": _2, "suwalki": _2, "swidnica": _2, "swiebodzin": _2, "swinoujscie": _2, "szczecin": _2, "szczytno": _2, "tarnobrzeg": _2, "tgory": _2, "turek": _2, "tychy": _2, "ustka": _2, "walbrzych": _2, "warmia": _2, "warszawa": _2, "waw": _2, "wegrow": _2, "wielun": _2, "wlocl": _2, "wloclawek": _2, "wodzislaw": _2, "wolomin": _2, "wroclaw": _2, "zachpomor": _2, "zagan": _2, "zarow": _2, "zgora": _2, "zgorzelec": _2, "beep": _3, "ecommerce-shop": _3, "shoparena": _3, "homesklep": _3, "sdscloud": _3, "unicloud": _3, "krasnik": _3, "leczna": _3, "lubartow": _3, "lublin": _3, "poniatowa": _3, "swidnik": _3, "co": _3, "simplesite": _3, "art": _3, "gliwice": _3, "krakow": _3, "poznan": _3, "wroc": _3, "zakopane": _3, "myspreadshop": _3, "gda": _3, "gdansk": _3, "gdynia": _3, "med": _3, "sopot": _3 } }, "pm": { "$": 1, "succ": { "own": _3, "name": _3 } }, "pn": { "$": 1, "succ": { "gov": _2, "co": _2, "org": _2, "edu": _2, "net": _2 } }, "post": _2, "pr": { "$": 1, "succ": { "com": _2, "net": _2, "org": _2, "gov": _2, "edu": _2, "isla": _2, "pro": _2, "biz": _2, "info": _2, "name": _2, "est": _2, "prof": _2, "ac": _2 } }, "pro": { "$": 1, "succ": { "aaa": _2, "aca": _2, "acct": _2, "avocat": _2, "bar": _2, "cpa": _2, "eng": _2, "jur": _2, "law": _2, "med": _2, "recht": _2, "cloudns": _3, "dnstrace": { "$": 0, "succ": { "bci": _3 } }, "barsy": _3 } }, "ps": { "$": 1, "succ": { "edu": _2, "gov": _2, "sec": _2, "plo": _2, "com": _2, "org": _2, "net": _2 } }, "pt": { "$": 1, "succ": { "net": _2, "gov": _2, "org": _2, "edu": _2, "int": _2, "publ": _2, "com": _2, "nome": _2, "blogspot": _3, "123paginaweb": _3 } }, "pw": { "$": 1, "succ": { "co": _2, "ne": _2, "or": _2, "ed": _2, "go": _2, "belau": _2, "cloudns": _3, "x443": _3 } }, "py": { "$": 1, "succ": { "com": _2, "coop": _2, "edu": _2, "gov": _2, "mil": _2, "net": _2, "org": _2 } }, "qa": { "$": 1, "succ": { "com": _2, "edu": _2, "gov": _2, "mil": _2, "name": _2, "net": _2, "org": _2, "sch": _2, "blogspot": _3 } }, "re": { "$": 1, "succ": { "asso": _2, "com": _2, "nom": _2, "blogspot": _3 } }, "ro": { "$": 1, "succ": { "arts": _2, "com": _2, "firm": _2, "info": _2, "nom": _2, "nt": _2, "org": _2, "rec": _2, "store": _2, "tm": _2, "www": _2, "co": _3, "shop": _3, "blogspot": _3, "barsy": _3 } }, "rs": { "$": 1, "succ": { "ac": _2, "co": _2, "edu": _2, "gov": _2, "in": _2, "org": _2, "brendly": { "$": 0, "succ": { "shop": _3 } }, "blogspot": _3, "ua": _3, "ox": _3 } }, "ru": { "$": 1, "succ": { "ac": _3, "edu": _3, "gov": _3, "int": _3, "mil": _3, "test": _3, "eurodir": _3, "adygeya": _3, "bashkiria": _3, "bir": _3, "cbg": _3, "com": _3, "dagestan": _3, "grozny": _3, "kalmykia": _3, "kustanai": _3, "marine": _3, "mordovia": _3, "msk": _3, "mytis": _3, "nalchik": _3, "nov": _3, "pyatigorsk": _3, "spb": _3, "vladikavkaz": _3, "vladimir": _3, "blogspot": _3, "na4u": _3, "mircloud": _3, "regruhosting": _27, "myjino": { "$": 2, "succ": { "hosting": _5, "landing": _5, "spectrum": _5, "vps": _5 } }, "cldmail": { "$": 0, "succ": { "hb": _3 } }, "mcdir": { "$": 2, "succ": { "vps": _3 } }, "mcpre": _3, "net": _3, "org": _3, "pp": _3, "123sait": _3, "lk3": _3, "ras": _3 } }, "rw": { "$": 1, "succ": { "ac": _2, "co": _2, "coop": _2, "gov": _2, "mil": _2, "net": _2, "org": _2 } }, "sa": { "$": 1, "succ": { "com": _2, "net": _2, "org": _2, "gov": _2, "med": _2, "pub": _2, "edu": _2, "sch": _2 } }, "sb": _4, "sc": _4, "sd": { "$": 1, "succ": { "com": _2, "net": _2, "org": _2, "edu": _2, "med": _2, "tv": _2, "gov": _2, "info": _2 } }, "se": { "$": 1, "succ": { "a": _2, "ac": _2, "b": _2, "bd": _2, "brand": _2, "c": _2, "d": _2, "e": _2, "f": _2, "fh": _2, "fhsk": _2, "fhv": _2, "g": _2, "h": _2, "i": _2, "k": _2, "komforb": _2, "kommunalforbund": _2, "komvux": _2, "l": _2, "lanbib": _2, "m": _2, "n": _2, "naturbruksgymn": _2, "o": _2, "org": _2, "p": _2, "parti": _2, "pp": _2, "press": _2, "r": _2, "s": _2, "t": _2, "tm": _2, "u": _2, "w": _2, "x": _2, "y": _2, "z": _2, "com": _3, "blogspot": _3, "conf": _3, "iopsys": _3, "123minsida": _3, "itcouldbewor": _3, "myspreadshop": _3, "paba": { "$": 0, "succ": { "su": _3 } } } }, "sg": { "$": 1, "succ": { "com": _2, "net": _2, "org": _2, "gov": _2, "edu": _2, "per": _2, "blogspot": _3, "enscaled": _3 } }, "sh": { "$": 1, "succ": { "com": _2, "net": _2, "gov": _2, "org": _2, "mil": _2, "bip": _3, "hashbang": _3, "platform": { "$": 0, "succ": { "bc": _3, "ent": _3, "eu": _3, "us": _3 } }, "now": _3, "vxl": _3, "wedeploy": _3 } }, "si": { "$": 1, "succ": { "gitapp": _3, "gitpage": _3, "blogspot": _3 } }, "sj": _2, "sk": _6, "sl": _4, "sm": _2, "sn": { "$": 1, "succ": { "art": _2, "com": _2, "edu": _2, "gouv": _2, "org": _2, "perso": _2, "univ": _2, "blogspot": _3 } }, "so": { "$": 1, "succ": { "com": _2, "edu": _2, "gov": _2, "me": _2, "net": _2, "org": _2, "sch": _3 } }, "sr": _2, "ss": { "$": 1, "succ": { "biz": _2, "com": _2, "edu": _2, "gov": _2, "me": _2, "net": _2, "org": _2, "sch": _2 } }, "st": { "$": 1, "succ": { "co": _2, "com": _2, "consulado": _2, "edu": _2, "embaixada": _2, "mil": _2, "net": _2, "org": _2, "principe": _2, "saotome": _2, "store": _2, "kirara": _3, "noho": _3 } }, "su": { "$": 1, "succ": { "abkhazia": _3, "adygeya": _3, "aktyubinsk": _3, "arkhangelsk": _3, "armenia": _3, "ashgabad": _3, "azerbaijan": _3, "balashov": _3, "bashkiria": _3, "bryansk": _3, "bukhara": _3, "chimkent": _3, "dagestan": _3, "east-kazakhstan": _3, "exnet": _3, "georgia": _3, "grozny": _3, "ivanovo": _3, "jambyl": _3, "kalmykia": _3, "kaluga": _3, "karacol": _3, "karaganda": _3, "karelia": _3, "khakassia": _3, "krasnodar": _3, "kurgan": _3, "kustanai": _3, "lenug": _3, "mangyshlak": _3, "mordovia": _3, "msk": _3, "murmansk": _3, "nalchik": _3, "navoi": _3, "north-kazakhstan": _3, "nov": _3, "obninsk": _3, "penza": _3, "pokrovsk": _3, "sochi": _3, "spb": _3, "tashkent": _3, "termez": _3, "togliatti": _3, "troitsk": _3, "tselinograd": _3, "tula": _3, "tuva": _3, "vladikavkaz": _3, "vladimir": _3, "vologda": _3 } }, "sv": { "$": 1, "succ": { "com": _2, "edu": _2, "gob": _2, "org": _2, "red": _2 } }, "sx": _7, "sy": _32, "sz": { "$": 1, "succ": { "co": _2, "ac": _2, "org": _2 } }, "tc": { "$": 1, "succ": { "ch": _3, "me": _3, "we": _3 } }, "td": _6, "tel": _2, "tf": { "$": 1, "succ": { "sch": _3 } }, "tg": _2, "th": { "$": 1, "succ": { "ac": _2, "co": _2, "go": _2, "in": _2, "mi": _2, "net": _2, "or": _2, "online": _3, "shop": _3 } }, "tj": { "$": 1, "succ": { "ac": _2, "biz": _2, "co": _2, "com": _2, "edu": _2, "go": _2, "gov": _2, "int": _2, "mil": _2, "name": _2, "net": _2, "nic": _2, "org": _2, "test": _2, "web": _2 } }, "tk": _2, "tl": _7, "tm": { "$": 1, "succ": { "com": _2, "co": _2, "org": _2, "net": _2, "nom": _2, "gov": _2, "mil": _2, "edu": _2 } }, "tn": { "$": 1, "succ": { "com": _2, "ens": _2, "fin": _2, "gov": _2, "ind": _2, "info": _2, "intl": _2, "mincom": _2, "nat": _2, "net": _2, "org": _2, "perso": _2, "tourism": _2, "orangecloud": _3 } }, "to": { "$": 1, "succ": { "611": _3, "com": _2, "gov": _2, "net": _2, "org": _2, "edu": _2, "mil": _2, "oya": _3, "rdv": _3, "x0": _3, "vpnplus": _3, "quickconnect": _13, "nyan": _3 } }, "tr": { "$": 1, "succ": { "av": _2, "bbs": _2, "bel": _2, "biz": _2, "com": _6, "dr": _2, "edu": _2, "gen": _2, "gov": _2, "info": _2, "mil": _2, "k12": _2, "kep": _2, "name": _2, "net": _2, "org": _2, "pol": _2, "tel": _2, "tsk": _2, "tv": _2, "web": _2, "nc": _7 } }, "tt": { "$": 1, "succ": { "co": _2, "com": _2, "org": _2, "net": _2, "biz": _2, "info": _2, "pro": _2, "int": _2, "coop": _2, "jobs": _2, "mobi": _2, "travel": _2, "museum": _2, "aero": _2, "name": _2, "gov": _2, "edu": _2 } }, "tv": { "$": 1, "succ": { "dyndns": _3, "better-than": _3, "on-the-web": _3, "worse-than": _3, "from": _3, "sakura": _3 } }, "tw": { "$": 1, "succ": { "edu": _2, "gov": _2, "mil": _2, "com": { "$": 1, "succ": { "mymailer": _3 } }, "net": _2, "org": _2, "idv": _2, "game": _2, "ebiz": _2, "club": _2, "xn--zf0ao64a": _2, "網路": _2, "xn--uc0atv": _2, "組織": _2, "xn--czrw28b": _2, "商業": _2, "url": _3, "blogspot": _3 } }, "tz": { "$": 1, "succ": { "ac": _2, "co": _2, "go": _2, "hotel": _2, "info": _2, "me": _2, "mil": _2, "mobi": _2, "ne": _2, "or": _2, "sc": _2, "tv": _2 } }, "ua": { "$": 1, "succ": { "com": _2, "edu": _2, "gov": _2, "in": _2, "net": _2, "org": _2, "cherkassy": _2, "cherkasy": _2, "chernigov": _2, "chernihiv": _2, "chernivtsi": _2, "chernovtsy": _2, "ck": _2, "cn": _2, "cr": _2, "crimea": _2, "cv": _2, "dn": _2, "dnepropetrovsk": _2, "dnipropetrovsk": _2, "donetsk": _2, "dp": _2, "if": _2, "ivano-frankivsk": _2, "kh": _2, "kharkiv": _2, "kharkov": _2, "kherson": _2, "khmelnitskiy": _2, "khmelnytskyi": _2, "kiev": _2, "kirovograd": _2, "km": _2, "kr": _2, "krym": _2, "ks": _2, "kv": _2, "kyiv": _2, "lg": _2, "lt": _2, "lugansk": _2, "lutsk": _2, "lv": _2, "lviv": _2, "mk": _2, "mykolaiv": _2, "nikolaev": _2, "od": _2, "odesa": _2, "odessa": _2, "pl": _2, "poltava": _2, "rivne": _2, "rovno": _2, "rv": _2, "sb": _2, "sebastopol": _2, "sevastopol": _2, "sm": _2, "sumy": _2, "te": _2, "ternopil": _2, "uz": _2, "uzhgorod": _2, "vinnica": _2, "vinnytsia": _2, "vn": _2, "volyn": _2, "yalta": _2, "zaporizhzhe": _2, "zaporizhzhia": _2, "zhitomir": _2, "zhytomyr": _2, "zp": _2, "zt": _2, "cc": _3, "inf": _3, "ltd": _3, "cx": _3, "ie": _3, "biz": _3, "co": _3, "pp": _3, "v": _3 } }, "ug": { "$": 1, "succ": { "co": _2, "or": _2, "ac": _2, "sc": _2, "go": _2, "ne": _2, "com": _2, "org": _2, "blogspot": _3 } }, "uk": { "$": 1, "succ": { "ac": _2, "co": { "$": 1, "succ": { "bytemark": { "$": 0, "succ": { "dh": _3, "vm": _3 } }, "blogspot": _3, "layershift": _26, "barsy": _3, "barsyonline": _3, "retrosnub": _31, "nh-serv": _3, "no-ip": _3, "wellbeingzone": _3, "adimo": _3, "myspreadshop": _3 } }, "gov": { "$": 1, "succ": { "campaign": _3, "service": _3, "api": _3, "homeoffice": _3 } }, "ltd": _2, "me": _2, "net": _2, "nhs": _2, "org": { "$": 1, "succ": { "glug": _3, "lug": _3, "lugs": _3, "affinitylottery": _3, "raffleentry": _3, "weeklylottery": _3 } }, "plc": _2, "police": _2, "sch": _8, "conn": _3, "copro": _3, "hosp": _3, "independent-commission": _3, "independent-inquest": _3, "independent-inquiry": _3, "independent-panel": _3, "independent-review": _3, "public-inquiry": _3, "royal-commission": _3, "pymnt": _3, "barsy": _3 } }, "us": { "$": 1, "succ": { "dni": _2, "fed": _2, "isa": _2, "kids": _2, "nsn": _2, "ak": _40, "al": _40, "ar": _40, "as": _40, "az": _40, "ca": _40, "co": _40, "ct": _40, "dc": _40, "de": { "$": 1, "succ": { "k12": _2, "cc": _2, "lib": _3 } }, "fl": _40, "ga": _40, "gu": _40, "hi": _41, "ia": _40, "id": _40, "il": _40, "in": _40, "ks": _40, "ky": _40, "la": _40, "ma": { "$": 1, "succ": { "k12": { "$": 1, "succ": { "pvt": _2, "chtr": _2, "paroch": _2 } }, "cc": _2, "lib": _2 } }, "md": _40, "me": _40, "mi": { "$": 1, "succ": { "k12": _2, "cc": _2, "lib": _2, "ann-arbor": _2, "cog": _2, "dst": _2, "eaton": _2, "gen": _2, "mus": _2, "tec": _2, "washtenaw": _2 } }, "mn": _40, "mo": _40, "ms": _40, "mt": _40, "nc": _40, "nd": _41, "ne": _40, "nh": _40, "nj": _40, "nm": _40, "nv": _40, "ny": _40, "oh": _40, "ok": _40, "or": _40, "pa": _40, "pr": _40, "ri": _41, "sc": _40, "sd": _41, "tn": _40, "tx": _40, "ut": _40, "vi": _40, "vt": _40, "va": _40, "wa": _40, "wi": _40, "wv": { "$": 1, "succ": { "cc": _2 } }, "wy": _40, "graphox": _3, "cloudns": _3, "drud": _3, "is-by": _3, "land-4-sale": _3, "stuff-4-sale": _3, "enscaled": { "$": 0, "succ": { "phx": _3 } }, "mircloud": _3, "freeddns": _3, "golffan": _3, "noip": _3, "pointto": _3, "platterp": _3 } }, "uy": { "$": 1, "succ": { "com": _6, "edu": _2, "gub": _2, "mil": _2, "net": _2, "org": _2 } }, "uz": { "$": 1, "succ": { "co": _2, "com": _2, "net": _2, "org": _2 } }, "va": _2, "vc": { "$": 1, "succ": { "com": _2, "net": _2, "org": _2, "gov": _2, "mil": _2, "edu": _2, "gv": { "$": 2, "succ": { "d": _3 } }, "0e": _3 } }, "ve": { "$": 1, "succ": { "arts": _2, "bib": _2, "co": _2, "com": _2, "e12": _2, "edu": _2, "firm": _2, "gob": _2, "gov": _2, "info": _2, "int": _2, "mil": _2, "net": _2, "nom": _2, "org": _2, "rar": _2, "rec": _2, "store": _2, "tec": _2, "web": _2 } }, "vg": { "$": 1, "succ": { "at": _3 } }, "vi": { "$": 1, "succ": { "co": _2, "com": _2, "k12": _2, "net": _2, "org": _2 } }, "vn": { "$": 1, "succ": { "com": _2, "net": _2, "org": _2, "edu": _2, "gov": _2, "int": _2, "ac": _2, "biz": _2, "info": _2, "name": _2, "pro": _2, "health": _2, "blogspot": _3 } }, "vu": { "$": 1, "succ": { "com": _2, "edu": _2, "net": _2, "org": _2, "cn": _3, "blog": _3, "dev": _3, "me": _3 } }, "wf": { "$": 1, "succ": { "biz": _3, "sch": _3 } }, "ws": { "$": 1, "succ": { "com": _2, "net": _2, "org": _2, "gov": _2, "edu": _2, "advisor": _5, "cloud66": _3, "dyndns": _3, "mypets": _3 } }, "yt": { "$": 1, "succ": { "org": _3 } }, "xn--mgbaam7a8h": _2, "امارات": _2, "xn--y9a3aq": _2, "հայ": _2, "xn--54b7fta0cc": _2, "বাংলা": _2, "xn--90ae": _2, "бг": _2, "xn--mgbcpq6gpa1a": _2, "البحرين": _2, "xn--90ais": _2, "бел": _2, "xn--fiqs8s": _2, "中国": _2, "xn--fiqz9s": _2, "中國": _2, "xn--lgbbat1ad8j": _2, "الجزائر": _2, "xn--wgbh1c": _2, "مصر": _2, "xn--e1a4c": _2, "ею": _2, "xn--qxa6a": _2, "ευ": _2, "xn--mgbah1a3hjkrd": _2, "موريتانيا": _2, "xn--node": _2, "გე": _2, "xn--qxam": _2, "ελ": _2, "xn--j6w193g": { "$": 1, "succ": { "xn--55qx5d": _2, "xn--wcvs22d": _2, "xn--mxtq1m": _2, "xn--gmqw5a": _2, "xn--od0alg": _2, "xn--uc0atv": _2 } }, "香港": { "$": 1, "succ": { "公司": _2, "教育": _2, "政府": _2, "個人": _2, "網絡": _2, "組織": _2 } }, "xn--2scrj9c": _2, "ಭಾರತ": _2, "xn--3hcrj9c": _2, "ଭାରତ": _2, "xn--45br5cyl": _2, "ভাৰত": _2, "xn--h2breg3eve": _2, "भारतम्": _2, "xn--h2brj9c8c": _2, "भारोत": _2, "xn--mgbgu82a": _2, "ڀارت": _2, "xn--rvc1e0am3e": _2, "ഭാരതം": _2, "xn--h2brj9c": _2, "भारत": _2, "xn--mgbbh1a": _2, "بارت": _2, "xn--mgbbh1a71e": _2, "بھارت": _2, "xn--fpcrj9c3d": _2, "భారత్": _2, "xn--gecrj9c": _2, "ભારત": _2, "xn--s9brj9c": _2, "ਭਾਰਤ": _2, "xn--45brj9c": _2, "ভারত": _2, "xn--xkc2dl3a5ee0h": _2, "இந்தியா": _2, "xn--mgba3a4f16a": _2, "ایران": _2, "xn--mgba3a4fra": _2, "ايران": _2, "xn--mgbtx2b": _2, "عراق": _2, "xn--mgbayh7gpa": _2, "الاردن": _2, "xn--3e0b707e": _2, "한국": _2, "xn--80ao21a": _2, "қаз": _2, "xn--q7ce6a": _2, "ລາວ": _2, "xn--fzc2c9e2c": _2, "ලංකා": _2, "xn--xkc2al3hye2a": _2, "இலங்கை": _2, "xn--mgbc0a9azcg": _2, "المغرب": _2, "xn--d1alf": _2, "мкд": _2, "xn--l1acc": _2, "мон": _2, "xn--mix891f": _2, "澳門": _2, "xn--mix082f": _2, "澳门": _2, "xn--mgbx4cd0ab": _2, "مليسيا": _2, "xn--mgb9awbf": _2, "عمان": _2, "xn--mgbai9azgqp6j": _2, "پاکستان": _2, "xn--mgbai9a5eva00b": _2, "پاكستان": _2, "xn--ygbi2ammx": _2, "فلسطين": _2, "xn--90a3ac": { "$": 1, "succ": { "xn--o1ac": _2, "xn--c1avg": _2, "xn--90azh": _2, "xn--d1at": _2, "xn--o1ach": _2, "xn--80au": _2 } }, "срб": { "$": 1, "succ": { "пр": _2, "орг": _2, "обр": _2, "од": _2, "упр": _2, "ак": _2 } }, "xn--p1ai": _2, "рф": _2, "xn--wgbl6a": _2, "قطر": _2, "xn--mgberp4a5d4ar": _2, "السعودية": _2, "xn--mgberp4a5d4a87g": _2, "السعودیة": _2, "xn--mgbqly7c0a67fbc": _2, "السعودیۃ": _2, "xn--mgbqly7cvafr": _2, "السعوديه": _2, "xn--mgbpl2fh": _2, "سودان": _2, "xn--yfro4i67o": _2, "新加坡": _2, "xn--clchc0ea0b2g2a9gcd": _2, "சிங்கப்பூர்": _2, "xn--ogbpf8fl": _2, "سورية": _2, "xn--mgbtf8fl": _2, "سوريا": _2, "xn--o3cw4h": { "$": 1, "succ": { "xn--12c1fe0br": _2, "xn--12co0c3b4eva": _2, "xn--h3cuzk1di": _2, "xn--o3cyx2a": _2, "xn--m3ch0j3a": _2, "xn--12cfi8ixb8l": _2 } }, "ไทย": { "$": 1, "succ": { "ศึกษา": _2, "ธุรกิจ": _2, "รัฐบาล": _2, "ทหาร": _2, "เน็ต": _2, "องค์กร": _2 } }, "xn--pgbs0dh": _2, "تونس": _2, "xn--kpry57d": _2, "台灣": _2, "xn--kprw13d": _2, "台湾": _2, "xn--nnx388a": _2, "臺灣": _2, "xn--j1amh": _2, "укр": _2, "xn--mgb2ddes": _2, "اليمن": _2, "xxx": _2, "ye": _32, "za": { "$": 0, "succ": { "ac": _2, "agric": _2, "alt": _2, "co": _6, "edu": _2, "gov": _2, "grondar": _2, "law": _2, "mil": _2, "net": _2, "ngo": _2, "nic": _2, "nis": _2, "nom": _2, "org": _2, "school": _2, "tm": _2, "web": _2 } }, "zm": { "$": 1, "succ": { "ac": _2, "biz": _2, "co": _2, "com": _2, "edu": _2, "gov": _2, "info": _2, "mil": _2, "net": _2, "org": _2, "sch": _2 } }, "zw": { "$": 1, "succ": { "ac": _2, "co": _2, "gov": _2, "mil": _2, "org": _2 } }, "aaa": _2, "aarp": _2, "abarth": _2, "abb": _2, "abbott": _2, "abbvie": _2, "abc": _2, "able": _2, "abogado": _2, "abudhabi": _2, "academy": { "$": 1, "succ": { "official": _3 } }, "accenture": _2, "accountant": _2, "accountants": _2, "aco": _2, "actor": _2, "ads": _2, "adult": _2, "aeg": _2, "aetna": _2, "afl": _2, "africa": _2, "agakhan": _2, "agency": _2, "aig": _2, "airbus": _2, "airforce": _2, "airtel": _2, "akdn": _2, "alfaromeo": _2, "alibaba": _2, "alipay": _2, "allfinanz": _2, "allstate": _2, "ally": _2, "alsace": _2, "alstom": _2, "amazon": _2, "americanexpress": _2, "americanfamily": _2, "amex": _2, "amfam": _2, "amica": _2, "amsterdam": _2, "analytics": _2, "android": _2, "anquan": _2, "anz": _2, "aol": _2, "apartments": _2, "app": { "$": 1, "succ": { "beget": _5, "clerk": _3, "clerkstage": _3, "wnext": _3, "platform0": _3, "deta": _3, "ondigitalocean": _3, "easypanel": _3, "encr": _3, "edgecompute": _3, "fireweb": _3, "onflashdrive": _3, "framer": _3, "run": { "$": 2, "succ": { "a": _3 } }, "web": _3, "hasura": _3, "loginline": _3, "messerli": _3, "netlify": _3, "ngrok": _3, "ngrok-free": _3, "developer": _5, "noop": _3, "northflank": _5, "snowflake": { "$": 2, "succ": { "privatelink": _3 } }, "streamlit": _3, "telebit": _3, "typedream": _3, "vercel": _3, "bookonline": _3 } }, "apple": _2, "aquarelle": _2, "arab": _2, "aramco": _2, "archi": _2, "army": _2, "art": _2, "arte": _2, "asda": _2, "associates": _2, "athleta": _2, "attorney": _2, "auction": _2, "audi": _2, "audible": _2, "audio": _2, "auspost": _2, "author": _2, "auto": _2, "autos": _2, "avianca": _2, "aws": _2, "axa": _2, "azure": _2, "baby": _2, "baidu": _2, "banamex": _2, "bananarepublic": _2, "band": _2, "bank": _2, "bar": _2, "barcelona": _2, "barclaycard": _2, "barclays": _2, "barefoot": _2, "bargains": _2, "baseball": _2, "basketball": { "$": 1, "succ": { "aus": _3, "nz": _3 } }, "bauhaus": _2, "bayern": _2, "bbc": _2, "bbt": _2, "bbva": _2, "bcg": _2, "bcn": _2, "beats": _2, "beauty": _2, "beer": _2, "bentley": _2, "berlin": _2, "best": _2, "bestbuy": _2, "bet": _2, "bharti": _2, "bible": _2, "bid": _2, "bike": _2, "bing": _2, "bingo": _2, "bio": _2, "black": _2, "blackfriday": _2, "blockbuster": _2, "blog": _2, "bloomberg": _2, "blue": _2, "bms": _2, "bmw": _2, "bnpparibas": _2, "boats": _2, "boehringer": _2, "bofa": _2, "bom": _2, "bond": _2, "boo": _2, "book": _2, "booking": _2, "bosch": _2, "bostik": _2, "boston": _2, "bot": _2, "boutique": _2, "box": _2, "bradesco": _2, "bridgestone": _2, "broadway": _2, "broker": _2, "brother": _2, "brussels": _2, "build": _2, "builders": { "$": 1, "succ": { "cloudsite": _3 } }, "business": _10, "buy": _2, "buzz": _2, "bzh": _2, "cab": _2, "cafe": _2, "cal": _2, "call": _2, "calvinklein": _2, "cam": _2, "camera": _2, "camp": _2, "canon": _2, "capetown": _2, "capital": _2, "capitalone": _2, "car": _2, "caravan": _2, "cards": _2, "care": _2, "career": _2, "careers": _2, "cars": _2, "casa": { "$": 1, "succ": { "nabu": { "$": 0, "succ": { "ui": _3 } } } }, "case": _2, "cash": _2, "casino": _2, "catering": _2, "catholic": _2, "cba": _2, "cbn": _2, "cbre": _2, "cbs": _2, "center": _2, "ceo": _2, "cern": _2, "cfa": _2, "cfd": _2, "chanel": _2, "channel": _2, "charity": _2, "chase": _2, "chat": _2, "cheap": _2, "chintai": _2, "christmas": _2, "chrome": _2, "church": _2, "cipriani": _2, "circle": _2, "cisco": _2, "citadel": _2, "citi": _2, "citic": _2, "city": _2, "cityeats": _2, "claims": _2, "cleaning": _2, "click": _2, "clinic": _2, "clinique": _2, "clothing": _2, "cloud": { "$": 1, "succ": { "banzai": _5, "elementor": _3, "encoway": { "$": 0, "succ": { "eu": _3 } }, "statics": _5, "ravendb": _3, "axarnet": { "$": 0, "succ": { "es-1": _3 } }, "diadem": _3, "jelastic": { "$": 0, "succ": { "vip": _3 } }, "jele": _3, "jenv-aruba": { "$": 0, "succ": { "aruba": { "$": 0, "succ": { "eur": { "$": 0, "succ": { "it1": _3 } } } }, "it1": _3 } }, "keliweb": { "$": 2, "succ": { "cs": _3 } }, "oxa": { "$": 2, "succ": { "tn": _3, "uk": _3 } }, "primetel": { "$": 2, "succ": { "uk": _3 } }, "reclaim": { "$": 0, "succ": { "ca": _3, "uk": _3, "us": _3 } }, "trendhosting": { "$": 0, "succ": { "ch": _3, "de": _3 } }, "jotelulu": _3, "kuleuven": _3, "linkyard": _3, "magentosite": _5, "perspecta": _3, "vapor": _3, "on-rancher": _5, "scw": { "$": 0, "succ": { "baremetal": { "$": 0, "succ": { "fr-par-1": _3, "fr-par-2": _3, "nl-ams-1": _3 } }, "fr-par": { "$": 0, "succ": { "fnc": { "$": 2, "succ": { "functions": _3 } }, "k8s": _11, "s3": _3, "s3-website": _3, "whm": _3 } }, "instances": { "$": 0, "succ": { "priv": _3, "pub": _3 } }, "k8s": _3, "nl-ams": { "$": 0, "succ": { "k8s": _11, "s3": _3, "s3-website": _3, "whm": _3 } }, "pl-waw": { "$": 0, "succ": { "k8s": _11, "s3": _3, "s3-website": _3 } }, "scalebook": _3, "smartlabeling": _3 } }, "sensiosite": _5, "trafficplex": _3, "urown": _3, "voorloper": _3 } }, "club": { "$": 1, "succ": { "cloudns": _3, "jele": _3, "barsy": _3 } }, "clubmed": _2, "coach": _2, "codes": { "$": 1, "succ": { "owo": _5 } }, "coffee": _2, "college": _2, "cologne": _2, "comcast": _2, "commbank": _2, "community": { "$": 1, "succ": { "nog": _3, "ravendb": _3, "myforum": _3 } }, "company": _2, "compare": _2, "computer": _2, "comsec": _2, "condos": _2, "construction": _2, "consulting": _2, "contact": _2, "contractors": _2, "cooking": _2, "cookingchannel": _2, "cool": { "$": 1, "succ": { "elementor": _3, "de": _3 } }, "corsica": _2, "country": _2, "coupon": _2, "coupons": _2, "courses": _2, "cpa": _2, "credit": _2, "creditcard": _2, "creditunion": _2, "cricket": _2, "crown": _2, "crs": _2, "cruise": _2, "cruises": _2, "cuisinella": _2, "cymru": _2, "cyou": _2, "dabur": _2, "dad": _2, "dance": _2, "data": _2, "date": _2, "dating": _2, "datsun": _2, "day": _2, "dclk": _2, "dds": _2, "deal": _2, "dealer": _2, "deals": _2, "degree": _2, "delivery": _2, "dell": _2, "deloitte": _2, "delta": _2, "democrat": _2, "dental": _2, "dentist": _2, "desi": _2, "design": { "$": 1, "succ": { "bss": _3 } }, "dev": { "$": 1, "succ": { "autocode": _3, "lcl": _5, "lclstage": _5, "stg": _5, "stgstage": _5, "pages": _3, "r2": _3, "workers": _3, "curv": _3, "deno": _3, "deno-staging": _3, "deta": _3, "fly": _3, "githubpreview": _3, "gateway": _5, "iserv": _3, "localcert": { "$": 0, "succ": { "user": _5 } }, "loginline": _3, "mediatech": _3, "ngrok": _3, "ngrok-free": _3, "platter-app": _3, "shiftcrypto": _3, "vercel": _3, "webhare": _5 } }, "dhl": _2, "diamonds": _2, "diet": _2, "digital": { "$": 1, "succ": { "cloudapps": { "$": 2, "succ": { "london": _3 } } } }, "direct": _2, "directory": _2, "discount": _2, "discover": _2, "dish": _2, "diy": _2, "dnp": _2, "docs": _2, "doctor": _2, "dog": _2, "domains": _2, "dot": _2, "download": _2, "drive": _2, "dtv": _2, "dubai": _2, "dunlop": _2, "dupont": _2, "durban": _2, "dvag": _2, "dvr": _2, "earth": { "$": 1, "succ": { "dapps": { "$": 0, "succ": { "*": _3, "bzz": _5 } } } }, "eat": _2, "eco": _2, "edeka": _2, "education": _10, "email": _2, "emerck": _2, "energy": _2, "engineer": _2, "engineering": _2, "enterprises": _2, "epson": _2, "equipment": _2, "ericsson": _2, "erni": _2, "esq": _2, "estate": { "$": 1, "succ": { "compute": _5 } }, "etisalat": _2, "eurovision": _2, "eus": { "$": 1, "succ": { "party": _28 } }, "events": { "$": 1, "succ": { "koobin": _3, "co": _3 } }, "exchange": _2, "expert": _2, "exposed": _2, "express": _2, "extraspace": _2, "fage": _2, "fail": _2, "fairwinds": _2, "faith": _29, "family": _2, "fan": _2, "fans": _2, "farm": { "$": 1, "succ": { "storj": _3 } }, "farmers": _2, "fashion": _2, "fast": _2, "fedex": _2, "feedback": _2, "ferrari": _2, "ferrero": _2, "fiat": _2, "fidelity": _2, "fido": _2, "film": _2, "final": _2, "finance": _2, "financial": _10, "fire": _2, "firestone": _2, "firmdale": _2, "fish": _2, "fishing": _2, "fit": _2, "fitness": _2, "flickr": _2, "flights": _2, "flir": _2, "florist": _2, "flowers": _2, "fly": _2, "foo": _2, "food": _2, "foodnetwork": _2, "football": _2, "ford": _2, "forex": _2, "forsale": _2, "forum": _2, "foundation": _2, "fox": _2, "free": _2, "fresenius": _2, "frl": _2, "frogans": _2, "frontdoor": _2, "frontier": _2, "ftr": _2, "fujitsu": _2, "fun": _2, "fund": _2, "furniture": _2, "futbol": _2, "fyi": _2, "gal": _2, "gallery": _2, "gallo": _2, "gallup": _2, "game": _2, "games": _2, "gap": _2, "garden": _2, "gay": _2, "gbiz": _2, "gdn": { "$": 1, "succ": { "cnpy": _3 } }, "gea": _2, "gent": _2, "genting": _2, "george": _2, "ggee": _2, "gift": _2, "gifts": _2, "gives": _2, "giving": _2, "glass": _2, "gle": _2, "global": _2, "globo": _2, "gmail": _2, "gmbh": _2, "gmo": _2, "gmx": _2, "godaddy": _2, "gold": _2, "goldpoint": _2, "golf": _2, "goo": _2, "goodyear": _2, "goog": { "$": 1, "succ": { "cloud": _3, "translate": _3, "usercontent": _5 } }, "google": _2, "gop": _2, "got": _2, "grainger": _2, "graphics": _2, "gratis": _2, "green": _2, "gripe": _2, "grocery": _2, "group": { "$": 1, "succ": { "discourse": _3 } }, "guardian": _2, "gucci": _2, "guge": _2, "guide": _2, "guitars": _2, "guru": _2, "hair": _2, "hamburg": _2, "hangout": _2, "haus": _2, "hbo": _2, "hdfc": _2, "hdfcbank": _2, "health": { "$": 1, "succ": { "hra": _3 } }, "healthcare": _2, "help": _2, "helsinki": _2, "here": _2, "hermes": _2, "hgtv": _2, "hiphop": _2, "hisamitsu": _2, "hitachi": _2, "hiv": _2, "hkt": _2, "hockey": _2, "holdings": _2, "holiday": _2, "homedepot": _2, "homegoods": _2, "homes": _2, "homesense": _2, "honda": _2, "horse": _2, "hospital": _2, "host": { "$": 1, "succ": { "cloudaccess": _3, "freesite": _3, "easypanel": _3, "fastvps": _3, "myfast": _3, "tempurl": _3, "wpmudev": _3, "jele": _3, "mircloud": _3, "pcloud": _3, "half": _3 } }, "hosting": { "$": 1, "succ": { "opencraft": _3 } }, "hot": _2, "hoteles": _2, "hotels": _2, "hotmail": _2, "house": _2, "how": _2, "hsbc": _2, "hughes": _2, "hyatt": _2, "hyundai": _2, "ibm": _2, "icbc": _2, "ice": _2, "icu": _2, "ieee": _2, "ifm": _2, "ikano": _2, "imamat": _2, "imdb": _2, "immo": _2, "immobilien": _2, "inc": _2, "industries": _2, "infiniti": _2, "ing": _2, "ink": _2, "institute": _2, "insurance": _2, "insure": _2, "international": _2, "intuit": _2, "investments": _2, "ipiranga": _2, "irish": _2, "ismaili": _2, "ist": _2, "istanbul": _2, "itau": _2, "itv": _2, "jaguar": _2, "java": _2, "jcb": _2, "jeep": _2, "jetzt": _2, "jewelry": _2, "jio": _2, "jll": _2, "jmp": _2, "jnj": _2, "joburg": _2, "jot": _2, "joy": _2, "jpmorgan": _2, "jprs": _2, "juegos": _2, "juniper": _2, "kaufen": _2, "kddi": _2, "kerryhotels": _2, "kerrylogistics": _2, "kerryproperties": _2, "kfh": _2, "kia": _2, "kids": _2, "kim": _2, "kinder": _2, "kindle": _2, "kitchen": _2, "kiwi": _2, "koeln": _2, "komatsu": _2, "kosher": _2, "kpmg": _2, "kpn": _2, "krd": { "$": 1, "succ": { "co": _3, "edu": _3 } }, "kred": _2, "kuokgroup": _2, "kyoto": _2, "lacaixa": _2, "lamborghini": _2, "lamer": _2, "lancaster": _2, "lancia": _2, "land": { "$": 1, "succ": { "static": { "$": 2, "succ": { "dev": _3, "sites": _3 } } } }, "landrover": _2, "lanxess": _2, "lasalle": _2, "lat": _2, "latino": _2, "latrobe": _2, "law": _2, "lawyer": _2, "lds": _2, "lease": _2, "leclerc": _2, "lefrak": _2, "legal": _2, "lego": _2, "lexus": _2, "lgbt": _2, "lidl": _2, "life": _2, "lifeinsurance": _2, "lifestyle": _2, "lighting": _2, "like": _2, "lilly": _2, "limited": _2, "limo": _2, "lincoln": _2, "link": { "$": 1, "succ": { "cyon": _3, "mypep": _3, "dweb": _5 } }, "lipsy": _2, "live": { "$": 1, "succ": { "hlx": _3 } }, "living": _2, "llc": _2, "llp": _2, "loan": _2, "loans": _2, "locker": _2, "locus": _2, "lol": { "$": 1, "succ": { "omg": _3 } }, "london": _2, "lotte": _2, "lotto": _2, "love": _2, "lpl": _2, "lplfinancial": _2, "ltd": _2, "ltda": _2, "lundbeck": _2, "luxe": _2, "luxury": _2, "madrid": _2, "maif": _2, "maison": _2, "makeup": _2, "man": _2, "management": { "$": 1, "succ": { "router": _3 } }, "mango": _2, "map": _2, "market": _2, "marketing": _2, "markets": _2, "marriott": _2, "marshalls": _2, "maserati": _2, "mattel": _2, "mba": _2, "mckinsey": _2, "med": _2, "media": _35, "meet": _2, "melbourne": _2, "meme": _2, "memorial": _2, "men": _2, "menu": _36, "merckmsd": _2, "miami": _2, "microsoft": _2, "mini": _2, "mint": _2, "mit": _2, "mitsubishi": _2, "mlb": _2, "mls": _2, "mma": _2, "mobile": _2, "moda": _2, "moe": _2, "moi": _2, "mom": _2, "monash": _2, "money": _2, "monster": _2, "mormon": _2, "mortgage": _2, "moscow": _2, "moto": _2, "motorcycles": _2, "mov": _2, "movie": _2, "msd": _2, "mtn": _2, "mtr": _2, "music": _2, "mutual": _2, "nab": _2, "nagoya": _2, "natura": _2, "navy": _2, "nba": _2, "nec": _2, "netbank": _2, "netflix": _2, "network": { "$": 1, "succ": { "alces": _5, "co": _3, "arvo": _3, "azimuth": _3, "tlon": _3 } }, "neustar": _2, "new": _2, "news": { "$": 1, "succ": { "noticeable": _3 } }, "next": _2, "nextdirect": _2, "nexus": _2, "nfl": _2, "ngo": _2, "nhk": _2, "nico": _2, "nike": _2, "nikon": _2, "ninja": _2, "nissan": _2, "nissay": _2, "nokia": _2, "northwesternmutual": _2, "norton": _2, "now": _2, "nowruz": _2, "nowtv": _2, "nra": _2, "nrw": _2, "ntt": _2, "nyc": _2, "obi": _2, "observer": _2, "office": _2, "okinawa": _2, "olayan": _2, "olayangroup": _2, "oldnavy": _2, "ollo": _2, "omega": _2, "one": { "$": 1, "succ": { "onred": { "$": 2, "succ": { "staging": _3 } }, "service": _3, "homelink": _3 } }, "ong": _2, "onl": _2, "online": { "$": 1, "succ": { "eero": _3, "eero-stage": _3, "barsy": _3 } }, "ooo": _2, "open": _2, "oracle": _2, "orange": { "$": 1, "succ": { "tech": _3 } }, "organic": _2, "origins": _2, "osaka": _2, "otsuka": _2, "ott": _2, "ovh": { "$": 1, "succ": { "nerdpol": _3 } }, "page": { "$": 1, "succ": { "hlx": _3, "hlx3": _3, "translated": _3, "codeberg": _3, "pdns": _3, "plesk": _3, "prvcy": _3, "rocky": _3, "magnet": _3 } }, "panasonic": _2, "paris": _2, "pars": _2, "partners": _2, "parts": _2, "party": _29, "passagens": _2, "pay": _2, "pccw": _2, "pet": _2, "pfizer": _2, "pharmacy": _2, "phd": _2, "philips": _2, "phone": _2, "photo": _2, "photography": _2, "photos": _35, "physio": _2, "pics": _2, "pictet": _2, "pictures": { "$": 1, "succ": { "1337": _3 } }, "pid": _2, "pin": _2, "ping": _2, "pink": _2, "pioneer": _2, "pizza": { "$": 1, "succ": { "ngrok": _3 } }, "place": _10, "play": _2, "playstation": _2, "plumbing": _2, "plus": _2, "pnc": _2, "pohl": _2, "poker": _2, "politie": _2, "porn": { "$": 1, "succ": { "indie": _3 } }, "pramerica": _2, "praxi": _2, "press": _2, "prime": _2, "prod": _2, "productions": _2, "prof": _2, "progressive": _2, "promo": _2, "properties": _2, "property": _2, "protection": _2, "pru": _2, "prudential": _2, "pub": _36, "pwc": _2, "qpon": _2, "quebec": _2, "quest": _2, "racing": _2, "radio": _2, "read": _2, "realestate": _2, "realtor": _2, "realty": _2, "recipes": _2, "red": _2, "redstone": _2, "redumbrella": _2, "rehab": _2, "reise": _2, "reisen": _2, "reit": _2, "reliance": _2, "ren": _2, "rent": _2, "rentals": _2, "repair": _2, "report": _2, "republican": _2, "rest": _2, "restaurant": _2, "review": _29, "reviews": _2, "rexroth": _2, "rich": _2, "richardli": _2, "ricoh": _2, "ril": _2, "rio": _2, "rip": { "$": 1, "succ": { "clan": _3 } }, "rocher": _2, "rocks": { "$": 1, "succ": { "myddns": _3, "lima-city": _3, "webspace": _3 } }, "rodeo": _2, "rogers": _2, "room": _2, "rsvp": _2, "rugby": _2, "ruhr": _2, "run": { "$": 1, "succ": { "hs": _3, "development": _3, "ravendb": _3, "servers": _3, "build": _5, "code": _5, "database": _5, "migration": _5, "onporter": _3, "repl": _3 } }, "rwe": _2, "ryukyu": _2, "saarland": _2, "safe": _2, "safety": _2, "sakura": _2, "sale": _2, "salon": _2, "samsclub": _2, "samsung": _2, "sandvik": _2, "sandvikcoromant": _2, "sanofi": _2, "sap": _2, "sarl": _2, "sas": _2, "save": _2, "saxo": _2, "sbi": _2, "sbs": _2, "sca": _2, "scb": _2, "schaeffler": _2, "schmidt": _2, "scholarships": _2, "school": _2, "schule": _2, "schwarz": _2, "science": _29, "scot": { "$": 1, "succ": { "edu": _3, "gov": { "$": 2, "succ": { "service": _3 } } } }, "search": _2, "seat": _2, "secure": _2, "security": _2, "seek": _2, "select": _2, "sener": _2, "services": { "$": 1, "succ": { "loginline": _3 } }, "seven": _2, "sew": _2, "sex": _2, "sexy": _2, "sfr": _2, "shangrila": _2, "sharp": _2, "shaw": _2, "shell": _2, "shia": _2, "shiksha": _2, "shoes": _2, "shop": { "$": 1, "succ": { "base": _3, "hoplix": _3, "barsy": _3 } }, "shopping": _2, "shouji": _2, "show": _2, "showtime": _2, "silk": _2, "sina": _2, "singles": _2, "site": { "$": 1, "succ": { "cloudera": _5, "cyon": _3, "fnwk": _3, "folionetwork": _3, "fastvps": _3, "jele": _3, "lelux": _3, "loginline": _3, "barsy": _3, "mintere": _3, "omniwe": _3, "opensocial": _3, "platformsh": _5, "tst": _5, "byen": _3, "srht": _3, "novecore": _3 } }, "ski": _2, "skin": _2, "sky": _2, "skype": _2, "sling": _2, "smart": _2, "smile": _2, "sncf": _2, "soccer": _2, "social": _2, "softbank": _2, "software": _2, "sohu": _2, "solar": _2, "solutions": { "$": 1, "succ": { "diher": _5 } }, "song": _2, "sony": _2, "soy": _2, "spa": _2, "space": { "$": 1, "succ": { "myfast": _3, "uber": _3, "xs4all": _3 } }, "sport": _2, "spot": _2, "srl": _2, "stada": _2, "staples": _2, "star": _2, "statebank": _2, "statefarm": _2, "stc": _2, "stcgroup": _2, "stockholm": _2, "storage": _2, "store": { "$": 1, "succ": { "sellfy": _3, "shopware": _3, "storebase": _3 } }, "stream": _2, "studio": _2, "study": _2, "style": _2, "sucks": _2, "supplies": _2, "supply": _2, "support": _36, "surf": _2, "surgery": _2, "suzuki": _2, "swatch": _2, "swiss": _2, "sydney": _2, "systems": { "$": 1, "succ": { "knightpoint": _3 } }, "tab": _2, "taipei": _2, "talk": _2, "taobao": _2, "target": _2, "tatamotors": _2, "tatar": _2, "tattoo": _2, "tax": _2, "taxi": _2, "tci": _2, "tdk": _2, "team": { "$": 1, "succ": { "discourse": _3, "jelastic": _3 } }, "tech": _2, "technology": _10, "temasek": _2, "tennis": _2, "teva": _2, "thd": _2, "theater": _2, "theatre": _2, "tiaa": _2, "tickets": _2, "tienda": _2, "tiffany": _2, "tips": _2, "tires": _2, "tirol": _2, "tjmaxx": _2, "tjx": _2, "tkmaxx": _2, "tmall": _2, "today": { "$": 1, "succ": { "prequalifyme": _3 } }, "tokyo": _2, "tools": _2, "top": { "$": 1, "succ": { "now-dns": _3, "ntdll": _3 } }, "toray": _2, "toshiba": _2, "total": _2, "tours": _2, "town": _2, "toyota": _2, "toys": _2, "trade": _29, "trading": _2, "training": _2, "travel": _2, "travelchannel": _2, "travelers": _2, "travelersinsurance": _2, "trust": _2, "trv": _2, "tube": _2, "tui": _2, "tunes": _2, "tushu": _2, "tvs": _2, "ubank": _2, "ubs": _2, "unicom": _2, "university": _2, "uno": _2, "uol": _2, "ups": _2, "vacations": _2, "vana": _2, "vanguard": _2, "vegas": _2, "ventures": _2, "verisign": _2, "versicherung": _2, "vet": _2, "viajes": _2, "video": _2, "vig": _2, "viking": _2, "villas": _2, "vin": _2, "vip": _2, "virgin": _2, "visa": _2, "vision": _2, "viva": _2, "vivo": _2, "vlaanderen": _2, "vodka": _2, "volkswagen": _2, "volvo": _2, "vote": _2, "voting": _2, "voto": _2, "voyage": _2, "vuelos": _2, "wales": _2, "walmart": _2, "walter": _2, "wang": _2, "wanggou": _2, "watch": _2, "watches": _2, "weather": _2, "weatherchannel": _2, "webcam": _2, "weber": _2, "website": _35, "wedding": _2, "weibo": _2, "weir": _2, "whoswho": _2, "wien": _2, "wiki": _35, "williamhill": _2, "win": _2, "windows": _2, "wine": _2, "winners": _2, "wme": _2, "wolterskluwer": _2, "woodside": _2, "work": _2, "works": _2, "world": _2, "wow": _2, "wtc": _2, "wtf": _2, "xbox": _2, "xerox": _2, "xfinity": _2, "xihuan": _2, "xin": _2, "xn--11b4c3d": _2, "कॉम": _2, "xn--1ck2e1b": _2, "セール": _2, "xn--1qqw23a": _2, "佛山": _2, "xn--30rr7y": _2, "慈善": _2, "xn--3bst00m": _2, "集团": _2, "xn--3ds443g": _2, "在线": _2, "xn--3pxu8k": _2, "点看": _2, "xn--42c2d9a": _2, "คอม": _2, "xn--45q11c": _2, "八卦": _2, "xn--4gbrim": _2, "موقع": _2, "xn--55qw42g": _2, "公益": _2, "xn--55qx5d": _2, "公司": _2, "xn--5su34j936bgsg": _2, "香格里拉": _2, "xn--5tzm5g": _2, "网站": _2, "xn--6frz82g": _2, "移动": _2, "xn--6qq986b3xl": _2, "我爱你": _2, "xn--80adxhks": _2, "москва": _2, "xn--80aqecdr1a": _2, "католик": _2, "xn--80asehdb": _2, "онлайн": _2, "xn--80aswg": _2, "сайт": _2, "xn--8y0a063a": _2, "联通": _2, "xn--9dbq2a": _2, "קום": _2, "xn--9et52u": _2, "时尚": _2, "xn--9krt00a": _2, "微博": _2, "xn--b4w605ferd": _2, "淡马锡": _2, "xn--bck1b9a5dre4c": _2, "ファッション": _2, "xn--c1avg": _2, "орг": _2, "xn--c2br7g": _2, "नेट": _2, "xn--cck2b3b": _2, "ストア": _2, "xn--cckwcxetd": _2, "アマゾン": _2, "xn--cg4bki": _2, "삼성": _2, "xn--czr694b": _2, "商标": _2, "xn--czrs0t": _2, "商店": _2, "xn--czru2d": _2, "商城": _2, "xn--d1acj3b": _2, "дети": _2, "xn--eckvdtc9d": _2, "ポイント": _2, "xn--efvy88h": _2, "新闻": _2, "xn--fct429k": _2, "家電": _2, "xn--fhbei": _2, "كوم": _2, "xn--fiq228c5hs": _2, "中文网": _2, "xn--fiq64b": _2, "中信": _2, "xn--fjq720a": _2, "娱乐": _2, "xn--flw351e": _2, "谷歌": _2, "xn--fzys8d69uvgm": _2, "電訊盈科": _2, "xn--g2xx48c": _2, "购物": _2, "xn--gckr3f0f": _2, "クラウド": _2, "xn--gk3at1e": _2, "通販": _2, "xn--hxt814e": _2, "网店": _2, "xn--i1b6b1a6a2e": _2, "संगठन": _2, "xn--imr513n": _2, "餐厅": _2, "xn--io0a7i": _2, "网络": _2, "xn--j1aef": _2, "ком": _2, "xn--jlq480n2rg": _2, "亚马逊": _2, "xn--jvr189m": _2, "食品": _2, "xn--kcrx77d1x4a": _2, "飞利浦": _2, "xn--kput3i": _2, "手机": _2, "xn--mgba3a3ejt": _2, "ارامكو": _2, "xn--mgba7c0bbn0a": _2, "العليان": _2, "xn--mgbaakc7dvf": _2, "اتصالات": _2, "xn--mgbab2bd": _2, "بازار": _2, "xn--mgbca7dzdo": _2, "ابوظبي": _2, "xn--mgbi4ecexp": _2, "كاثوليك": _2, "xn--mgbt3dhd": _2, "همراه": _2, "xn--mk1bu44c": _2, "닷컴": _2, "xn--mxtq1m": _2, "政府": _2, "xn--ngbc5azd": _2, "شبكة": _2, "xn--ngbe9e0a": _2, "بيتك": _2, "xn--ngbrx": _2, "عرب": _2, "xn--nqv7f": _2, "机构": _2, "xn--nqv7fs00ema": _2, "组织机构": _2, "xn--nyqy26a": _2, "健康": _2, "xn--otu796d": _2, "招聘": _2, "xn--p1acf": { "$": 1, "succ": { "xn--90amc": _3, "xn--j1aef": _3, "xn--j1ael8b": _3, "xn--h1ahn": _3, "xn--j1adp": _3, "xn--c1avg": _3, "xn--80aaa0cvac": _3, "xn--h1aliz": _3, "xn--90a1af": _3, "xn--41a": _3 } }, "рус": { "$": 1, "succ": { "биз": _3, "ком": _3, "крым": _3, "мир": _3, "мск": _3, "орг": _3, "самара": _3, "сочи": _3, "спб": _3, "я": _3 } }, "xn--pssy2u": _2, "大拿": _2, "xn--q9jyb4c": _2, "みんな": _2, "xn--qcka1pmc": _2, "グーグル": _2, "xn--rhqv96g": _2, "世界": _2, "xn--rovu88b": _2, "書籍": _2, "xn--ses554g": _2, "网址": _2, "xn--t60b56a": _2, "닷넷": _2, "xn--tckwe": _2, "コム": _2, "xn--tiq49xqyj": _2, "天主教": _2, "xn--unup4y": _2, "游戏": _2, "xn--vermgensberater-ctb": _2, "vermögensberater": _2, "xn--vermgensberatung-pwb": _2, "vermögensberatung": _2, "xn--vhquv": _2, "企业": _2, "xn--vuq861b": _2, "信息": _2, "xn--w4r85el8fhu5dnra": _2, "嘉里大酒店": _2, "xn--w4rs40l": _2, "嘉里": _2, "xn--xhq521b": _2, "广东": _2, "xn--zfr164b": _2, "政务": _2, "xyz": { "$": 1, "succ": { "blogsite": _3, "localzone": _3, "crafting": _3, "zapto": _3, "telebit": _5 } }, "yachts": _2, "yahoo": _2, "yamaxun": _2, "yandex": _2, "yodobashi": _2, "yoga": _2, "yokohama": _2, "you": _2, "youtube": _2, "yun": _2, "zappos": _2, "zara": _2, "zero": _2, "zip": _2, "zone": { "$": 1, "succ": { "cloud66": _3, "hs": _3, "triton": _5, "lima": _3 } }, "zuerich": _2 } };
    ;
    return rules;
})();

;// ./node_modules/.pnpm/tldts@5.7.112/node_modules/tldts/dist/es6/src/suffix-trie.js


/**
 * Lookup parts of domain in Trie
 */
function lookupInTrie(parts, trie, index, allowedMask) {
    let result = null;
    let node = trie;
    while (node !== undefined) {
        // We have a match!
        if ((node.$ & allowedMask) !== 0) {
            result = {
                index: index + 1,
                isIcann: node.$ === 1 /* RULE_TYPE.ICANN */,
                isPrivate: node.$ === 2 /* RULE_TYPE.PRIVATE */,
            };
        }
        // No more `parts` to look for
        if (index === -1) {
            break;
        }
        const succ = node.succ;
        node = succ && (succ[parts[index]] || succ['*']);
        index -= 1;
    }
    return result;
}
/**
 * Check if `hostname` has a valid public suffix in `trie`.
 */
function suffix_trie_suffixLookup(hostname, options, out) {
    if (fast_path(hostname, options, out) === true) {
        return;
    }
    const hostnameParts = hostname.split('.');
    const allowedMask = (options.allowPrivateDomains === true ? 2 /* RULE_TYPE.PRIVATE */ : 0) |
        (options.allowIcannDomains === true ? 1 /* RULE_TYPE.ICANN */ : 0);
    // Look for exceptions
    const exceptionMatch = lookupInTrie(hostnameParts, exceptions, hostnameParts.length - 1, allowedMask);
    if (exceptionMatch !== null) {
        out.isIcann = exceptionMatch.isIcann;
        out.isPrivate = exceptionMatch.isPrivate;
        out.publicSuffix = hostnameParts.slice(exceptionMatch.index + 1).join('.');
        return;
    }
    // Look for a match in rules
    const rulesMatch = lookupInTrie(hostnameParts, rules, hostnameParts.length - 1, allowedMask);
    if (rulesMatch !== null) {
        out.isIcann = rulesMatch.isIcann;
        out.isPrivate = rulesMatch.isPrivate;
        out.publicSuffix = hostnameParts.slice(rulesMatch.index).join('.');
        return;
    }
    // No match found...
    // Prevailing rule is '*' so we consider the top-level domain to be the
    // public suffix of `hostname` (e.g.: 'example.org' => 'org').
    out.isIcann = false;
    out.isPrivate = false;
    out.publicSuffix = hostnameParts[hostnameParts.length - 1];
}

;// ./node_modules/.pnpm/tldts@5.7.112/node_modules/tldts/dist/es6/index.js


// For all methods but 'parse', it does not make sense to allocate an object
// every single time to only return the value of a specific attribute. To avoid
// this un-necessary allocation, we use a global object which is re-used.
const RESULT = getEmptyResult();
function parse(url, options = {}) {
    return factory_parseImpl(url, 5 /* FLAG.ALL */, suffix_trie_suffixLookup, options, getEmptyResult());
}
function getHostname(url, options = {}) {
    /*@__INLINE__*/ factory_resetResult(RESULT);
    return factory_parseImpl(url, 0 /* FLAG.HOSTNAME */, suffix_trie_suffixLookup, options, RESULT).hostname;
}
function getPublicSuffix(url, options = {}) {
    /*@__INLINE__*/ factory_resetResult(RESULT);
    return factory_parseImpl(url, 2 /* FLAG.PUBLIC_SUFFIX */, suffix_trie_suffixLookup, options, RESULT)
        .publicSuffix;
}
function es6_getDomain(url, options = {}) {
    /*@__INLINE__*/ factory_resetResult(RESULT);
    return factory_parseImpl(url, 3 /* FLAG.DOMAIN */, suffix_trie_suffixLookup, options, RESULT).domain;
}
function es6_getSubdomain(url, options = {}) {
    /*@__INLINE__*/ resetResult(RESULT);
    return parseImpl(url, 4 /* FLAG.SUB_DOMAIN */, suffixLookup, options, RESULT)
        .subdomain;
}
function es6_getDomainWithoutSuffix(url, options = {}) {
    /*@__INLINE__*/ resetResult(RESULT);
    return parseImpl(url, 5 /* FLAG.ALL */, suffixLookup, options, RESULT)
        .domainWithoutSuffix;
}


/***/ }),

/***/ 10434:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   H: () => (/* binding */ AbpSnippetInjectionBodyCommon)
/* harmony export */ });
/*
 * AGTree v3.1.3 (build date: Tue, 29 Apr 2025 12:25:03 GMT)
 * (c) 2025 Adguard Software Ltd.
 * Released under the MIT license
 * https://github.com/AdguardTeam/tsurlfilter/tree/master/packages/agtree#readme
 */
/**
 * Common class for the ABP snippet injection body.
 * This class contains shared constants and utilities for handling ABP snippet injection bodies.
 */
class AbpSnippetInjectionBodyCommon {
    /**
     * Error messages used by the parser and generator.
     */
    static ERROR_MESSAGES = {
        /**
         * Error message indicating that an ABP snippet call is empty.
         */
        EMPTY_SCRIPTLET_CALL: 'Empty ABP snippet call',
    };
}




/***/ }),

/***/ 38303:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   w: () => (/* binding */ getAdblockSyntax)
/* harmony export */ });
/* harmony import */ var _utils_adblockers_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(73734);
/*
 * AGTree v3.1.3 (build date: Tue, 29 Apr 2025 12:25:03 GMT)
 * (c) 2025 Adguard Software Ltd.
 * Released under the MIT license
 * https://github.com/AdguardTeam/tsurlfilter/tree/master/packages/agtree#readme
 */


/**
 * Possible AdGuard agent markers.
 */
const ADG_NAME_MARKERS = new Set([
    'adguard',
    'adg',
]);
/**
 * Possible uBlock Origin agent markers.
 */
const UBO_NAME_MARKERS = new Set([
    'ublock',
    'ublock origin',
    'ubo',
]);
/**
 * Possible Adblock Plus agent markers.
 */
const ABP_NAME_MARKERS = new Set([
    'adblock',
    'adblock plus',
    'adblockplus',
    'abp',
]);
/**
 * Returns the adblock syntax based on the adblock name parsed from the agent type comment.
 * Needed for modifiers validation of network rules by AGLint.
 *
 * @param name Adblock name.
 *
 * @returns Adblock syntax.
 */
const getAdblockSyntax = (name) => {
    let syntax = _utils_adblockers_js__WEBPACK_IMPORTED_MODULE_0__/* .AdblockSyntax */ .Y.Common;
    const lowerCaseName = name.toLowerCase();
    if (ADG_NAME_MARKERS.has(lowerCaseName)) {
        syntax = _utils_adblockers_js__WEBPACK_IMPORTED_MODULE_0__/* .AdblockSyntax */ .Y.Adg;
    }
    else if (UBO_NAME_MARKERS.has(lowerCaseName)) {
        syntax = _utils_adblockers_js__WEBPACK_IMPORTED_MODULE_0__/* .AdblockSyntax */ .Y.Ubo;
    }
    else if (ABP_NAME_MARKERS.has(lowerCaseName)) {
        syntax = _utils_adblockers_js__WEBPACK_IMPORTED_MODULE_0__/* .AdblockSyntax */ .Y.Abp;
    }
    return syntax;
};




/***/ }),

/***/ 5596:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   S: () => (/* binding */ UboPseudoName)
/* harmony export */ });
/*
 * AGTree v3.1.3 (build date: Tue, 29 Apr 2025 12:25:03 GMT)
 * (c) 2025 Adguard Software Ltd.
 * Released under the MIT license
 * https://github.com/AdguardTeam/tsurlfilter/tree/master/packages/agtree#readme
 */
/**
 * Known uBO-specific pseudo-class names.
 */
const UboPseudoName = {
    MatchesMedia: 'matches-media',
    MatchesPath: 'matches-path',
    Remove: 'remove',
    Style: 'style',
};




/***/ }),

/***/ 60003:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   PY: () => (/* binding */ ABP_EXT_CSS_PREFIX),
/* harmony export */   Ss: () => (/* binding */ EXT_CSS_PSEUDO_CLASSES),
/* harmony export */   at: () => (/* binding */ LEGACY_EXT_CSS_ATTRIBUTE_PREFIX),
/* harmony export */   ig: () => (/* binding */ EXT_CSS_PSEUDO_CLASSES_STRICT)
/* harmony export */ });
/* unused harmony exports EXT_CSS_LEGACY_ATTRIBUTES, FORBIDDEN_CSS_FUNCTIONS */
/*
 * AGTree v3.1.3 (build date: Tue, 29 Apr 2025 12:25:03 GMT)
 * (c) 2025 Adguard Software Ltd.
 * Released under the MIT license
 * https://github.com/AdguardTeam/tsurlfilter/tree/master/packages/agtree#readme
 */
/**
 * @file Known CSS elements and attributes.
 * TODO: Implement a compatibility table for Extended CSS
 */
/**
 * Legacy Extended CSS attribute prefix.
 *
 * @example
 * ```css
 * [-ext-<name>=...]
 * ```
 */
const LEGACY_EXT_CSS_ATTRIBUTE_PREFIX = '-ext-';
/**
 * ABP Extended CSS prefix.
 *
 * @example
 * ```css
 * [-abp-<name>=...]
 * -abp-<name>(...)
 * ```
 */
const ABP_EXT_CSS_PREFIX = '-abp';
/**
 * Known _strict_ Extended CSS pseudo-classes. Please, keep this list sorted.
 * Strict means that these pseudo-classes are not supported by any browser natively,
 * and they always require Extended CSS libraries to work.
 */
const EXT_CSS_PSEUDO_CLASSES_STRICT = new Set([
    // AdGuard
    // https://github.com/AdguardTeam/ExtendedCss
    'contains',
    'if-not',
    'matches-attr',
    'matches-css',
    'matches-property',
    'nth-ancestor',
    'remove',
    'upward',
    'xpath',
    // uBlock Origin
    // https://github.com/gorhill/uBlock/wiki/Static-filter-syntax#procedural-cosmetic-filters
    'has-text',
    'matches-css-after',
    'matches-css-before',
    'matches-path',
    'min-text-length',
    'watch-attr',
    // Adblock Plus
    // https://help.eyeo.com/adblockplus/how-to-write-filters#elemhide-emulation
    '-abp-contains',
    '-abp-has',
    '-abp-properties',
]);
/**
 * _ALL_ known Extended CSS pseudo-classes. Please, keep this list sorted.
 * It includes strict pseudo-classes and additional pseudo-classes that may be
 * supported by some browsers natively.
 */
const EXT_CSS_PSEUDO_CLASSES = new Set([
    ...EXT_CSS_PSEUDO_CLASSES_STRICT,
    /**
     * https://developer.mozilla.org/en-US/docs/Web/CSS/:has
     */
    'has',
    /**
     * https://developer.mozilla.org/en-US/docs/Web/CSS/:is
     */
    'is',
]);
/**
 * Known legacy Extended CSS attributes. These attributes are deprecated and
 * should be replaced with the corresponding pseudo-classes. In a long term,
 * these attributes will be COMPLETELY removed from the Extended CSS syntax.
 *
 * Please, keep this list sorted.
 */
const EXT_CSS_LEGACY_ATTRIBUTES = new Set([
    // AdGuard
    '-ext-contains',
    '-ext-has',
    '-ext-if-not',
    '-ext-is',
    '-ext-matches-attr',
    '-ext-matches-css',
    '-ext-matches-property',
    '-ext-nth-ancestor',
    '-ext-remove',
    '-ext-upward',
    '-ext-xpath',
    // uBlock Origin
    '-ext-has-text',
    '-ext-matches-css-after',
    '-ext-matches-css-before',
    '-ext-matches-path',
    '-ext-min-text-length',
    '-ext-watch-attr',
    // Adblock Plus
    '-ext-abp-contains',
    '-ext-abp-has',
    '-ext-abp-properties',
]);
/**
 * Known CSS functions that aren't allowed in CSS injection rules, because they
 * able to load external resources. Please, keep this list sorted.
 */
const FORBIDDEN_CSS_FUNCTIONS = new Set([
    // https://developer.mozilla.org/en-US/docs/Web/CSS/cross-fade
    '-webkit-cross-fade',
    'cross-fade',
    // https://developer.mozilla.org/en-US/docs/Web/CSS/image
    'image',
    // https://developer.mozilla.org/en-US/docs/Web/CSS/image-set
    '-webkit-image-set',
    'image-set',
    // https://developer.mozilla.org/en-US/docs/Web/CSS/url
    'url',
]);




/***/ }),

/***/ 49415:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  b: () => (/* binding */ RuleConverter)
});

// EXTERNAL MODULE: ./node_modules/.pnpm/@adguard+agtree@3.1.3/node_modules/@adguard/agtree/dist/nodes/index.js
var nodes = __webpack_require__(91354);
// EXTERNAL MODULE: ./node_modules/.pnpm/@adguard+agtree@3.1.3/node_modules/@adguard/agtree/dist/utils/constants.js
var constants = __webpack_require__(27895);
// EXTERNAL MODULE: ./node_modules/.pnpm/@adguard+agtree@3.1.3/node_modules/@adguard/agtree/dist/errors/not-implemented-error.js
var not_implemented_error = __webpack_require__(74173);
;// ./node_modules/.pnpm/@adguard+agtree@3.1.3/node_modules/@adguard/agtree/dist/converter/base-interfaces/base-converter.js
/*
 * AGTree v3.1.3 (build date: Tue, 29 Apr 2025 12:25:03 GMT)
 * (c) 2025 Adguard Software Ltd.
 * Released under the MIT license
 * https://github.com/AdguardTeam/tsurlfilter/tree/master/packages/agtree#readme
 */


/**
 * @file Base class for converters
 *
 * TS doesn't support abstract static methods, so we should use
 * a workaround and extend this class instead of implementing it
 */
/* eslint-disable jsdoc/require-returns-check */
/* eslint-disable @typescript-eslint/no-unused-vars */
/**
 * Basic class for rule converters
 */
class BaseConverter {
    /**
     * Converts some data to AdGuard format
     *
     * @param data Data to convert
     * @returns An object which follows the {@link ConversionResult} interface. Its `result` property contains
     * the converted node, and its `isConverted` flag indicates whether the original node was converted.
     * If the node was not converted, the result will contain the original node with the same object reference
     * @throws If the data is invalid or incompatible
     */
    static convertToAdg(data) {
        throw new not_implemented_error/* NotImplementedError */.E();
    }
    /**
     * Converts some data to Adblock Plus format
     *
     * @param data Data to convert
     * @returns An object which follows the {@link ConversionResult} interface. Its `result` property contains
     * the converted node, and its `isConverted` flag indicates whether the original node was converted.
     * If the node was not converted, the result will contain the original node with the same object reference
     * @throws If the data is invalid or incompatible
     */
    static convertToAbp(data) {
        throw new not_implemented_error/* NotImplementedError */.E();
    }
    /**
     * Converts some data to uBlock Origin format
     *
     * @param data Data to convert
     * @returns An object which follows the {@link ConversionResult} interface. Its `result` property contains
     * the converted node, and its `isConverted` flag indicates whether the original node was converted.
     * If the node was not converted, the result will contain the original node with the same object reference
     * @throws If the data is invalid or incompatible
     */
    static convertToUbo(data) {
        throw new not_implemented_error/* NotImplementedError */.E();
    }
}



;// ./node_modules/.pnpm/@adguard+agtree@3.1.3/node_modules/@adguard/agtree/dist/converter/base-interfaces/rule-converter-base.js
/*
 * AGTree v3.1.3 (build date: Tue, 29 Apr 2025 12:25:03 GMT)
 * (c) 2025 Adguard Software Ltd.
 * Released under the MIT license
 * https://github.com/AdguardTeam/tsurlfilter/tree/master/packages/agtree#readme
 */



/**
 * @file Base class for rule converters
 *
 * TS doesn't support abstract static methods, so we should use
 * a workaround and extend this class instead of implementing it
 */
/* eslint-disable jsdoc/require-returns-check */
/* eslint-disable @typescript-eslint/no-unused-vars */
/**
 * Basic class for rule converters
 */
class RuleConverterBase extends BaseConverter {
    /**
     * Converts an adblock filtering rule to AdGuard format, if possible.
     *
     * @param rule Rule node to convert
     * @returns An object which follows the {@link NodeConversionResult} interface. Its `result` property contains
     * the array of converted rule nodes, and its `isConverted` flag indicates whether the original rule was converted.
     * If the rule was not converted, the result array will contain the original node with the same object reference
     * @throws If the rule is invalid or cannot be converted
     */
    static convertToAdg(rule) {
        throw new not_implemented_error/* NotImplementedError */.E();
    }
    /**
     * Converts an adblock filtering rule to Adblock Plus format, if possible.
     *
     * @param rule Rule node to convert
     * @returns An object which follows the {@link NodeConversionResult} interface. Its `result` property contains
     * the array of converted rule nodes, and its `isConverted` flag indicates whether the original rule was converted.
     * If the rule was not converted, the result array will contain the original node with the same object reference
     * @throws If the rule is invalid or cannot be converted
     */
    static convertToAbp(rule) {
        throw new not_implemented_error/* NotImplementedError */.E();
    }
    /**
     * Converts an adblock filtering rule to uBlock Origin format, if possible.
     *
     * @param rule Rule node to convert
     * @returns An object which follows the {@link NodeConversionResult} interface. Its `result` property contains
     * the array of converted rule nodes, and its `isConverted` flag indicates whether the original rule was converted.
     * If the rule was not converted, the result array will contain the original node with the same object reference
     * @throws If the rule is invalid or cannot be converted
     */
    static convertToUbo(rule) {
        throw new not_implemented_error/* NotImplementedError */.E();
    }
}



// EXTERNAL MODULE: ./node_modules/.pnpm/clone-deep@4.0.1/node_modules/clone-deep/index.js
var clone_deep = __webpack_require__(51258);
;// ./node_modules/.pnpm/@adguard+agtree@3.1.3/node_modules/@adguard/agtree/dist/utils/clone.js
/*
 * AGTree v3.1.3 (build date: Tue, 29 Apr 2025 12:25:03 GMT)
 * (c) 2025 Adguard Software Ltd.
 * Released under the MIT license
 * https://github.com/AdguardTeam/tsurlfilter/tree/master/packages/agtree#readme
 */


/**
 * @file Clone related utilities
 *
 * We should keep clone related functions in this file. Thus, we just provide
 * a simple interface for cloning values, we use it across the AGTree project,
 * and the implementation "under the hood" can be improved later, if needed.
 */
/**
 * Clones an input value to avoid side effects. Use it only in justified cases,
 * because it can impact performance negatively.
 *
 * @param value Value to clone
 * @returns Cloned value
 */
function clone(value) {
    // TODO: Replace cloneDeep with a more efficient implementation
    return clone_deep(value);
}



;// ./node_modules/.pnpm/@adguard+agtree@3.1.3/node_modules/@adguard/agtree/dist/converter/base-interfaces/conversion-result.js
/*
 * AGTree v3.1.3 (build date: Tue, 29 Apr 2025 12:25:03 GMT)
 * (c) 2025 Adguard Software Ltd.
 * Released under the MIT license
 * https://github.com/AdguardTeam/tsurlfilter/tree/master/packages/agtree#readme
 */
/**
 * @file Conversion result interface and helper functions
 */
/**
 * Helper function to create a generic conversion result.
 *
 * @param result Conversion result
 * @param isConverted Indicates whether the input item was converted
 * @template T Type of the item to convert
 * @template U Type of the conversion result (defaults to `T`, but can be `T[]` as well)
 * @returns Generic conversion result
 */
// eslint-disable-next-line max-len
function createConversionResult(result, isConverted) {
    return {
        result,
        isConverted,
    };
}
/**
 * Helper function to create a node conversion result.
 *
 * @param nodes Array of nodes
 * @param isConverted Indicates whether the input item was converted
 * @template T Type of the node (extends `Node`)
 * @returns Node conversion result
 */
function createNodeConversionResult(nodes, isConverted) {
    return createConversionResult(nodes, isConverted);
}



;// ./node_modules/.pnpm/@adguard+agtree@3.1.3/node_modules/@adguard/agtree/dist/converter/comment/index.js
/*
 * AGTree v3.1.3 (build date: Tue, 29 Apr 2025 12:25:03 GMT)
 * (c) 2025 Adguard Software Ltd.
 * Released under the MIT license
 * https://github.com/AdguardTeam/tsurlfilter/tree/master/packages/agtree#readme
 */






/**
 * @file Comment rule converter
 */
/**
 * Comment rule converter class
 *
 * @todo Implement `convertToUbo` and `convertToAbp`
 */
class CommentRuleConverter extends RuleConverterBase {
    /**
     * Converts a comment rule to AdGuard format, if possible.
     *
     * @param rule Rule node to convert
     * @returns An object which follows the {@link NodeConversionResult} interface. Its `result` property contains
     * the array of converted rule nodes, and its `isConverted` flag indicates whether the original rule was converted.
     * If the rule was not converted, the result array will contain the original node with the same object reference
     * @throws If the rule is invalid or cannot be converted
     */
    static convertToAdg(rule) {
        // TODO: Add support for other comment types, if needed
        // Main task is # -> ! conversion
        switch (rule.type) {
            case nodes/* CommentRuleType */.gV.CommentRule:
                // Check if the rule needs to be converted
                if (rule.type === nodes/* CommentRuleType */.gV.CommentRule && rule.marker.value === nodes/* CommentMarker */.yg.Hashmark) {
                    // Add a ! to the beginning of the comment
                    // TODO: Replace with custom clone method
                    const ruleClone = clone(rule);
                    ruleClone.marker.value = nodes/* CommentMarker */.yg.Regular;
                    // Add the hashmark to the beginning of the comment text
                    ruleClone.text.value = `${constants/* SPACE */.t6}${nodes/* CommentMarker */.yg.Hashmark}${ruleClone.text.value}`;
                    return createNodeConversionResult([ruleClone], true);
                }
                return createNodeConversionResult([rule], false);
            // Leave any other comment rule as is
            default:
                return createNodeConversionResult([rule], false);
        }
    }
}



// EXTERNAL MODULE: ./node_modules/.pnpm/@adguard+agtree@3.1.3/node_modules/@adguard/agtree/dist/utils/adblockers.js
var adblockers = __webpack_require__(73734);
// EXTERNAL MODULE: ./node_modules/.pnpm/@adguard+css-tokenizer@1.2.0/node_modules/@adguard/css-tokenizer/dist/csstokenizer.mjs
var csstokenizer = __webpack_require__(25651);
// EXTERNAL MODULE: ./node_modules/.pnpm/sprintf-js@1.1.3/node_modules/sprintf-js/src/sprintf.js
var sprintf = __webpack_require__(63607);
;// ./node_modules/.pnpm/@adguard+agtree@3.1.3/node_modules/@adguard/agtree/dist/errors/rule-conversion-error.js
/*
 * AGTree v3.1.3 (build date: Tue, 29 Apr 2025 12:25:03 GMT)
 * (c) 2025 Adguard Software Ltd.
 * Released under the MIT license
 * https://github.com/AdguardTeam/tsurlfilter/tree/master/packages/agtree#readme
 */
/**
 * @file Customized error class for conversion errors.
 */
const ERROR_NAME = 'RuleConversionError';
/**
 * Customized error class for conversion errors.
 */
class RuleConversionError extends Error {
    /**
     * Constructs a new `RuleConversionError` instance.
     *
     * @param message Error message
     */
    constructor(message) {
        super(message);
        this.name = ERROR_NAME;
    }
}



;// ./node_modules/.pnpm/@adguard+agtree@3.1.3/node_modules/@adguard/agtree/dist/utils/regexp.js
/*
 * AGTree v3.1.3 (build date: Tue, 29 Apr 2025 12:25:03 GMT)
 * (c) 2025 Adguard Software Ltd.
 * Released under the MIT license
 * https://github.com/AdguardTeam/tsurlfilter/tree/master/packages/agtree#readme
 */


/**
 * @file Regular expression utilities
 */
// Special RegExp constants
const REGEX_START = constants/* CARET */.cP; // '^'
const REGEX_END = constants/* DOLLAR_SIGN */.nj; // '$'
const REGEX_ANY_CHARACTERS = constants/* DOT */.y0 + constants/* ASTERISK */.Ln; // '.*'
// Special adblock pattern symbols and their RegExp equivalents
const ADBLOCK_URL_START = constants/* PIPE */.L5 + constants/* PIPE */.L5; // '||'
const ADBLOCK_URL_START_REGEX = '^(http|https|ws|wss)://([a-z0-9-_.]+\\.)?';
const ADBLOCK_URL_SEPARATOR = constants/* CARET */.cP; // '^'
const ADBLOCK_URL_SEPARATOR_REGEX = '([^ a-zA-Z0-9.%_-]|$)';
const ADBLOCK_WILDCARD = constants/* ASTERISK */.Ln; // '*'
const ADBLOCK_WILDCARD_REGEX = REGEX_ANY_CHARACTERS;
// Negation wrapper for RegExp patterns
const REGEX_NEGATION_PREFIX = '^((?!';
const REGEX_NEGATION_SUFFIX = ').)*$';
/**
 * Special RegExp symbols
 *
 * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions#special-escape
 */
const SPECIAL_REGEX_SYMBOLS = new Set([
    constants/* ASTERISK */.Ln,
    constants/* CARET */.cP,
    constants/* CLOSE_CURLY_BRACKET */.wU,
    constants/* CLOSE_PARENTHESIS */.s1,
    constants/* CLOSE_SQUARE_BRACKET */.A1,
    constants/* DOLLAR_SIGN */.nj,
    constants/* DOT */.y0,
    constants/* ESCAPE_CHARACTER */.Kx,
    constants/* OPEN_CURLY_BRACKET */.sV,
    constants/* OPEN_PARENTHESIS */.Cx,
    constants/* OPEN_SQUARE_BRACKET */.cU,
    constants/* PIPE */.L5,
    constants/* PLUS */.uu,
    constants/* QUESTION_MARK */.Nb,
    constants/* SLASH */.o,
]);
/**
 * Utility functions for working with RegExp patterns
 */
class RegExpUtils {
    /**
     * Checks whether a string possibly is a RegExp pattern.
     * Flags are not supported.
     *
     * Note: it does not perform a full validation of the pattern,
     * it just checks if the string starts and ends with a slash.
     *
     * @param pattern - Pattern to check
     * @returns `true` if the string is a RegExp pattern, `false` otherwise
     */
    static isRegexPattern(pattern) {
        const trimmedPattern = pattern.trim();
        // Avoid false positives
        return trimmedPattern.length > constants/* REGEX_MARKER */.Vb.length * 2
            && trimmedPattern.startsWith(constants/* REGEX_MARKER */.Vb)
            && trimmedPattern.endsWith(constants/* REGEX_MARKER */.Vb)
            && trimmedPattern[constants/* REGEX_MARKER */.Vb.length - 2] !== constants/* ESCAPE_CHARACTER */.Kx;
    }
    /**
     * Checks whether a string is a negated RegExp pattern.
     *
     * @param pattern - Pattern to check
     * @returns `true` if the string is a negated RegExp pattern, `false` otherwise
     */
    static isNegatedRegexPattern(pattern) {
        if (pattern.startsWith(constants/* REGEX_MARKER */.Vb) && pattern.endsWith(constants/* REGEX_MARKER */.Vb)) {
            const innerPattern = pattern.slice(constants/* REGEX_MARKER */.Vb.length, pattern.length - constants/* REGEX_MARKER */.Vb.length);
            return innerPattern.startsWith(REGEX_NEGATION_PREFIX) && innerPattern.endsWith(REGEX_NEGATION_SUFFIX);
        }
        return pattern.startsWith(REGEX_NEGATION_PREFIX) && pattern.endsWith(REGEX_NEGATION_SUFFIX);
    }
    /**
     * Removes negation from a RegExp pattern.
     *
     * @param pattern - RegExp pattern to remove negation from
     * @returns RegExp pattern without negation
     */
    static removeNegationFromRegexPattern(pattern) {
        let result = pattern.trim();
        const slashes = RegExpUtils.isRegexPattern(result);
        if (slashes) {
            result = result.substring(constants/* REGEX_MARKER */.Vb.length, result.length - constants/* REGEX_MARKER */.Vb.length);
        }
        if (result.startsWith(REGEX_NEGATION_PREFIX) && result.endsWith(REGEX_NEGATION_SUFFIX)) {
            result = result.substring(REGEX_NEGATION_PREFIX.length, result.length - REGEX_NEGATION_SUFFIX.length);
        }
        return slashes ? `${constants/* REGEX_MARKER */.Vb}${result}${constants/* REGEX_MARKER */.Vb}` : result;
    }
    /**
     * Negates a RegExp pattern. Technically, this method wraps the pattern in `^((?!` and `).)*$`.
     *
     * RegExp modifiers are not supported.
     *
     * @param pattern Pattern to negate (can be wrapped in slashes or not)
     * @returns Negated RegExp pattern
     */
    static negateRegexPattern(pattern) {
        let result = pattern.trim();
        let slashes = false;
        // Remove the leading and trailing slashes (/)
        if (RegExpUtils.isRegexPattern(result)) {
            result = result.substring(constants/* REGEX_MARKER */.Vb.length, result.length - constants/* REGEX_MARKER */.Vb.length);
            slashes = true;
        }
        // Only negate the pattern if it's not already negated
        if (!(result.startsWith(REGEX_NEGATION_PREFIX) && result.endsWith(REGEX_NEGATION_SUFFIX))) {
            // Remove leading caret (^)
            if (result.startsWith(REGEX_START)) {
                result = result.substring(REGEX_START.length);
            }
            // Remove trailing dollar sign ($)
            if (result.endsWith(REGEX_END)) {
                result = result.substring(0, result.length - REGEX_END.length);
            }
            // Wrap the pattern in the negation
            result = `${REGEX_NEGATION_PREFIX}${result}${REGEX_NEGATION_SUFFIX}`;
        }
        // Add the leading and trailing slashes back if they were there
        if (slashes) {
            result = `${constants/* REGEX_MARKER */.Vb}${result}${constants/* REGEX_MARKER */.Vb}`;
        }
        return result;
    }
    /**
     * Ensures that a pattern is wrapped in slashes.
     *
     * @param pattern Pattern to ensure slashes for
     * @returns Pattern with slashes
     */
    static ensureSlashes(pattern) {
        let result = pattern;
        if (!result.startsWith(constants/* REGEX_MARKER */.Vb)) {
            result = `${constants/* REGEX_MARKER */.Vb}${result}`;
        }
        if (!result.endsWith(constants/* REGEX_MARKER */.Vb)) {
            result += constants/* REGEX_MARKER */.Vb;
        }
        return result;
    }
    /**
     * Converts a basic adblock rule pattern to a RegExp pattern. Based on
     * https://github.com/AdguardTeam/tsurlfilter/blob/9b26e0b4a0e30b87690bc60f7cf377d112c3085c/packages/tsurlfilter/src/rules/simple-regex.ts#L219
     *
     * @param pattern Pattern to convert
     * @returns RegExp equivalent of the pattern
     * @see {@link https://kb.adguard.com/en/general/how-to-create-your-own-ad-filters#basic-rules}
     */
    static patternToRegexp(pattern) {
        const trimmed = pattern.trim();
        // Return regex for any character sequence if the pattern is just |, ||, * or empty
        if (trimmed === ADBLOCK_URL_START
            || trimmed === constants/* PIPE */.L5
            || trimmed === ADBLOCK_WILDCARD
            || trimmed === constants/* EMPTY */.wg) {
            return REGEX_ANY_CHARACTERS;
        }
        // If the pattern is already a RegExp, just return it, but remove the leading and trailing slashes
        if (RegExpUtils.isRegexPattern(pattern)) {
            return pattern.substring(constants/* REGEX_MARKER */.Vb.length, pattern.length - constants/* REGEX_MARKER */.Vb.length);
        }
        let result = constants/* EMPTY */.wg;
        let offset = 0;
        let len = trimmed.length;
        // Handle leading pipes
        if (trimmed[0] === constants/* PIPE */.L5) {
            if (trimmed[1] === constants/* PIPE */.L5) {
                // Replace adblock url start (||) with its RegExp equivalent
                result += ADBLOCK_URL_START_REGEX;
                offset = ADBLOCK_URL_START.length;
            }
            else {
                // Replace single pipe (|) with the RegExp start symbol (^)
                result += REGEX_START;
                offset = REGEX_START.length;
            }
        }
        // Handle trailing pipes
        let trailingPipe = false;
        if (trimmed.endsWith(constants/* PIPE */.L5)) {
            trailingPipe = true;
            len -= constants/* PIPE */.L5.length;
        }
        // Handle the rest of the pattern, if any
        for (; offset < len; offset += 1) {
            if (trimmed[offset] === ADBLOCK_WILDCARD) {
                // Replace adblock wildcard (*) with its RegExp equivalent
                result += ADBLOCK_WILDCARD_REGEX;
            }
            else if (trimmed[offset] === ADBLOCK_URL_SEPARATOR) {
                // Replace adblock url separator (^) with its RegExp equivalent
                result += ADBLOCK_URL_SEPARATOR_REGEX;
            }
            else if (SPECIAL_REGEX_SYMBOLS.has(trimmed[offset])) {
                // Escape special RegExp symbols (we handled pipe (|) and asterisk (*) already)
                result += constants/* ESCAPE_CHARACTER */.Kx + trimmed[offset];
            }
            else {
                // Just add any other character
                result += trimmed[offset];
            }
        }
        // Handle trailing pipes
        if (trailingPipe) {
            // Replace trailing pipe (|) with the RegExp end symbol ($)
            result += REGEX_END;
        }
        return result;
    }
}



// EXTERNAL MODULE: ./node_modules/.pnpm/@adguard+agtree@3.1.3/node_modules/@adguard/agtree/dist/utils/type-guards.js
var type_guards = __webpack_require__(8123);
;// ./node_modules/.pnpm/@adguard+agtree@3.1.3/node_modules/@adguard/agtree/dist/ast-utils/clone.js
/*
 * AGTree v3.1.3 (build date: Tue, 29 Apr 2025 12:25:03 GMT)
 * (c) 2025 Adguard Software Ltd.
 * Released under the MIT license
 * https://github.com/AdguardTeam/tsurlfilter/tree/master/packages/agtree#readme
 */


/**
 * @file Custom clone functions for AST nodes, this is probably the most efficient way to clone AST nodes.
 * @todo Maybe move them to parser classes as 'clone' methods
 */
/**
 * Clones a scriptlet rule node.
 *
 * @param node Node to clone
 * @returns Cloned node
 */
function cloneScriptletRuleNode(node) {
    return {
        type: node.type,
        children: node.children.map((child) => ((0,type_guards/* isNull */.kZ)(child) ? null : { ...child })),
    };
}
/**
 * Clones a domain list node.
 *
 * @param node Node to clone
 * @returns Cloned node
 */
function cloneDomainListNode(node) {
    return {
        type: node.type,
        separator: node.separator,
        children: node.children.map((domain) => ({ ...domain })),
    };
}
/**
 * Clones a modifier list node.
 *
 * @param node Node to clone
 * @returns Cloned node
 */
function cloneModifierListNode(node) {
    return {
        type: node.type,
        children: node.children.map((modifier) => {
            const res = {
                type: modifier.type,
                exception: modifier.exception,
                name: { ...modifier.name },
            };
            if (modifier.value) {
                res.value = { ...modifier.value };
            }
            return res;
        }),
    };
}



// EXTERNAL MODULE: ./node_modules/.pnpm/@adguard+agtree@3.1.3/node_modules/@adguard/agtree/dist/parser/css/css-token-stream.js
var css_token_stream = __webpack_require__(6034);
// EXTERNAL MODULE: ./node_modules/.pnpm/@adguard+agtree@3.1.3/node_modules/@adguard/agtree/dist/utils/string.js
var string = __webpack_require__(38949);
;// ./node_modules/.pnpm/@adguard+agtree@3.1.3/node_modules/@adguard/agtree/dist/converter/cosmetic/html.js
/*
 * AGTree v3.1.3 (build date: Tue, 29 Apr 2025 12:25:03 GMT)
 * (c) 2025 Adguard Software Ltd.
 * Released under the MIT license
 * https://github.com/AdguardTeam/tsurlfilter/tree/master/packages/agtree#readme
 */













/**
 * @file HTML filtering rule converter
 */
/**
 * From the AdGuard docs:
 * Specifies the maximum length for content of HTML element. If this parameter is
 * set and the content length exceeds the value, a rule does not apply to the element.
 * If this parameter is not specified, the max-length is considered to be 8192 (8 KB).
 * When converting from other formats, we set the max-length to 262144 (256 KB).
 *
 * @see {@link https://adguard.com/kb/general/ad-filtering/create-own-filters/#html-filtering-rules}
 */
const ADG_HTML_DEFAULT_MAX_LENGTH = 8192;
const ADG_HTML_CONVERSION_MAX_LENGTH = ADG_HTML_DEFAULT_MAX_LENGTH * 32;
const NOT_SPECIFIED = -1;
const PseudoClasses = {
    Contains: 'contains',
    HasText: 'has-text',
    MinTextLength: 'min-text-length',
};
const AttributeSelectors = {
    MaxLength: 'max-length',
    MinLength: 'min-length',
    TagContent: 'tag-content'};
const SUPPORTED_UBO_PSEUDO_CLASSES = new Set([
    PseudoClasses.Contains,
    PseudoClasses.HasText,
    PseudoClasses.MinTextLength,
]);
const ERROR_MESSAGES = {
    ABP_NOT_SUPPORTED: 'Invalid rule, ABP does not support HTML filtering rules',
    TAG_SHOULD_BE_FIRST_CHILD: "Unexpected token '%s' with value '%s', tag selector should be the first child",
    INVALID_ATTRIBUTE_NAME: "Attribute name should be an identifier, but got '%s' with value '%s'",
    // eslint-disable-next-line max-len
    INVALID_ATTRIBUTE_VALUE: `Expected '${(0,csstokenizer/* getFormattedTokenName */.bZ)(csstokenizer/* TokenType */.ks.Ident)}' or '${(0,csstokenizer/* getFormattedTokenName */.bZ)(csstokenizer/* TokenType */.ks.String)}' as attribute value, but got '%s' with value '%s`,
    VALUE_FOR_ATTR_SHOULD_BE_INT: "Value for '%s' attribute should be an integer, but got '%s'",
    INVALID_PSEUDO_CLASS: "Unsupported pseudo class '%s'",
    VALUE_FOR_PSEUDO_CLASS_SHOULD_BE_INT: "Value for '%s' pseudo class should be an integer, but got '%s'",
    // eslint-disable-next-line max-len
    REGEXP_NOT_SUPPORTED: "Cannot convert RegExp parameter '%s' from '%s' pseudo class, because converting RegExp patterns are not supported yet",
    ATTRIBUTE_SELECTOR_REQUIRES_VALUE: "Attribute selector '%s' requires a value",
    VALUE_SHOULD_BE_SPECIFIED: 'Value should be specified if operator is specified',
    UNEXPECTED_TOKEN_WITH_VALUE: "Unexpected token '%s' with value '%s'",
    FLAGS_NOT_SUPPORTED: 'Flags are not supported for attribute selectors',
};
/**
 * Convert `""` to `\"` within strings, because it does not compatible with the standard CSS syntax.
 *
 * @param selector CSS selector string
 * @returns Escaped CSS selector
 * @note In the legacy syntax, `""` is used to escape double quotes, but it cannot be used in the standard CSS syntax,
 * so we use conversion functions to handle this.
 * @see {@link https://kb.adguard.com/en/general/how-to-create-your-own-ad-filters#tag-content}
 */
function escapeDoubleQuotes(selector) {
    let withinString = false;
    const buffer = [];
    for (let i = 0; i < selector.length; i += 1) {
        if (!withinString && selector[i] === string/* DOUBLE_QUOTE_MARKER */.E0) {
            withinString = true;
            buffer.push(selector[i]);
        }
        else if (withinString && selector[i] === string/* DOUBLE_QUOTE_MARKER */.E0 && selector[i + 1] === string/* DOUBLE_QUOTE_MARKER */.E0) {
            buffer.push(constants/* ESCAPE_CHARACTER */.Kx);
            buffer.push(string/* DOUBLE_QUOTE_MARKER */.E0);
            i += 1;
        }
        else if (withinString && selector[i] === string/* DOUBLE_QUOTE_MARKER */.E0 && selector[i + 1] !== string/* DOUBLE_QUOTE_MARKER */.E0) {
            buffer.push(string/* DOUBLE_QUOTE_MARKER */.E0);
            withinString = false;
        }
        else {
            buffer.push(selector[i]);
        }
    }
    return buffer.join(constants/* EMPTY */.wg);
}
/**
 * Convert escaped double quotes `\"` to `""` within strings.
 *
 * @param selector CSS selector string
 * @returns Unescaped CSS selector
 * @note In the legacy syntax, `""` is used to escape double quotes, but it cannot be used in the standard CSS syntax,
 * so we use conversion functions to handle this.
 * @see {@link https://kb.adguard.com/en/general/how-to-create-your-own-ad-filters#tag-content}
 */
function unescapeDoubleQuotes(selector) {
    let withinString = false;
    const buffer = [];
    for (let i = 0; i < selector.length; i += 1) {
        if (selector[i] === string/* DOUBLE_QUOTE_MARKER */.E0 && selector[i - 1] !== constants/* ESCAPE_CHARACTER */.Kx) {
            withinString = !withinString;
            buffer.push(selector[i]);
        }
        else if (withinString && selector[i] === constants/* ESCAPE_CHARACTER */.Kx && selector[i + 1] === string/* DOUBLE_QUOTE_MARKER */.E0) {
            buffer.push(string/* DOUBLE_QUOTE_MARKER */.E0);
        }
        else {
            buffer.push(selector[i]);
        }
    }
    return buffer.join(constants/* EMPTY */.wg);
}
/**
 * Helper function to render an attribute selector
 *
 * @param attr Attribute name
 * @param op Operator (optional)
 * @param value Attribute value (optional)
 * @param flags Attribute flags (optional)
 * @returns Rendered attribute selector string
 */
function renderAttrSelector(attr, op, value, flags) {
    const result = [];
    result.push(constants/* OPEN_SQUARE_BRACKET */.cU);
    result.push(attr);
    {
        if (value === undefined) {
            throw new Error(ERROR_MESSAGES.VALUE_SHOULD_BE_SPECIFIED);
        }
        result.push(op);
    }
    if (value !== undefined) {
        result.push(string/* DOUBLE_QUOTE_MARKER */.E0);
        result.push(value);
        result.push(string/* DOUBLE_QUOTE_MARKER */.E0);
    }
    result.push(constants/* CLOSE_SQUARE_BRACKET */.A1);
    return result.join(constants/* EMPTY */.wg);
}
/**
 * HTML filtering rule converter class
 *
 * @todo Implement `convertToUbo` (ABP currently doesn't support HTML filtering rules)
 */
class HtmlRuleConverter extends RuleConverterBase {
    /**
     * Converts a HTML rule to AdGuard syntax, if possible. Also can be used to convert
     * AdGuard rules to AdGuard syntax to validate them.
     *
     * _Note:_ uBlock Origin supports multiple selectors within a single rule, but AdGuard doesn't,
     * so the following rule
     * ```
     * example.com##^div[attr1="value1"][attr2="value2"], script:has-text(value)
     * ```
     * will be converted to multiple AdGuard rules:
     * ```
     * example.com$$div[attr1="value1"][attr2="value2"][max-length="262144"]
     * example.com$$script[tag-content="value"][max-length="262144"]
     * ```
     *
     * @param rule Rule node to convert
     * @returns An object which follows the {@link NodeConversionResult} interface. Its `result` property contains
     * the array of converted rule nodes, and its `isConverted` flag indicates whether the original rule was converted.
     * If the rule was not converted, the result array will contain the original node with the same object reference
     * @throws If the rule is invalid or cannot be converted
     */
    static convertToAdg(rule) {
        // Ignore AdGuard rules
        if (rule.syntax === adblockers/* AdblockSyntax */.Y.Adg) {
            return createNodeConversionResult([rule], false);
        }
        if (rule.syntax === adblockers/* AdblockSyntax */.Y.Abp) {
            throw new RuleConversionError(ERROR_MESSAGES.ABP_NOT_SUPPORTED);
        }
        const source = escapeDoubleQuotes(rule.body.value);
        const stream = new css_token_stream/* CssTokenStream */.d(source);
        const convertedSelector = [];
        const convertedSelectorList = [];
        let minLen = NOT_SPECIFIED;
        let maxLen = NOT_SPECIFIED;
        // Skip leading whitespace
        stream.skipWhitespace();
        // Skip ^
        stream.expect(csstokenizer/* TokenType */.ks.Delim, { value: constants/* UBO_HTML_MASK */._h });
        stream.advance();
        while (!stream.isEof()) {
            const token = stream.getOrFail();
            if (token.type === csstokenizer/* TokenType */.ks.Ident) {
                // Tag selector should be the first child, if present, but whitespace is allowed before it
                if (convertedSelector.length !== 0 && stream.lookbehindForNonWs() !== undefined) {
                    throw new RuleConversionError((0,sprintf.sprintf)(ERROR_MESSAGES.TAG_SHOULD_BE_FIRST_CHILD, (0,csstokenizer/* getFormattedTokenName */.bZ)(token.type), source.slice(token.start, token.end)));
                }
                convertedSelector.push(source.slice(token.start, token.end));
                stream.advance();
            }
            else if (token.type === csstokenizer/* TokenType */.ks.OpenSquareBracket) {
                // Attribute selectors: https://developer.mozilla.org/en-US/docs/Web/CSS/Attribute_selectors#syntax
                const { start } = token;
                let tempToken;
                // Advance opening square bracket
                stream.advance();
                // Skip optional whitespace after the opening square bracket
                stream.skipWhitespace();
                // Parse attribute name
                tempToken = stream.getOrFail();
                if (tempToken.type !== csstokenizer/* TokenType */.ks.Ident) {
                    throw new RuleConversionError((0,sprintf.sprintf)(ERROR_MESSAGES.INVALID_ATTRIBUTE_NAME, (0,csstokenizer/* getFormattedTokenName */.bZ)(tempToken.type), source.slice(tempToken.start, tempToken.end)));
                }
                const attr = source.slice(tempToken.start, tempToken.end);
                stream.advance();
                // Skip optional whitespace after the attribute name
                stream.skipWhitespace();
                // Maybe attribute selector ends here, because value is not required, like in '[disabled]'
                tempToken = stream.getOrFail();
                // So check if the next non whitespace token is a closing square bracket
                if (tempToken.type === csstokenizer/* TokenType */.ks.CloseSquareBracket) {
                    const { end } = tempToken;
                    stream.advance();
                    // Special case for min-length and max-length attributes
                    if (attr === AttributeSelectors.MinLength || attr === AttributeSelectors.MaxLength) {
                        throw new RuleConversionError((0,sprintf.sprintf)(ERROR_MESSAGES.ATTRIBUTE_SELECTOR_REQUIRES_VALUE, attr));
                    }
                    convertedSelector.push(source.slice(start, end));
                    continue;
                }
                // Next token should be a valid attribute selector operator
                // Only '=' operator is supported
                stream.expect(csstokenizer/* TokenType */.ks.Delim, { value: constants/* EQUALS */.UT });
                // Advance the operator
                stream.advance();
                // Skip optional whitespace after the operator
                stream.skipWhitespace();
                // Parse attribute value
                tempToken = stream.getOrFail();
                // According to the spec, attribute value should be an identifier or a string
                if (tempToken.type !== csstokenizer/* TokenType */.ks.Ident && tempToken.type !== csstokenizer/* TokenType */.ks.String) {
                    throw new RuleConversionError((0,sprintf.sprintf)(ERROR_MESSAGES.INVALID_ATTRIBUTE_VALUE, (0,csstokenizer/* getFormattedTokenName */.bZ)(tempToken.type), source.slice(tempToken.start, tempToken.end)));
                }
                const value = source.slice(tempToken.start, tempToken.end);
                // Advance the attribute value
                stream.advance();
                // Skip optional whitespace after the attribute value
                stream.skipWhitespace();
                // Attribute selector may have flags - but AdGuard HTML filtering does not support them
                tempToken = stream.getOrFail();
                if (tempToken.type === csstokenizer/* TokenType */.ks.Ident) {
                    throw new RuleConversionError((0,sprintf.sprintf)(ERROR_MESSAGES.FLAGS_NOT_SUPPORTED));
                }
                // Next token should be a closing square bracket
                stream.expect(csstokenizer/* TokenType */.ks.CloseSquareBracket);
                const { end } = stream.getOrFail();
                stream.advance();
                if (attr === AttributeSelectors.MinLength) {
                    // Min length attribute
                    const parsed = parseInt(value, 10);
                    if (Number.isNaN(parsed)) {
                        throw new RuleConversionError((0,sprintf.sprintf)(ERROR_MESSAGES.VALUE_FOR_ATTR_SHOULD_BE_INT, attr, value));
                    }
                    minLen = parsed;
                }
                else if (attr === AttributeSelectors.MaxLength) {
                    // Max length attribute
                    const parsed = parseInt(value, 10);
                    if (Number.isNaN(parsed)) {
                        throw new RuleConversionError((0,sprintf.sprintf)(ERROR_MESSAGES.VALUE_FOR_ATTR_SHOULD_BE_INT, attr, value));
                    }
                    maxLen = parsed;
                }
                else {
                    convertedSelector.push(source.slice(start, end));
                }
            }
            else if (token.type === csstokenizer/* TokenType */.ks.Colon) {
                let tempToken;
                // Pseudo classes: https://developer.mozilla.org/en-US/docs/Web/CSS/Pseudo-classes#syntax
                stream.advance();
                // Next token should be a pseudo class name
                stream.expect(csstokenizer/* TokenType */.ks.Function);
                tempToken = stream.getOrFail();
                const fn = source.slice(tempToken.start, tempToken.end - 1); // do not include '('
                // Pseudo class should be supported
                if (!SUPPORTED_UBO_PSEUDO_CLASSES.has(fn)) {
                    throw new RuleConversionError((0,sprintf.sprintf)(ERROR_MESSAGES.INVALID_PSEUDO_CLASS, fn));
                }
                const paramStart = tempToken.end;
                // Find the closing paren
                stream.skipUntilBalanced();
                tempToken = stream.getOrFail();
                const paramEnd = tempToken.end;
                // Get the parameter
                const param = source.slice(paramStart, paramEnd - 1);
                if (fn === PseudoClasses.MinTextLength) {
                    // Min text length pseudo class
                    // Parameter should be parsed as an integer
                    const parsed = parseInt(param, 10);
                    if (Number.isNaN(parsed)) {
                        throw new RuleConversionError((0,sprintf.sprintf)(ERROR_MESSAGES.VALUE_FOR_PSEUDO_CLASS_SHOULD_BE_INT, fn, param));
                    }
                    minLen = parsed;
                }
                else if (fn === PseudoClasses.Contains || fn === PseudoClasses.HasText) {
                    // Contains and has-text pseudo classes
                    // Check if the argument is a RegExp
                    if (RegExpUtils.isRegexPattern(param)) {
                        // TODO: Add some support for RegExp patterns later
                        // Need to find a way to convert some RegExp patterns to glob patterns
                        throw new RuleConversionError((0,sprintf.sprintf)(ERROR_MESSAGES.REGEXP_NOT_SUPPORTED, param, fn));
                    }
                    // Escape unescaped double quotes in the parameter
                    const paramEscaped = string/* StringUtils */.$x.escapeCharacter(param, string/* DOUBLE_QUOTE_MARKER */.E0);
                    convertedSelector.push(renderAttrSelector(AttributeSelectors.TagContent, constants/* EQUALS */.UT, paramEscaped));
                }
                stream.advance();
            }
            else if (token.type === csstokenizer/* TokenType */.ks.Comma && token.balance === 0) {
                if (minLen !== NOT_SPECIFIED) {
                    convertedSelector.push(renderAttrSelector(AttributeSelectors.MinLength, constants/* EQUALS */.UT, minLen.toString()));
                }
                convertedSelector.push(renderAttrSelector(AttributeSelectors.MaxLength, constants/* EQUALS */.UT, maxLen !== NOT_SPECIFIED ? maxLen.toString() : ADG_HTML_CONVERSION_MAX_LENGTH.toString()));
                convertedSelectorList.push(convertedSelector.join(constants/* EMPTY */.wg));
                convertedSelector.length = 0;
                stream.advance();
            }
            else if (token.type === csstokenizer/* TokenType */.ks.Whitespace) {
                stream.advance();
            }
            else {
                throw new RuleConversionError((0,sprintf.sprintf)(ERROR_MESSAGES.UNEXPECTED_TOKEN_WITH_VALUE, (0,csstokenizer/* getFormattedTokenName */.bZ)(token.type), source.slice(token.start, token.end)));
            }
        }
        if (convertedSelector.length !== 0) {
            if (minLen !== NOT_SPECIFIED) {
                convertedSelector.push(renderAttrSelector(AttributeSelectors.MinLength, constants/* EQUALS */.UT, minLen.toString()));
            }
            convertedSelector.push(renderAttrSelector(AttributeSelectors.MaxLength, constants/* EQUALS */.UT, maxLen !== NOT_SPECIFIED ? maxLen.toString() : ADG_HTML_CONVERSION_MAX_LENGTH.toString()));
            convertedSelectorList.push(convertedSelector.join(constants/* EMPTY */.wg));
        }
        return createNodeConversionResult(
        // Since AdGuard HTML filtering rules do not support multiple selectors, we need to split each selector
        // into a separate rule node.
        convertedSelectorList.map((selector) => ({
            category: nodes/* RuleCategory */.$O.Cosmetic,
            type: nodes/* CosmeticRuleType */.k9.HtmlFilteringRule,
            syntax: adblockers/* AdblockSyntax */.Y.Adg,
            exception: rule.exception,
            domains: cloneDomainListNode(rule.domains),
            // Convert the separator based on the exception status
            separator: {
                type: 'Value',
                value: rule.exception
                    ? nodes/* CosmeticRuleSeparator */.p5.AdgHtmlFilteringException
                    : nodes/* CosmeticRuleSeparator */.p5.AdgHtmlFiltering,
            },
            body: {
                type: 'Value',
                value: unescapeDoubleQuotes(selector),
            },
        })), true);
    }
}



// EXTERNAL MODULE: ./node_modules/.pnpm/@adguard+agtree@3.1.3/node_modules/@adguard/agtree/dist/utils/quotes.js
var quotes = __webpack_require__(31529);
;// ./node_modules/.pnpm/@adguard+agtree@3.1.3/node_modules/@adguard/agtree/dist/ast-utils/scriptlets.js
/*
 * AGTree v3.1.3 (build date: Tue, 29 Apr 2025 12:25:03 GMT)
 * (c) 2025 Adguard Software Ltd.
 * Released under the MIT license
 * https://github.com/AdguardTeam/tsurlfilter/tree/master/packages/agtree#readme
 */




/**
 * @file Utility functions for working with scriptlet nodes
 */
/**
 * Get name of the scriptlet from the scriptlet node
 *
 * @param scriptletNode Scriptlet node to get name of
 * @returns Name of the scriptlet
 * @throws If the scriptlet is empty
 */
function getScriptletName(scriptletNode) {
    if (scriptletNode.children.length === 0) {
        throw new Error('Empty scriptlet');
    }
    return scriptletNode.children[0]?.value ?? constants/* EMPTY */.wg;
}
/**
 * Transform the nth argument of the scriptlet node
 *
 * @param scriptletNode Scriptlet node to transform argument of
 * @param index Index of the argument to transform (index 0 is the scriptlet name)
 * @param transform Function to transform the argument
 */
function transformNthScriptletArgument(scriptletNode, index, transform) {
    const child = scriptletNode.children[index];
    if (!(0,type_guards/* isUndefined */.b0)(child)) {
        const transformed = transform(child?.value ?? null);
        if ((0,type_guards/* isNull */.kZ)(transformed)) {
            // eslint-disable-next-line no-param-reassign
            scriptletNode.children[index] = null;
            return;
        }
        if ((0,type_guards/* isNull */.kZ)(child)) {
            // eslint-disable-next-line no-param-reassign
            scriptletNode.children[index] = {
                type: 'Value',
                value: transformed,
            };
            return;
        }
        child.value = transformed;
    }
}
/**
 * Transform all arguments of the scriptlet node
 *
 * @param scriptletNode Scriptlet node to transform arguments of
 * @param transform Function to transform the arguments
 */
function transformAllScriptletArguments(scriptletNode, transform) {
    for (let i = 0; i < scriptletNode.children.length; i += 1) {
        transformNthScriptletArgument(scriptletNode, i, transform);
    }
}
/**
 * Set name of the scriptlet.
 * Modifies input `scriptletNode` if needed.
 *
 * @param scriptletNode Scriptlet node to set name of
 * @param name Name to set
 */
function setScriptletName(scriptletNode, name) {
    transformNthScriptletArgument(scriptletNode, 0, () => name);
}
/**
 * Set quote type of the scriptlet parameters
 *
 * @param scriptletNode Scriptlet node to set quote type of
 * @param quoteType Preferred quote type
 */
function setScriptletQuoteType(scriptletNode, quoteType) {
    // null is a special value that means "no value", but we can't change its quote type,
    // so we need to convert it to empty string
    transformAllScriptletArguments(scriptletNode, (value) => quotes/* QuoteUtils */.Qj.setStringQuoteType(value ?? constants/* EMPTY */.wg, quoteType));
}



;// ./node_modules/.pnpm/@adguard+agtree@3.1.3/node_modules/@adguard/agtree/dist/compatibility-tables/platforms.js
/*
 * AGTree v3.1.3 (build date: Tue, 29 Apr 2025 12:25:03 GMT)
 * (c) 2025 Adguard Software Ltd.
 * Released under the MIT license
 * https://github.com/AdguardTeam/tsurlfilter/tree/master/packages/agtree#readme
 */
/* eslint-disable no-bitwise */
/**
 * @file Provides platform enums.
 * The difference between specific and generic platforms is that specific platforms are individual platforms
 * (e.g. AdGuard for Windows, AdGuard for Android, etc.),
 * while generic platforms are groups of specific platforms
 * (e.g. AdGuard for any OS, AdGuard for any Chromium-based extension, etc.).
 */
/**
 * List of specific platforms.
 */
const SpecificPlatform = {
    AdgOsWindows: 1,
    AdgOsMac: 1 << 1,
    AdgOsAndroid: 1 << 2,
    AdgExtChrome: 1 << 3,
    AdgExtOpera: 1 << 4,
    AdgExtEdge: 1 << 5,
    AdgExtFirefox: 1 << 6,
    AdgCbAndroid: 1 << 7,
    AdgCbIos: 1 << 8,
    AdgCbSafari: 1 << 9,
    UboExtChrome: 1 << 10,
    UboExtOpera: 1 << 11,
    UboExtEdge: 1 << 12,
    UboExtFirefox: 1 << 13,
    AbpExtChrome: 1 << 14,
    AbpExtOpera: 1 << 15,
    AbpExtEdge: 1 << 16,
    AbpExtFirefox: 1 << 17,
};
const AdgOsAny = SpecificPlatform.AdgOsWindows
    | SpecificPlatform.AdgOsMac
    | SpecificPlatform.AdgOsAndroid;
const AdgSafariAny = SpecificPlatform.AdgCbSafari | SpecificPlatform.AdgCbIos;
const AdgExtChromium = SpecificPlatform.AdgExtChrome
    | SpecificPlatform.AdgExtOpera
    | SpecificPlatform.AdgExtEdge;
const AdgExtAny = AdgExtChromium | SpecificPlatform.AdgExtFirefox;
const AdgAny = AdgExtAny | AdgOsAny | AdgSafariAny | SpecificPlatform.AdgCbAndroid;
const UboExtChromium = SpecificPlatform.UboExtChrome
    | SpecificPlatform.UboExtOpera
    | SpecificPlatform.UboExtEdge;
const UboExtAny = UboExtChromium | SpecificPlatform.UboExtFirefox;
const UboAny = UboExtAny;
const AbpExtChromium = SpecificPlatform.AbpExtChrome
    | SpecificPlatform.AbpExtOpera
    | SpecificPlatform.AbpExtEdge;
const AbpExtAny = AbpExtChromium | SpecificPlatform.AbpExtFirefox;
const AbpAny = AbpExtAny;
const Any = AdgAny | UboAny | AbpAny;
/**
 * List of generic platforms (combinations of specific platforms).
 */
const GenericPlatform = {
    AdgOsAny,
    AdgSafariAny,
    AdgExtChromium,
    AdgExtAny,
    AdgAny,
    UboExtChromium,
    UboExtAny,
    UboAny,
    AbpExtChromium,
    AbpExtAny,
    AbpAny,
    Any,
};



;// ./node_modules/.pnpm/@adguard+agtree@3.1.3/node_modules/@adguard/agtree/dist/compatibility-tables/utils/platform-helpers.js
/*
 * AGTree v3.1.3 (build date: Tue, 29 Apr 2025 12:25:03 GMT)
 * (c) 2025 Adguard Software Ltd.
 * Released under the MIT license
 * https://github.com/AdguardTeam/tsurlfilter/tree/master/packages/agtree#readme
 */


/* eslint-disable no-bitwise */
/**
 * @file Provides platform mapping and helper functions.
 */
/**
 * Map of specific platforms string names to their corresponding enum values.
 */
const SPECIFIC_PLATFORM_MAP = new Map([
    ['adg_os_windows', SpecificPlatform.AdgOsWindows],
    ['adg_os_mac', SpecificPlatform.AdgOsMac],
    ['adg_os_android', SpecificPlatform.AdgOsAndroid],
    ['adg_ext_chrome', SpecificPlatform.AdgExtChrome],
    ['adg_ext_opera', SpecificPlatform.AdgExtOpera],
    ['adg_ext_edge', SpecificPlatform.AdgExtEdge],
    ['adg_ext_firefox', SpecificPlatform.AdgExtFirefox],
    ['adg_cb_android', SpecificPlatform.AdgCbAndroid],
    ['adg_cb_ios', SpecificPlatform.AdgCbIos],
    ['adg_cb_safari', SpecificPlatform.AdgCbSafari],
    ['ubo_ext_chrome', SpecificPlatform.UboExtChrome],
    ['ubo_ext_opera', SpecificPlatform.UboExtOpera],
    ['ubo_ext_edge', SpecificPlatform.UboExtEdge],
    ['ubo_ext_firefox', SpecificPlatform.UboExtFirefox],
    ['abp_ext_chrome', SpecificPlatform.AbpExtChrome],
    ['abp_ext_opera', SpecificPlatform.AbpExtOpera],
    ['abp_ext_edge', SpecificPlatform.AbpExtEdge],
    ['abp_ext_firefox', SpecificPlatform.AbpExtFirefox],
]);
/**
 * Map of specific platforms enum values to their corresponding string names.
 *
 * @note Reverse of {@link SPECIFIC_PLATFORM_MAP}.
 */
const SPECIFIC_PLATFORM_MAP_REVERSE = new Map([...SPECIFIC_PLATFORM_MAP].map(([key, value]) => [value, key]));
/**
 * Map of generic platforms string names to their corresponding enum values.
 */
const GENERIC_PLATFORM_MAP = new Map([
    ['adg_os_any', GenericPlatform.AdgOsAny],
    ['adg_safari_any', GenericPlatform.AdgSafariAny],
    ['adg_ext_chromium', GenericPlatform.AdgExtChromium],
    ['adg_ext_any', GenericPlatform.AdgExtAny],
    ['adg_any', GenericPlatform.AdgAny],
    ['ubo_ext_chromium', GenericPlatform.UboExtChromium],
    ['ubo_ext_any', GenericPlatform.UboExtAny],
    ['ubo_any', GenericPlatform.UboAny],
    ['abp_ext_chromium', GenericPlatform.AbpExtChromium],
    ['abp_ext_any', GenericPlatform.AbpExtAny],
    ['abp_any', GenericPlatform.AbpAny],
    ['any', GenericPlatform.Any],
]);
/**
 * Check if the platform is a generic platform.
 *
 * @param platform Platform to check.
 *
 * @returns True if the platform is a generic platform, false otherwise.
 */
const isGenericPlatform = (platform) => {
    // if more than one bit is set, it's a generic platform
    return !!(platform & (platform - 1));
};
/**
 * Returns the platform enum value for the given platform string name.
 *
 * @param platform Platform string name, e.g., 'adg_os_windows'.
 *
 * @returns Specific or generic platform enum value.
 * @throws Error if the platform is unknown.
 */
const getPlatformId = (platform) => {
    const specificPlatform = SPECIFIC_PLATFORM_MAP.get(platform);
    if (specificPlatform) {
        return specificPlatform;
    }
    const genericPlatform = GENERIC_PLATFORM_MAP.get(platform);
    if (genericPlatform) {
        return genericPlatform;
    }
    throw new Error(`Unknown platform: ${platform}`);
};
/**
 * Returns the specific platform string name for the given platform enum value.
 *
 * @param platform Specific platform enum value.
 *
 * @returns Specific platform string name, e.g., 'adg_os_windows'.
 * @throws Error if the platform is unknown.
 */
const getSpecificPlatformName = (platform) => {
    const specificPlatform = SPECIFIC_PLATFORM_MAP_REVERSE.get(platform);
    if (!specificPlatform) {
        throw new Error(`Unknown platform: ${platform}`);
    }
    return specificPlatform;
};



;// ./node_modules/.pnpm/@adguard+agtree@3.1.3/node_modules/@adguard/agtree/dist/compatibility-tables/base.js
/*
 * AGTree v3.1.3 (build date: Tue, 29 Apr 2025 12:25:03 GMT)
 * (c) 2025 Adguard Software Ltd.
 * Released under the MIT license
 * https://github.com/AdguardTeam/tsurlfilter/tree/master/packages/agtree#readme
 */





/* eslint-disable no-bitwise */
/**
 * @file Provides common compatibility table methods.
 */
/**
 * Base compatibility table class which provides common methods to work with compatibility data.
 *
 * @template T Compatibility data schema.
 */
class CompatibilityTableBase {
    /**
     * Compatibility table data.
     */
    data;
    /**
     * Optional name transformer function. If provided,
     * it will be called in all methods before processing compatibility data names.
     */
    nameTransformer;
    /**
     * Creates a new instance of the common compatibility table.
     *
     * @param data Compatibility table data.
     * @param nameTransformer Optional name transformer function.
     */
    constructor(data, nameTransformer = null) {
        this.data = data;
        this.nameTransformer = nameTransformer;
    }
    /**
     * Helper method to get a 'row' from the compatibility table data by name.
     *
     * @param name Compatibility data name.
     * @returns Compatibility table row storage or `null` if not found.
     */
    getRowStorage(name) {
        const idx = this.data.map[name];
        if ((0,type_guards/* isUndefined */.b0)(idx)) {
            return null;
        }
        return this.data.shared[idx];
    }
    /**
     * Checks whether a compatibility data `name` exists for any platform.
     *
     * @note Technically, do the same as `exists()` method with generic platform _any_
     * but it is faster because it does not apply complex logic.
     *
     * @param name Compatibility data name.
     *
     * @returns True if the compatibility data exists, false otherwise.
     */
    existsAny(name) {
        const normalizedName = this.nameTransformer ? this.nameTransformer(name) : name;
        return !(0,type_guards/* isUndefined */.b0)(this.data.map[normalizedName]);
    }
    /**
     * Checks whether a compatibility data `name` exists for a specified platform.
     *
     * @param name Compatibility data name.
     * @param platform Specific or generic platform.
     *
     * @returns True if the compatibility data exists, false otherwise.
     */
    exists(name, platform) {
        const normalizedName = this.nameTransformer ? this.nameTransformer(name) : name;
        const data = this.getRowStorage(normalizedName);
        if (!data) {
            return false;
        }
        const isMatch = (idx) => {
            const el = data.shared[idx];
            return !(0,type_guards/* isUndefined */.b0)(el) && (el.name === normalizedName || !!el.aliases?.includes(normalizedName));
        };
        if (isGenericPlatform(platform)) {
            // Since indexes are specific platforms in the compatibility table data,
            // we can't index them directly if the platform is generic (union of specific platforms).
            // In this case, we need to iterate over the keys and return true on the first match.
            const keys = Object.keys(data.map);
            for (let i = 0; i < keys.length; i += 1) {
                const key = Number(keys[i]);
                if (platform & key) {
                    const idx = data.map[key];
                    if (isMatch(idx)) {
                        return true;
                    }
                }
            }
            return false;
        }
        const idx = data.map[platform];
        return isMatch(idx);
    }
    /**
     * Returns a compatibility data by name and specific platform.
     *
     * @param name The name of the compatibility data.
     * @param platform The specific platform.
     *
     * @returns A single compatibility data or `null` if not found.
     */
    getSingle(name, platform) {
        const normalizedName = this.nameTransformer ? this.nameTransformer(name) : name;
        const data = this.getRowStorage(normalizedName);
        if (!data) {
            return null;
        }
        const idx = data.map[platform];
        return (0,type_guards/* isUndefined */.b0)(idx) ? null : data.shared[idx];
    }
    /**
     * Returns all compatibility data records for name and specified platform.
     *
     * @param name Compatibility data name.
     * @param platform Specific or generic platform.
     *
     * @returns Multiple records grouped by platforms.
     * Technically, it is an object where keys are platform enums values and values are compatibility data records.
     *
     * @note Platform enum values can be converted to string names using {@link getSpecificPlatformName} on demand.
     */
    getMultiple(name, platform) {
        const normalizedName = this.nameTransformer ? this.nameTransformer(name) : name;
        const data = this.getRowStorage(normalizedName);
        if (!data) {
            return null;
        }
        if (isGenericPlatform(platform)) {
            const result = {};
            const keys = Object.keys(data.map);
            for (let i = 0; i < keys.length; i += 1) {
                const key = Number(keys[i]);
                if (platform & key) {
                    const idx = data.map[key];
                    if (!(0,type_guards/* isUndefined */.b0)(idx)) {
                        result[key] = data.shared[idx];
                    }
                }
            }
            return result;
        }
        const idx = data.map[platform];
        if ((0,type_guards/* isUndefined */.b0)(idx)) {
            return null;
        }
        return { key: data.shared[idx] };
    }
    /**
     * Returns all compatibility data records for the specified platform.
     *
     * @param platform Specific or generic platform.
     *
     * @returns Array of multiple records grouped by platforms.
     */
    getAllMultiple(platform) {
        const result = [];
        for (let i = 0; i < this.data.shared.length; i += 1) {
            const data = this.data.shared[i];
            const names = new Set(data.shared.map(({ name }) => name));
            names.forEach((name) => {
                const multipleRecords = this.getMultiple(name, platform);
                if (multipleRecords) {
                    result.push(multipleRecords);
                }
            });
        }
        return result;
    }
    /**
     * Returns the first compatibility data record for name and specified platform.
     *
     * @param name Compatibility data name.
     * @param platform Specific or generic platform.
     *
     * @returns First found compatibility data record or `null` if not found.
     */
    getFirst(name, platform) {
        const normalizedName = this.nameTransformer ? this.nameTransformer(name) : name;
        const data = this.getRowStorage(normalizedName);
        if (!data) {
            return null;
        }
        if (isGenericPlatform(platform)) {
            const keys = Object.keys(data.map);
            for (let i = 0; i < keys.length; i += 1) {
                const key = Number(keys[i]);
                if (platform & key) {
                    const idx = data.map[key];
                    if (!(0,type_guards/* isUndefined */.b0)(idx)) {
                        // return the first found record
                        return data.shared[idx];
                    }
                }
            }
            return null;
        }
        const idx = data.map[platform];
        if ((0,type_guards/* isUndefined */.b0)(idx)) {
            return null;
        }
        return data.shared[idx];
    }
    /**
     * Returns all compatibility data records for the specified name.
     *
     * @param name Compatibility data name.
     *
     * @returns Array of multiple records grouped by platforms.
     */
    getRow(name) {
        const normalizedName = this.nameTransformer ? this.nameTransformer(name) : name;
        const data = this.getRowStorage(normalizedName);
        if (!data) {
            return [];
        }
        return data.shared;
    }
    /**
     * Returns all compatibility data grouped by products.
     *
     * @returns Array of multiple records grouped by products.
     */
    getRowsByProduct() {
        const result = [];
        for (let i = 0; i < this.data.shared.length; i += 1) {
            const data = this.data.shared[i];
            const keys = Object.keys(data.map);
            const row = {
                [adblockers/* AdblockSyntax */.Y.Adg]: {},
                [adblockers/* AdblockSyntax */.Y.Ubo]: {},
                [adblockers/* AdblockSyntax */.Y.Abp]: {},
            };
            for (let j = 0; j < keys.length; j += 1) {
                const key = Number(keys[j]);
                if (key & GenericPlatform.AdgAny) {
                    row[adblockers/* AdblockSyntax */.Y.Adg][key] = data.shared[data.map[key]];
                }
                else if (key & GenericPlatform.UboAny) {
                    row[adblockers/* AdblockSyntax */.Y.Ubo][key] = data.shared[data.map[key]];
                }
                else if (key & GenericPlatform.AbpAny) {
                    row[adblockers/* AdblockSyntax */.Y.Abp][key] = data.shared[data.map[key]];
                }
            }
            result.push(row);
        }
        return result;
    }
}



;// ./node_modules/.pnpm/@adguard+agtree@3.1.3/node_modules/@adguard/agtree/dist/compatibility-tables/compatibility-table-data.js
/*
 * AGTree v3.1.3 (build date: Tue, 29 Apr 2025 12:25:03 GMT)
 * (c) 2025 Adguard Software Ltd.
 * Released under the MIT license
 * https://github.com/AdguardTeam/tsurlfilter/tree/master/packages/agtree#readme
 */
const modifiersCompatibilityTableData = {shared:[{shared:[{name:'all',aliases:null,description:'$all modifier is made of $document, $popup, and all content-type modifiers combined.',docs:'https://adguard.app/kb/general/ad-filtering/create-own-filters/#all-modifier',versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,conflicts:null,inverseConflicts:false,assignable:false,negatable:false,blockOnly:true,exceptionOnly:false,valueOptional:false,valueFormat:null,valueFormatFlags:null},{name:'all',aliases:null,description:'The `all` option is equivalent to specifying all network-based types\n+ `popup`, `document`, `inline-font` and `inline-script`.',docs:'https://github.com/gorhill/uBlock/wiki/Static-filter-syntax#all',versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,conflicts:null,inverseConflicts:false,assignable:false,negatable:false,blockOnly:false,exceptionOnly:false,valueOptional:false,valueFormat:null,valueFormatFlags:null}],map:{'1':0,'2':0,'4':0,'8':0,'16':0,'32':0,'64':0,'256':0,'512':0,'1024':1,'2048':1,'4096':1,'8192':1}},{shared:[{name:'app',aliases:null,description:'The `$app` modifier lets you narrow the rule coverage down to a specific application or a list of applications.\nThe modifier\'s behavior and syntax perfectly match the corresponding basic rules `$app` modifier.',docs:'https://adguard.app/kb/general/ad-filtering/create-own-filters/#app-modifier',versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,conflicts:null,inverseConflicts:false,assignable:true,negatable:false,blockOnly:false,exceptionOnly:false,valueOptional:false,valueFormat:'pipe_separated_apps',valueFormatFlags:null}],map:{'1':0,'2':0,'4':0}},{shared:[{name:'badfilter',aliases:null,description:'The rules with the `$badfilter` modifier disable other basic rules to which they refer. It means that\nthe text of the disabled rule should match the text of the `$badfilter` rule (without the `$badfilter` modifier).',docs:'https://adguard.app/kb/general/ad-filtering/create-own-filters/#badfilter-modifier',versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,conflicts:null,inverseConflicts:false,assignable:false,negatable:false,blockOnly:false,exceptionOnly:false,valueOptional:false,valueFormat:null,valueFormatFlags:null},{name:'badfilter',aliases:null,description:'The rules with the `$badfilter` modifier disable other basic rules to which they refer. It means that\nthe text of the disabled rule should match the text of the `$badfilter` rule (without the `$badfilter` modifier).',docs:'https://github.com/gorhill/uBlock/wiki/Static-filter-syntax#badfilter',versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,conflicts:null,inverseConflicts:false,assignable:false,negatable:false,blockOnly:false,exceptionOnly:false,valueOptional:false,valueFormat:null,valueFormatFlags:null}],map:{'1':0,'2':0,'4':0,'8':0,'16':0,'32':0,'64':0,'256':0,'512':0,'1024':1,'2048':1,'4096':1,'8192':1}},{shared:[{name:'cname',aliases:null,description:'When used in an exception filter,\nit will bypass blocking CNAME uncloaked requests for the current (specified) document.',docs:'https://github.com/gorhill/uBlock/wiki/Static-filter-syntax#cname',versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,conflicts:null,inverseConflicts:false,assignable:false,negatable:false,blockOnly:false,exceptionOnly:true,valueOptional:false,valueFormat:null,valueFormatFlags:null}],map:{'1024':0,'2048':0,'4096':0,'8192':0}},{shared:[{name:'content',aliases:null,description:'Disables HTML filtering and `$replace` rules on the pages that match the rule.',docs:'https://adguard.app/kb/general/ad-filtering/create-own-filters/#content-modifier',versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,conflicts:null,inverseConflicts:false,assignable:false,negatable:false,blockOnly:false,exceptionOnly:true,valueOptional:false,valueFormat:null,valueFormatFlags:null}],map:{'1':0,'2':0,'4':0}},{shared:[{name:'cookie',aliases:null,description:'The `$cookie` modifier completely changes rule behavior.\nInstead of blocking a request, this modifier makes us suppress or modify the Cookie and Set-Cookie headers.',docs:'https://adguard.app/kb/general/ad-filtering/create-own-filters/#cookie-modifier',versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,conflicts:null,inverseConflicts:false,assignable:true,negatable:false,blockOnly:false,exceptionOnly:false,valueOptional:true,valueFormat:'^([^;=\\s]*?)((?:;(maxAge=\\d+;?)?|(sameSite=(lax|none|strict);?)?){1,3})(?<!;)$',valueFormatFlags:null}],map:{'1':0,'2':0,'4':0,'8':0,'16':0,'32':0,'64':0}},{shared:[{name:'csp',aliases:null,description:'This modifier completely changes the rule behavior.\nIf it is applied to a rule, it will not block the matching request.\nThe response headers are going to be modified instead.',docs:'https://adguard.app/kb/general/ad-filtering/create-own-filters/#csp-modifier',versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,conflicts:['domain','important','subdocument','badfilter'],inverseConflicts:true,assignable:true,negatable:false,blockOnly:false,exceptionOnly:false,valueOptional:true,valueFormat:'csp_value',valueFormatFlags:null},{name:'csp',aliases:null,description:'This modifier completely changes the rule behavior.\nIf it is applied to a rule, it will not block the matching request.\nThe response headers are going to be modified instead.',docs:'https://github.com/gorhill/uBlock/wiki/Static-filter-syntax#csp',versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,conflicts:['1p','3p','domain','badfilter'],inverseConflicts:true,assignable:true,negatable:false,blockOnly:false,exceptionOnly:false,valueOptional:true,valueFormat:'csp_value',valueFormatFlags:null},{name:'csp',aliases:null,description:'This modifier completely changes the rule behavior.\nIf it is applied to a rule, it will not block the matching request.\nThe response headers are going to be modified instead.',docs:'https://help.adblockplus.org/hc/en-us/articles/360062733293-How-to-write-filters#content-security-policies',versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,conflicts:['domain','subdocument'],inverseConflicts:true,assignable:true,negatable:false,blockOnly:false,exceptionOnly:false,valueOptional:true,valueFormat:'csp_value',valueFormatFlags:null}],map:{'1':0,'2':0,'4':0,'8':0,'16':0,'32':0,'64':0,'1024':1,'2048':1,'4096':1,'8192':1,'16384':2,'32768':2,'65536':2,'131072':2}},{shared:[{name:'denyallow',aliases:null,description:'The `$denyallow` modifier allows to avoid creating additional rules\nwhen it is needed to disable a certain rule for specific domains.\n`$denyallow` matches only target domains and not referrer domains.',docs:'https://adguard.app/kb/general/ad-filtering/create-own-filters/#denyallow-modifier',versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,conflicts:['to'],inverseConflicts:false,assignable:true,negatable:false,blockOnly:false,exceptionOnly:false,valueOptional:false,valueFormat:'pipe_separated_denyallow_domains',valueFormatFlags:null},{name:'denyallow',aliases:null,description:'The `$denyallow` modifier allows to avoid creating additional rules\nwhen it is needed to disable a certain rule for specific domains.\n`$denyallow` matches only target domains and not referrer domains.',docs:'https://github.com/gorhill/uBlock/wiki/Static-filter-syntax#denyallow',versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,conflicts:['to'],inverseConflicts:false,assignable:true,negatable:false,blockOnly:false,exceptionOnly:false,valueOptional:false,valueFormat:'pipe_separated_denyallow_domains',valueFormatFlags:null}],map:{'1':0,'2':0,'4':0,'8':0,'16':0,'32':0,'64':0,'256':0,'512':0,'1024':1,'2048':1,'4096':1,'8192':1}},{shared:[{name:'document',aliases:null,description:'The rule corresponds to the main frame document requests,\ni.e. HTML documents that are loaded in the browser tab.',docs:'https://adguard.app/kb/general/ad-filtering/create-own-filters/#document-modifier',versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,conflicts:null,inverseConflicts:false,assignable:false,negatable:false,blockOnly:false,exceptionOnly:false,valueOptional:false,valueFormat:null,valueFormatFlags:null},{name:'document',aliases:null,description:'The rule corresponds to the main frame document requests,\ni.e. HTML documents that are loaded in the browser tab.',docs:'https://adguard.app/kb/general/ad-filtering/create-own-filters/#document-modifier',versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,conflicts:null,inverseConflicts:false,assignable:false,negatable:false,blockOnly:false,exceptionOnly:false,valueOptional:false,valueFormat:null,valueFormatFlags:null},{name:'document',aliases:null,description:'The rule corresponds to the main frame document requests,\ni.e. HTML documents that are loaded in the browser tab.',docs:'https://adguard.app/kb/general/ad-filtering/create-own-filters/#document-modifier',versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,conflicts:null,inverseConflicts:false,assignable:false,negatable:false,blockOnly:false,exceptionOnly:false,valueOptional:false,valueFormat:null,valueFormatFlags:null},{name:'document',aliases:null,description:'The rule corresponds to the main frame document requests,\ni.e. HTML documents that are loaded in the browser tab.',docs:'https://adguard.app/kb/general/ad-filtering/create-own-filters/#document-modifier',versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,conflicts:null,inverseConflicts:false,assignable:false,negatable:false,blockOnly:false,exceptionOnly:false,valueOptional:false,valueFormat:null,valueFormatFlags:null},{name:'document',aliases:['doc'],description:'The rule corresponds to the main frame document requests,\ni.e. HTML documents that are loaded in the browser tab.',docs:'https://github.com/gorhill/uBlock/wiki/Static-filter-syntax#document',versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,conflicts:null,inverseConflicts:false,assignable:false,negatable:false,blockOnly:false,exceptionOnly:false,valueOptional:false,valueFormat:null,valueFormatFlags:null},{name:'document',aliases:null,description:'The rule corresponds to the main frame document requests,\ni.e. HTML documents that are loaded in the browser tab.',docs:'https://help.adblockplus.org/hc/en-us/articles/360062733293-How-to-write-filters#allowlist',versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,conflicts:null,inverseConflicts:false,assignable:false,negatable:false,blockOnly:false,exceptionOnly:false,valueOptional:false,valueFormat:null,valueFormatFlags:null}],map:{'1':0,'2':0,'4':0,'8':1,'16':1,'32':1,'64':1,'256':2,'512':3,'1024':4,'2048':4,'4096':4,'8192':4,'16384':5,'32768':5,'65536':5,'131072':5}},{shared:[{name:'domain',aliases:['from'],description:'The `$domain` modifier limits the rule application area to a list of domains and their subdomains.',docs:'https://adguard.app/kb/general/ad-filtering/create-own-filters/#domain-modifier',versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,conflicts:null,inverseConflicts:false,assignable:true,negatable:false,blockOnly:false,exceptionOnly:false,valueOptional:false,valueFormat:'pipe_separated_domains',valueFormatFlags:null},{name:'domain',aliases:['from'],description:'The `$domain` modifier limits the rule application area to a list of domains and their subdomains.',docs:'https://github.com/gorhill/uBlock/wiki/Static-filter-syntax#from',versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,conflicts:null,inverseConflicts:false,assignable:true,negatable:false,blockOnly:false,exceptionOnly:false,valueOptional:false,valueFormat:'pipe_separated_domains',valueFormatFlags:null},{name:'domain',aliases:null,description:'The `$domain` modifier limits the rule application area to a list of domains and their subdomains.',docs:'https://help.adblockplus.org/hc/en-us/articles/360062733293-How-to-write-filters#domain-restrictions',versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,conflicts:null,inverseConflicts:false,assignable:true,negatable:false,blockOnly:false,exceptionOnly:false,valueOptional:false,valueFormat:'pipe_separated_domains',valueFormatFlags:null}],map:{'1':0,'2':0,'4':0,'8':0,'16':0,'32':0,'64':0,'128':0,'256':0,'512':0,'1024':1,'2048':1,'4096':1,'8192':1,'16384':2,'32768':2,'65536':2,'131072':2}},{shared:[{name:'elemhide',aliases:['ehide'],description:'Disables any cosmetic rules on the pages matching the rule.',docs:'https://adguard.app/kb/general/ad-filtering/create-own-filters/#elemhide-modifier',versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,conflicts:null,inverseConflicts:false,assignable:false,negatable:false,blockOnly:false,exceptionOnly:true,valueOptional:false,valueFormat:null,valueFormatFlags:null},{name:'elemhide',aliases:['ehide'],description:'Disables any cosmetic rules on the pages matching the rule.',docs:'https://github.com/gorhill/uBlock/wiki/Static-filter-syntax#elemhide-1',versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,conflicts:null,inverseConflicts:false,assignable:false,negatable:false,blockOnly:false,exceptionOnly:true,valueOptional:false,valueFormat:null,valueFormatFlags:null},{name:'elemhide',aliases:['ehide'],description:'Disables any cosmetic rules on the pages matching the rule.',docs:'https://help.adblockplus.org/hc/en-us/articles/360062733293-How-to-write-filters#type-options',versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,conflicts:null,inverseConflicts:false,assignable:false,negatable:false,blockOnly:false,exceptionOnly:true,valueOptional:false,valueFormat:null,valueFormatFlags:null}],map:{'1':0,'2':0,'4':0,'8':0,'16':0,'32':0,'64':0,'128':0,'256':0,'512':0,'1024':1,'2048':1,'4096':1,'8192':1,'16384':2,'32768':2,'65536':2,'131072':2}},{shared:[{name:'empty',aliases:null,description:'This modifier is deprecated in favor of the $redirect modifier.\nRules with `$empty` are still supported and being converted into `$redirect=nooptext` now\nbut the support shall be removed in the future.',docs:'https://adguard.app/kb/general/ad-filtering/create-own-filters/#empty-modifier',versionAdded:null,versionRemoved:null,deprecated:true,deprecationMessage:'Rules with `$empty` are still supported and being converted into `$redirect=nooptext` now\nbut the support shall be removed in the future.',removed:false,removalMessage:null,conflicts:null,inverseConflicts:false,assignable:false,negatable:false,blockOnly:false,exceptionOnly:false,valueOptional:false,valueFormat:null,valueFormatFlags:null},{name:'empty',aliases:null,description:'This modifier is deprecated in favor of the $redirect modifier.\nRules with `$empty` are still supported and being converted into `$redirect=nooptext` now\nbut the support shall be removed in the future.',docs:'https://adguard.app/kb/general/ad-filtering/create-own-filters/#empty-modifier',versionAdded:null,versionRemoved:null,deprecated:true,deprecationMessage:'Rules with `$empty` are still supported and being converted into `$redirect=nooptext` now\nbut the support shall be removed in the future.',removed:false,removalMessage:null,conflicts:null,inverseConflicts:false,assignable:false,negatable:false,blockOnly:false,exceptionOnly:false,valueOptional:false,valueFormat:null,valueFormatFlags:null},{name:'empty',aliases:null,description:'This modifier is deprecated in favor of the $redirect modifier.\nRules with `$empty` are supported and being converted into `$redirect=nooptext`.',docs:'https://github.com/gorhill/uBlock/wiki/Static-filter-syntax#empty',versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,conflicts:null,inverseConflicts:false,assignable:false,negatable:false,blockOnly:false,exceptionOnly:false,valueOptional:false,valueFormat:null,valueFormatFlags:null}],map:{'1':0,'2':0,'4':0,'8':1,'16':1,'32':1,'64':1,'1024':2,'2048':2,'4096':2,'8192':2}},{shared:[{name:'extension',aliases:null,description:'Disables all userscripts on the pages matching this rule.',docs:'https://adguard.app/kb/general/ad-filtering/create-own-filters/#extension-modifier',versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,conflicts:['domain','specifichide','generichide','elemhide','genericblock','urlblock','jsinject','content','xmlhttprequest','badfilter'],inverseConflicts:true,assignable:false,negatable:true,blockOnly:false,exceptionOnly:true,valueOptional:false,valueFormat:null,valueFormatFlags:null}],map:{'1':0,'2':0,'4':0}},{shared:[{name:'first-party',aliases:['1p','~third-party'],description:'A restriction of first-party requests. Equal to `~third-party`.',docs:'https://adguard.app/kb/general/ad-filtering/create-own-filters/#third-party-modifier',versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,conflicts:null,inverseConflicts:false,assignable:false,negatable:false,blockOnly:false,exceptionOnly:false,valueOptional:false,valueFormat:null,valueFormatFlags:null},{name:'first-party',aliases:['1p','~third-party'],description:'A restriction of first-party requests. Equal to `~third-party`.',docs:'https://github.com/gorhill/uBlock/wiki/Static-filter-syntax#1p',versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,conflicts:null,inverseConflicts:false,assignable:false,negatable:false,blockOnly:false,exceptionOnly:false,valueOptional:false,valueFormat:null,valueFormatFlags:null}],map:{'1':0,'2':0,'4':0,'8':0,'16':0,'32':0,'64':0,'128':0,'256':0,'512':0,'1024':1,'2048':1,'4096':1,'8192':1}},{shared:[{name:'font',aliases:null,description:'The rule corresponds to requests for fonts, e.g. `.woff` filename extension.',docs:'https://adguard.app/kb/general/ad-filtering/create-own-filters/#font-modifier',versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,conflicts:null,inverseConflicts:false,assignable:false,negatable:true,blockOnly:false,exceptionOnly:false,valueOptional:false,valueFormat:null,valueFormatFlags:null},{name:'font',aliases:null,description:'The rule corresponds to requests for fonts, e.g. `.woff` filename extension.',docs:'https://help.adblockplus.org/hc/en-us/articles/360062733293#options',versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,conflicts:null,inverseConflicts:false,assignable:false,negatable:true,blockOnly:false,exceptionOnly:false,valueOptional:false,valueFormat:null,valueFormatFlags:null},{name:'font',aliases:null,description:'The rule corresponds to requests for fonts, e.g. `.woff` filename extension.',docs:'https://help.adblockplus.org/hc/en-us/articles/360062733293#options',versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,conflicts:null,inverseConflicts:false,assignable:false,negatable:true,blockOnly:false,exceptionOnly:false,valueOptional:false,valueFormat:null,valueFormatFlags:null}],map:{'1':0,'2':0,'4':0,'8':0,'16':0,'32':0,'64':0,'128':0,'256':0,'512':0,'1024':1,'2048':1,'4096':1,'8192':1,'16384':2,'32768':2,'65536':2,'131072':2}},{shared:[{name:'genericblock',aliases:null,description:'Disables generic basic rules on pages that correspond to exception rule.',docs:'https://adguard.app/kb/general/ad-filtering/create-own-filters/#genericblock-modifier',versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,conflicts:['domain','specifichide','generichide','elemhide','extension','jsinject','content','badfilter'],inverseConflicts:true,assignable:false,negatable:false,blockOnly:false,exceptionOnly:true,valueOptional:false,valueFormat:null,valueFormatFlags:null},{name:'genericblock',aliases:null,description:'Disables generic basic rules on pages that correspond to exception rule.',docs:'https://adguard.app/kb/general/ad-filtering/create-own-filters/#genericblock-modifier',versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,conflicts:['domain','specifichide','generichide','elemhide','jsinject','badfilter'],inverseConflicts:true,assignable:false,negatable:false,blockOnly:false,exceptionOnly:true,valueOptional:false,valueFormat:null,valueFormatFlags:null},{name:'genericblock',aliases:null,description:'Disables generic basic rules on pages that correspond to exception rule.',docs:'https://adguard.app/kb/general/ad-filtering/create-own-filters/#genericblock-modifier',versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,conflicts:['domain','specifichide','generichide','elemhide','jsinject','badfilter'],inverseConflicts:true,assignable:false,negatable:false,blockOnly:false,exceptionOnly:true,valueOptional:false,valueFormat:null,valueFormatFlags:null},{name:'genericblock',aliases:null,description:'Disables generic basic rules on pages that correspond to exception rule.',docs:'https://adguard.app/kb/general/ad-filtering/create-own-filters/#genericblock-modifier',versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,conflicts:['domain','specifichide','generichide','elemhide','jsinject','badfilter'],inverseConflicts:true,assignable:false,negatable:false,blockOnly:false,exceptionOnly:true,valueOptional:false,valueFormat:null,valueFormatFlags:null},{name:'genericblock',aliases:null,description:'Disables generic basic rules on pages that correspond to exception rule.',docs:'https://help.adblockplus.org/hc/en-us/articles/360062733293-How-to-write-filters#type-options',versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,conflicts:null,inverseConflicts:false,assignable:false,negatable:false,blockOnly:false,exceptionOnly:true,valueOptional:false,valueFormat:null,valueFormatFlags:null}],map:{'1':0,'2':0,'4':0,'8':1,'16':1,'32':1,'64':1,'256':2,'512':3,'16384':4,'32768':4,'65536':4,'131072':4}},{shared:[{name:'generichide',aliases:['ghide'],description:'Disables all generic cosmetic rules.',docs:'https://adguard.app/kb/general/ad-filtering/create-own-filters/#generichide-modifier',versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,conflicts:['domain','genericblock','urlblock','extension','jsinject','content','xmlhttprequest','badfilter'],inverseConflicts:true,assignable:false,negatable:false,blockOnly:false,exceptionOnly:true,valueOptional:false,valueFormat:null,valueFormatFlags:null},{name:'generichide',aliases:['ghide'],description:'Disables all generic cosmetic rules.',docs:'https://github.com/gorhill/uBlock/wiki/Static-filter-syntax#generichide',versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,conflicts:['domain','badfilter'],inverseConflicts:true,assignable:false,negatable:false,blockOnly:false,exceptionOnly:true,valueOptional:false,valueFormat:null,valueFormatFlags:null},{name:'generichide',aliases:null,description:'Disables all generic cosmetic rules.',docs:'https://help.adblockplus.org/hc/en-us/articles/360062733293-How-to-write-filters#type-options',versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,conflicts:['domain'],inverseConflicts:true,assignable:false,negatable:false,blockOnly:false,exceptionOnly:true,valueOptional:false,valueFormat:null,valueFormatFlags:null}],map:{'1':0,'2':0,'4':0,'8':0,'16':0,'32':0,'64':0,'128':0,'256':0,'512':0,'1024':1,'2048':1,'4096':1,'8192':1,'16384':2,'32768':2,'65536':2,'131072':2}},{shared:[{name:'header',aliases:null,description:'The `$header` modifier allows matching the HTTP response\nhaving a specific header with (optionally) a specific value.',docs:'https://adguard.app/kb/general/ad-filtering/create-own-filters/#header-modifier',versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,conflicts:null,inverseConflicts:false,assignable:true,negatable:true,blockOnly:false,exceptionOnly:false,valueOptional:false,valueFormat:'^(?:)[\\w-]+(:(?:)(\\w+|\\/.+\\/))?',valueFormatFlags:'i'},{name:'header',aliases:null,description:'The `$header` modifier allows matching the HTTP response\nhaving a specific header with (optionally) a specific value.',docs:'https://adguard.app/kb/general/ad-filtering/create-own-filters/#header-modifier',versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,conflicts:null,inverseConflicts:false,assignable:true,negatable:true,blockOnly:false,exceptionOnly:false,valueOptional:false,valueFormat:'^(?:)[\\w-]+(:(?:)(\\w+|\\/.+\\/))?',valueFormatFlags:'i'},{name:'header',aliases:null,description:'The `$header` modifier allows matching the HTTP response\nhaving a specific header with (optionally) a specific value.',docs:'https://github.com/gorhill/uBlock/wiki/Static-filter-syntax#header',versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,conflicts:null,inverseConflicts:false,assignable:true,negatable:true,blockOnly:false,exceptionOnly:false,valueOptional:false,valueFormat:'^(?:)[\\w-]+(:(?:)(\\w+|\\/.+\\/))?',valueFormatFlags:'i'}],map:{'1':0,'2':0,'4':0,'8':1,'16':1,'32':1,'64':1,'1024':2,'2048':2,'4096':2,'8192':2}},{shared:[{name:'hls',aliases:null,description:'The `$hls` rules modify the response of a matching request.\nThey are intended as a convenient way to remove segments from HLS playlists (RFC 8216).',docs:'https://adguard.app/kb/general/ad-filtering/create-own-filters/#hls-modifier',versionAdded:'CoreLibs 1.10',versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,conflicts:['domain','third-party','app','important','match-case','xmlhttprequest'],inverseConflicts:true,assignable:true,negatable:false,blockOnly:false,exceptionOnly:false,valueOptional:true,valueFormat:'((?:)\\w+(?:)|(?:)\\/.+\\/(?:)([ti]*)?)',valueFormatFlags:'i'}],map:{'1':0,'2':0,'4':0}},{shared:[{name:'image',aliases:null,description:'The rule corresponds to images requests.',docs:'https://adguard.app/kb/general/ad-filtering/create-own-filters/#image-modifier',versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,conflicts:null,inverseConflicts:false,assignable:false,negatable:true,blockOnly:false,exceptionOnly:false,valueOptional:false,valueFormat:null,valueFormatFlags:null},{name:'image',aliases:null,description:'The rule corresponds to images requests.',docs:'https://help.adblockplus.org/hc/en-us/articles/360062733293#options',versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,conflicts:null,inverseConflicts:false,assignable:false,negatable:true,blockOnly:false,exceptionOnly:false,valueOptional:false,valueFormat:null,valueFormatFlags:null},{name:'image',aliases:null,description:'The rule corresponds to images requests.',docs:'https://help.adblockplus.org/hc/en-us/articles/360062733293#options',versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,conflicts:null,inverseConflicts:false,assignable:false,negatable:true,blockOnly:false,exceptionOnly:false,valueOptional:false,valueFormat:null,valueFormatFlags:null}],map:{'1':0,'2':0,'4':0,'8':0,'16':0,'32':0,'64':0,'128':0,'256':0,'512':0,'1024':1,'2048':1,'4096':1,'8192':1,'16384':2,'32768':2,'65536':2,'131072':2}},{shared:[{name:'important',aliases:null,description:'The `$important` modifier applied to a rule increases its priority\nover any other rule without `$important` modifier. Even over basic exception rules.',docs:'https://adguard.app/kb/general/ad-filtering/create-own-filters/#important-modifier',versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,conflicts:null,inverseConflicts:false,assignable:false,negatable:false,blockOnly:false,exceptionOnly:false,valueOptional:false,valueFormat:null,valueFormatFlags:null},{name:'important',aliases:null,description:'The `$important` modifier applied to a rule increases its priority\nover any other rule without `$important` modifier. Even over basic exception rules.',docs:'https://github.com/gorhill/uBlock/wiki/Static-filter-syntax#important',versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,conflicts:null,inverseConflicts:false,assignable:false,negatable:false,blockOnly:false,exceptionOnly:false,valueOptional:false,valueFormat:null,valueFormatFlags:null}],map:{'1':0,'2':0,'4':0,'8':0,'16':0,'32':0,'64':0,'128':0,'256':0,'512':0,'1024':1,'2048':1,'4096':1,'8192':1}},{shared:[{name:'inline-font',aliases:null,description:'The `$inline-font` modifier is a sort of a shortcut for $csp modifier with specific value.\nE.g. `||example.org^$inline-font` is converting into:\n```adblock\n||example.org^$csp=font-src \'self\' \'unsafe-eval\' http: https: data: blob: mediastream: filesystem:\n```',docs:'https://adguard.app/kb/general/ad-filtering/create-own-filters/#inline-font-modifier',versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,conflicts:null,inverseConflicts:false,assignable:false,negatable:true,blockOnly:false,exceptionOnly:false,valueOptional:false,valueFormat:null,valueFormatFlags:null},{name:'inline-font',aliases:null,description:'The `$inline-font` modifier is a sort of a shortcut for $csp modifier with specific value.\nE.g. `||example.org^$inline-font` is converting into:\n```adblock\n||example.org^$csp=font-src \'self\' \'unsafe-eval\' http: https: data: blob: mediastream: filesystem:\n```',docs:'https://adguard.app/kb/general/ad-filtering/create-own-filters/#inline-font-modifier',versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,conflicts:null,inverseConflicts:false,assignable:false,negatable:true,blockOnly:false,exceptionOnly:false,valueOptional:false,valueFormat:null,valueFormatFlags:null},{name:'inline-font',aliases:null,description:'The `$inline-font` modifier is a sort of a shortcut for $csp modifier with specific value.\nE.g. `||example.org^$inline-font` is converting into:\n```adblock\n||example.org^$csp=font-src \'self\' \'unsafe-eval\' http: https: data: blob: mediastream: filesystem:\n```',docs:'https://github.com/gorhill/uBlock/wiki/Static-filter-syntax#inline-font',versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,conflicts:null,inverseConflicts:false,assignable:false,negatable:true,blockOnly:false,exceptionOnly:false,valueOptional:false,valueFormat:null,valueFormatFlags:null}],map:{'1':0,'2':0,'4':0,'8':1,'16':1,'32':1,'64':1,'1024':2,'2048':2,'4096':2,'8192':2}},{shared:[{name:'inline-script',aliases:null,description:'The `$inline-script` modifier is a sort of a shortcut for $csp modifier with specific value.\nE.g. `||example.org^$inline-script` is converting into:\n```adblock\n||example.org^$csp=script-src \'self\' \'unsafe-eval\' http: https: data: blob: mediastream: filesystem:\n```',docs:'https://adguard.app/kb/general/ad-filtering/create-own-filters/#inline-script-modifier',versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,conflicts:null,inverseConflicts:false,assignable:false,negatable:true,blockOnly:false,exceptionOnly:false,valueOptional:false,valueFormat:null,valueFormatFlags:null},{name:'inline-script',aliases:null,description:'The `$inline-script` modifier is a sort of a shortcut for $csp modifier with specific value.\nE.g. `||example.org^$inline-script` is converting into:\n```adblock\n||example.org^$csp=script-src \'self\' \'unsafe-eval\' http: https: data: blob: mediastream: filesystem:\n```',docs:'https://adguard.app/kb/general/ad-filtering/create-own-filters/#inline-script-modifier',versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,conflicts:null,inverseConflicts:false,assignable:false,negatable:true,blockOnly:false,exceptionOnly:false,valueOptional:false,valueFormat:null,valueFormatFlags:null},{name:'inline-script',aliases:null,description:'The `$inline-script` modifier is a sort of a shortcut for $csp modifier with specific value.\nE.g. `||example.org^$inline-script` is converting into:\n```adblock\n||example.org^$csp=script-src \'self\' \'unsafe-eval\' http: https: data: blob: mediastream: filesystem:\n```',docs:'https://github.com/gorhill/uBlock/wiki/Static-filter-syntax#inline-script',versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,conflicts:null,inverseConflicts:false,assignable:false,negatable:true,blockOnly:false,exceptionOnly:false,valueOptional:false,valueFormat:null,valueFormatFlags:null}],map:{'1':0,'2':0,'4':0,'8':1,'16':1,'32':1,'64':1,'1024':2,'2048':2,'4096':2,'8192':2}},{shared:[{name:'jsinject',aliases:null,description:'Forbids adding of javascript code to the page.',docs:'https://adguard.app/kb/general/ad-filtering/create-own-filters/#jsinject-modifier',versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,conflicts:['domain','specifichide','generichide','elemhide','genericblock','urlblock','extension','content','xmlhttprequest','badfilter'],inverseConflicts:true,assignable:false,negatable:false,blockOnly:false,exceptionOnly:true,valueOptional:false,valueFormat:null,valueFormatFlags:null},{name:'jsinject',aliases:null,description:'Forbids adding of javascript code to the page.',docs:'https://adguard.app/kb/general/ad-filtering/create-own-filters/#jsinject-modifier',versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,conflicts:['domain','specifichide','generichide','elemhide','genericblock','urlblock','xmlhttprequest','badfilter'],inverseConflicts:true,assignable:false,negatable:false,blockOnly:false,exceptionOnly:true,valueOptional:false,valueFormat:null,valueFormatFlags:null},{name:'jsinject',aliases:null,description:'Forbids adding of javascript code to the page.',docs:'https://adguard.app/kb/general/ad-filtering/create-own-filters/#jsinject-modifier',versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,conflicts:['domain','specifichide','generichide','elemhide','genericblock','urlblock','xmlhttprequest','badfilter'],inverseConflicts:true,assignable:false,negatable:false,blockOnly:false,exceptionOnly:true,valueOptional:false,valueFormat:null,valueFormatFlags:null},{name:'jsinject',aliases:null,description:'Forbids adding of javascript code to the page.',docs:'https://adguard.app/kb/general/ad-filtering/create-own-filters/#jsinject-modifier',versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,conflicts:['domain','specifichide','generichide','elemhide','genericblock','urlblock','xmlhttprequest','badfilter'],inverseConflicts:true,assignable:false,negatable:false,blockOnly:false,exceptionOnly:true,valueOptional:false,valueFormat:null,valueFormatFlags:null}],map:{'1':0,'2':0,'4':0,'8':1,'16':1,'32':1,'64':1,'256':2,'512':3}},{shared:[{name:'jsonprune',aliases:null,description:'The `$jsonprune` rules modify the response to a matching request\nby removing JSON items that match a modified JSONPath expression.\nThey do not modify responses which are not valid JSON documents.',docs:'https://adguard.app/kb/general/ad-filtering/create-own-filters/#jsonprune-modifier',versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,conflicts:null,inverseConflicts:false,assignable:true,negatable:false,blockOnly:false,exceptionOnly:false,valueOptional:true,valueFormat:'^(?:)\\\\(?:)\\$(?:)\\.?(?:).+(?:)$',valueFormatFlags:'i'}],map:{'1':0,'2':0,'4':0}},{shared:[{name:'match-case',aliases:null,description:'This modifier defines a rule which applies only to addresses that match the case.\nDefault rules are case-insensitive.',docs:'https://adguard.app/kb/general/ad-filtering/create-own-filters/#match-case-modifier',versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,conflicts:null,inverseConflicts:false,assignable:false,negatable:true,blockOnly:false,exceptionOnly:false,valueOptional:false,valueFormat:null,valueFormatFlags:null},{name:'match-case',aliases:null,description:'This modifier defines a rule which applies only to addresses that match the case.\nDefault rules are case-insensitive.',docs:'https://github.com/gorhill/uBlock/wiki/Static-filter-syntax#match-case',versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,conflicts:null,inverseConflicts:false,assignable:false,negatable:true,blockOnly:false,exceptionOnly:false,valueOptional:false,valueFormat:null,valueFormatFlags:null},{name:'match-case',aliases:null,description:'This modifier defines a rule which applies only to addresses that match the case.\nDefault rules are case-insensitive.',docs:'https://help.adblockplus.org/hc/en-us/articles/360062733293-How-to-write-filters#type-options',versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,conflicts:null,inverseConflicts:false,assignable:false,negatable:true,blockOnly:false,exceptionOnly:false,valueOptional:false,valueFormat:null,valueFormatFlags:null}],map:{'1':0,'2':0,'4':0,'8':0,'16':0,'32':0,'64':0,'128':0,'256':0,'512':0,'1024':1,'2048':1,'4096':1,'8192':1,'16384':2,'32768':2,'65536':2,'131072':2}},{shared:[{name:'media',aliases:null,description:'A restriction of third-party and own requests.\nA third-party request is a request from a different domain.\nFor example, a request to `example.org` from `domain.com` is a third-party request.',docs:'https://adguard.app/kb/general/ad-filtering/create-own-filters/#media-modifier',versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,conflicts:null,inverseConflicts:false,assignable:false,negatable:true,blockOnly:false,exceptionOnly:false,valueOptional:false,valueFormat:null,valueFormatFlags:null},{name:'media',aliases:null,description:'A restriction of third-party and own requests.\nA third-party request is a request from a different domain.\nFor example, a request to `example.org` from `domain.com` is a third-party request.',docs:'https://help.adblockplus.org/hc/en-us/articles/360062733293#options',versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,conflicts:null,inverseConflicts:false,assignable:false,negatable:true,blockOnly:false,exceptionOnly:false,valueOptional:false,valueFormat:null,valueFormatFlags:null},{name:'media',aliases:null,description:'A restriction of third-party and own requests.\nA third-party request is a request from a different domain.\nFor example, a request to `example.org` from `domain.com` is a third-party request.',docs:'https://help.adblockplus.org/hc/en-us/articles/360062733293#options',versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,conflicts:null,inverseConflicts:false,assignable:false,negatable:true,blockOnly:false,exceptionOnly:false,valueOptional:false,valueFormat:null,valueFormatFlags:null}],map:{'1':0,'2':0,'4':0,'8':0,'16':0,'32':0,'64':0,'128':0,'256':0,'512':0,'1024':1,'2048':1,'4096':1,'8192':1,'16384':2,'32768':2,'65536':2,'131072':2}},{shared:[{name:'method',aliases:null,description:'This modifier limits the rule scope to requests that use the specified set of HTTP methods.\nNegated methods are allowed.',docs:'https://adguard.app/kb/general/ad-filtering/create-own-filters/#method-modifier',versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,conflicts:null,inverseConflicts:false,assignable:true,negatable:false,blockOnly:false,exceptionOnly:false,valueOptional:false,valueFormat:'pipe_separated_methods',valueFormatFlags:null},{name:'method',aliases:null,description:'This modifier limits the rule scope to requests that use the specified set of HTTP methods.\nNegated methods are allowed.',docs:'https://adguard.app/kb/general/ad-filtering/create-own-filters/#method-modifier',versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,conflicts:null,inverseConflicts:false,assignable:true,negatable:false,blockOnly:false,exceptionOnly:false,valueOptional:false,valueFormat:'pipe_separated_methods',valueFormatFlags:null},{name:'method',aliases:null,description:'This modifier limits the rule scope to requests that use the specified set of HTTP methods.\nNegated methods are allowed.',docs:'https://github.com/gorhill/uBlock/wiki/Static-filter-syntax#method',versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,conflicts:null,inverseConflicts:false,assignable:true,negatable:false,blockOnly:false,exceptionOnly:false,valueOptional:false,valueFormat:'pipe_separated_methods',valueFormatFlags:null}],map:{'1':0,'2':0,'4':0,'8':1,'16':1,'32':1,'64':1,'1024':2,'2048':2,'4096':2,'8192':2}},{shared:[{name:'mp4',aliases:null,description:'As a response to blocked request AdGuard returns a short video placeholder.\nRules with `$mp4` are still supported and being converted into `$redirect=noopmp4-1s` now\nbut the support shall be removed in the future.',docs:'https://adguard.app/kb/general/ad-filtering/create-own-filters/#mp4-modifier',versionAdded:null,versionRemoved:null,deprecated:true,deprecationMessage:'Rules with `$mp4` are still supported and being converted into `$redirect=noopmp4-1s` now\nbut the support shall be removed in the future.',removed:false,removalMessage:null,conflicts:null,inverseConflicts:false,assignable:false,negatable:false,blockOnly:false,exceptionOnly:false,valueOptional:false,valueFormat:null,valueFormatFlags:null},{name:'mp4',aliases:null,description:'As a response to blocked request AdGuard returns a short video placeholder.\nRules with `$mp4` are still supported and being converted into `$redirect=noopmp4-1s` now\nbut the support shall be removed in the future.',docs:'https://adguard.app/kb/general/ad-filtering/create-own-filters/#mp4-modifier',versionAdded:null,versionRemoved:null,deprecated:true,deprecationMessage:'Rules with `$mp4` are still supported and being converted into `$redirect=noopmp4-1s` now\nbut the support shall be removed in the future.',removed:false,removalMessage:null,conflicts:null,inverseConflicts:false,assignable:false,negatable:false,blockOnly:false,exceptionOnly:false,valueOptional:false,valueFormat:null,valueFormatFlags:null},{name:'mp4',aliases:null,description:'As a response to blocked request a short video placeholder is returned.\nRules with `$mp4` are supported and being converted into `$redirect=noopmp4-1s`.',docs:'https://github.com/gorhill/uBlock/wiki/Static-filter-syntax#mp4',versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,conflicts:null,inverseConflicts:false,assignable:false,negatable:false,blockOnly:false,exceptionOnly:false,valueOptional:false,valueFormat:null,valueFormatFlags:null}],map:{'1':0,'2':0,'4':0,'8':1,'16':1,'32':1,'64':1,'1024':2,'2048':2,'4096':2,'8192':2}},{shared:[{name:'network',aliases:null,description:'This is basically a Firewall-kind of rules allowing to fully block\nor unblock access to a specified remote address.',docs:'https://adguard.app/kb/general/ad-filtering/create-own-filters/#network-modifier',versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,conflicts:['app','important'],inverseConflicts:true,assignable:false,negatable:false,blockOnly:false,exceptionOnly:false,valueOptional:false,valueFormat:null,valueFormatFlags:null}],map:{'1':0,'2':0,'4':0}},{shared:[{name:'_',aliases:null,description:'The noop modifier does nothing and can be used solely to increase rules\' readability.\nIt consists of a sequence of underscore characters (_) of any length\nand can appear in a rule as many times as needed.',docs:'https://adguard.app/kb/general/ad-filtering/create-own-filters/#noop-modifier',versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,conflicts:null,inverseConflicts:false,assignable:false,negatable:false,blockOnly:false,exceptionOnly:false,valueOptional:false,valueFormat:null,valueFormatFlags:null},{name:'_',aliases:null,description:'The noop modifier does nothing and can be used solely to increase rules\' readability.\nIt consists of a sequence of underscore characters (_) of any length\nand can appear in a rule as many times as needed.',docs:'https://adguard.app/kb/general/ad-filtering/create-own-filters/#noop-modifier',versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,conflicts:null,inverseConflicts:false,assignable:false,negatable:false,blockOnly:false,exceptionOnly:false,valueOptional:false,valueFormat:null,valueFormatFlags:null},{name:'_',aliases:null,description:'The noop modifier does nothing and can be used solely to increase rules\' readability.\nIt consists of a sequence of underscore characters (_) of any length\nand can appear in a rule as many times as needed.',docs:'https://adguard.app/kb/general/ad-filtering/create-own-filters/#noop-modifier',versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,conflicts:null,inverseConflicts:false,assignable:false,negatable:false,blockOnly:false,exceptionOnly:false,valueOptional:false,valueFormat:null,valueFormatFlags:null},{name:'_',aliases:null,description:'The noop modifier does nothing and can be used solely to increase rules\' readability.\nIt consists of a sequence of underscore characters (_) of any length\nand can appear in a rule as many times as needed.',docs:'https://adguard.app/kb/general/ad-filtering/create-own-filters/#noop-modifier',versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,conflicts:null,inverseConflicts:false,assignable:false,negatable:false,blockOnly:false,exceptionOnly:false,valueOptional:false,valueFormat:null,valueFormatFlags:null},{name:'_',aliases:null,description:'The noop modifier does nothing and can be used solely to increase rules\' readability.\nIt consists of a sequence of underscore characters (_) of any length\nand can appear in a rule as many times as needed.',docs:'https://github.com/gorhill/uBlock/wiki/Static-filter-syntax#_-aka-noop',versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,conflicts:null,inverseConflicts:false,assignable:false,negatable:false,blockOnly:false,exceptionOnly:false,valueOptional:false,valueFormat:null,valueFormatFlags:null}],map:{'1':0,'2':0,'4':0,'8':1,'16':1,'32':1,'64':1,'256':2,'512':3,'1024':4,'2048':4,'4096':4,'8192':4}},{shared:[{name:'object-subrequest',aliases:null,description:'The `$object-subrequest` modifier is removed and is no longer supported.\nRules with it are considered as invalid.\nThe rule corresponds to requests by browser plugins (it is usually Flash).',docs:'https://adguard.app/kb/general/ad-filtering/create-own-filters/#object-subrequest-modifier',versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:true,removalMessage:'The `$object-subrequest` modifier is removed and is no longer supported.\nRules with it are considered as invalid.',conflicts:null,inverseConflicts:false,assignable:false,negatable:true,blockOnly:false,exceptionOnly:false,valueOptional:false,valueFormat:null,valueFormatFlags:null}],map:{'1':0,'2':0,'4':0,'8':0,'16':0,'32':0,'64':0,'128':0,'256':0,'512':0}},{shared:[{name:'object',aliases:null,description:'The rule corresponds to browser plugins resources, e.g. Java or Flash',docs:'https://adguard.app/kb/general/ad-filtering/create-own-filters/#object-modifier',versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,conflicts:null,inverseConflicts:false,assignable:false,negatable:true,blockOnly:false,exceptionOnly:false,valueOptional:false,valueFormat:null,valueFormatFlags:null},{name:'object',aliases:null,description:'The rule corresponds to browser plugins resources, e.g. Java or Flash.',docs:'https://help.adblockplus.org/hc/en-us/articles/360062733293-How-to-write-filters#type-options',versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,conflicts:null,inverseConflicts:false,assignable:false,negatable:true,blockOnly:false,exceptionOnly:false,valueOptional:false,valueFormat:null,valueFormatFlags:null},{name:'object',aliases:null,description:'The rule corresponds to browser plugins resources, e.g. Java or Flash.',docs:'https://help.adblockplus.org/hc/en-us/articles/360062733293-How-to-write-filters#type-options',versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,conflicts:null,inverseConflicts:false,assignable:false,negatable:true,blockOnly:false,exceptionOnly:false,valueOptional:false,valueFormat:null,valueFormatFlags:null}],map:{'1':0,'2':0,'4':0,'8':0,'16':0,'32':0,'64':0,'128':0,'256':0,'512':0,'1024':1,'2048':1,'4096':1,'8192':1,'16384':2,'32768':2,'65536':2,'131072':2}},{shared:[{name:'other',aliases:null,description:'The rule applies to requests for which the type has not been determined\nor does not match the types listed above.',docs:'https://adguard.app/kb/general/ad-filtering/create-own-filters/#other-modifier',versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,conflicts:null,inverseConflicts:false,assignable:false,negatable:true,blockOnly:false,exceptionOnly:false,valueOptional:false,valueFormat:null,valueFormatFlags:null},{name:'other',aliases:null,description:'The rule applies to requests for which the type has not been determined\nor does not match the types listed above.',docs:'https://help.adblockplus.org/hc/en-us/articles/360062733293-How-to-write-filters#type-options',versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,conflicts:null,inverseConflicts:false,assignable:false,negatable:true,blockOnly:false,exceptionOnly:false,valueOptional:false,valueFormat:null,valueFormatFlags:null},{name:'other',aliases:null,description:'The rule applies to requests for which the type has not been determined\nor does not match the types listed above.',docs:'https://help.adblockplus.org/hc/en-us/articles/360062733293-How-to-write-filters#type-options',versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,conflicts:null,inverseConflicts:false,assignable:false,negatable:true,blockOnly:false,exceptionOnly:false,valueOptional:false,valueFormat:null,valueFormatFlags:null}],map:{'1':0,'2':0,'4':0,'8':0,'16':0,'32':0,'64':0,'128':0,'256':0,'512':0,'1024':1,'2048':1,'4096':1,'8192':1,'16384':2,'32768':2,'65536':2,'131072':2}},{shared:[{name:'permissions',aliases:null,description:'For the requests matching a `$permissions` rule, ad blocker strengthens response\'s feature policy\nby adding additional feature policy equal to the `$permissions` modifier contents.\n`$permissions` rules are applied independently from any other rule type.',docs:'https://adguard.app/kb/general/ad-filtering/create-own-filters/#permissions-modifier',versionAdded:'CoreLibs 1.11',versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,conflicts:['domain','important','subdocument'],inverseConflicts:true,assignable:true,negatable:false,blockOnly:false,exceptionOnly:false,valueOptional:true,valueFormat:'permissions_value',valueFormatFlags:null}],map:{'1':0,'2':0,'4':0}},{shared:[{name:'ping',aliases:null,description:'The rule corresponds to requests caused by either navigator.sendBeacon() or the ping attribute on links.',docs:'https://adguard.app/kb/general/ad-filtering/create-own-filters/#ping-modifier',versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,conflicts:null,inverseConflicts:false,assignable:false,negatable:true,blockOnly:false,exceptionOnly:false,valueOptional:false,valueFormat:null,valueFormatFlags:null},{name:'ping',aliases:null,description:'The rule corresponds to requests caused by either navigator.sendBeacon() or the ping attribute on links.',docs:'https://help.adblockplus.org/hc/en-us/articles/360062733293-How-to-write-filters#type-options',versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,conflicts:null,inverseConflicts:false,assignable:false,negatable:true,blockOnly:false,exceptionOnly:false,valueOptional:false,valueFormat:null,valueFormatFlags:null},{name:'ping',aliases:null,description:'The rule corresponds to requests caused by either navigator.sendBeacon() or the ping attribute on links.',docs:'https://help.adblockplus.org/hc/en-us/articles/360062733293-How-to-write-filters#type-options',versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,conflicts:null,inverseConflicts:false,assignable:false,negatable:true,blockOnly:false,exceptionOnly:false,valueOptional:false,valueFormat:null,valueFormatFlags:null}],map:{'1':0,'2':0,'4':0,'8':0,'16':0,'32':0,'64':0,'128':0,'256':0,'512':0,'1024':1,'2048':1,'4096':1,'8192':1,'16384':2,'32768':2,'65536':2,'131072':2}},{shared:[{name:'popunder',aliases:null,description:'To block "popunders" windows/tabs where the original page redirects to an advertisement\nand the desired content loads in the newly created one.\nTo be used in the same manner as the popup filter option, except that it will block popunders.',docs:'https://github.com/gorhill/uBlock/wiki/Static-filter-syntax#popunder',versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,conflicts:null,inverseConflicts:false,assignable:false,negatable:false,blockOnly:true,exceptionOnly:false,valueOptional:false,valueFormat:null,valueFormatFlags:null}],map:{'1024':0,'2048':0,'4096':0,'8192':0}},{shared:[{name:'popup',aliases:null,description:'Pages opened in a new tab or window.\nNote: Filters will not block pop-ups by default, only if the `$popup`  type option is specified.',docs:'https://adguard.app/kb/general/ad-filtering/create-own-filters/#popup-modifier',versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,conflicts:null,inverseConflicts:false,assignable:false,negatable:false,blockOnly:false,exceptionOnly:false,valueOptional:false,valueFormat:null,valueFormatFlags:null},{name:'popup',aliases:null,description:'Pages opened in a new tab or window.\nNote: Filters will not block pop-ups by default, only if the `$popup`  type option is specified.',docs:'https://help.adblockplus.org/hc/en-us/articles/360062733293-How-to-write-filters#type-options',versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,conflicts:null,inverseConflicts:false,assignable:false,negatable:false,blockOnly:false,exceptionOnly:false,valueOptional:false,valueFormat:null,valueFormatFlags:null},{name:'popup',aliases:null,description:'Pages opened in a new tab or window.\nNote: Filters will not block pop-ups by default, only if the `$popup`  type option is specified.',docs:'https://help.adblockplus.org/hc/en-us/articles/360062733293-How-to-write-filters#type-options',versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,conflicts:null,inverseConflicts:false,assignable:false,negatable:false,blockOnly:false,exceptionOnly:false,valueOptional:false,valueFormat:null,valueFormatFlags:null}],map:{'1':0,'2':0,'4':0,'8':0,'16':0,'32':0,'64':0,'128':0,'256':0,'512':0,'1024':1,'2048':1,'4096':1,'8192':1,'16384':2,'32768':2,'65536':2,'131072':2}},{shared:[{name:'redirect-rule',aliases:null,description:'This is basically an alias to `$redirect`\nsince it has the same "redirection" values and the logic is almost similar.\nThe difference is that `$redirect-rule` is applied only in the case\nwhen the target request is blocked by a different basic rule.',docs:'https://adguard.app/kb/general/ad-filtering/create-own-filters/#redirect-rule-modifier',versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,conflicts:['domain','to','third-party','popup','match-case','header','first-party','document','image','stylesheet','script','object','font','media','subdocument','ping','xmlhttprequest','websocket','other','webrtc','important','badfilter','app'],inverseConflicts:true,assignable:true,negatable:false,blockOnly:false,exceptionOnly:false,valueOptional:true,valueFormat:'^(1x1-transparent\\.gif|2x2-transparent\\.png|3x2-transparent\\.png|32x32-transparent\\.png|noopframe|noopcss|noopjs|noopjson|nooptext|empty|noopvmap-1\\.0|noopvast-2\\.0|noopvast-3\\.0|noopvast-4\\.0|noopmp3-0\\.1s|noopmp4-1s|amazon-apstag|ati-smarttag|didomi-loader|fingerprintjs2|fingerprintjs3|gemius|google-analytics-ga|google-analytics|google-ima3|googlesyndication-adsbygoogle|googletagservices-gpt|matomo|metrika-yandex-tag|metrika-yandex-watch|naver-wcslog|noeval|pardot-1\\.0|prebid-ads|prebid|prevent-bab|prevent-bab2|prevent-fab-3\\.2\\.0|prevent-popads-net|scorecardresearch-beacon|set-popads-dummy|click2load\\.html|)?$',valueFormatFlags:null},{name:'redirect-rule',aliases:null,description:'This is basically an alias to `$redirect`\nsince it has the same "redirection" values and the logic is almost similar.\nThe difference is that `$redirect-rule` is applied only in the case\nwhen the target request is blocked by a different basic rule.',docs:'https://adguard.app/kb/general/ad-filtering/create-own-filters/#redirect-rule-modifier',versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,conflicts:['domain','to','third-party','popup','match-case','header','first-party','document','image','stylesheet','script','object','font','media','subdocument','ping','xmlhttprequest','websocket','other','webrtc','important','badfilter'],inverseConflicts:true,assignable:true,negatable:false,blockOnly:false,exceptionOnly:false,valueOptional:true,valueFormat:'^(1x1-transparent\\.gif|2x2-transparent\\.png|3x2-transparent\\.png|32x32-transparent\\.png|noopframe|noopcss|noopjs|noopjson|nooptext|empty|noopvmap-1\\.0|noopvast-2\\.0|noopvast-3\\.0|noopvast-4\\.0|noopmp3-0\\.1s|noopmp4-1s|amazon-apstag|ati-smarttag|didomi-loader|fingerprintjs2|fingerprintjs3|gemius|google-analytics-ga|google-analytics|google-ima3|googlesyndication-adsbygoogle|googletagservices-gpt|matomo|metrika-yandex-tag|metrika-yandex-watch|naver-wcslog|noeval|pardot-1\\.0|prebid-ads|prebid|prevent-bab|prevent-bab2|prevent-fab-3\\.2\\.0|prevent-popads-net|scorecardresearch-beacon|set-popads-dummy|click2load\\.html|)?$',valueFormatFlags:null},{name:'redirect-rule',aliases:null,description:'This is basically an alias to `$redirect`\nsince it has the same "redirection" values and the logic is almost similar.\nThe difference is that `$redirect-rule` is applied only in the case\nwhen the target request is blocked by a different basic rule.',docs:'https://github.com/gorhill/uBlock/wiki/Static-filter-syntax#redirect-rule',versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,conflicts:['domain','to','third-party','popup','match-case','header','first-party','document','image','stylesheet','script','object','font','media','subdocument','ping','xmlhttprequest','websocket','other','webrtc','important','badfilter'],inverseConflicts:true,assignable:true,negatable:false,blockOnly:false,exceptionOnly:false,valueOptional:false,valueFormat:'^(1x1\\.gif|2x2\\.png|3x2\\.png|32x32\\.png|noop\\.css|noop\\.html|noopframe|noop\\.js|noop\\.txt|noop-0\\.1s\\.mp3|noop-0\\.5s\\.mp3|noop-1s\\.mp4|none|click2load\\.html|addthis_widget\\.js|amazon_ads\\.js|amazon_apstag\\.js|monkeybroker\\.js|doubleclick_instream_ad_status|google-analytics_ga\\.js|google-analytics_analytics\\.js|google-analytics_inpage_linkid\\.js|google-analytics_cx_api\\.js|google-ima\\.js|googletagservices_gpt\\.js|googletagmanager_gtm\\.js|googlesyndication_adsbygoogle\\.js|scorecardresearch_beacon\\.js|outbrain-widget\\.js|hd-main\\.js)(:[0-9]+)?$',valueFormatFlags:null}],map:{'1':0,'2':0,'4':0,'8':1,'16':1,'32':1,'64':1,'1024':2,'2048':2,'4096':2,'8192':2}},{shared:[{name:'redirect',aliases:null,description:'Used to redirect web requests to a local "resource".',docs:'https://adguard.app/kb/general/ad-filtering/create-own-filters/#redirect-modifier',versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,conflicts:null,inverseConflicts:false,assignable:true,negatable:false,blockOnly:false,exceptionOnly:false,valueOptional:true,valueFormat:'^(1x1-transparent\\.gif|2x2-transparent\\.png|3x2-transparent\\.png|32x32-transparent\\.png|noopframe|noopcss|noopjs|noopjson|nooptext|empty|noopvmap-1\\.0|noopvast-2\\.0|noopvast-3\\.0|noopvast-4\\.0|noopmp3-0\\.1s|noopmp4-1s|amazon-apstag|ati-smarttag|didomi-loader|fingerprintjs2|fingerprintjs3|gemius|google-analytics-ga|google-analytics|googletagmanager-gtm|google-ima3|googlesyndication-adsbygoogle|googletagservices-gpt|matomo|metrika-yandex-tag|metrika-yandex-watch|naver-wcslog|noeval|pardot-1\\.0|prebid-ads|prebid|prevent-bab|prevent-bab2|prevent-fab-3\\.2\\.0|prevent-popads-net|scorecardresearch-beacon|set-popads-dummy|click2load\\.html)?$',valueFormatFlags:null},{name:'redirect',aliases:null,description:'Used to redirect web requests to a local "resource".',docs:'https://adguard.app/kb/general/ad-filtering/create-own-filters/#redirect-modifier',versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,conflicts:null,inverseConflicts:false,assignable:true,negatable:false,blockOnly:false,exceptionOnly:false,valueOptional:true,valueFormat:'^(1x1-transparent\\.gif|2x2-transparent\\.png|3x2-transparent\\.png|32x32-transparent\\.png|noopframe|noopcss|noopjs|noopjson|nooptext|empty|noopvmap-1\\.0|noopvast-2\\.0|noopvast-3\\.0|noopvast-4\\.0|noopmp3-0\\.1s|noopmp4-1s|amazon-apstag|ati-smarttag|didomi-loader|fingerprintjs2|fingerprintjs3|gemius|google-analytics-ga|google-analytics|googletagmanager-gtm|google-ima3|googlesyndication-adsbygoogle|googletagservices-gpt|matomo|metrika-yandex-tag|metrika-yandex-watch|naver-wcslog|noeval|pardot-1\\.0|prebid-ads|prebid|prevent-bab|prevent-bab2|prevent-fab-3\\.2\\.0|prevent-popads-net|scorecardresearch-beacon|set-popads-dummy|click2load\\.html)?$',valueFormatFlags:null},{name:'redirect',aliases:null,description:'Used to redirect web requests to a local "resource".',docs:'https://github.com/gorhill/uBlock/wiki/Static-filter-syntax#redirect',versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,conflicts:null,inverseConflicts:false,assignable:true,negatable:false,blockOnly:false,exceptionOnly:false,valueOptional:true,valueFormat:'^(1x1\\.gif|2x2\\.png|3x2\\.png|32x32\\.png|noop\\.css|noop\\.html|noopframe|noop\\.js|noop\\.txt|noop-0\\.1s\\.mp3|noop-0\\.5s\\.mp3|noop-1s\\.mp4|none|click2load\\.html|addthis_widget\\.js|amazon_ads\\.js|amazon_apstag\\.js|monkeybroker\\.js|doubleclick_instream_ad_status|google-analytics_ga\\.js|google-analytics_analytics\\.js|google-analytics_inpage_linkid\\.js|google-analytics_cx_api\\.js|google-ima\\.js|googletagservices_gpt\\.js|googletagmanager_gtm\\.js|googlesyndication_adsbygoogle\\.js|scorecardresearch_beacon\\.js|outbrain-widget\\.js|hd-main\\.js)(:[0-9]+)?$',valueFormatFlags:null},{name:'rewrite',aliases:null,description:'The `rewrite=` option allows the rewriting of URLs (or redirecting requests) to an internal\nresource in order to deactivate it without causing an error. Indicate the internal resource\nby name and prefix `abp-resource:` in order to be recognized. For example\n`$rewrite=abp-resource:blank-js` sends an empty JavaScript.',docs:'https://help.adblockplus.org/hc/en-us/articles/360062733293#rewrite',versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,conflicts:null,inverseConflicts:false,assignable:true,negatable:false,blockOnly:false,exceptionOnly:false,valueOptional:false,valueFormat:'(?:)^abp-resource:(?:)(blank-text|blank-css|blank-js|blank-html|blank-mp3|1x1-transparent-gif|2x2-transparent-png|3x2-transparent-png|32x32-transparent-png)$',valueFormatFlags:null}],map:{'1':0,'2':0,'4':0,'8':1,'16':1,'32':1,'64':1,'1024':2,'2048':2,'4096':2,'8192':2,'16384':3,'32768':3,'65536':3,'131072':3}},{shared:[{name:'referrerpolicy',aliases:null,description:'This modifier allows overriding of a page\'s referrer policy.',docs:'https://adguard.app/kb/general/ad-filtering/create-own-filters/#referrerpolicy-modifier',versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,conflicts:['document','subdocument'],inverseConflicts:true,assignable:true,negatable:false,blockOnly:false,exceptionOnly:false,valueOptional:true,valueFormat:'referrerpolicy_value',valueFormatFlags:null}],map:{'1':0,'2':0,'4':0}},{shared:[{name:'removeheader',aliases:null,description:'Rules with the `$removeheader` modifier are intended to remove headers from HTTP requests and responses.',docs:'https://adguard.app/kb/general/ad-filtering/create-own-filters/#removeheader-modifier',versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,conflicts:['domain','third-party','first-party','app','important','match-case','document','image','stylesheet','script','object','font','media','subdocument','ping','xmlhttpreqeust','websocket','other','webrtc'],inverseConflicts:true,assignable:true,negatable:false,blockOnly:false,exceptionOnly:false,valueOptional:true,valueFormat:'^(?:)(request:)?(?:)(?!(access-control-allow-origin|access-control-allow-credentials|access-control-allow-headers|access-control-allow-methods|access-control-expose-headers|access-control-max-age|access-control-request-headers|access-control-request-method|origin|timing-allow-origin|allow|cross-origin-embedder-policy|cross-origin-opener-policy|cross-origin-resource-policy|content-security-policy|content-security-policy-report-only|expect-ct|feature-policy|origin-isolation|strict-transport-security|upgrade-insecure-requests|x-content-type-options|x-download-options|x-frame-options|x-permitted-cross-domain-policies|x-powered-by|x-xss-protection|public-key-pins|public-key-pins-report-only|sec-websocket-key|sec-websocket-extensions|sec-websocket-accept|sec-websocket-protocol|sec-websocket-version|p3p|sec-fetch-mode|sec-fetch-dest|sec-fetch-site|sec-fetch-user|referrer-policy|content-type|content-length|accept|accept-encoding|host|connection|transfer-encoding|upgrade)$)(?:)[A-z0-9-]+(?:)$',valueFormatFlags:'i'},{name:'removeheader',aliases:null,description:'Rules with the `$removeheader` modifier are intended to remove headers from HTTP requests and responses.',docs:'https://adguard.app/kb/general/ad-filtering/create-own-filters/#removeheader-modifier',versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,conflicts:['domain','third-party','first-party','app','important','match-case','document','image','stylesheet','script','object','font','media','subdocument','ping','xmlhttpreqeust','websocket','other','webrtc'],inverseConflicts:true,assignable:true,negatable:false,blockOnly:false,exceptionOnly:false,valueOptional:true,valueFormat:'^(?:)(request:)?(?:)(?!(access-control-allow-origin|access-control-allow-credentials|access-control-allow-headers|access-control-allow-methods|access-control-expose-headers|access-control-max-age|access-control-request-headers|access-control-request-method|origin|timing-allow-origin|allow|cross-origin-embedder-policy|cross-origin-opener-policy|cross-origin-resource-policy|content-security-policy|content-security-policy-report-only|expect-ct|feature-policy|origin-isolation|strict-transport-security|upgrade-insecure-requests|x-content-type-options|x-download-options|x-frame-options|x-permitted-cross-domain-policies|x-powered-by|x-xss-protection|public-key-pins|public-key-pins-report-only|sec-websocket-key|sec-websocket-extensions|sec-websocket-accept|sec-websocket-protocol|sec-websocket-version|p3p|sec-fetch-mode|sec-fetch-dest|sec-fetch-site|sec-fetch-user|referrer-policy|content-type|content-length|accept|accept-encoding|host|connection|transfer-encoding|upgrade)$)(?:)[A-z0-9-]+(?:)$',valueFormatFlags:'i'}],map:{'1':0,'2':0,'4':0,'8':1,'16':1,'32':1,'64':1}},{shared:[{name:'removeparam',aliases:null,description:'Rules with the `$removeparam` modifier are intended to strip query parameters from requests\' URLs.',docs:'https://adguard.app/kb/general/ad-filtering/create-own-filters/#removeparam-modifier',versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,conflicts:null,inverseConflicts:false,assignable:true,negatable:false,blockOnly:false,exceptionOnly:false,valueOptional:true,valueFormat:'((?:)\\w+(?:)|\\/.+\\/(?:)([gimuy]+)?)',valueFormatFlags:'i'},{name:'removeparam',aliases:null,description:'Rules with the `$removeparam` modifier are intended to strip query parameters from requests\' URLs.',docs:'https://adguard.app/kb/general/ad-filtering/create-own-filters/#removeparam-modifier',versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,conflicts:null,inverseConflicts:false,assignable:true,negatable:false,blockOnly:false,exceptionOnly:false,valueOptional:true,valueFormat:'((?:)\\w+(?:)|\\/.+\\/(?:)([gimuy]+)?)',valueFormatFlags:'i'},{name:'removeparam',aliases:null,description:'Rules with the `$removeparam` modifier are intended to strip query parameters from requests\' URLs.',docs:'https://github.com/gorhill/uBlock/wiki/Static-filter-syntax#removeparam',versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,conflicts:null,inverseConflicts:false,assignable:true,negatable:false,blockOnly:false,exceptionOnly:false,valueOptional:false,valueFormat:'((?:)\\w+(?:)|\\/.+\\/(?:)([gimuy]+)?)',valueFormatFlags:'i'}],map:{'1':0,'2':0,'4':0,'8':1,'16':1,'32':1,'64':1,'1024':2,'2048':2,'4096':2,'8192':2}},{shared:[{name:'replace',aliases:null,description:'This modifier completely changes the rule behavior.\nIf it is applied, the rule will not block the request. The response is going to be modified instead.',docs:'https://adguard.app/kb/general/ad-filtering/create-own-filters/#replace-modifier',versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,conflicts:['app','domain','document','subdocument','script','stylesheet','other','xmlhttprequest','first-party','third-party','important','badfilter'],inverseConflicts:true,assignable:true,negatable:false,blockOnly:false,exceptionOnly:false,valueOptional:false,valueFormat:'^(?:)\\/(?:)(.+)(?:)\\/(?:)(.+)?(?:)\\/(?:)([gimuy]*)?(?:)$',valueFormatFlags:'i'},{name:'replace',aliases:null,description:'This modifier completely changes the rule behavior.\nIf it is applied, the rule will not block the request. The response is going to be modified instead.',docs:'https://adguard.app/kb/general/ad-filtering/create-own-filters/#replace-modifier',versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,conflicts:['app','domain','document','subdocument','script','stylesheet','other','xmlhttprequest','first-party','third-party','important','badfilter'],inverseConflicts:true,assignable:true,negatable:false,blockOnly:false,exceptionOnly:false,valueOptional:false,valueFormat:'^(?:)\\/(?:)(.+)(?:)\\/(?:)(.+)?(?:)\\/(?:)([gimuy]*)?(?:)$',valueFormatFlags:'i'},{name:'replace',aliases:null,description:'This modifier completely changes the rule behavior.\nIf it is applied, the rule will not block the request. The response is going to be modified instead.',docs:'https://github.com/gorhill/uBlock/wiki/Static-filter-syntax#replace',versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,conflicts:['app','domain','document','subdocument','script','stylesheet','other','xmlhttprequest','first-party','third-party','important','badfilter'],inverseConflicts:true,assignable:true,negatable:false,blockOnly:false,exceptionOnly:false,valueOptional:false,valueFormat:'^(?:)\\/(?:)(.+)(?:)\\/(?:)(.+)?(?:)\\/(?:)([gimuy]*)?(?:)$',valueFormatFlags:'i'}],map:{'1':0,'2':0,'4':0,'64':1,'8192':2}},{shared:[{name:'script',aliases:null,description:'The rule corresponds to script requests, e.g. javascript, vbscript.',docs:'https://adguard.app/kb/general/ad-filtering/create-own-filters/#script-modifier',versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,conflicts:null,inverseConflicts:false,assignable:false,negatable:true,blockOnly:false,exceptionOnly:false,valueOptional:false,valueFormat:null,valueFormatFlags:null},{name:'script',aliases:null,description:'The rule corresponds to script requests, e.g. javascript, vbscript.',docs:'https://help.adblockplus.org/hc/en-us/articles/360062733293#options',versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,conflicts:null,inverseConflicts:false,assignable:false,negatable:true,blockOnly:false,exceptionOnly:false,valueOptional:false,valueFormat:null,valueFormatFlags:null},{name:'script',aliases:null,description:'The rule corresponds to script requests, e.g. javascript, vbscript.',docs:'https://help.adblockplus.org/hc/en-us/articles/360062733293-How-to-write-filters#type-options',versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,conflicts:null,inverseConflicts:false,assignable:false,negatable:true,blockOnly:false,exceptionOnly:false,valueOptional:false,valueFormat:null,valueFormatFlags:null}],map:{'1':0,'2':0,'4':0,'8':0,'16':0,'32':0,'64':0,'128':0,'256':0,'512':0,'1024':1,'2048':1,'4096':1,'8192':1,'16384':2,'32768':2,'65536':2,'131072':2}},{shared:[{name:'specifichide',aliases:['shide'],description:'Disables all specific element hiding and CSS rules, but not general ones.\nHas an opposite effect to `$generichide`.',docs:'https://adguard.app/kb/general/ad-filtering/create-own-filters/#specifichide-modifier',versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,conflicts:['domain','genericblock','urlblock','extension','jsinject','content','xmlhttprequest','badfilter'],inverseConflicts:true,assignable:false,negatable:false,blockOnly:false,exceptionOnly:true,valueOptional:false,valueFormat:null,valueFormatFlags:null},{name:'specifichide',aliases:['shide'],description:'Disables all specific element hiding and CSS rules, but not general ones.\nHas an opposite effect to `$generichide`.',docs:'https://github.com/gorhill/uBlock/wiki/Static-filter-syntax#specifichide',versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,conflicts:['domain','badfilter'],inverseConflicts:true,assignable:false,negatable:false,blockOnly:false,exceptionOnly:true,valueOptional:false,valueFormat:null,valueFormatFlags:null}],map:{'1':0,'2':0,'4':0,'8':0,'16':0,'32':0,'64':0,'128':0,'256':0,'512':0,'1024':1,'2048':1,'4096':1,'8192':1}},{shared:[{name:'stealth',aliases:null,description:'Disables the Stealth Mode module for all corresponding pages and requests.',docs:'https://adguard.app/kb/general/ad-filtering/create-own-filters/#stealth-modifier',versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,conflicts:null,inverseConflicts:false,assignable:true,negatable:false,blockOnly:false,exceptionOnly:true,valueOptional:true,valueFormat:'pipe_separated_stealth_options',valueFormatFlags:null},{name:'stealth',aliases:null,description:'Disables the Stealth Mode module for all corresponding pages and requests.',docs:'https://adguard.app/kb/general/ad-filtering/create-own-filters/#stealth-modifier',versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,conflicts:null,inverseConflicts:false,assignable:true,negatable:false,blockOnly:false,exceptionOnly:true,valueOptional:true,valueFormat:'pipe_separated_stealth_options',valueFormatFlags:null},{name:'stealth',aliases:null,description:'Disables the Stealth Mode module for all corresponding pages and requests.',docs:'https://adguard.app/kb/general/ad-filtering/create-own-filters/#stealth-modifier',versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,conflicts:null,inverseConflicts:false,assignable:true,negatable:false,blockOnly:false,exceptionOnly:true,valueOptional:true,valueFormat:'pipe_separated_stealth_options',valueFormatFlags:null},{name:'stealth',aliases:null,description:'Disables the Stealth Mode module for all corresponding pages and requests.',docs:'https://adguard.app/kb/general/ad-filtering/create-own-filters/#stealth-modifier',versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,conflicts:null,inverseConflicts:false,assignable:true,negatable:false,blockOnly:false,exceptionOnly:true,valueOptional:true,valueFormat:'pipe_separated_stealth_options',valueFormatFlags:null},{name:'stealth',aliases:null,description:'Disables the Stealth Mode module for all corresponding pages and requests.',docs:'https://adguard.app/kb/general/ad-filtering/create-own-filters/#stealth-modifier',versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,conflicts:null,inverseConflicts:false,assignable:true,negatable:false,blockOnly:false,exceptionOnly:true,valueOptional:true,valueFormat:'pipe_separated_stealth_options',valueFormatFlags:null}],map:{'1':0,'2':0,'4':0,'8':1,'16':2,'32':3,'64':4}},{shared:[{name:'strict1p',aliases:null,description:'This new `strict1p` option can check for strict partyness.\nFor example, a network request qualifies as 1st-party if both the context and the request share the same hostname.',docs:'https://github.com/gorhill/uBlock/wiki/Static-filter-syntax#strict1p',versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,conflicts:null,inverseConflicts:false,assignable:false,negatable:true,blockOnly:false,exceptionOnly:false,valueOptional:false,valueFormat:null,valueFormatFlags:null}],map:{'1024':0,'2048':0,'4096':0,'8192':0}},{shared:[{name:'strict3p',aliases:null,description:'This new `strict3p` option can check for strict partyness.\nFor example, a network request qualifies as 3rd-party if the context and the request hostnames are different.',docs:'https://github.com/gorhill/uBlock/wiki/Static-filter-syntax#strict3p',versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,conflicts:null,inverseConflicts:false,assignable:false,negatable:true,blockOnly:false,exceptionOnly:false,valueOptional:false,valueFormat:null,valueFormatFlags:null}],map:{'1024':0,'2048':0,'4096':0,'8192':0}},{shared:[{name:'stylesheet',aliases:null,description:'The rule corresponds to CSS files requests.',docs:'https://adguard.app/kb/general/ad-filtering/create-own-filters/#stylesheet-modifier',versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,conflicts:null,inverseConflicts:false,assignable:false,negatable:true,blockOnly:false,exceptionOnly:false,valueOptional:false,valueFormat:null,valueFormatFlags:null},{name:'stylesheet',aliases:['css'],description:'The rule corresponds to CSS files requests.',docs:'https://github.com/gorhill/uBlock/wiki/Static-filter-syntax#css',versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,conflicts:null,inverseConflicts:false,assignable:false,negatable:true,blockOnly:false,exceptionOnly:false,valueOptional:false,valueFormat:null,valueFormatFlags:null},{name:'stylesheet',aliases:null,description:'The rule corresponds to CSS files requests.',docs:'https://help.adblockplus.org/hc/en-us/articles/360062733293-How-to-write-filters#type-options',versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,conflicts:null,inverseConflicts:false,assignable:false,negatable:true,blockOnly:false,exceptionOnly:false,valueOptional:false,valueFormat:null,valueFormatFlags:null}],map:{'1':0,'2':0,'4':0,'8':0,'16':0,'32':0,'64':0,'128':0,'256':0,'512':0,'1024':1,'2048':1,'4096':1,'8192':1,'16384':2,'32768':2,'65536':2,'131072':2}},{shared:[{name:'subdocument',aliases:null,description:'The rule corresponds to requests for built-in pages — HTML tags frame and iframe.',docs:'https://adguard.app/kb/general/ad-filtering/create-own-filters/#subdocument-modifier',versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,conflicts:null,inverseConflicts:false,assignable:false,negatable:true,blockOnly:false,exceptionOnly:false,valueOptional:false,valueFormat:null,valueFormatFlags:null},{name:'subdocument',aliases:['frame'],description:'The rule corresponds to requests for built-in pages — HTML tags frame and iframe.',docs:'https://github.com/gorhill/uBlock/wiki/Static-filter-syntax#frame',versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,conflicts:null,inverseConflicts:false,assignable:false,negatable:true,blockOnly:false,exceptionOnly:false,valueOptional:false,valueFormat:null,valueFormatFlags:null},{name:'subdocument',aliases:null,description:'The rule corresponds to requests for built-in pages — HTML tags frame and iframe.',docs:'https://help.adblockplus.org/hc/en-us/articles/360062733293-How-to-write-filters#type-options',versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,conflicts:null,inverseConflicts:false,assignable:false,negatable:true,blockOnly:false,exceptionOnly:false,valueOptional:false,valueFormat:null,valueFormatFlags:null}],map:{'1':0,'2':0,'4':0,'8':0,'16':0,'32':0,'64':0,'128':0,'256':0,'512':0,'1024':1,'2048':1,'4096':1,'8192':1,'16384':2,'32768':2,'65536':2,'131072':2}},{shared:[{name:'third-party',aliases:['3p'],description:'A restriction of third-party and own requests.\nA third-party request is a request from a different domain.\nFor example, a request to `example.org` from `domain.com` is a third-party request.',docs:'https://adguard.app/kb/general/ad-filtering/create-own-filters/#third-party-modifier',versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,conflicts:null,inverseConflicts:false,assignable:false,negatable:true,blockOnly:false,exceptionOnly:false,valueOptional:false,valueFormat:null,valueFormatFlags:null},{name:'3p',aliases:['third-party'],description:'A restriction of third-party and own requests.\nA third-party request is a request from a different domain.\nFor example, a request to `example.org` from `domain.com` is a third-party request.',docs:'https://github.com/gorhill/uBlock/wiki/Static-filter-syntax#3p',versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,conflicts:null,inverseConflicts:false,assignable:false,negatable:true,blockOnly:false,exceptionOnly:false,valueOptional:false,valueFormat:null,valueFormatFlags:null},{name:'third-party',aliases:null,description:'A restriction of third-party and own requests.\nA third-party request is a request from a different domain.\nFor example, a request to `example.org` from `domain.com` is a third-party request.',docs:'https://help.adblockplus.org/hc/en-us/articles/360062733293#party-requests',versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,conflicts:null,inverseConflicts:false,assignable:false,negatable:true,blockOnly:false,exceptionOnly:false,valueOptional:false,valueFormat:null,valueFormatFlags:null}],map:{'1':0,'2':0,'4':0,'8':0,'16':0,'32':0,'64':0,'128':0,'256':0,'512':0,'1024':1,'2048':1,'4096':1,'8192':1,'16384':2,'32768':2,'65536':2,'131072':2}},{shared:[{name:'to',aliases:null,description:'`$to` limits the rule scope to requests made to the specified domains and their subdomains.\nTo add multiple domains to one rule, use the `|` character as a separator.',docs:'https://adguard.com/kb/general/ad-filtering/create-own-filters/#to-modifier',versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,conflicts:['denyallow'],inverseConflicts:false,assignable:true,negatable:false,blockOnly:false,exceptionOnly:false,valueOptional:false,valueFormat:'pipe_separated_domains',valueFormatFlags:null},{name:'to',aliases:null,description:'`$to` limits the rule scope to requests made to the specified domains and their subdomains.\nTo add multiple domains to one rule, use the `|` character as a separator.',docs:'https://adguard.com/kb/general/ad-filtering/create-own-filters/#to-modifier',versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,conflicts:['denyallow'],inverseConflicts:false,assignable:true,negatable:false,blockOnly:false,exceptionOnly:false,valueOptional:false,valueFormat:'pipe_separated_domains',valueFormatFlags:null},{name:'to',aliases:null,description:'The main motivation of this option is\nto give static network filtering engine an equivalent of DNR\'s `requestDomains` and `excludedRequestDomains`.',docs:'https://github.com/gorhill/uBlock/wiki/Static-filter-syntax#to',versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,conflicts:['denyallow'],inverseConflicts:false,assignable:true,negatable:false,blockOnly:false,exceptionOnly:false,valueOptional:false,valueFormat:'pipe_separated_domains',valueFormatFlags:null}],map:{'1':0,'2':0,'4':0,'8':1,'16':1,'32':1,'64':1,'1024':2,'2048':2,'4096':2,'8192':2}},{shared:[{name:'urlblock',aliases:null,description:'Disables blocking of all requests sent from the pages matching the rule.',docs:'https://adguard.app/kb/general/ad-filtering/create-own-filters/#urlblock-modifier',versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,conflicts:['domain','specifichide','generichide','elemhide','extension','jsinject','content','badfilter'],inverseConflicts:true,assignable:false,negatable:false,blockOnly:false,exceptionOnly:true,valueOptional:false,valueFormat:null,valueFormatFlags:null}],map:{'1':0,'2':0,'4':0,'8':0,'16':0,'32':0,'64':0,'128':0,'256':0,'512':0}},{shared:[{name:'webrtc',aliases:null,description:'The rule applies only to WebRTC connections.',docs:'https://adguard.app/kb/general/ad-filtering/create-own-filters/#webrtc-modifier',versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:true,removalMessage:'This modifier is removed and is no longer supported.\nRules with it are considered as invalid. If you need to suppress WebRTC, consider using\nthe [nowebrtc scriptlet](https://github.com/AdguardTeam/Scriptlets/blob/master/wiki/about-scriptlets.md#nowebrtc).',conflicts:null,inverseConflicts:false,assignable:false,negatable:true,blockOnly:false,exceptionOnly:false,valueOptional:false,valueFormat:null,valueFormatFlags:null},{name:'webrtc',aliases:null,description:'The rule applies only to WebRTC connections.',docs:'https://github.com/gorhill/uBlock/wiki/Static-filter-syntax',versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:true,removalMessage:'This modifier is removed and is no longer supported.\nIf you need to suppress WebRTC, consider using\nthe [nowebrtc scriptlet](https://github.com/gorhill/uBlock/wiki/Resources-Library#nowebrtcjs-).',conflicts:null,inverseConflicts:false,assignable:false,negatable:true,blockOnly:false,exceptionOnly:false,valueOptional:false,valueFormat:null,valueFormatFlags:null},{name:'webrtc',aliases:null,description:'The rule applies only to WebRTC connections.',docs:'https://help.adblockplus.org/hc/en-us/articles/360062733293-How-to-write-filters#type-options',versionAdded:'1.13.3',versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,conflicts:null,inverseConflicts:false,assignable:false,negatable:true,blockOnly:false,exceptionOnly:false,valueOptional:false,valueFormat:null,valueFormatFlags:null}],map:{'1':0,'2':0,'4':0,'8':0,'16':0,'32':0,'64':0,'128':0,'256':0,'512':0,'1024':1,'2048':1,'4096':1,'8192':1,'16384':2,'32768':2,'65536':2,'131072':2}},{shared:[{name:'websocket',aliases:null,description:'The rule applies only to WebSocket connections.',docs:'https://adguard.app/kb/general/ad-filtering/create-own-filters/#websocket-modifier',versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,conflicts:null,inverseConflicts:false,assignable:false,negatable:true,blockOnly:false,exceptionOnly:false,valueOptional:false,valueFormat:null,valueFormatFlags:null},{name:'websocket',aliases:null,description:'The rule applies only to WebSocket connections.',docs:'https://adguard.app/kb/general/ad-filtering/create-own-filters/#websocket-modifier',versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,conflicts:null,inverseConflicts:false,assignable:false,negatable:true,blockOnly:false,exceptionOnly:false,valueOptional:false,valueFormat:null,valueFormatFlags:null},{name:'websocket',aliases:null,description:'The rule applies only to WebSocket connections.',docs:'https://adguard.app/kb/general/ad-filtering/create-own-filters/#websocket-modifier',versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,conflicts:null,inverseConflicts:false,assignable:false,negatable:true,blockOnly:false,exceptionOnly:false,valueOptional:false,valueFormat:null,valueFormatFlags:null},{name:'websocket',aliases:null,description:'The rule applies only to WebSocket connections.',docs:'https://adguard.app/kb/general/ad-filtering/create-own-filters/#websocket-modifier',versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,conflicts:null,inverseConflicts:false,assignable:false,negatable:true,blockOnly:false,exceptionOnly:false,valueOptional:false,valueFormat:null,valueFormatFlags:null},{name:'websocket',aliases:null,description:'The rule applies only to WebSocket connections.',docs:'https://help.adblockplus.org/hc/en-us/articles/360062733293-How-to-write-filters#type-options',versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,conflicts:null,inverseConflicts:false,assignable:false,negatable:true,blockOnly:false,exceptionOnly:false,valueOptional:false,valueFormat:null,valueFormatFlags:null},{name:'websocket',aliases:null,description:'The rule applies only to WebSocket connections.',docs:'https://help.adblockplus.org/hc/en-us/articles/360062733293-How-to-write-filters#type-options',versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,conflicts:null,inverseConflicts:false,assignable:false,negatable:true,blockOnly:false,exceptionOnly:false,valueOptional:false,valueFormat:null,valueFormatFlags:null}],map:{'1':0,'2':0,'4':0,'8':1,'16':1,'32':1,'64':1,'256':2,'512':3,'1024':4,'2048':4,'4096':4,'8192':4,'16384':5,'32768':5,'65536':5,'131072':5}},{shared:[{name:'xmlhttprequest',aliases:['xhr'],description:'The rule applies only to ajax requests (requests sent via javascript object XMLHttpRequest).',docs:'https://adguard.app/kb/general/ad-filtering/create-own-filters/#xmlhttprequest-modifier',versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,conflicts:null,inverseConflicts:false,assignable:false,negatable:true,blockOnly:false,exceptionOnly:false,valueOptional:false,valueFormat:null,valueFormatFlags:null},{name:'xhr',aliases:['xmlhttprequest'],description:'The rule applies only to ajax requests (requests sent via javascript object XMLHttpRequest).',docs:'https://github.com/gorhill/uBlock/wiki/Static-filter-syntax#xhr',versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,conflicts:null,inverseConflicts:false,assignable:false,negatable:true,blockOnly:false,exceptionOnly:false,valueOptional:false,valueFormat:null,valueFormatFlags:null},{name:'xmlhttprequest',aliases:null,description:'The rule applies only to ajax requests (requests sent via javascript object XMLHttpRequest).',docs:'https://help.adblockplus.org/hc/en-us/articles/360062733293-How-to-write-filters#type-options',versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,conflicts:null,inverseConflicts:false,assignable:false,negatable:true,blockOnly:false,exceptionOnly:false,valueOptional:false,valueFormat:null,valueFormatFlags:null}],map:{'1':0,'2':0,'4':0,'8':0,'16':0,'32':0,'64':0,'128':0,'256':0,'512':0,'1024':1,'2048':1,'4096':1,'8192':1,'16384':2,'32768':2,'65536':2,'131072':2}}],map:{all:0,app:1,badfilter:2,cname:3,content:4,cookie:5,csp:6,denyallow:7,document:8,doc:8,domain:9,from:9,elemhide:10,ehide:10,empty:11,extension:12,'first-party':13,'1p':13,'~third-party':13,font:14,genericblock:15,generichide:16,ghide:16,header:17,hls:18,image:19,important:20,'inline-font':21,'inline-script':22,jsinject:23,jsonprune:24,'match-case':25,media:26,method:27,mp4:28,network:29,_:30,'object-subrequest':31,object:32,other:33,permissions:34,ping:35,popunder:36,popup:37,'redirect-rule':38,redirect:39,rewrite:39,referrerpolicy:40,removeheader:41,removeparam:42,replace:43,script:44,specifichide:45,shide:45,stealth:46,strict1p:47,strict3p:48,stylesheet:49,css:49,subdocument:50,frame:50,'third-party':51,'3p':51,to:52,urlblock:53,webrtc:54,websocket:55,xmlhttprequest:56,xhr:56}};
const redirectsCompatibilityTableData = {shared:[{shared:[{name:'1x1-transparent.gif',aliases:['1x1.gif','1x1-transparent-gif'],description:'Redirects to a 1x1 transparent GIF.',docs:'https://github.com/AdguardTeam/Scriptlets/blob/master/wiki/about-redirects.md#1x1-transparent.gif',versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,isBlocking:false,resourceTypes:[]},{name:'1x1.gif',aliases:null,description:'Redirects to a 1x1 transparent GIF.',docs:'https://github.com/gorhill/uBlock/wiki/Resources-Library#available-empty-redirect-resources',versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,isBlocking:false,resourceTypes:['image']},{name:'1x1-transparent-gif',aliases:null,description:'Redirects to a 1x1 transparent GIF.',docs:'https://help.adblockplus.org/hc/en-us/articles/360062733293#rewrite',versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,isBlocking:false,resourceTypes:[]}],map:{'1':0,'2':0,'4':0,'8':0,'16':0,'32':0,'64':0,'1024':1,'2048':1,'4096':1,'8192':1,'16384':2,'32768':2,'65536':2,'131072':2}},{shared:[{name:'2x2-transparent.png',aliases:['2x2.png','2x2-transparent-png'],description:'Redirects to a 2x2 transparent PNG.',docs:'https://github.com/AdguardTeam/Scriptlets/blob/master/wiki/about-redirects.md#2x2-transparent.png',versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,isBlocking:false,resourceTypes:[]},{name:'2x2.png',aliases:null,description:'Redirects to a 2x2 transparent PNG.',docs:'https://github.com/gorhill/uBlock/wiki/Resources-Library#available-empty-redirect-resources',versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,isBlocking:false,resourceTypes:['image']},{name:'2x2-transparent-png',aliases:null,description:'Redirects to a 2x2 transparent PNG.',docs:'https://help.adblockplus.org/hc/en-us/articles/360062733293#rewrite',versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,isBlocking:false,resourceTypes:[]}],map:{'1':0,'2':0,'4':0,'8':0,'16':0,'32':0,'64':0,'1024':1,'2048':1,'4096':1,'8192':1,'16384':2,'32768':2,'65536':2,'131072':2}},{shared:[{name:'32x32-transparent.png',aliases:['32x32.png','32x32-transparent-png'],description:'Redirects to a 32x32 transparent PNG.',docs:'https://github.com/AdguardTeam/Scriptlets/blob/master/wiki/about-redirects.md#32x32-transparent.png',versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,isBlocking:false,resourceTypes:[]},{name:'32x32.png',aliases:null,description:'Redirects to a 32x32 transparent PNG.',docs:'https://github.com/gorhill/uBlock/wiki/Resources-Library#available-empty-redirect-resources',versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,isBlocking:false,resourceTypes:['image']},{name:'32x32-transparent-png',aliases:null,description:'Redirects to a 32x32 transparent PNG.',docs:'https://help.adblockplus.org/hc/en-us/articles/360062733293#rewrite',versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,isBlocking:false,resourceTypes:[]}],map:{'1':0,'2':0,'4':0,'8':0,'16':0,'32':0,'64':0,'1024':1,'2048':1,'4096':1,'8192':1,'16384':2,'32768':2,'65536':2,'131072':2}},{shared:[{name:'3x2-transparent.png',aliases:['3x2.png','3x2-transparent-png'],description:'Redirects to a 3x2 transparent PNG.',docs:'https://github.com/AdguardTeam/Scriptlets/blob/master/wiki/about-redirects.md#3x2-transparent.png',versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,isBlocking:false,resourceTypes:[]},{name:'3x2.png',aliases:null,description:'Redirects to a 3x2 transparent PNG.',docs:'https://github.com/gorhill/uBlock/wiki/Resources-Library#available-empty-redirect-resources',versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,isBlocking:false,resourceTypes:['image']},{name:'3x2-transparent-png',aliases:null,description:'Redirects to a 3x2 transparent PNG.',docs:'https://help.adblockplus.org/hc/en-us/articles/360062733293#rewrite',versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,isBlocking:false,resourceTypes:[]}],map:{'1':0,'2':0,'4':0,'8':0,'16':0,'32':0,'64':0,'1024':1,'2048':1,'4096':1,'8192':1,'16384':2,'32768':2,'65536':2,'131072':2}},{shared:[{name:'amazon-apstag',aliases:['ubo-amazon_apstag.js','amazon_apstag.js'],description:'Mocks Amazon\'s apstag.js',docs:'https://github.com/AdguardTeam/Scriptlets/blob/master/wiki/about-redirects.md#amazon-apstag',versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,isBlocking:false,resourceTypes:[]},{name:'amazon_apstag.js',aliases:null,description:'Mocks Amazon\'s apstag.js',docs:'https://github.com/gorhill/uBlock/wiki/Resources-Library#amazon_apstagjs-',versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,isBlocking:false,resourceTypes:['script']}],map:{'1':0,'2':0,'4':0,'8':0,'16':0,'32':0,'64':0,'1024':1,'2048':1,'4096':1,'8192':1}},{shared:[{name:'amazon_ads.js',aliases:null,description:null,docs:null,versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,isBlocking:false,resourceTypes:['script']}],map:{'1024':0,'2048':0,'4096':0,'8192':0}},{shared:[{name:'ampproject_v0.js',aliases:null,description:null,docs:null,versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,isBlocking:false,resourceTypes:['script']}],map:{'1024':0,'2048':0,'4096':0,'8192':0}},{shared:[{name:'ati-smarttag',aliases:null,description:null,docs:null,versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,isBlocking:false,resourceTypes:[]}],map:{'1':0,'2':0,'4':0,'8':0,'16':0,'32':0,'64':0}},{shared:[{name:'chartbeat.js',aliases:null,description:null,docs:null,versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,isBlocking:false,resourceTypes:['script']}],map:{'1024':0,'2048':0,'4096':0,'8192':0}},{shared:[{name:'click2load.html',aliases:['click2load.html','ubo-click2load.html'],description:'Redirects resource and replaces supposed content by decoy frame with button for original content recovering.',docs:null,versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,isBlocking:true,resourceTypes:[]},{name:'click2load.html',aliases:null,description:'Redirects resource and replaces supposed content by decoy frame with button for original content recovering.',docs:null,versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,isBlocking:true,resourceTypes:[]}],map:{'1':0,'2':0,'4':0,'8':0,'16':0,'32':0,'64':0,'1024':1,'2048':1,'4096':1,'8192':1}},{shared:[{name:'didomi-loader',aliases:null,description:'Mocks Didomi\'s CMP loader script.',docs:null,versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,isBlocking:false,resourceTypes:[]}],map:{'1':0,'2':0,'4':0,'8':0,'16':0,'32':0,'64':0}},{shared:[{name:'empty',aliases:null,description:'Redirects to an empty file.',docs:null,versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,isBlocking:false,resourceTypes:[]},{name:'empty',aliases:null,description:'Redirects to an empty file.',docs:null,versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,isBlocking:false,resourceTypes:[]}],map:{'1':0,'2':0,'4':0,'8':0,'16':0,'32':0,'64':0,'1024':1,'2048':1,'4096':1,'8192':1}},{shared:[{name:'fingerprintjs2',aliases:['fingerprint2.js'],description:'Mocks FingerprintJS2 script.',docs:null,versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,isBlocking:false,resourceTypes:[]},{name:'fingerprint2.js',aliases:null,description:'Mocks FingerprintJS2 script.',docs:null,versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,isBlocking:false,resourceTypes:['script']}],map:{'1':0,'2':0,'4':0,'8':0,'16':0,'32':0,'64':0,'1024':1,'2048':1,'4096':1,'8192':1}},{shared:[{name:'fingerprintjs3',aliases:['fingerprint3.js'],description:'Mocks FingerprintJS v3.',docs:null,versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,isBlocking:false,resourceTypes:[]},{name:'fingerprint3.js',aliases:null,description:'Mocks FingerprintJS v3.',docs:null,versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,isBlocking:false,resourceTypes:['script']}],map:{'1':0,'2':0,'4':0,'8':0,'16':0,'32':0,'64':0,'1024':1,'2048':1,'4096':1,'8192':1}},{shared:[{name:'gemius',aliases:null,description:'Mocks Gemius Analytics.',docs:null,versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,isBlocking:false,resourceTypes:[]}],map:{'1':0,'2':0,'4':0,'8':0,'16':0,'32':0,'64':0}},{shared:[{name:'google-analytics-ga',aliases:['ubo-google-analytics_ga.js','google-analytics_ga.js'],description:'Mocks old Google Analytics API.',docs:null,versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,isBlocking:false,resourceTypes:[]},{name:'google-analytics_ga.js',aliases:null,description:'Mocks old Google Analytics API.',docs:null,versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,isBlocking:false,resourceTypes:['script']}],map:{'1':0,'2':0,'4':0,'8':0,'16':0,'32':0,'64':0,'1024':1,'2048':1,'4096':1,'8192':1}},{shared:[{name:'google-analytics',aliases:['ubo-google-analytics_analytics.js','google-analytics_analytics.js','googletagmanager-gtm','ubo-googletagmanager_gtm.js','googletagmanager_gtm.js'],description:'Mocks Google\'s Analytics and Tag Manager APIs.',docs:null,versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,isBlocking:false,resourceTypes:[]},{name:'google-analytics_analytics.js',aliases:null,description:'Mocks Google\'s Analytics and Tag Manager APIs.',docs:null,versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,isBlocking:false,resourceTypes:['script']}],map:{'1':0,'2':0,'4':0,'8':0,'16':0,'32':0,'64':0,'1024':1,'2048':1,'4096':1,'8192':1}},{shared:[{name:'google-analytics_cx_api.js',aliases:null,description:null,docs:null,versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,isBlocking:false,resourceTypes:['script']}],map:{'1024':0,'2048':0,'4096':0,'8192':0}},{shared:[{name:'google-analytics_inpage_linkid.js',aliases:null,description:null,docs:null,versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,isBlocking:false,resourceTypes:['script']}],map:{'1024':0,'2048':0,'4096':0,'8192':0}},{shared:[{name:'google-ima3',aliases:['ubo-google-ima.js','google-ima.js'],description:'Mocks the IMA SDK of Google.',docs:null,versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,isBlocking:false,resourceTypes:[]},{name:'google-ima.js',aliases:null,description:'Mocks the IMA SDK of Google.',docs:null,versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,isBlocking:false,resourceTypes:['script']}],map:{'1':0,'2':0,'4':0,'8':0,'16':0,'32':0,'64':0,'1024':1,'2048':1,'4096':1,'8192':1}},{shared:[{name:'googlesyndication-adsbygoogle',aliases:['ubo-googlesyndication_adsbygoogle.js','ubo-googlesyndication.com/adsbygoogle.js','googlesyndication_adsbygoogle.js'],description:'Mocks Google AdSense API.',docs:null,versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,isBlocking:false,resourceTypes:[]},{name:'googlesyndication_adsbygoogle.js',aliases:['googlesyndication.com/adsbygoogle.js'],description:'Mocks Google AdSense API.',docs:null,versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,isBlocking:false,resourceTypes:['script']}],map:{'1':0,'2':0,'4':0,'8':0,'16':0,'32':0,'64':0,'1024':1,'2048':1,'4096':1,'8192':1}},{shared:[{name:'googletagservices-gpt',aliases:['ubo-googletagservices_gpt.js','googletagservices_gpt.js'],description:'Mocks Google Publisher Tag API.',docs:null,versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,isBlocking:false,resourceTypes:[]},{name:'googletagservices_gpt.js',aliases:null,description:'Mocks Google Publisher Tag API.',docs:null,versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,isBlocking:false,resourceTypes:['script']}],map:{'1':0,'2':0,'4':0,'8':0,'16':0,'32':0,'64':0,'1024':1,'2048':1,'4096':1,'8192':1}},{shared:[{name:'hd-main.js',aliases:null,description:null,docs:null,versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,isBlocking:false,resourceTypes:['script']}],map:{'1024':0,'2048':0,'4096':0,'8192':0}},{shared:[{name:'matomo',aliases:null,description:'Mocks the piwik.js file of Matomo (formerly Piwik).',docs:null,versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,isBlocking:false,resourceTypes:[]}],map:{'1':0,'2':0,'4':0,'8':0,'16':0,'32':0,'64':0}},{shared:[{name:'metrika-yandex-tag',aliases:null,description:'Mocks Yandex Metrika API.',docs:null,versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,isBlocking:false,resourceTypes:[]}],map:{'1':0,'2':0,'4':0,'8':0,'16':0,'32':0,'64':0}},{shared:[{name:'metrika-yandex-watch',aliases:null,description:'Mocks the old Yandex Metrika API.',docs:null,versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,isBlocking:false,resourceTypes:[]}],map:{'1':0,'2':0,'4':0,'8':0,'16':0,'32':0,'64':0}},{shared:[{name:'naver-wcslog',aliases:null,description:'Mocks wcslog.js of Naver Analytics.',docs:null,versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,isBlocking:false,resourceTypes:[]}],map:{'1':0,'2':0,'4':0,'8':0,'16':0,'32':0,'64':0}},{shared:[{name:'no-protected-audience',aliases:null,description:'Prevents using the Protected Audience API.',docs:null,versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,isBlocking:false,resourceTypes:[]}],map:{'1':0,'2':0,'4':0,'8':0,'16':0,'32':0,'64':0}},{shared:[{name:'no-topics',aliases:null,description:'Prevents using the Topics API.',docs:null,versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,isBlocking:false,resourceTypes:[]}],map:{'1':0,'2':0,'4':0,'8':0,'16':0,'32':0,'64':0}},{shared:[{name:'noeval',aliases:['noeval.js','silent-noeval.js','ubo-noeval.js','ubo-silent-noeval.js','ubo-noeval','ubo-silent-noeval'],description:'Prevents page to use eval.',docs:null,versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,isBlocking:false,resourceTypes:[]},{name:'noeval.js',aliases:null,description:'Prevents page to use eval.',docs:null,versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,isBlocking:false,resourceTypes:['script']}],map:{'1':0,'2':0,'4':0,'8':0,'16':0,'32':0,'64':0,'1024':1,'2048':1,'4096':1,'8192':1}},{shared:[{name:'noop-0.5s.mp3',aliases:null,description:'Redirects to an empty MP3 file with a duration of 0.5 seconds.',docs:null,versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,isBlocking:false,resourceTypes:['media']}],map:{'1024':0,'2048':0,'4096':0,'8192':0}},{shared:[{name:'noopcss',aliases:['noop.css','blank-css'],description:'Redirects to an empty CSS file.',docs:null,versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,isBlocking:false,resourceTypes:[]},{name:'noop.css',aliases:null,description:'Redirects to an empty CSS file.',docs:null,versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,isBlocking:false,resourceTypes:['stylesheet']},{name:'blank-css',aliases:null,description:'Redirects to an empty CSS file.',docs:null,versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,isBlocking:false,resourceTypes:[]}],map:{'1':0,'2':0,'4':0,'8':0,'16':0,'32':0,'64':0,'1024':1,'2048':1,'4096':1,'8192':1,'16384':2,'32768':2,'65536':2,'131072':2}},{shared:[{name:'noopframe',aliases:['noop.html','blank-html'],description:'Redirects to an empty HTML file.',docs:null,versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,isBlocking:false,resourceTypes:[]},{name:'noop.html',aliases:null,description:'Redirects to an empty HTML file.',docs:null,versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,isBlocking:false,resourceTypes:['sub_frame']},{name:'blank-html',aliases:null,description:'Redirects to an empty HTML file.',docs:null,versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,isBlocking:false,resourceTypes:[]}],map:{'1':0,'2':0,'4':0,'8':0,'16':0,'32':0,'64':0,'1024':1,'2048':1,'4096':1,'8192':1,'16384':2,'32768':2,'65536':2,'131072':2}},{shared:[{name:'noopjs',aliases:['noop.js','blank-js'],description:'Redirects to an empty JavaScript file.',docs:null,versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,isBlocking:false,resourceTypes:[]},{name:'noop.js',aliases:null,description:'Redirects to an empty JavaScript file.',docs:null,versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,isBlocking:false,resourceTypes:['script']},{name:'blank-js',aliases:null,description:'Redirects to an empty JavaScript file.',docs:null,versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,isBlocking:false,resourceTypes:[]}],map:{'1':0,'2':0,'4':0,'8':0,'16':0,'32':0,'64':0,'1024':1,'2048':1,'4096':1,'8192':1,'16384':2,'32768':2,'65536':2,'131072':2}},{shared:[{name:'noopjson',aliases:['noop.json'],description:'Redirects to an empty JSON file.',docs:null,versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,isBlocking:false,resourceTypes:[]},{name:'noop.json',aliases:null,description:'Redirects to an empty JSON file.',docs:null,versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,isBlocking:false,resourceTypes:[]}],map:{'1':0,'2':0,'4':0,'8':0,'16':0,'32':0,'64':0,'1024':1,'2048':1,'4096':1,'8192':1}},{shared:[{name:'noopmp3-0.1s',aliases:['noop-0.1s.mp3','blank-mp3'],description:'Redirects to an empty MP3 file with a duration of 0.1 seconds.',docs:null,versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,isBlocking:false,resourceTypes:[]},{name:'noop-0.1s.mp3',aliases:null,description:'Redirects to an empty MP3 file with a duration of 0.1 seconds.',docs:null,versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,isBlocking:false,resourceTypes:['media']},{name:'blank-mp3',aliases:null,description:'Redirects to an empty MP3 file with a duration of 0.1 seconds.',docs:null,versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,isBlocking:false,resourceTypes:[]}],map:{'1':0,'2':0,'4':0,'8':0,'16':0,'32':0,'64':0,'1024':1,'2048':1,'4096':1,'8192':1,'16384':2,'32768':2,'65536':2,'131072':2}},{shared:[{name:'noopmp4-1s',aliases:['noop-1s.mp4','blank-mp4'],description:'Redirects to an empty MP4 file with a duration of 1 second.',docs:null,versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,isBlocking:false,resourceTypes:[]},{name:'noop-1s.mp4',aliases:null,description:'Redirects to an empty MP4 file with a duration of 1 second.',docs:null,versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,isBlocking:false,resourceTypes:['media']},{name:'blank-mp4',aliases:null,description:'Redirects to an empty MP4 file with a duration of 1 second.',docs:null,versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,isBlocking:false,resourceTypes:[]}],map:{'1':0,'2':0,'4':0,'8':0,'16':0,'32':0,'64':0,'1024':1,'2048':1,'4096':1,'8192':1,'16384':2,'32768':2,'65536':2,'131072':2}},{shared:[{name:'nooptext',aliases:['noop.txt','blank-text'],description:'Redirects to an empty text file.',docs:null,versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,isBlocking:false,resourceTypes:[]},{name:'noop.txt',aliases:null,description:'Redirects to an empty text file.',docs:null,versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,isBlocking:false,resourceTypes:['image','media','sub_frame','stylesheet','script','xmlhttprequest','other']},{name:'blank-text',aliases:null,description:'Redirects to an empty text file.',docs:null,versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,isBlocking:false,resourceTypes:[]}],map:{'1':0,'2':0,'4':0,'8':0,'16':0,'32':0,'64':0,'1024':1,'2048':1,'4096':1,'8192':1,'16384':2,'32768':2,'65536':2,'131072':2}},{shared:[{name:'noopvast-2.0',aliases:null,description:'Redirects to an empty VAST 2.0 XML file.',docs:null,versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,isBlocking:false,resourceTypes:[]}],map:{'1':0,'2':0,'4':0,'8':0,'16':0,'32':0,'64':0}},{shared:[{name:'noopvast-3.0',aliases:null,description:'Redirects to an empty VAST 3.0 XML file.',docs:null,versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,isBlocking:false,resourceTypes:[]}],map:{'1':0,'2':0,'4':0,'8':0,'16':0,'32':0,'64':0}},{shared:[{name:'noopvast-4.0',aliases:null,description:'Redirects to an empty VAST 4.0 XML file.',docs:null,versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,isBlocking:false,resourceTypes:[]}],map:{'1':0,'2':0,'4':0,'8':0,'16':0,'32':0,'64':0}},{shared:[{name:'noopvmap-1.0',aliases:['noop-vmap1.0.xml'],description:'Redirects to an empty VMAP 1.0 XML file.',docs:null,versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,isBlocking:false,resourceTypes:[]},{name:'noop-vmap1.0.xml',aliases:null,description:'Redirects to an empty VMAP 1.0 XML file.',docs:null,versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,isBlocking:false,resourceTypes:['media']}],map:{'1':0,'2':0,'4':0,'8':0,'16':0,'32':0,'64':0,'1024':1,'2048':1,'4096':1,'8192':1}},{shared:[{name:'nowebrtc',aliases:['nowebrtc.js','ubo-nowebrtc.js','ubo-nowebrtc'],description:'Disables WebRTC by overriding `RTCPeerConnection`.',docs:null,versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,isBlocking:false,resourceTypes:[]},{name:'nowebrtc.js',aliases:null,description:'Disables WebRTC by overriding `RTCPeerConnection`.',docs:null,versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,isBlocking:false,resourceTypes:['other']}],map:{'1':0,'2':0,'4':0,'8':0,'16':0,'32':0,'64':0,'1024':1,'2048':1,'4096':1,'8192':1}},{shared:[{name:'outbrain-widget.js',aliases:null,description:null,docs:null,versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,isBlocking:false,resourceTypes:['script']}],map:{'1024':0,'2048':0,'4096':0,'8192':0}},{shared:[{name:'pardot-1.0',aliases:null,description:'Mocks the pd.js file of Salesforce.',docs:null,versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,isBlocking:false,resourceTypes:[]}],map:{'1':0,'2':0,'4':0,'8':0,'16':0,'32':0,'64':0}},{shared:[{name:'prebid-ads',aliases:['prebid-ads.js'],description:'Mocks prebid-ads.js script.',docs:null,versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,isBlocking:false,resourceTypes:[]},{name:'prebid-ads.js',aliases:null,description:'Mocks prebid-ads.js script.',docs:null,versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,isBlocking:false,resourceTypes:['script']}],map:{'1':0,'2':0,'4':0,'8':0,'16':0,'32':0,'64':0,'1024':1,'2048':1,'4096':1,'8192':1}},{shared:[{name:'prebid',aliases:null,description:'Mocks the prebid.js header bidding suit.',docs:null,versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,isBlocking:false,resourceTypes:[]}],map:{'1':0,'2':0,'4':0,'8':0,'16':0,'32':0,'64':0}},{shared:[{name:'prevent-bab',aliases:['nobab.js'],description:'Prevents BlockAdblock script from detecting an ad blocker.',docs:null,versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,isBlocking:false,resourceTypes:[]},{name:'nobab.js',aliases:null,description:'Prevents BlockAdblock script from detecting an ad blocker.',docs:null,versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,isBlocking:false,resourceTypes:['script']}],map:{'1':0,'2':0,'4':0,'8':0,'16':0,'32':0,'64':0,'1024':1,'2048':1,'4096':1,'8192':1}},{shared:[{name:'prevent-bab2',aliases:['nobab2.js'],description:'Prevents BlockAdblock script from detecting an ad blocker.',docs:null,versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,isBlocking:false,resourceTypes:[]},{name:'nobab2.js',aliases:null,description:'Prevents BlockAdblock script from detecting an ad blocker.',docs:null,versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,isBlocking:false,resourceTypes:['script']}],map:{'1':0,'2':0,'4':0,'8':0,'16':0,'32':0,'64':0,'1024':1,'2048':1,'4096':1,'8192':1}},{shared:[{name:'prevent-fab-3.2.0',aliases:['nofab.js'],description:'Mocks FAB script v3.2.0.',docs:null,versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,isBlocking:false,resourceTypes:[]},{name:'nofab.js',aliases:['fuckadblock.js-3.2.0','fuckadblock.js-3.2.0.js'],description:'Mocks FAB script v3.2.0.',docs:null,versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,isBlocking:false,resourceTypes:['script']}],map:{'1':0,'2':0,'4':0,'8':0,'16':0,'32':0,'64':0,'1024':1,'2048':1,'4096':1,'8192':1}},{shared:[{name:'prevent-popads-net',aliases:['popads.js'],description:'Aborts on property write (PopAds, popns), throws reference error with random id.',docs:null,versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,isBlocking:false,resourceTypes:[]},{name:'popads.js',aliases:null,description:'Aborts on property write (PopAds, popns), throws reference error with random id.',docs:null,versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,isBlocking:false,resourceTypes:['script']}],map:{'1':0,'2':0,'4':0,'8':0,'16':0,'32':0,'64':0,'1024':1,'2048':1,'4096':1,'8192':1}},{shared:[{name:'scorecardresearch-beacon',aliases:['scorecardresearch_beacon.js'],description:'Mocks Scorecard Research API.',docs:null,versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,isBlocking:false,resourceTypes:[]},{name:'scorecardresearch_beacon.js',aliases:null,description:'Mocks Scorecard Research API.',docs:null,versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,isBlocking:false,resourceTypes:['script']}],map:{'1':0,'2':0,'4':0,'8':0,'16':0,'32':0,'64':0,'1024':1,'2048':1,'4096':1,'8192':1}},{shared:[{name:'set-popads-dummy',aliases:['popads-dummy.js'],description:'Sets static properties PopAds and popns.',docs:null,versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,isBlocking:false,resourceTypes:[]},{name:'popads-dummy.js',aliases:null,description:'Sets static properties PopAds and popns.',docs:null,versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,isBlocking:false,resourceTypes:['script']}],map:{'1':0,'2':0,'4':0,'8':0,'16':0,'32':0,'64':0,'1024':1,'2048':1,'4096':1,'8192':1}}],map:{'1x1-transparent.gif':0,'1x1.gif':0,'1x1-transparent-gif':0,'2x2-transparent.png':1,'2x2.png':1,'2x2-transparent-png':1,'32x32-transparent.png':2,'32x32.png':2,'32x32-transparent-png':2,'3x2-transparent.png':3,'3x2.png':3,'3x2-transparent-png':3,'amazon-apstag':4,'ubo-amazon_apstag.js':4,'amazon_apstag.js':4,'amazon_ads.js':5,'ampproject_v0.js':6,'ati-smarttag':7,'chartbeat.js':8,'click2load.html':9,'ubo-click2load.html':9,'didomi-loader':10,empty:11,fingerprintjs2:12,'fingerprint2.js':12,fingerprintjs3:13,'fingerprint3.js':13,gemius:14,'google-analytics-ga':15,'ubo-google-analytics_ga.js':15,'google-analytics_ga.js':15,'google-analytics':16,'ubo-google-analytics_analytics.js':16,'google-analytics_analytics.js':16,'googletagmanager-gtm':16,'ubo-googletagmanager_gtm.js':16,'googletagmanager_gtm.js':16,'google-analytics_cx_api.js':17,'google-analytics_inpage_linkid.js':18,'google-ima3':19,'ubo-google-ima.js':19,'google-ima.js':19,'googlesyndication-adsbygoogle':20,'ubo-googlesyndication_adsbygoogle.js':20,'ubo-googlesyndication.com/adsbygoogle.js':20,'googlesyndication_adsbygoogle.js':20,'googlesyndication.com/adsbygoogle.js':20,'googletagservices-gpt':21,'ubo-googletagservices_gpt.js':21,'googletagservices_gpt.js':21,'hd-main.js':22,matomo:23,'metrika-yandex-tag':24,'metrika-yandex-watch':25,'naver-wcslog':26,'no-protected-audience':27,'no-topics':28,noeval:29,'noeval.js':29,'silent-noeval.js':29,'ubo-noeval.js':29,'ubo-silent-noeval.js':29,'ubo-noeval':29,'ubo-silent-noeval':29,'noop-0.5s.mp3':30,noopcss:31,'noop.css':31,'blank-css':31,noopframe:32,'noop.html':32,'blank-html':32,noopjs:33,'noop.js':33,'blank-js':33,noopjson:34,'noop.json':34,'noopmp3-0.1s':35,'noop-0.1s.mp3':35,'blank-mp3':35,'noopmp4-1s':36,'noop-1s.mp4':36,'blank-mp4':36,nooptext:37,'noop.txt':37,'blank-text':37,'noopvast-2.0':38,'noopvast-3.0':39,'noopvast-4.0':40,'noopvmap-1.0':41,'noop-vmap1.0.xml':41,nowebrtc:42,'nowebrtc.js':42,'ubo-nowebrtc.js':42,'ubo-nowebrtc':42,'outbrain-widget.js':43,'pardot-1.0':44,'prebid-ads':45,'prebid-ads.js':45,prebid:46,'prevent-bab':47,'nobab.js':47,'prevent-bab2':48,'nobab2.js':48,'prevent-fab-3.2.0':49,'nofab.js':49,'fuckadblock.js-3.2.0':49,'fuckadblock.js-3.2.0.js':49,'prevent-popads-net':50,'popads.js':50,'scorecardresearch-beacon':51,'scorecardresearch_beacon.js':51,'set-popads-dummy':52,'popads-dummy.js':52}};
const scriptletsCompatibilityTableData = {shared:[{shared:[{name:'abort-current-inline-script',aliases:['abort-current-script.js','ubo-abort-current-script.js','acs.js','ubo-acs.js','ubo-abort-current-script','ubo-acs','abort-current-inline-script.js','ubo-abort-current-inline-script.js','acis.js','ubo-acis.js','ubo-abort-current-inline-script','ubo-acis','abp-abort-current-inline-script'],description:null,docs:'https://github.com/AdguardTeam/Scriptlets/blob/master/wiki/about-scriptlets.md#abort-current-inline-script',versionAdded:'1.0.4',versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,parameters:[{name:'property',required:true,description:null,pattern:null,'default':null,debug:false},{name:'search',required:false,description:null,pattern:null,'default':null,debug:false}]},{name:'abort-current-script.js',aliases:['acs.js','abort-current-inline-script.js','acis.js'],description:null,docs:'https://github.com/gorhill/uBlock/wiki/Resources-Library#abort-current-scriptjs-',versionAdded:'1.37.0',versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,parameters:[{name:'property',required:true,description:null,pattern:null,'default':null,debug:false},{name:'search',required:false,description:null,pattern:null,'default':null,debug:false}]},{name:'abort-current-inline-script',aliases:null,description:null,docs:'https://help.adblockplus.org/hc/en-us/articles/1500002338501-Snippet-filters-tutorial#snippets-ref',versionAdded:'3.4.3',versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,parameters:[{name:'api',required:true,description:null,pattern:null,'default':null,debug:false},{name:'search',required:false,description:null,pattern:null,'default':null,debug:false}]}],map:{'1':0,'2':0,'4':0,'8':0,'16':0,'32':0,'64':0,'1024':1,'2048':1,'4096':1,'8192':1,'16384':2,'32768':2,'65536':2,'131072':2}},{shared:[{name:'abort-on-property-read',aliases:['abort-on-property-read.js','ubo-abort-on-property-read.js','aopr.js','ubo-aopr.js','ubo-abort-on-property-read','ubo-aopr','abp-abort-on-property-read'],description:null,docs:'https://github.com/AdguardTeam/Scriptlets/blob/master/wiki/about-scriptlets.md#abort-on-property-read',versionAdded:'1.0.4',versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,parameters:[{name:'property',required:true,description:null,pattern:null,'default':null,debug:false}]},{name:'abort-on-property-read.js',aliases:['aopr.js'],description:null,docs:'https://github.com/gorhill/uBlock/wiki/Resources-Library#abort-on-property-readjs-',versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,parameters:[{name:'property',required:true,description:null,pattern:null,'default':null,debug:false}]},{name:'abort-on-property-read',aliases:null,description:null,docs:'https://help.adblockplus.org/hc/en-us/articles/1500002338501-Snippet-filters-tutorial#snippets-ref',versionAdded:'3.4.1',versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,parameters:[{name:'property',required:true,description:null,pattern:null,'default':null,debug:false},{name:'setConfigurable',required:false,description:null,pattern:null,'default':null,debug:false}]}],map:{'1':0,'2':0,'4':0,'8':0,'16':0,'32':0,'64':0,'1024':1,'2048':1,'4096':1,'8192':1,'16384':2,'32768':2,'65536':2,'131072':2}},{shared:[{name:'abort-on-property-write',aliases:['abort-on-property-write.js','ubo-abort-on-property-write.js','aopw.js','ubo-aopw.js','ubo-abort-on-property-write','ubo-aopw','abp-abort-on-property-write'],description:null,docs:'https://github.com/AdguardTeam/Scriptlets/blob/master/wiki/about-scriptlets.md#abort-on-property-write',versionAdded:'1.0.4',versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,parameters:[{name:'property',required:true,description:null,pattern:null,'default':null,debug:false}]},{name:'abort-on-property-write.js',aliases:['aopw.js'],description:null,docs:'https://github.com/gorhill/uBlock/wiki/Resources-Library#abort-on-property-writejs-',versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,parameters:[{name:'property',required:true,description:null,pattern:null,'default':null,debug:false}]},{name:'abort-on-property-write',aliases:null,description:null,docs:'https://help.adblockplus.org/hc/en-us/articles/1500002338501-Snippet-filters-tutorial#snippets-ref',versionAdded:'3.4.3',versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,parameters:[{name:'property',required:true,description:null,pattern:null,'default':null,debug:false},{name:'setConfigurable',required:false,description:null,pattern:null,'default':null,debug:false}]}],map:{'1':0,'2':0,'4':0,'8':0,'16':0,'32':0,'64':0,'1024':1,'2048':1,'4096':1,'8192':1,'16384':2,'32768':2,'65536':2,'131072':2}},{shared:[{name:'abort-on-stack-trace',aliases:['abort-on-stack-trace.js','ubo-abort-on-stack-trace.js','aost.js','ubo-aost.js','ubo-abort-on-stack-trace','ubo-aost','abp-abort-on-stack-trace'],description:null,docs:'https://github.com/AdguardTeam/Scriptlets/blob/master/wiki/about-scriptlets.md#abort-on-stack-trace',versionAdded:'1.5.0',versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,parameters:[{name:'property',required:true,description:null,pattern:null,'default':null,debug:false},{name:'stack',required:true,description:null,pattern:null,'default':null,debug:false}]},{name:'abort-on-stack-trace.js',aliases:['aost.js'],description:null,docs:'https://github.com/gorhill/uBlock/wiki/Resources-Library#abort-on-stack-tracejs-',versionAdded:'1.29.3rc9',versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,parameters:[{name:'property',required:true,description:null,pattern:null,'default':null,debug:false},{name:'stack',required:true,description:null,pattern:null,'default':null,debug:false}]}],map:{'1':0,'2':0,'4':0,'8':0,'16':0,'32':0,'64':0,'1024':1,'2048':1,'4096':1,'8192':1}},{shared:[{name:'adjust-setInterval',aliases:['nano-setInterval-booster.js','ubo-nano-setInterval-booster.js','nano-sib.js','ubo-nano-sib.js','adjust-setInterval.js','ubo-adjust-setInterval.js','ubo-nano-setInterval-booster','ubo-nano-sib','ubo-adjust-setInterval'],description:null,docs:'https://github.com/AdguardTeam/Scriptlets/blob/master/wiki/about-scriptlets.md#adjust-setInterval',versionAdded:'1.0.4',versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,parameters:[{name:'matchCallback',required:false,description:null,pattern:null,'default':null,debug:false},{name:'matchDelay',required:false,description:null,pattern:null,'default':null,debug:false},{name:'boost',required:false,description:null,pattern:null,'default':null,debug:false}]},{name:'adjust-setInterval.js',aliases:['nano-setInterval-booster.js','nano-sib.js'],description:null,docs:'https://github.com/gorhill/uBlock/wiki/Resources-Library#adjust-setIntervaljs-',versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,parameters:[{name:'matchCallback',required:false,description:null,pattern:null,'default':null,debug:false},{name:'matchDelay',required:false,description:null,pattern:null,'default':null,debug:false},{name:'boost',required:false,description:null,pattern:null,'default':null,debug:false}]}],map:{'1':0,'2':0,'4':0,'8':0,'16':0,'32':0,'64':0,'1024':1,'2048':1,'4096':1,'8192':1}},{shared:[{name:'adjust-setTimeout',aliases:['adjust-setTimeout.js','ubo-adjust-setTimeout.js','nano-setTimeout-booster.js','ubo-nano-setTimeout-booster.js','nano-stb.js','ubo-nano-stb.js','ubo-adjust-setTimeout','ubo-nano-setTimeout-booster','ubo-nano-stb'],description:null,docs:'https://github.com/AdguardTeam/Scriptlets/blob/master/wiki/about-scriptlets.md#adjust-setTimeout',versionAdded:'1.0.4',versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,parameters:[{name:'matchCallback',required:false,description:null,pattern:null,'default':null,debug:false},{name:'matchDelay',required:false,description:null,pattern:null,'default':null,debug:false},{name:'boost',required:false,description:null,pattern:null,'default':null,debug:false}]},{name:'adjust-setTimeout.js',aliases:['nano-setTimeout-booster.js','nano-stb.js'],description:null,docs:'https://github.com/gorhill/uBlock/wiki/Resources-Library#adjust-setTimeoutjs-',versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,parameters:[{name:'matchCallback',required:false,description:null,pattern:null,'default':null,debug:false},{name:'matchDelay',required:false,description:null,pattern:null,'default':null,debug:false},{name:'boost',required:false,description:null,pattern:null,'default':null,debug:false}]}],map:{'1':0,'2':0,'4':0,'8':0,'16':0,'32':0,'64':0,'1024':1,'2048':1,'4096':1,'8192':1}},{shared:[{name:'amazon-apstag',aliases:['ubo-amazon_apstag.js','amazon_apstag.js'],description:null,docs:'https://github.com/AdguardTeam/Scriptlets/blob/master/wiki/about-scriptlets.md#amazon-apstag',versionAdded:'1.10.25',versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null}],map:{'1':0,'2':0,'4':0,'8':0,'16':0,'32':0,'64':0}},{shared:[{name:'call-nothrow',aliases:['call-nothrow.js','ubo-call-nothrow.js','ubo-call-nothrow'],description:null,docs:'https://github.com/AdguardTeam/Scriptlets/blob/master/wiki/about-scriptlets.md#call-nothrow',versionAdded:'1.10.1',versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,parameters:[{name:'functionName',required:true,description:null,pattern:null,'default':null,debug:false}]},{name:'call-nothrow.js',aliases:null,description:null,docs:'https://github.com/gorhill/uBlock/wiki/Resources-Library#call-nothrowjs-',versionAdded:'1.48.1b0',versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,parameters:[{name:'functionName',required:true,description:null,pattern:null,'default':null,debug:false}]}],map:{'1':0,'2':0,'4':0,'8':0,'16':0,'32':0,'64':0,'1024':1,'2048':1,'4096':1,'8192':1}},{shared:[{name:'close-window',aliases:['window-close-if.js','ubo-window-close-if.js','ubo-window-close-if','close-window.js','ubo-close-window.js','ubo-close-window'],description:null,docs:'https://github.com/AdguardTeam/Scriptlets/blob/master/wiki/about-scriptlets.md#close-window',versionAdded:'1.5.0',versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,parameters:[{name:'path',required:false,description:null,pattern:null,'default':null,debug:false}]},{name:'close-window.js',aliases:['window-close-if.js'],description:null,docs:'https://github.com/gorhill/uBlock/wiki/Resources-Library#close-windowjs-',versionAdded:'1.39.3b10',versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,parameters:[{name:'path',required:false,description:null,pattern:null,'default':null,debug:false}]}],map:{'1':0,'2':0,'4':0,'8':0,'16':0,'32':0,'64':0,'1024':1,'2048':1,'4096':1,'8192':1}},{shared:[{name:'debug-current-inline-script',aliases:null,description:null,docs:'https://github.com/AdguardTeam/Scriptlets/blob/master/wiki/about-scriptlets.md#debug-current-inline-script',versionAdded:'1.0.4',versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,parameters:[{name:'property',required:true,description:null,pattern:null,'default':null,debug:false},{name:'search',required:false,description:null,pattern:null,'default':null,debug:false}]}],map:{'1':0,'2':0,'4':0,'8':0,'16':0,'32':0,'64':0}},{shared:[{name:'debug-on-property-read',aliases:null,description:null,docs:'https://github.com/AdguardTeam/Scriptlets/blob/master/wiki/about-scriptlets.md#debug-on-property-read',versionAdded:'1.0.4',versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,parameters:[{name:'property',required:true,description:null,pattern:null,'default':null,debug:false}]}],map:{'1':0,'2':0,'4':0,'8':0,'16':0,'32':0,'64':0}},{shared:[{name:'debug-on-property-write',aliases:null,description:null,docs:'https://github.com/AdguardTeam/Scriptlets/blob/master/wiki/about-scriptlets.md#debug-on-property-write',versionAdded:'1.0.4',versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,parameters:[{name:'property',required:true,description:null,pattern:null,'default':null,debug:false}]}],map:{'1':0,'2':0,'4':0,'8':0,'16':0,'32':0,'64':0}},{shared:[{name:'didomi-loader',aliases:null,description:null,docs:'https://github.com/AdguardTeam/Scriptlets/blob/master/wiki/about-scriptlets.md#didomi-loader',versionAdded:'1.10.25',versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null}],map:{'1':0,'2':0,'4':0,'8':0,'16':0,'32':0,'64':0}},{shared:[{name:'dir-string',aliases:null,description:null,docs:'https://github.com/AdguardTeam/Scriptlets/blob/master/wiki/about-scriptlets.md#dir-string',versionAdded:'1.0.4',versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,parameters:[{name:'times',required:false,description:null,pattern:null,'default':null,debug:false}]}],map:{'1':0,'2':0,'4':0,'8':0,'16':0,'32':0,'64':0}},{shared:[{name:'disable-newtab-links',aliases:['disable-newtab-links.js','ubo-disable-newtab-links.js','ubo-disable-newtab-links'],description:null,docs:'https://github.com/AdguardTeam/Scriptlets/blob/master/wiki/about-scriptlets.md#disable-newtab-links',versionAdded:'1.0.4',versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null},{name:'disable-newtab-links.js',aliases:null,description:null,docs:'https://github.com/gorhill/uBlock/wiki/Resources-Library#disable-newtab-linksjs-',versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null}],map:{'1':0,'2':0,'4':0,'8':0,'16':0,'32':0,'64':0,'1024':1,'2048':1,'4096':1,'8192':1}},{shared:[{name:'evaldata-prune',aliases:['evaldata-prune.js','ubo-evaldata-prune.js','ubo-evaldata-prune'],description:null,docs:'https://github.com/AdguardTeam/Scriptlets/blob/master/wiki/about-scriptlets.md#evaldata-prune',versionAdded:'1.9.37',versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,parameters:[{name:'propsToRemove',required:false,description:null,pattern:null,'default':null,debug:false},{name:'obligatoryProps',required:false,description:null,pattern:null,'default':null,debug:false},{name:'stack',required:false,description:null,pattern:null,'default':null,debug:false}]},{name:'evaldata-prune.js',aliases:null,description:null,docs:'https://github.com/gorhill/uBlock/wiki/Resources-Library#evaldata-prunejs-',versionAdded:'1.49.3rc15',versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,parameters:[{name:'propsToRemove',required:false,description:null,pattern:null,'default':null,debug:false},{name:'obligatoryProps',required:false,description:null,pattern:null,'default':null,debug:false},{name:'stack',required:false,description:null,pattern:null,'default':null,debug:false}]}],map:{'1':0,'2':0,'4':0,'8':0,'16':0,'32':0,'64':0,'1024':1,'2048':1,'4096':1,'8192':1}},{shared:[{name:'fingerprintjs2',aliases:['ubo-fingerprint2.js','fingerprint2.js'],description:null,docs:'https://github.com/AdguardTeam/Scriptlets/blob/master/wiki/about-scriptlets.md#fingerprintjs2',versionAdded:'1.10.25',versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null}],map:{'1':0,'2':0,'4':0,'8':0,'16':0,'32':0,'64':0}},{shared:[{name:'fingerprintjs3',aliases:['ubo-fingerprint3.js','fingerprint3.js'],description:null,docs:'https://github.com/AdguardTeam/Scriptlets/blob/master/wiki/about-scriptlets.md#fingerprintjs3',versionAdded:'1.10.25',versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null}],map:{'1':0,'2':0,'4':0,'8':0,'16':0,'32':0,'64':0}},{shared:[{name:'gemius',aliases:null,description:null,docs:'https://github.com/AdguardTeam/Scriptlets/blob/master/wiki/about-scriptlets.md#gemius',versionAdded:'1.10.25',versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null}],map:{'1':0,'2':0,'4':0,'8':0,'16':0,'32':0,'64':0}},{shared:[{name:'google-analytics-ga',aliases:['ubo-google-analytics_ga.js','google-analytics_ga.js'],description:null,docs:'https://github.com/AdguardTeam/Scriptlets/blob/master/wiki/about-scriptlets.md#google-analytics-ga',versionAdded:'1.10.25',versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null}],map:{'1':0,'2':0,'4':0,'8':0,'16':0,'32':0,'64':0}},{shared:[{name:'google-analytics',aliases:['ubo-google-analytics_analytics.js','google-analytics_analytics.js','googletagmanager-gtm','ubo-googletagmanager_gtm.js','googletagmanager_gtm.js'],description:null,docs:'https://github.com/AdguardTeam/Scriptlets/blob/master/wiki/about-scriptlets.md#google-analytics',versionAdded:'1.10.25',versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null}],map:{'1':0,'2':0,'4':0,'8':0,'16':0,'32':0,'64':0}},{shared:[{name:'google-ima3',aliases:['ubo-google-ima.js','google-ima.js'],description:null,docs:'https://github.com/AdguardTeam/Scriptlets/blob/master/wiki/about-scriptlets.md#google-ima3',versionAdded:'1.10.25',versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null}],map:{'1':0,'2':0,'4':0,'8':0,'16':0,'32':0,'64':0}},{shared:[{name:'googlesyndication-adsbygoogle',aliases:['ubo-googlesyndication_adsbygoogle.js','googlesyndication_adsbygoogle.js'],description:null,docs:'https://github.com/AdguardTeam/Scriptlets/blob/master/wiki/about-scriptlets.md#googlesyndication-adsbygoogle',versionAdded:'1.10.25',versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null}],map:{'1':0,'2':0,'4':0,'8':0,'16':0,'32':0,'64':0}},{shared:[{name:'googletagservices-gpt',aliases:['ubo-googletagservices_gpt.js','googletagservices_gpt.js'],description:null,docs:'https://github.com/AdguardTeam/Scriptlets/blob/master/wiki/about-scriptlets.md#googletagservices-gpt',versionAdded:'1.10.25',versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null}],map:{'1':0,'2':0,'4':0,'8':0,'16':0,'32':0,'64':0}},{shared:[{name:'hide-in-shadow-dom',aliases:null,description:null,docs:'https://github.com/AdguardTeam/Scriptlets/blob/master/wiki/about-scriptlets.md#hide-in-shadow-dom',versionAdded:'1.3.0',versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,parameters:[{name:'selector',required:true,description:null,pattern:null,'default':null,debug:false},{name:'baseSelector',required:false,description:null,pattern:null,'default':null,debug:false}]}],map:{'1':0,'2':0,'4':0,'8':0,'16':0,'32':0,'64':0}},{shared:[{name:'href-sanitizer',aliases:['href-sanitizer.js','ubo-href-sanitizer.js','ubo-href-sanitizer'],description:null,docs:'https://github.com/AdguardTeam/Scriptlets/blob/master/wiki/about-scriptlets.md#href-sanitizer',versionAdded:'1.10.25',versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,parameters:[{name:'selector',required:true,description:null,pattern:null,'default':null,debug:false},{name:'attribute',required:false,description:null,pattern:null,'default':null,debug:false}]},{name:'href-sanitizer.js',aliases:null,description:null,docs:'https://github.com/gorhill/uBlock/wiki/Resources-Library#href-sanitizerjs-',versionAdded:'1.47.5b4',versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,parameters:[{name:'selector',required:true,description:null,pattern:null,'default':null,debug:false},{name:'attribute',required:false,description:null,pattern:null,'default':null,debug:false}]}],map:{'1':0,'2':0,'4':0,'8':0,'16':0,'32':0,'64':0,'1024':1,'2048':1,'4096':1,'8192':1}},{shared:[{name:'inject-css-in-shadow-dom',aliases:null,description:null,docs:'https://github.com/AdguardTeam/Scriptlets/blob/master/wiki/about-scriptlets.md#inject-css-in-shadow-dom',versionAdded:'1.8.2',versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,parameters:[{name:'cssRule',required:true,description:null,pattern:null,'default':null,debug:false},{name:'hostSelector',required:false,description:null,pattern:null,'default':null,debug:false}]}],map:{'1':0,'2':0,'4':0,'8':0,'16':0,'32':0,'64':0}},{shared:[{name:'json-prune-fetch-response',aliases:['json-prune-fetch-response.js','ubo-json-prune-fetch-response.js','ubo-json-prune-fetch-response'],description:null,docs:'https://github.com/AdguardTeam/Scriptlets/blob/master/wiki/about-scriptlets.md#json-prune-fetch-response',versionAdded:'1.10.25',versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,parameters:[{name:'propsToRemove',required:false,description:null,pattern:null,'default':null,debug:false},{name:'obligatoryProps',required:false,description:null,pattern:null,'default':null,debug:false},{name:'propsToMatch',required:false,description:null,pattern:null,'default':null,debug:false},{name:'stack',required:false,description:null,pattern:null,'default':null,debug:false}]},{name:'json-prune-fetch-response.js',aliases:null,description:null,docs:'https://github.com/gorhill/uBlock/wiki/Resources-Library#json-prune-fetch-responsejs-',versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,parameters:[{name:'propsToRemove',required:false,description:null,pattern:null,'default':null,debug:false},{name:'obligatoryProps',required:false,description:null,pattern:null,'default':null,debug:false},{name:'propsToMatch',required:false,description:null,pattern:null,'default':null,debug:false},{name:'stack',required:false,description:null,pattern:null,'default':null,debug:false}]}],map:{'1':0,'2':0,'4':0,'8':0,'16':0,'32':0,'64':0,'1024':1,'2048':1,'4096':1,'8192':1}},{shared:[{name:'json-prune-xhr-response',aliases:['json-prune-xhr-response.js','ubo-json-prune-xhr-response.js','ubo-json-prune-xhr-response'],description:null,docs:'https://github.com/AdguardTeam/Scriptlets/blob/master/wiki/about-scriptlets.md#json-prune-xhr-response',versionAdded:'1.10.25',versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,parameters:[{name:'propsToRemove',required:false,description:null,pattern:null,'default':null,debug:false},{name:'obligatoryProps',required:false,description:null,pattern:null,'default':null,debug:false},{name:'propsToMatch',required:false,description:null,pattern:null,'default':null,debug:false},{name:'stack',required:false,description:null,pattern:null,'default':null,debug:false}]},{name:'json-prune-xhr-response.js',aliases:null,description:null,docs:'https://github.com/gorhill/uBlock/wiki/Resources-Library#json-prune-xhr-responsejs-',versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,parameters:[{name:'propsToRemove',required:false,description:null,pattern:null,'default':null,debug:false},{name:'obligatoryProps',required:false,description:null,pattern:null,'default':null,debug:false},{name:'propsToMatch',required:false,description:null,pattern:null,'default':null,debug:false},{name:'stack',required:false,description:null,pattern:null,'default':null,debug:false}]}],map:{'1':0,'2':0,'4':0,'8':0,'16':0,'32':0,'64':0,'1024':1,'2048':1,'4096':1,'8192':1}},{shared:[{name:'json-prune',aliases:['json-prune.js','ubo-json-prune.js','ubo-json-prune','abp-json-prune'],description:null,docs:'https://github.com/AdguardTeam/Scriptlets/blob/master/wiki/about-scriptlets.md#json-prune',versionAdded:'1.1.0',versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,parameters:[{name:'propsToRemove',required:false,description:null,pattern:null,'default':null,debug:false},{name:'obligatoryProps',required:false,description:null,pattern:null,'default':null,debug:false},{name:'stack',required:false,description:null,pattern:null,'default':null,debug:false}]},{name:'json-prune.js',aliases:null,description:null,docs:'https://github.com/gorhill/uBlock/wiki/Resources-Library#json-prunejs-',versionAdded:'1.23.0',versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,parameters:[{name:'propsToRemove',required:false,description:null,pattern:null,'default':null,debug:false},{name:'obligatoryProps',required:false,description:null,pattern:null,'default':null,debug:false},{name:'stack',required:false,description:null,pattern:null,'default':null,debug:false}]},{name:'json-prune',aliases:null,description:null,docs:'https://help.adblockplus.org/hc/en-us/articles/1500002338501-Snippet-filters-tutorial#snippets-ref',versionAdded:'3.9.0',versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,parameters:[{name:'rawPrunePaths',required:true,description:null,pattern:null,'default':null,debug:false},{name:'rawNeedlePaths',required:false,description:null,pattern:null,'default':null,debug:false}]}],map:{'1':0,'2':0,'4':0,'8':0,'16':0,'32':0,'64':0,'1024':1,'2048':1,'4096':1,'8192':1,'16384':2,'32768':2,'65536':2,'131072':2}},{shared:[{name:'log-addEventListener',aliases:['addEventListener-logger.js','ubo-addEventListener-logger.js','aell.js','ubo-aell.js','ubo-addEventListener-logger','ubo-aell'],description:null,docs:'https://github.com/AdguardTeam/Scriptlets/blob/master/wiki/about-scriptlets.md#log-addEventListener',versionAdded:'1.0.4',versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null}],map:{'1':0,'2':0,'4':0,'8':0,'16':0,'32':0,'64':0}},{shared:[{name:'log-eval',aliases:null,description:null,docs:'https://github.com/AdguardTeam/Scriptlets/blob/master/wiki/about-scriptlets.md#log-eval',versionAdded:'1.0.4',versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null}],map:{'1':0,'2':0,'4':0,'8':0,'16':0,'32':0,'64':0}},{shared:[{name:'log-on-stack-trace',aliases:null,description:null,docs:'https://github.com/AdguardTeam/Scriptlets/blob/master/wiki/about-scriptlets.md#log-on-stack-trace',versionAdded:'1.5.0',versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,parameters:[{name:'property',required:true,description:null,pattern:null,'default':null,debug:false}]}],map:{'1':0,'2':0,'4':0,'8':0,'16':0,'32':0,'64':0}},{shared:[{name:'log',aliases:['abp-log'],description:null,docs:'https://github.com/AdguardTeam/Scriptlets/blob/master/wiki/about-scriptlets.md#log',versionAdded:'1.0.4',versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,parameters:[{name:'arguments',required:false,description:null,pattern:null,'default':null,debug:false}]}],map:{'1':0,'2':0,'4':0,'8':0,'16':0,'32':0,'64':0}},{shared:[{name:'m3u-prune',aliases:['m3u-prune.js','ubo-m3u-prune.js','ubo-m3u-prune'],description:null,docs:'https://github.com/AdguardTeam/Scriptlets/blob/master/wiki/about-scriptlets.md#m3u-prune',versionAdded:'1.9.1',versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,parameters:[{name:'propsToRemove',required:false,description:null,pattern:null,'default':null,debug:false},{name:'urlToMatch',required:false,description:null,pattern:null,'default':null,debug:false}]},{name:'m3u-prune.js',aliases:null,description:null,docs:'https://github.com/gorhill/uBlock/wiki/Resources-Library#m3u-prunejs-',versionAdded:'1.44.5b6',versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,parameters:[{name:'propsToRemove',required:false,description:null,pattern:null,'default':null,debug:false},{name:'urlToMatch',required:false,description:null,pattern:null,'default':null,debug:false}]}],map:{'1':0,'2':0,'4':0,'8':0,'16':0,'32':0,'64':0,'1024':1,'2048':1,'4096':1,'8192':1}},{shared:[{name:'matomo',aliases:null,description:null,docs:'https://github.com/AdguardTeam/Scriptlets/blob/master/wiki/about-scriptlets.md#matomo',versionAdded:'1.10.25',versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null}],map:{'1':0,'2':0,'4':0,'8':0,'16':0,'32':0,'64':0}},{shared:[{name:'metrika-yandex-tag',aliases:null,description:null,docs:'https://github.com/AdguardTeam/Scriptlets/blob/master/wiki/about-scriptlets.md#metrika-yandex-tag',versionAdded:'1.10.25',versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null}],map:{'1':0,'2':0,'4':0,'8':0,'16':0,'32':0,'64':0}},{shared:[{name:'metrika-yandex-watch',aliases:null,description:null,docs:'https://github.com/AdguardTeam/Scriptlets/blob/master/wiki/about-scriptlets.md#metrika-yandex-watch',versionAdded:'1.10.25',versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null}],map:{'1':0,'2':0,'4':0,'8':0,'16':0,'32':0,'64':0}},{shared:[{name:'naver-wcslog',aliases:null,description:null,docs:'https://github.com/AdguardTeam/Scriptlets/blob/master/wiki/about-scriptlets.md#naver-wcslog',versionAdded:'1.10.25',versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null}],map:{'1':0,'2':0,'4':0,'8':0,'16':0,'32':0,'64':0}},{shared:[{name:'no-protected-audience',aliases:null,description:null,docs:'https://github.com/AdguardTeam/Scriptlets/blob/master/wiki/about-scriptlets.md#no-protected-audience',versionAdded:'1.10.25',versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null}],map:{'1':0,'2':0,'4':0,'8':0,'16':0,'32':0,'64':0}},{shared:[{name:'no-topics',aliases:null,description:null,docs:'https://github.com/AdguardTeam/Scriptlets/blob/master/wiki/about-scriptlets.md#no-topics',versionAdded:'1.6.18',versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null}],map:{'1':0,'2':0,'4':0,'8':0,'16':0,'32':0,'64':0}},{shared:[{name:'noeval',aliases:['noeval.js','silent-noeval.js','ubo-noeval.js','ubo-silent-noeval.js','ubo-noeval','ubo-silent-noeval'],description:null,docs:'https://github.com/AdguardTeam/Scriptlets/blob/master/wiki/about-scriptlets.md#noeval',versionAdded:'1.0.4',versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null}],map:{'1':0,'2':0,'4':0,'8':0,'16':0,'32':0,'64':0}},{shared:[{name:'nowebrtc',aliases:['nowebrtc.js','ubo-nowebrtc.js','ubo-nowebrtc'],description:null,docs:'https://github.com/AdguardTeam/Scriptlets/blob/master/wiki/about-scriptlets.md#nowebrtc',versionAdded:'1.0.4',versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null},{name:'nowebrtc.js',aliases:null,description:null,docs:'https://github.com/gorhill/uBlock/wiki/Resources-Library#nowebrtcjs-',versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null}],map:{'1':0,'2':0,'4':0,'8':0,'16':0,'32':0,'64':0,'1024':1,'2048':1,'4096':1,'8192':1}},{shared:[{name:'pardot-1.0',aliases:null,description:null,docs:'https://github.com/AdguardTeam/Scriptlets/blob/master/wiki/about-scriptlets.md#pardot-1.0',versionAdded:'1.10.25',versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null}],map:{'1':0,'2':0,'4':0,'8':0,'16':0,'32':0,'64':0}},{shared:[{name:'prebid',aliases:null,description:null,docs:'https://github.com/AdguardTeam/Scriptlets/blob/master/wiki/about-scriptlets.md#prebid',versionAdded:'1.10.25',versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null}],map:{'1':0,'2':0,'4':0,'8':0,'16':0,'32':0,'64':0}},{shared:[{name:'prevent-addEventListener',aliases:['addEventListener-defuser.js','ubo-addEventListener-defuser.js','aeld.js','ubo-aeld.js','ubo-addEventListener-defuser','ubo-aeld','abp-prevent-listener'],description:null,docs:'https://github.com/AdguardTeam/Scriptlets/blob/master/wiki/about-scriptlets.md#prevent-addEventListener',versionAdded:'1.0.4',versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,parameters:[{name:'typeSearch',required:false,description:null,pattern:null,'default':null,debug:false},{name:'listenerSearch',required:false,description:null,pattern:null,'default':null,debug:false}]},{name:'addEventListener-defuser.js',aliases:['aeld.js','prevent-addEventListener.js'],description:null,docs:'https://github.com/gorhill/uBlock/wiki/Resources-Library#addEventListener-defuserjs-',versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,parameters:[{name:'typeSearch',required:false,description:null,pattern:null,'default':null,debug:false},{name:'listenerSearch',required:false,description:null,pattern:null,'default':null,debug:false}]},{name:'prevent-listener',aliases:null,description:null,docs:'https://help.adblockplus.org/hc/en-us/articles/1500002338501-Snippet-filters-tutorial#snippets-ref',versionAdded:'3.11.2',versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,parameters:[{name:'type',required:true,description:null,pattern:null,'default':null,debug:false},{name:'handler',required:false,description:null,pattern:null,'default':null,debug:false},{name:'selector',required:false,description:null,pattern:null,'default':null,debug:false}]}],map:{'1':0,'2':0,'4':0,'8':0,'16':0,'32':0,'64':0,'1024':1,'2048':1,'4096':1,'8192':1,'16384':2,'32768':2,'65536':2,'131072':2}},{shared:[{name:'prevent-adfly',aliases:['adfly-defuser.js','ubo-adfly-defuser.js','ubo-adfly-defuser'],description:null,docs:'https://github.com/AdguardTeam/Scriptlets/blob/master/wiki/about-scriptlets.md#prevent-adfly',versionAdded:'1.0.4',versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null}],map:{'1':0,'2':0,'4':0,'8':0,'16':0,'32':0,'64':0}},{shared:[{name:'prevent-bab',aliases:null,description:null,docs:'https://github.com/AdguardTeam/Scriptlets/blob/master/wiki/about-scriptlets.md#prevent-bab',versionAdded:'1.0.4',versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null}],map:{'1':0,'2':0,'4':0,'8':0,'16':0,'32':0,'64':0}},{shared:[{name:'prevent-element-src-loading',aliases:null,description:null,docs:'https://github.com/AdguardTeam/Scriptlets/blob/master/wiki/about-scriptlets.md#prevent-element-src-loading',versionAdded:'1.6.2',versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,parameters:[{name:'tagName',required:true,description:null,pattern:null,'default':null,debug:false},{name:'match',required:true,description:null,pattern:null,'default':null,debug:false}]}],map:{'1':0,'2':0,'4':0,'8':0,'16':0,'32':0,'64':0}},{shared:[{name:'prevent-eval-if',aliases:['noeval-if.js','ubo-noeval-if.js','ubo-noeval-if'],description:null,docs:'https://github.com/AdguardTeam/Scriptlets/blob/master/wiki/about-scriptlets.md#prevent-eval-if',versionAdded:'1.0.4',versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,parameters:[{name:'search',required:false,description:null,pattern:null,'default':null,debug:false}]},{name:'noeval-if.js',aliases:['prevent-eval-if.js'],description:null,docs:'https://github.com/gorhill/uBlock/wiki/Resources-Library#noeval-ifjs-',versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,parameters:[{name:'search',required:false,description:null,pattern:null,'default':null,debug:false}]}],map:{'1':0,'2':0,'4':0,'8':0,'16':0,'32':0,'64':0,'1024':1,'2048':1,'4096':1,'8192':1}},{shared:[{name:'prevent-fab-3.2.0',aliases:['nofab.js','ubo-nofab.js','fuckadblock.js-3.2.0','ubo-fuckadblock.js-3.2.0','ubo-nofab'],description:null,docs:'https://github.com/AdguardTeam/Scriptlets/blob/master/wiki/about-scriptlets.md#prevent-fab-3.2.0',versionAdded:'1.0.4',versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null}],map:{'1':0,'2':0,'4':0,'8':0,'16':0,'32':0,'64':0}},{shared:[{name:'prevent-fetch',aliases:['prevent-fetch.js','no-fetch-if.js','ubo-no-fetch-if.js','ubo-no-fetch-if'],description:null,docs:'https://github.com/AdguardTeam/Scriptlets/blob/master/wiki/about-scriptlets.md#prevent-fetch',versionAdded:'1.3.18',versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,parameters:[{name:'propsToMatch',required:false,description:null,pattern:null,'default':null,debug:false},{name:'responseBody',required:false,description:null,pattern:null,'default':null,debug:false},{name:'responseType',required:false,description:null,pattern:null,'default':null,debug:false}]},{name:'prevent-fetch.js',aliases:['no-fetch-if.js'],description:null,docs:'https://github.com/gorhill/uBlock/wiki/Resources-Library#prevent-fetchjs-',versionAdded:'1.31.3b9',versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,parameters:[{name:'propsToMatch',required:false,description:null,pattern:null,'default':null,debug:false},{name:'responseBody',required:false,description:null,pattern:null,'default':null,debug:false},{name:'responseType',required:false,description:null,pattern:null,'default':null,debug:false}]}],map:{'1':0,'2':0,'4':0,'8':0,'16':0,'32':0,'64':0,'1024':1,'2048':1,'4096':1,'8192':1}},{shared:[{name:'prevent-popads-net',aliases:['popads.net.js','ubo-popads.net.js','ubo-popads.net'],description:null,docs:'https://github.com/AdguardTeam/Scriptlets/blob/master/wiki/about-scriptlets.md#prevent-popads-net',versionAdded:'1.0.4',versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null}],map:{'1':0,'2':0,'4':0,'8':0,'16':0,'32':0,'64':0}},{shared:[{name:'prevent-refresh',aliases:['prevent-refresh.js','refresh-defuser.js','refresh-defuser','ubo-prevent-refresh.js','ubo-prevent-refresh','ubo-refresh-defuser.js','ubo-refresh-defuser'],description:null,docs:'https://github.com/AdguardTeam/Scriptlets/blob/master/wiki/about-scriptlets.md#prevent-refresh',versionAdded:'1.6.2',versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,parameters:[{name:'delay',required:false,description:null,pattern:null,'default':null,debug:false}]},{name:'prevent-refresh.js',aliases:['refresh-defuser.js'],description:null,docs:'https://github.com/gorhill/uBlock/wiki/Resources-Library#prevent-refreshjs-',versionAdded:'1.38.7b3',versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,parameters:[{name:'delay',required:false,description:null,pattern:null,'default':null,debug:false}]}],map:{'1':0,'2':0,'4':0,'8':0,'16':0,'32':0,'64':0,'1024':1,'2048':1,'4096':1,'8192':1}},{shared:[{name:'prevent-requestAnimationFrame',aliases:['no-requestAnimationFrame-if.js','ubo-no-requestAnimationFrame-if.js','norafif.js','ubo-norafif.js','ubo-no-requestAnimationFrame-if','ubo-norafif'],description:null,docs:'https://github.com/AdguardTeam/Scriptlets/blob/master/wiki/about-scriptlets.md#prevent-requestAnimationFrame',versionAdded:'1.1.15',versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,parameters:[{name:'search',required:false,description:null,pattern:null,'default':null,debug:false}]},{name:'no-requestAnimationFrame-if.js',aliases:['norafif.js','prevent-requestAnimationFrame.js'],description:null,docs:'https://github.com/gorhill/uBlock/wiki/Resources-Library#no-requestAnimationFrame-ifjs-',versionAdded:'1.27.0',versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,parameters:[{name:'search',required:false,description:null,pattern:null,'default':null,debug:false}]}],map:{'1':0,'2':0,'4':0,'8':0,'16':0,'32':0,'64':0,'1024':1,'2048':1,'4096':1,'8192':1}},{shared:[{name:'prevent-setInterval',aliases:['no-setInterval-if.js','ubo-no-setInterval-if.js','setInterval-defuser.js','ubo-setInterval-defuser.js','nosiif.js','ubo-nosiif.js','sid.js','ubo-sid.js','ubo-no-setInterval-if','ubo-setInterval-defuser','ubo-nosiif','ubo-sid'],description:null,docs:'https://github.com/AdguardTeam/Scriptlets/blob/master/wiki/about-scriptlets.md#prevent-setInterval',versionAdded:'1.0.4',versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,parameters:[{name:'matchCallback',required:false,description:null,pattern:null,'default':null,debug:false},{name:'matchDelay',required:false,description:null,pattern:null,'default':null,debug:false}]},{name:'no-setInterval-if.js',aliases:['nosiif.js','prevent-setInterval.js','setInterval-defuser.js'],description:null,docs:'https://github.com/gorhill/uBlock/wiki/Resources-Library#no-setInterval-ifjs-',versionAdded:'1.23.0',versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,parameters:[{name:'matchCallback',required:false,description:null,pattern:null,'default':null,debug:false},{name:'matchDelay',required:false,description:null,pattern:null,'default':null,debug:false}]}],map:{'1':0,'2':0,'4':0,'8':0,'16':0,'32':0,'64':0,'1024':1,'2048':1,'4096':1,'8192':1}},{shared:[{name:'prevent-setTimeout',aliases:['no-setTimeout-if.js','ubo-no-setTimeout-if.js','nostif.js','ubo-nostif.js','ubo-no-setTimeout-if','ubo-nostif','setTimeout-defuser.js','ubo-setTimeout-defuser.js','ubo-setTimeout-defuser','std.js','ubo-std.js','ubo-std'],description:null,docs:'https://github.com/AdguardTeam/Scriptlets/blob/master/wiki/about-scriptlets.md#prevent-setTimeout',versionAdded:'1.0.4',versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,parameters:[{name:'matchCallback',required:false,description:null,pattern:null,'default':null,debug:false},{name:'matchDelay',required:false,description:null,pattern:null,'default':null,debug:false}]},{name:'no-setTimeout-if.js',aliases:['nostif.js','prevent-setTimeout.js','setTimeout-defuser.js'],description:null,docs:'https://github.com/gorhill/uBlock/wiki/Resources-Library#no-setTimeout-ifjs-',versionAdded:'1.23.0',versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,parameters:[{name:'matchCallback',required:false,description:null,pattern:null,'default':null,debug:false},{name:'matchDelay',required:false,description:null,pattern:null,'default':null,debug:false}]}],map:{'1':0,'2':0,'4':0,'8':0,'16':0,'32':0,'64':0,'1024':1,'2048':1,'4096':1,'8192':1}},{shared:[{name:'prevent-window-open',aliases:['window.open-defuser.js','ubo-window.open-defuser.js','ubo-window.open-defuser','nowoif.js','ubo-nowoif.js','ubo-nowoif','no-window-open-if.js','ubo-no-window-open-if.js','ubo-no-window-open-if'],description:null,docs:'https://github.com/AdguardTeam/Scriptlets/blob/master/wiki/about-scriptlets.md#prevent-window-open',versionAdded:'1.0.4',versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,parameters:[{name:'match',required:false,description:null,pattern:null,'default':null,debug:false},{name:'delay',required:false,description:null,pattern:null,'default':null,debug:false},{name:'replacement',required:false,description:null,pattern:null,'default':null,debug:false}]},{name:'no-window-open-if.js',aliases:['nowoif.js','prevent-window-open.js','window.open-defuser.js'],description:null,docs:'https://github.com/gorhill/uBlock/wiki/Resources-Library#no-window-open-ifjs-',versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,parameters:[{name:'match',required:false,description:null,pattern:null,'default':null,debug:false},{name:'delay',required:false,description:null,pattern:null,'default':null,debug:false},{name:'replacement',required:false,description:null,pattern:null,'default':null,debug:false}]}],map:{'1':0,'2':0,'4':0,'8':0,'16':0,'32':0,'64':0,'1024':1,'2048':1,'4096':1,'8192':1}},{shared:[{name:'prevent-xhr',aliases:['no-xhr-if.js','ubo-no-xhr-if.js','ubo-no-xhr-if'],description:null,docs:'https://github.com/AdguardTeam/Scriptlets/blob/master/wiki/about-scriptlets.md#prevent-xhr',versionAdded:'1.5.0',versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,parameters:[{name:'propsToMatch',required:false,description:null,pattern:null,'default':null,debug:false},{name:'randomize',required:false,description:null,pattern:null,'default':null,debug:false}]},{name:'no-xhr-if.js',aliases:['prevent-xhr.js'],description:null,docs:'https://github.com/gorhill/uBlock/wiki/Resources-Library#no-xhr-ifjs-',versionAdded:'1.38.0',versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,parameters:[{name:'propsToMatch',required:false,description:null,pattern:null,'default':null,debug:false},{name:'randomize',required:false,description:null,pattern:null,'default':null,debug:false}]}],map:{'1':0,'2':0,'4':0,'8':0,'16':0,'32':0,'64':0,'1024':1,'2048':1,'4096':1,'8192':1}},{shared:[{name:'remove-attr',aliases:['remove-attr.js','ubo-remove-attr.js','ra.js','ubo-ra.js','ubo-remove-attr','ubo-ra'],description:null,docs:'https://github.com/AdguardTeam/Scriptlets/blob/master/wiki/about-scriptlets.md#remove-attr',versionAdded:'1.0.4',versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,parameters:[{name:'attrs',required:true,description:null,pattern:null,'default':null,debug:false},{name:'selector',required:false,description:null,pattern:null,'default':null,debug:false},{name:'applying',required:false,description:null,pattern:null,'default':null,debug:false}]},{name:'remove-attr.js',aliases:['ra.js','ra','remove-attr'],description:null,docs:'https://github.com/gorhill/uBlock/wiki/Resources-Library#remove-attrjs-',versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,parameters:[{name:'attrs',required:true,description:null,pattern:null,'default':null,debug:false},{name:'selector',required:false,description:null,pattern:null,'default':null,debug:false},{name:'applying',required:false,description:null,pattern:null,'default':null,debug:false}]}],map:{'1':0,'2':0,'4':0,'8':0,'16':0,'32':0,'64':0,'1024':1,'2048':1,'4096':1,'8192':1}},{shared:[{name:'remove-class',aliases:['remove-class.js','ubo-remove-class.js','rc.js','ubo-rc.js','ubo-remove-class','ubo-rc'],description:null,docs:'https://github.com/AdguardTeam/Scriptlets/blob/master/wiki/about-scriptlets.md#remove-class',versionAdded:'1.1.1',versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,parameters:[{name:'classes',required:true,description:null,pattern:null,'default':null,debug:false},{name:'selector',required:false,description:null,pattern:null,'default':null,debug:false},{name:'applying',required:false,description:null,pattern:null,'default':null,debug:false}]},{name:'remove-class.js',aliases:['rc.js','rc','remove-class'],description:null,docs:'https://github.com/gorhill/uBlock/wiki/Resources-Library#remove-classjs-',versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,parameters:[{name:'classes',required:true,description:null,pattern:null,'default':null,debug:false},{name:'selector',required:false,description:null,pattern:null,'default':null,debug:false},{name:'applying',required:false,description:null,pattern:null,'default':null,debug:false}]}],map:{'1':0,'2':0,'4':0,'8':0,'16':0,'32':0,'64':0,'1024':1,'2048':1,'4096':1,'8192':1}},{shared:[{name:'remove-cookie',aliases:['cookie-remover.js','ubo-cookie-remover.js','ubo-cookie-remover','remove-cookie.js','ubo-remove-cookie.js','ubo-remove-cookie','abp-cookie-remover'],description:null,docs:'https://github.com/AdguardTeam/Scriptlets/blob/master/wiki/about-scriptlets.md#remove-cookie',versionAdded:'1.0.4',versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,parameters:[{name:'match',required:false,description:null,pattern:null,'default':null,debug:false}]},{name:'remove-cookie.js',aliases:['cookie-remover.js'],description:null,docs:'https://github.com/gorhill/uBlock/wiki/Resources-Library#remove-cookiejs-',versionAdded:'1.28.0',versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,parameters:[{name:'match',required:false,description:null,pattern:null,'default':null,debug:false}]},{name:'cookie-remover',aliases:null,description:null,docs:'https://help.adblockplus.org/hc/en-us/articles/1500002338501-Snippet-filters-tutorial#snippets-ref',versionAdded:'3.11.2',versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,parameters:[{name:'cookie',required:true,description:null,pattern:null,'default':null,debug:false},{name:'autoRemoveCookie',required:false,description:null,pattern:null,'default':null,debug:false}]}],map:{'1':0,'2':0,'4':0,'8':0,'16':0,'32':0,'64':0,'1024':1,'2048':1,'4096':1,'8192':1,'16384':2,'32768':2,'65536':2,'131072':2}},{shared:[{name:'remove-in-shadow-dom',aliases:null,description:null,docs:'https://github.com/AdguardTeam/Scriptlets/blob/master/wiki/about-scriptlets.md#remove-in-shadow-dom',versionAdded:'1.3.14',versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,parameters:[{name:'selector',required:true,description:null,pattern:null,'default':null,debug:false},{name:'baseSelector',required:false,description:null,pattern:null,'default':null,debug:false}]}],map:{'1':0,'2':0,'4':0,'8':0,'16':0,'32':0,'64':0}},{shared:[{name:'remove-node-text',aliases:['remove-node-text.js','ubo-remove-node-text.js','rmnt.js','ubo-rmnt.js','ubo-remove-node-text','ubo-rmnt'],description:null,docs:'https://github.com/AdguardTeam/Scriptlets/blob/master/wiki/about-scriptlets.md#remove-node-text',versionAdded:'1.9.37',versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,parameters:[{name:'nodeName',required:true,description:null,pattern:null,'default':null,debug:false},{name:'textMatch',required:true,description:null,pattern:null,'default':null,debug:false}]},{name:'remove-node-text.js',aliases:['rmnt.js'],description:null,docs:'https://github.com/gorhill/uBlock/wiki/Resources-Library#remove-node-textjs-',versionAdded:'1.49.3rc15',versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,parameters:[{name:'nodeName',required:true,description:null,pattern:null,'default':null,debug:false},{name:'textMatch',required:true,description:null,pattern:null,'default':null,debug:false}]}],map:{'1':0,'2':0,'4':0,'8':0,'16':0,'32':0,'64':0,'1024':1,'2048':1,'4096':1,'8192':1}},{shared:[{name:'scorecardresearch-beacon',aliases:['ubo-scorecardresearch_beacon.js','scorecardresearch_beacon.js'],description:null,docs:'https://github.com/AdguardTeam/Scriptlets/blob/master/wiki/about-scriptlets.md#scorecardresearch-beacon',versionAdded:'1.10.25',versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null}],map:{'1':0,'2':0,'4':0,'8':0,'16':0,'32':0,'64':0}},{shared:[{name:'set-attr',aliases:['set-attr.js','ubo-set-attr.js','ubo-set-attr'],description:null,docs:'https://github.com/AdguardTeam/Scriptlets/blob/master/wiki/about-scriptlets.md#set-attr',versionAdded:'1.5.0',versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,parameters:[{name:'selector',required:true,description:null,pattern:null,'default':null,debug:false},{name:'attr',required:true,description:null,pattern:null,'default':null,debug:false},{name:'value',required:false,description:null,pattern:null,'default':null,debug:false}]},{name:'set-attr.js',aliases:null,description:null,docs:'https://github.com/gorhill/uBlock/wiki/Resources-Library#set-attrjs-',versionAdded:'1.50.1b16',versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,parameters:[{name:'selector',required:true,description:null,pattern:null,'default':null,debug:false},{name:'attr',required:true,description:null,pattern:null,'default':null,debug:false},{name:'value',required:false,description:null,pattern:null,'default':null,debug:false}]}],map:{'1':0,'2':0,'4':0,'8':0,'16':0,'32':0,'64':0,'1024':1,'2048':1,'4096':1,'8192':1}},{shared:[{name:'set-constant',aliases:['set-constant.js','ubo-set-constant.js','set.js','ubo-set.js','ubo-set-constant','ubo-set'],description:null,docs:'https://github.com/AdguardTeam/Scriptlets/blob/master/wiki/about-scriptlets.md#set-constant',versionAdded:'1.0.4',versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,parameters:[{name:'property',required:true,description:null,pattern:null,'default':null,debug:false},{name:'value',required:true,description:null,pattern:null,'default':null,debug:false},{name:'stack',required:false,description:null,pattern:null,'default':null,debug:false},{name:'valueWrapper',required:false,description:null,pattern:null,'default':null,debug:false},{name:'setProxyTrap',required:false,description:null,pattern:null,'default':null,debug:false}]},{name:'set-constant.js',aliases:['set.js'],description:null,docs:'https://github.com/gorhill/uBlock/wiki/Resources-Library#set-constantjs-',versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,parameters:[{name:'chain',required:true,description:null,pattern:null,'default':null,debug:false},{name:'rawValue',required:true,description:null,pattern:null,'default':null,debug:false},{name:'runAt',required:false,description:null,pattern:null,'default':null,debug:false}]},{name:'override-property-read',aliases:null,description:null,docs:'https://help.adblockplus.org/hc/en-us/articles/1500002338501-Snippet-filters-tutorial#snippets-ref',versionAdded:'3.9.4',versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,parameters:[{name:'property',required:true,description:null,pattern:null,'default':null,debug:false},{name:'value',required:true,description:null,pattern:null,'default':null,debug:false},{name:'setConfigurable',required:false,description:null,pattern:null,'default':null,debug:false}]}],map:{'1':0,'2':0,'4':0,'8':0,'16':0,'32':0,'64':0,'1024':1,'2048':1,'4096':1,'8192':1,'16384':2,'32768':2,'65536':2,'131072':2}},{shared:[{name:'set-cookie-reload',aliases:['set-cookie-reload.js','ubo-set-cookie-reload.js','ubo-set-cookie-reload'],description:null,docs:'https://github.com/AdguardTeam/Scriptlets/blob/master/wiki/about-scriptlets.md#set-cookie-reload',versionAdded:'1.3.14',versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,parameters:[{name:'name',required:true,description:null,pattern:null,'default':null,debug:false},{name:'value',required:true,description:null,pattern:null,'default':null,debug:false},{name:'path',required:false,description:null,pattern:null,'default':null,debug:false},{name:'domain',required:false,description:null,pattern:null,'default':null,debug:false}]},{name:'set-cookie-reload.js',aliases:null,description:null,docs:'https://github.com/gorhill/uBlock/wiki/Resources-Library#set-cookie-reloadjs-',versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,parameters:[{name:'name',required:true,description:null,pattern:null,'default':null,debug:false},{name:'value',required:true,description:null,pattern:null,'default':null,debug:false},{name:'path',required:false,description:null,pattern:null,'default':null,debug:false},{name:'domain',required:false,description:null,pattern:null,'default':null,debug:false}]}],map:{'1':0,'2':0,'4':0,'8':0,'16':0,'32':0,'64':0,'1024':1,'2048':1,'4096':1,'8192':1}},{shared:[{name:'set-cookie',aliases:['set-cookie.js','ubo-set-cookie.js','ubo-set-cookie'],description:null,docs:'https://github.com/AdguardTeam/Scriptlets/blob/master/wiki/about-scriptlets.md#set-cookie',versionAdded:'1.2.3',versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,parameters:[{name:'name',required:true,description:null,pattern:null,'default':null,debug:false},{name:'value',required:true,description:null,pattern:null,'default':null,debug:false},{name:'path',required:false,description:null,pattern:null,'default':null,debug:false}]},{name:'set-cookie.js',aliases:null,description:null,docs:'https://github.com/gorhill/uBlock/wiki/Resources-Library#set-cookiejs-',versionAdded:'1.50.1b0',versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,parameters:[{name:'name',required:true,description:null,pattern:null,'default':null,debug:false},{name:'value',required:true,description:null,pattern:null,'default':null,debug:false},{name:'path',required:false,description:null,pattern:null,'default':null,debug:false}]}],map:{'1':0,'2':0,'4':0,'8':0,'16':0,'32':0,'64':0,'1024':1,'2048':1,'4096':1,'8192':1}},{shared:[{name:'set-local-storage-item',aliases:['set-local-storage-item.js','ubo-set-local-storage-item.js','ubo-set-local-storage-item'],description:null,docs:'https://github.com/AdguardTeam/Scriptlets/blob/master/wiki/about-scriptlets.md#set-local-storage-item',versionAdded:'1.4.3',versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,parameters:[{name:'key',required:true,description:null,pattern:null,'default':null,debug:false},{name:'value',required:true,description:null,pattern:null,'default':null,debug:false}]},{name:'set-local-storage-item.js',aliases:null,description:null,docs:'https://github.com/gorhill/uBlock/wiki/Resources-Library#set-local-storage-itemjs-',versionAdded:'1.50.1b4',versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,parameters:[{name:'key',required:true,description:null,pattern:null,'default':null,debug:false},{name:'value',required:true,description:null,pattern:null,'default':null,debug:false}]}],map:{'1':0,'2':0,'4':0,'8':0,'16':0,'32':0,'64':0,'1024':1,'2048':1,'4096':1,'8192':1}},{shared:[{name:'set-popads-dummy',aliases:['popads-dummy.js','ubo-popads-dummy.js','ubo-popads-dummy'],description:null,docs:'https://github.com/AdguardTeam/Scriptlets/blob/master/wiki/about-scriptlets.md#set-popads-dummy',versionAdded:'1.0.4',versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null}],map:{'1':0,'2':0,'4':0,'8':0,'16':0,'32':0,'64':0}},{shared:[{name:'set-session-storage-item',aliases:['set-session-storage-item.js','ubo-set-session-storage-item.js','ubo-set-session-storage-item'],description:null,docs:'https://github.com/AdguardTeam/Scriptlets/blob/master/wiki/about-scriptlets.md#set-session-storage-item',versionAdded:'1.4.3',versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,parameters:[{name:'key',required:true,description:null,pattern:null,'default':null,debug:false},{name:'value',required:true,description:null,pattern:null,'default':null,debug:false}]},{name:'set-session-storage-item.js',aliases:null,description:null,docs:'https://github.com/gorhill/uBlock/wiki/Resources-Library#set-session-storage-itemjs-',versionAdded:'1.50.1b4',versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,parameters:[{name:'key',required:true,description:null,pattern:null,'default':null,debug:false},{name:'value',required:true,description:null,pattern:null,'default':null,debug:false}]}],map:{'1':0,'2':0,'4':0,'8':0,'16':0,'32':0,'64':0,'1024':1,'2048':1,'4096':1,'8192':1}},{shared:[{name:'spoof-css',aliases:['spoof-css.js','ubo-spoof-css.js','ubo-spoof-css'],description:null,docs:'https://github.com/AdguardTeam/Scriptlets/blob/master/wiki/about-scriptlets.md#spoof-css',versionAdded:'1.10.1',versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,parameters:[{name:'selectors',required:true,description:null,pattern:null,'default':null,debug:false},{name:'cssPropertyName',required:true,description:null,pattern:null,'default':null,debug:false},{name:'cssPropertyValue',required:true,description:null,pattern:null,'default':null,debug:false}]},{name:'spoof-css.js',aliases:null,description:null,docs:'https://github.com/gorhill/uBlock/wiki/Resources-Library#spoof-cssjs-',versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,parameters:[{name:'selectors',required:true,description:null,pattern:null,'default':null,debug:false},{name:'cssPropertyName',required:true,description:null,pattern:null,'default':null,debug:false},{name:'cssPropertyValue',required:true,description:null,pattern:null,'default':null,debug:false},{name:'arguments',required:false,description:null,pattern:null,'default':null,debug:false}]}],map:{'1':0,'2':0,'4':0,'8':0,'16':0,'32':0,'64':0,'1024':1,'2048':1,'4096':1,'8192':1}},{shared:[{name:'trusted-click-element',aliases:null,description:null,docs:null,versionAdded:'1.7.3',versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,parameters:[{name:'selectors',required:true,description:null,pattern:null,'default':null,debug:false},{name:'extraMatch',required:false,description:null,pattern:null,'default':null,debug:false},{name:'delay',required:false,description:null,pattern:null,'default':null,debug:false}]}],map:{'1':0,'2':0,'4':0,'8':0,'16':0,'32':0,'64':0}},{shared:[{name:'trusted-create-element',aliases:null,description:null,docs:null,versionAdded:'1.10.1',versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,parameters:[{name:'parentSelector',required:true,description:null,pattern:null,'default':null,debug:false},{name:'tagName',required:true,description:null,pattern:null,'default':null,debug:false},{name:'attributePairs',required:false,description:null,pattern:null,'default':null,debug:false},{name:'textContent',required:false,description:null,pattern:null,'default':null,debug:false},{name:'cleanupDelayMs',required:false,description:null,pattern:null,'default':null,debug:false}]}],map:{'1':0,'2':0,'4':0,'8':0,'16':0,'32':0,'64':0}},{shared:[{name:'trusted-dispatch-event',aliases:null,description:null,docs:null,versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,parameters:[{name:'event',required:true,description:null,pattern:null,'default':null,debug:false},{name:'target',required:false,description:null,pattern:null,'default':null,debug:false}]}],map:{'1':0,'2':0,'4':0,'8':0,'16':0,'32':0,'64':0}},{shared:[{name:'trusted-prune-inbound-object',aliases:null,description:null,docs:null,versionAdded:'1.9.91',versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,parameters:[{name:'functionName',required:true,description:null,pattern:null,'default':null,debug:false},{name:'propsToRemove',required:false,description:null,pattern:null,'default':null,debug:false},{name:'obligatoryProps',required:false,description:null,pattern:null,'default':null,debug:false},{name:'stack',required:false,description:null,pattern:null,'default':null,debug:false}]}],map:{'1':0,'2':0,'4':0,'8':0,'16':0,'32':0,'64':0}},{shared:[{name:'trusted-replace-fetch-response',aliases:null,description:null,docs:null,versionAdded:'1.7.3',versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,parameters:[{name:'pattern',required:false,description:null,pattern:null,'default':null,debug:false},{name:'replacement',required:false,description:null,pattern:null,'default':null,debug:false},{name:'propsToMatch',required:false,description:null,pattern:null,'default':null,debug:false}]}],map:{'1':0,'2':0,'4':0,'8':0,'16':0,'32':0,'64':0}},{shared:[{name:'trusted-replace-node-text',aliases:null,description:null,docs:null,versionAdded:'1.9.37',versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,parameters:[{name:'nodeName',required:true,description:null,pattern:null,'default':null,debug:false},{name:'textMatch',required:true,description:null,pattern:null,'default':null,debug:false},{name:'pattern',required:true,description:null,pattern:null,'default':null,debug:false},{name:'replacement',required:true,description:null,pattern:null,'default':null,debug:false}]}],map:{'1':0,'2':0,'4':0,'8':0,'16':0,'32':0,'64':0}},{shared:[{name:'trusted-replace-xhr-response',aliases:null,description:null,docs:null,versionAdded:'1.7.3',versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,parameters:[{name:'pattern',required:false,description:null,pattern:null,'default':null,debug:false},{name:'replacement',required:false,description:null,pattern:null,'default':null,debug:false},{name:'propsToMatch',required:false,description:null,pattern:null,'default':null,debug:false}]}],map:{'1':0,'2':0,'4':0,'8':0,'16':0,'32':0,'64':0}},{shared:[{name:'trusted-set-attr',aliases:null,description:null,docs:null,versionAdded:'1.10.1',versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,parameters:[{name:'selector',required:true,description:null,pattern:null,'default':null,debug:false},{name:'attr',required:true,description:null,pattern:null,'default':null,debug:false},{name:'value',required:false,description:null,pattern:null,'default':null,debug:false}]}],map:{'1':0,'2':0,'4':0,'8':0,'16':0,'32':0,'64':0}},{shared:[{name:'trusted-set-constant',aliases:null,description:null,docs:null,versionAdded:'1.8.2',versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,parameters:[{name:'property',required:true,description:null,pattern:null,'default':null,debug:false},{name:'value',required:true,description:null,pattern:null,'default':null,debug:false},{name:'stack',required:false,description:null,pattern:null,'default':null,debug:false}]}],map:{'1':0,'2':0,'4':0,'8':0,'16':0,'32':0,'64':0}},{shared:[{name:'trusted-set-cookie-reload',aliases:null,description:null,docs:null,versionAdded:'1.7.10',versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,parameters:[{name:'name',required:true,description:null,pattern:null,'default':null,debug:false},{name:'value',required:true,description:null,pattern:null,'default':null,debug:false},{name:'offsetExpiresSec',required:false,description:null,pattern:null,'default':null,debug:false},{name:'path',required:false,description:null,pattern:null,'default':null,debug:false},{name:'domain',required:false,description:null,pattern:null,'default':null,debug:false}]}],map:{'1':0,'2':0,'4':0,'8':0,'16':0,'32':0,'64':0}},{shared:[{name:'trusted-set-cookie',aliases:null,description:null,docs:null,versionAdded:'1.7.3',versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,parameters:[{name:'name',required:true,description:null,pattern:null,'default':null,debug:false},{name:'value',required:true,description:null,pattern:null,'default':null,debug:false},{name:'offsetExpiresSec',required:false,description:null,pattern:null,'default':null,debug:false},{name:'path',required:false,description:null,pattern:null,'default':null,debug:false},{name:'domain',required:false,description:null,pattern:null,'default':null,debug:false}]}],map:{'1':0,'2':0,'4':0,'8':0,'16':0,'32':0,'64':0}},{shared:[{name:'trusted-set-local-storage-item',aliases:null,description:null,docs:null,versionAdded:'1.7.3',versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,parameters:[{name:'key',required:true,description:null,pattern:null,'default':null,debug:false},{name:'value',required:true,description:null,pattern:null,'default':null,debug:false}]}],map:{'1':0,'2':0,'4':0,'8':0,'16':0,'32':0,'64':0}},{shared:[{name:'trusted-suppress-native-method',aliases:null,description:null,docs:null,versionAdded:'1.10.25',versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,parameters:[{name:'methodPath',required:true,description:null,pattern:null,'default':null,debug:false},{name:'signatureStr',required:true,description:null,pattern:null,'default':null,debug:false},{name:'how',required:false,description:null,pattern:null,'default':null,debug:false},{name:'stack',required:false,description:null,pattern:null,'default':null,debug:false}]}],map:{'1':0,'2':0,'4':0,'8':0,'16':0,'32':0,'64':0}},{shared:[{name:'xml-prune',aliases:['xml-prune.js','ubo-xml-prune.js','ubo-xml-prune'],description:null,docs:'https://github.com/AdguardTeam/Scriptlets/blob/master/wiki/about-scriptlets.md#xml-prune',versionAdded:'1.7.3',versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,parameters:[{name:'propsToMatch',required:false,description:null,pattern:null,'default':null,debug:false},{name:'optionalProp',required:false,description:null,pattern:null,'default':null,debug:false},{name:'urlToMatch',required:false,description:null,pattern:null,'default':null,debug:false}]},{name:'xml-prune.js',aliases:null,description:null,docs:'https://github.com/gorhill/uBlock/wiki/Resources-Library#xml-prunejs-',versionAdded:'1.49.3rc6',versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,parameters:[{name:'propsToMatch',required:false,description:null,pattern:null,'default':null,debug:false},{name:'optionalProp',required:false,description:null,pattern:null,'default':null,debug:false},{name:'urlToMatch',required:false,description:null,pattern:null,'default':null,debug:false}]}],map:{'1':0,'2':0,'4':0,'8':0,'16':0,'32':0,'64':0,'1024':1,'2048':1,'4096':1,'8192':1}}],map:{'abort-current-inline-script':0,'abort-current-script.js':0,'ubo-abort-current-script.js':0,'acs.js':0,'ubo-acs.js':0,'ubo-abort-current-script':0,'ubo-acs':0,'abort-current-inline-script.js':0,'ubo-abort-current-inline-script.js':0,'acis.js':0,'ubo-acis.js':0,'ubo-abort-current-inline-script':0,'ubo-acis':0,'abp-abort-current-inline-script':0,'abort-on-property-read':1,'abort-on-property-read.js':1,'ubo-abort-on-property-read.js':1,'aopr.js':1,'ubo-aopr.js':1,'ubo-abort-on-property-read':1,'ubo-aopr':1,'abp-abort-on-property-read':1,'abort-on-property-write':2,'abort-on-property-write.js':2,'ubo-abort-on-property-write.js':2,'aopw.js':2,'ubo-aopw.js':2,'ubo-abort-on-property-write':2,'ubo-aopw':2,'abp-abort-on-property-write':2,'abort-on-stack-trace':3,'abort-on-stack-trace.js':3,'ubo-abort-on-stack-trace.js':3,'aost.js':3,'ubo-aost.js':3,'ubo-abort-on-stack-trace':3,'ubo-aost':3,'abp-abort-on-stack-trace':3,'adjust-setInterval':4,'nano-setInterval-booster.js':4,'ubo-nano-setInterval-booster.js':4,'nano-sib.js':4,'ubo-nano-sib.js':4,'adjust-setInterval.js':4,'ubo-adjust-setInterval.js':4,'ubo-nano-setInterval-booster':4,'ubo-nano-sib':4,'ubo-adjust-setInterval':4,'adjust-setTimeout':5,'adjust-setTimeout.js':5,'ubo-adjust-setTimeout.js':5,'nano-setTimeout-booster.js':5,'ubo-nano-setTimeout-booster.js':5,'nano-stb.js':5,'ubo-nano-stb.js':5,'ubo-adjust-setTimeout':5,'ubo-nano-setTimeout-booster':5,'ubo-nano-stb':5,'amazon-apstag':6,'ubo-amazon_apstag.js':6,'amazon_apstag.js':6,'call-nothrow':7,'call-nothrow.js':7,'ubo-call-nothrow.js':7,'ubo-call-nothrow':7,'close-window':8,'window-close-if.js':8,'ubo-window-close-if.js':8,'ubo-window-close-if':8,'close-window.js':8,'ubo-close-window.js':8,'ubo-close-window':8,'debug-current-inline-script':9,'debug-on-property-read':10,'debug-on-property-write':11,'didomi-loader':12,'dir-string':13,'disable-newtab-links':14,'disable-newtab-links.js':14,'ubo-disable-newtab-links.js':14,'ubo-disable-newtab-links':14,'evaldata-prune':15,'evaldata-prune.js':15,'ubo-evaldata-prune.js':15,'ubo-evaldata-prune':15,fingerprintjs2:16,'ubo-fingerprint2.js':16,'fingerprint2.js':16,fingerprintjs3:17,'ubo-fingerprint3.js':17,'fingerprint3.js':17,gemius:18,'google-analytics-ga':19,'ubo-google-analytics_ga.js':19,'google-analytics_ga.js':19,'google-analytics':20,'ubo-google-analytics_analytics.js':20,'google-analytics_analytics.js':20,'googletagmanager-gtm':20,'ubo-googletagmanager_gtm.js':20,'googletagmanager_gtm.js':20,'google-ima3':21,'ubo-google-ima.js':21,'google-ima.js':21,'googlesyndication-adsbygoogle':22,'ubo-googlesyndication_adsbygoogle.js':22,'googlesyndication_adsbygoogle.js':22,'googletagservices-gpt':23,'ubo-googletagservices_gpt.js':23,'googletagservices_gpt.js':23,'hide-in-shadow-dom':24,'href-sanitizer':25,'href-sanitizer.js':25,'ubo-href-sanitizer.js':25,'ubo-href-sanitizer':25,'inject-css-in-shadow-dom':26,'json-prune-fetch-response':27,'json-prune-fetch-response.js':27,'ubo-json-prune-fetch-response.js':27,'ubo-json-prune-fetch-response':27,'json-prune-xhr-response':28,'json-prune-xhr-response.js':28,'ubo-json-prune-xhr-response.js':28,'ubo-json-prune-xhr-response':28,'json-prune':29,'json-prune.js':29,'ubo-json-prune.js':29,'ubo-json-prune':29,'abp-json-prune':29,'log-addEventListener':30,'addEventListener-logger.js':30,'ubo-addEventListener-logger.js':30,'aell.js':30,'ubo-aell.js':30,'ubo-addEventListener-logger':30,'ubo-aell':30,'log-eval':31,'log-on-stack-trace':32,log:33,'abp-log':33,'m3u-prune':34,'m3u-prune.js':34,'ubo-m3u-prune.js':34,'ubo-m3u-prune':34,matomo:35,'metrika-yandex-tag':36,'metrika-yandex-watch':37,'naver-wcslog':38,'no-protected-audience':39,'no-topics':40,noeval:41,'noeval.js':41,'silent-noeval.js':41,'ubo-noeval.js':41,'ubo-silent-noeval.js':41,'ubo-noeval':41,'ubo-silent-noeval':41,nowebrtc:42,'nowebrtc.js':42,'ubo-nowebrtc.js':42,'ubo-nowebrtc':42,'pardot-1.0':43,prebid:44,'prevent-addEventListener':45,'addEventListener-defuser.js':45,'ubo-addEventListener-defuser.js':45,'aeld.js':45,'ubo-aeld.js':45,'ubo-addEventListener-defuser':45,'ubo-aeld':45,'abp-prevent-listener':45,'prevent-addEventListener.js':45,'prevent-listener':45,'prevent-adfly':46,'adfly-defuser.js':46,'ubo-adfly-defuser.js':46,'ubo-adfly-defuser':46,'prevent-bab':47,'prevent-element-src-loading':48,'prevent-eval-if':49,'noeval-if.js':49,'ubo-noeval-if.js':49,'ubo-noeval-if':49,'prevent-eval-if.js':49,'prevent-fab-3.2.0':50,'nofab.js':50,'ubo-nofab.js':50,'fuckadblock.js-3.2.0':50,'ubo-fuckadblock.js-3.2.0':50,'ubo-nofab':50,'prevent-fetch':51,'prevent-fetch.js':51,'no-fetch-if.js':51,'ubo-no-fetch-if.js':51,'ubo-no-fetch-if':51,'prevent-popads-net':52,'popads.net.js':52,'ubo-popads.net.js':52,'ubo-popads.net':52,'prevent-refresh':53,'prevent-refresh.js':53,'refresh-defuser.js':53,'refresh-defuser':53,'ubo-prevent-refresh.js':53,'ubo-prevent-refresh':53,'ubo-refresh-defuser.js':53,'ubo-refresh-defuser':53,'prevent-requestAnimationFrame':54,'no-requestAnimationFrame-if.js':54,'ubo-no-requestAnimationFrame-if.js':54,'norafif.js':54,'ubo-norafif.js':54,'ubo-no-requestAnimationFrame-if':54,'ubo-norafif':54,'prevent-requestAnimationFrame.js':54,'prevent-setInterval':55,'no-setInterval-if.js':55,'ubo-no-setInterval-if.js':55,'setInterval-defuser.js':55,'ubo-setInterval-defuser.js':55,'nosiif.js':55,'ubo-nosiif.js':55,'sid.js':55,'ubo-sid.js':55,'ubo-no-setInterval-if':55,'ubo-setInterval-defuser':55,'ubo-nosiif':55,'ubo-sid':55,'prevent-setInterval.js':55,'prevent-setTimeout':56,'no-setTimeout-if.js':56,'ubo-no-setTimeout-if.js':56,'nostif.js':56,'ubo-nostif.js':56,'ubo-no-setTimeout-if':56,'ubo-nostif':56,'setTimeout-defuser.js':56,'ubo-setTimeout-defuser.js':56,'ubo-setTimeout-defuser':56,'std.js':56,'ubo-std.js':56,'ubo-std':56,'prevent-setTimeout.js':56,'prevent-window-open':57,'window.open-defuser.js':57,'ubo-window.open-defuser.js':57,'ubo-window.open-defuser':57,'nowoif.js':57,'ubo-nowoif.js':57,'ubo-nowoif':57,'no-window-open-if.js':57,'ubo-no-window-open-if.js':57,'ubo-no-window-open-if':57,'prevent-window-open.js':57,'prevent-xhr':58,'no-xhr-if.js':58,'ubo-no-xhr-if.js':58,'ubo-no-xhr-if':58,'prevent-xhr.js':58,'remove-attr':59,'remove-attr.js':59,'ubo-remove-attr.js':59,'ra.js':59,'ubo-ra.js':59,'ubo-remove-attr':59,'ubo-ra':59,ra:59,'remove-class':60,'remove-class.js':60,'ubo-remove-class.js':60,'rc.js':60,'ubo-rc.js':60,'ubo-remove-class':60,'ubo-rc':60,rc:60,'remove-cookie':61,'cookie-remover.js':61,'ubo-cookie-remover.js':61,'ubo-cookie-remover':61,'remove-cookie.js':61,'ubo-remove-cookie.js':61,'ubo-remove-cookie':61,'abp-cookie-remover':61,'cookie-remover':61,'remove-in-shadow-dom':62,'remove-node-text':63,'remove-node-text.js':63,'ubo-remove-node-text.js':63,'rmnt.js':63,'ubo-rmnt.js':63,'ubo-remove-node-text':63,'ubo-rmnt':63,'scorecardresearch-beacon':64,'ubo-scorecardresearch_beacon.js':64,'scorecardresearch_beacon.js':64,'set-attr':65,'set-attr.js':65,'ubo-set-attr.js':65,'ubo-set-attr':65,'set-constant':66,'set-constant.js':66,'ubo-set-constant.js':66,'set.js':66,'ubo-set.js':66,'ubo-set-constant':66,'ubo-set':66,'override-property-read':66,'set-cookie-reload':67,'set-cookie-reload.js':67,'ubo-set-cookie-reload.js':67,'ubo-set-cookie-reload':67,'set-cookie':68,'set-cookie.js':68,'ubo-set-cookie.js':68,'ubo-set-cookie':68,'set-local-storage-item':69,'set-local-storage-item.js':69,'ubo-set-local-storage-item.js':69,'ubo-set-local-storage-item':69,'set-popads-dummy':70,'popads-dummy.js':70,'ubo-popads-dummy.js':70,'ubo-popads-dummy':70,'set-session-storage-item':71,'set-session-storage-item.js':71,'ubo-set-session-storage-item.js':71,'ubo-set-session-storage-item':71,'spoof-css':72,'spoof-css.js':72,'ubo-spoof-css.js':72,'ubo-spoof-css':72,'trusted-click-element':73,'trusted-create-element':74,'trusted-dispatch-event':75,'trusted-prune-inbound-object':76,'trusted-replace-fetch-response':77,'trusted-replace-node-text':78,'trusted-replace-xhr-response':79,'trusted-set-attr':80,'trusted-set-constant':81,'trusted-set-cookie-reload':82,'trusted-set-cookie':83,'trusted-set-local-storage-item':84,'trusted-suppress-native-method':85,'xml-prune':86,'xml-prune.js':86,'ubo-xml-prune.js':86,'ubo-xml-prune':86}};



;// ./node_modules/.pnpm/@adguard+agtree@3.1.3/node_modules/@adguard/agtree/dist/utils/deep-freeze.js
/*
 * AGTree v3.1.3 (build date: Tue, 29 Apr 2025 12:25:03 GMT)
 * (c) 2025 Adguard Software Ltd.
 * Released under the MIT license
 * https://github.com/AdguardTeam/tsurlfilter/tree/master/packages/agtree#readme
 */
/**
 * Simple deep freeze implementation.
 * It freezes the object and all its properties recursively.
 *
 * @param object Object to freeze.
 *
 * @returns Frozen object.
 *
 * @template T Type of the object to freeze.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/freeze#deep_freezing}
 */
const deepFreeze = (object) => {
    // Retrieve the property names defined on object
    const propNames = Reflect.ownKeys(object);
    // Freeze properties before freezing self
    for (const name of propNames) {
        const value = object[name];
        if ((value && typeof value === 'object') || typeof value === 'function') {
            deepFreeze(value);
        }
    }
    return Object.freeze(object);
};



;// ./node_modules/.pnpm/@adguard+agtree@3.1.3/node_modules/@adguard/agtree/dist/compatibility-tables/scriptlets.js
/*
 * AGTree v3.1.3 (build date: Tue, 29 Apr 2025 12:25:03 GMT)
 * (c) 2025 Adguard Software Ltd.
 * Released under the MIT license
 * https://github.com/AdguardTeam/tsurlfilter/tree/master/packages/agtree#readme
 */




/**
 * @file Compatibility tables for scriptlets.
 */
/**
 * Compatibility table for scriptlets.
 */
class ScriptletsCompatibilityTable extends CompatibilityTableBase {
}
/**
 * Deep freeze the compatibility table data to avoid accidental modifications.
 */
deepFreeze(scriptletsCompatibilityTableData);
/**
 * Compatibility table instance for scriptlets.
 */
const scriptletsCompatibilityTable = new ScriptletsCompatibilityTable(scriptletsCompatibilityTableData);



;// ./node_modules/.pnpm/@adguard+agtree@3.1.3/node_modules/@adguard/agtree/dist/converter/cosmetic/scriptlet.js
/*
 * AGTree v3.1.3 (build date: Tue, 29 Apr 2025 12:25:03 GMT)
 * (c) 2025 Adguard Software Ltd.
 * Released under the MIT license
 * https://github.com/AdguardTeam/tsurlfilter/tree/master/packages/agtree#readme
 */























/**
 * @file Scriptlet injection rule converter
 */
const ABP_SCRIPTLET_PREFIX = 'abp-';
const UBO_SCRIPTLET_PREFIX = 'ubo-';
const UBO_SCRIPTLET_PREFIX_LENGTH = UBO_SCRIPTLET_PREFIX.length;
const UBO_SCRIPTLET_JS_SUFFIX = '.js';
const UBO_SCRIPTLET_JS_SUFFIX_LENGTH = UBO_SCRIPTLET_JS_SUFFIX.length;
const COMMA_SEPARATOR = ',';
const ADG_SET_CONSTANT_NAME = 'set-constant';
const ADG_SET_CONSTANT_EMPTY_STRING = '';
const ADG_SET_CONSTANT_EMPTY_ARRAY = 'emptyArr';
const ADG_SET_CONSTANT_EMPTY_OBJECT = 'emptyObj';
const UBO_SET_CONSTANT_EMPTY_STRING = '\'\'';
const UBO_SET_CONSTANT_EMPTY_ARRAY = '[]';
const UBO_SET_CONSTANT_EMPTY_OBJECT = '{}';
const ADG_PREVENT_FETCH_NAME = 'prevent-fetch';
const ADG_PREVENT_FETCH_EMPTY_STRING = '';
const ADG_PREVENT_FETCH_WILDCARD = '*';
const UBO_NO_FETCH_IF_WILDCARD = '/^/';
const UBO_REMOVE_CLASS_NAME = 'remove-class.js';
const UBO_REMOVE_ATTR_NAME = 'remove-attr.js';
const setConstantAdgToUboMap = {
    [ADG_SET_CONSTANT_EMPTY_STRING]: UBO_SET_CONSTANT_EMPTY_STRING,
    [ADG_SET_CONSTANT_EMPTY_ARRAY]: UBO_SET_CONSTANT_EMPTY_ARRAY,
    [ADG_SET_CONSTANT_EMPTY_OBJECT]: UBO_SET_CONSTANT_EMPTY_OBJECT,
};
const REMOVE_ATTR_CLASS_APPLYING = new Set([
    'asap',
    'stay',
    'complete',
]);
/**
 * Scriptlet injection rule converter class
 *
 * @todo Implement `convertToUbo` and `convertToAbp`
 */
class ScriptletRuleConverter extends RuleConverterBase {
    /**
     * Converts a scriptlet injection rule to AdGuard format, if possible.
     *
     * @param rule Rule node to convert
     * @returns An object which follows the {@link NodeConversionResult} interface. Its `result` property contains
     * the array of converted rule nodes, and its `isConverted` flag indicates whether the original rule was converted.
     * If the rule was not converted, the result array will contain the original node with the same object reference
     * @throws If the rule is invalid or cannot be converted
     */
    static convertToAdg(rule) {
        // Ignore AdGuard rules
        if (rule.syntax === adblockers/* AdblockSyntax */.Y.Adg) {
            return createNodeConversionResult([rule], false);
        }
        const separator = rule.separator.value;
        let convertedSeparator = separator;
        convertedSeparator = rule.exception
            ? nodes/* CosmeticRuleSeparator */.p5.AdgJsInjectionException
            : nodes/* CosmeticRuleSeparator */.p5.AdgJsInjection;
        const convertedScriptlets = [];
        for (const scriptlet of rule.body.children) {
            // Clone the node to avoid any side effects
            const scriptletClone = cloneScriptletRuleNode(scriptlet);
            // Remove possible quotes just to make it easier to work with the scriptlet name
            const scriptletName = quotes/* QuoteUtils */.Qj.setStringQuoteType(getScriptletName(scriptletClone), quotes/* QuoteType */.XA.None);
            // Add prefix if it's not already there
            let prefix;
            // In uBO / ABP syntax, if a parameter contains the separator character, it should be escaped,
            // but during the conversion, we need to unescape them, because AdGuard syntax uses quotes to
            // distinguish between parameters.
            let charToUnescape;
            switch (rule.syntax) {
                case adblockers/* AdblockSyntax */.Y.Abp:
                    prefix = ABP_SCRIPTLET_PREFIX;
                    charToUnescape = constants/* SPACE */.t6;
                    break;
                case adblockers/* AdblockSyntax */.Y.Ubo:
                    prefix = UBO_SCRIPTLET_PREFIX;
                    charToUnescape = COMMA_SEPARATOR;
                    break;
                default:
                    prefix = constants/* EMPTY */.wg;
            }
            if (!scriptletName.startsWith(prefix)) {
                setScriptletName(scriptletClone, `${prefix}${scriptletName}`);
            }
            if (!(0,type_guards/* isUndefined */.b0)(charToUnescape)) {
                transformAllScriptletArguments(scriptletClone, (value) => {
                    if (!(0,type_guards/* isNull */.kZ)(value)) {
                        return quotes/* QuoteUtils */.Qj.unescapeSingleEscapedOccurrences(value, charToUnescape);
                    }
                    return value;
                });
            }
            if (rule.syntax === adblockers/* AdblockSyntax */.Y.Ubo) {
                const scriptletData = scriptletsCompatibilityTable.getFirst(scriptletName, GenericPlatform.UboAny);
                // Some scriptlets have special values that need to be converted
                if (scriptletData
                    && (scriptletData.name === UBO_REMOVE_CLASS_NAME
                        || scriptletData.name === UBO_REMOVE_ATTR_NAME)
                    && scriptletClone.children.length > 2) {
                    const selectors = [];
                    let applying = null;
                    let lastArg = scriptletClone.children.pop();
                    // The very last argument might be the 'applying' parameter
                    if (lastArg) {
                        if (REMOVE_ATTR_CLASS_APPLYING.has(lastArg.value)) {
                            applying = lastArg.value;
                        }
                        else {
                            selectors.push(lastArg.value);
                        }
                    }
                    while (scriptletClone.children.length > 2) {
                        lastArg = scriptletClone.children.pop();
                        if (lastArg) {
                            selectors.push(lastArg.value.trim());
                        }
                    }
                    // Set last arg to be the combined selectors (in reverse order, because we popped them)
                    if (selectors.length > 0) {
                        scriptletClone.children.push({
                            type: 'Value',
                            value: selectors.reverse().join(', '),
                        });
                    }
                    // Push back the 'applying' parameter if it was found previously
                    if (!(0,type_guards/* isNull */.kZ)(applying)) {
                        // If we don't have any selectors,
                        // we need to add an empty parameter before the 'applying' one
                        if (selectors.length === 0) {
                            scriptletClone.children.push({
                                type: 'Value',
                                value: constants/* EMPTY */.wg,
                            });
                        }
                        scriptletClone.children.push({
                            type: 'Value',
                            value: applying,
                        });
                    }
                }
            }
            // ADG scriptlet parameters should be quoted, and single quoted are preferred
            setScriptletQuoteType(scriptletClone, quotes/* QuoteType */.XA.Single);
            convertedScriptlets.push(scriptletClone);
        }
        if (rule.body.children.length === 0) {
            const convertedScriptletNode = {
                category: rule.category,
                type: rule.type,
                syntax: adblockers/* AdblockSyntax */.Y.Adg,
                exception: rule.exception,
                domains: cloneDomainListNode(rule.domains),
                separator: {
                    type: 'Value',
                    value: convertedSeparator,
                },
                body: {
                    type: rule.body.type,
                    children: [],
                },
            };
            if (rule.modifiers) {
                convertedScriptletNode.modifiers = cloneModifierListNode(rule.modifiers);
            }
            return createNodeConversionResult([convertedScriptletNode], true);
        }
        return createNodeConversionResult(convertedScriptlets.map((scriptlet) => {
            const res = {
                category: rule.category,
                type: rule.type,
                syntax: adblockers/* AdblockSyntax */.Y.Adg,
                exception: rule.exception,
                domains: cloneDomainListNode(rule.domains),
                separator: {
                    type: 'Value',
                    value: convertedSeparator,
                },
                body: {
                    type: rule.body.type,
                    children: [scriptlet],
                },
            };
            if (rule.modifiers) {
                res.modifiers = cloneModifierListNode(rule.modifiers);
            }
            return res;
        }), true);
    }
    /**
     * Converts a scriptlet injection rule to uBlock format, if possible.
     *
     * @param rule Rule node to convert
     * @returns An object which follows the {@link NodeConversionResult} interface. Its `result` property contains
     * the array of converted rule nodes, and its `isConverted` flag indicates whether the original rule was converted.
     * If the rule was not converted, the result array will contain the original node with the same object reference
     * @throws If the rule is invalid or cannot be converted
     */
    static convertToUbo(rule) {
        // Ignore uBlock rules
        if (rule.syntax === adblockers/* AdblockSyntax */.Y.Ubo) {
            return createNodeConversionResult([rule], false);
        }
        const separator = rule.separator.value;
        let convertedSeparator = separator;
        convertedSeparator = rule.exception
            ? nodes/* CosmeticRuleSeparator */.p5.ElementHidingException
            : nodes/* CosmeticRuleSeparator */.p5.ElementHiding;
        const convertedScriptlets = [];
        for (const scriptlet of rule.body.children) {
            // Clone the node to avoid any side effects
            const scriptletClone = cloneScriptletRuleNode(scriptlet);
            // Remove possible quotes just to make it easier to work with the scriptlet name
            const scriptletName = quotes/* QuoteUtils */.Qj.setStringQuoteType(getScriptletName(scriptletClone), quotes/* QuoteType */.XA.None);
            let uboScriptletName;
            if (rule.syntax === adblockers/* AdblockSyntax */.Y.Adg && scriptletName.startsWith(UBO_SCRIPTLET_PREFIX)) {
                // Special case: AdGuard syntax 'preserves' the original scriptlet name,
                // so we need to convert it back by removing the uBO prefix
                uboScriptletName = scriptletName.slice(UBO_SCRIPTLET_PREFIX_LENGTH);
            }
            else {
                // Otherwise, try to find the corresponding uBO scriptlet name, or use the original one if not found
                const uboScriptlet = scriptletsCompatibilityTable.getFirst(scriptletName, GenericPlatform.UboAny);
                if (!uboScriptlet) {
                    throw new RuleConversionError(`Scriptlet "${scriptletName}" is not supported in uBlock Origin.`);
                }
                uboScriptletName = uboScriptlet.name;
            }
            // Remove the '.js' suffix if it's there - its presence is not mandatory
            if (uboScriptletName.endsWith(UBO_SCRIPTLET_JS_SUFFIX)) {
                uboScriptletName = uboScriptletName.slice(0, -UBO_SCRIPTLET_JS_SUFFIX_LENGTH);
            }
            setScriptletName(scriptletClone, uboScriptletName);
            setScriptletQuoteType(scriptletClone, quotes/* QuoteType */.XA.None);
            // Escape unescaped commas in parameters, because uBlock Origin uses them as separators.
            // For example, the following AdGuard rule:
            //
            // example.com#%#//scriptlet('spoof-css', '.adsbygoogle, #ads', 'visibility', 'visible')
            //
            //      ↓↓ should be converted to ↓↓
            //
            // example.com##+js(spoof-css.js, .adsbygoogle\, #ads, visibility, visible)
            //                  ------------  -------------------  ----------  -------
            //                    arg 0              arg 1           arg 2      arg 3
            //
            // and we need to escape the comma in the second argument to prevent it from being treated
            // as two separate arguments.
            transformAllScriptletArguments(scriptletClone, (value) => {
                if (!(0,type_guards/* isNull */.kZ)(value)) {
                    return quotes/* QuoteUtils */.Qj.escapeUnescapedOccurrences(value, COMMA_SEPARATOR);
                }
                return value;
            });
            // Unescape spaces in parameters, because uBlock Origin doesn't treat them as separators.
            if (rule.syntax === adblockers/* AdblockSyntax */.Y.Abp) {
                transformAllScriptletArguments(scriptletClone, (value) => {
                    if (!(0,type_guards/* isNull */.kZ)(value)) {
                        return quotes/* QuoteUtils */.Qj.unescapeSingleEscapedOccurrences(value, constants/* SPACE */.t6);
                    }
                    return value;
                });
            }
            // Some scriptlets have special values that need to be converted
            switch (scriptletName) {
                case ADG_SET_CONSTANT_NAME:
                    transformNthScriptletArgument(scriptletClone, 2, (value) => {
                        if (!(0,type_guards/* isNull */.kZ)(value)) {
                            return setConstantAdgToUboMap[value] ?? value;
                        }
                        return value;
                    });
                    break;
                case ADG_PREVENT_FETCH_NAME:
                    transformNthScriptletArgument(scriptletClone, 1, (value) => {
                        if (value === ADG_PREVENT_FETCH_EMPTY_STRING || value === ADG_PREVENT_FETCH_WILDCARD) {
                            return UBO_NO_FETCH_IF_WILDCARD;
                        }
                        return value;
                    });
                    break;
            }
            convertedScriptlets.push(scriptletClone);
        }
        // TODO: Refactor redundant code
        if (rule.body.children.length === 0) {
            const convertedScriptletNode = {
                category: rule.category,
                type: rule.type,
                syntax: adblockers/* AdblockSyntax */.Y.Ubo,
                exception: rule.exception,
                domains: cloneDomainListNode(rule.domains),
                separator: {
                    type: 'Value',
                    value: convertedSeparator,
                },
                body: {
                    type: rule.body.type,
                    children: [],
                },
            };
            if (rule.modifiers) {
                convertedScriptletNode.modifiers = cloneModifierListNode(rule.modifiers);
            }
            return createNodeConversionResult([convertedScriptletNode], true);
        }
        return createNodeConversionResult(convertedScriptlets.map((scriptlet) => {
            const res = {
                category: rule.category,
                type: rule.type,
                syntax: adblockers/* AdblockSyntax */.Y.Ubo,
                exception: rule.exception,
                domains: cloneDomainListNode(rule.domains),
                separator: {
                    type: 'Value',
                    value: convertedSeparator,
                },
                body: {
                    type: rule.body.type,
                    children: [scriptlet],
                },
            };
            if (rule.modifiers) {
                res.modifiers = cloneModifierListNode(rule.modifiers);
            }
            return res;
        }), true);
    }
}



;// ./node_modules/.pnpm/@adguard+agtree@3.1.3/node_modules/@adguard/agtree/dist/ast-utils/modifiers.js
/*
 * AGTree v3.1.3 (build date: Tue, 29 Apr 2025 12:25:03 GMT)
 * (c) 2025 Adguard Software Ltd.
 * Released under the MIT license
 * https://github.com/AdguardTeam/tsurlfilter/tree/master/packages/agtree#readme
 */



/**
 * @file Utility functions for working with modifier nodes
 */
/**
 * Creates a modifier node
 *
 * @param name Name of the modifier
 * @param value Value of the modifier
 * @param exception Whether the modifier is an exception
 * @returns Modifier node
 */
function createModifierNode(name, value = undefined, exception = false) {
    const result = {
        type: 'Modifier',
        exception,
        name: {
            type: 'Value',
            value: name,
        },
    };
    if (!(0,type_guards/* isUndefined */.b0)(value)) {
        result.value = {
            type: 'Value',
            value,
        };
    }
    return result;
}
/**
 * Creates a modifier list node
 *
 * @param modifiers Modifiers to put in the list (optional, defaults to an empty list)
 * @returns Modifier list node
 */
function createModifierListNode(modifiers = []) {
    const result = {
        type: 'ModifierList',
        // We need to clone the modifiers to avoid side effects
        children: modifiers.length ? clone(modifiers) : [],
    };
    return result;
}



;// ./node_modules/.pnpm/@adguard+agtree@3.1.3/node_modules/@adguard/agtree/dist/utils/multi-value-map.js
/*
 * AGTree v3.1.3 (build date: Tue, 29 Apr 2025 12:25:03 GMT)
 * (c) 2025 Adguard Software Ltd.
 * Released under the MIT license
 * https://github.com/AdguardTeam/tsurlfilter/tree/master/packages/agtree#readme
 */


/**
 * A very simple map extension that allows to store multiple values for the same key
 * by storing them in an array.
 *
 * @todo Add more methods if needed
 */
class MultiValueMap extends Map {
    /**
     * Adds a value to the map. If the key already exists, the value will be appended to the existing array,
     * otherwise a new array will be created for the key.
     *
     * @param key Key to add
     * @param values Value(s) to add
     */
    add(key, ...values) {
        let currentValues = super.get(key);
        if ((0,type_guards/* isUndefined */.b0)(currentValues)) {
            currentValues = [];
            super.set(key, values);
        }
        currentValues.push(...values);
    }
}



;// ./node_modules/.pnpm/@adguard+agtree@3.1.3/node_modules/@adguard/agtree/dist/converter/cosmetic/rule-modifiers/adg.js
/*
 * AGTree v3.1.3 (build date: Tue, 29 Apr 2025 12:25:03 GMT)
 * (c) 2025 Adguard Software Ltd.
 * Released under the MIT license
 * https://github.com/AdguardTeam/tsurlfilter/tree/master/packages/agtree#readme
 */









/**
 * @file Cosmetic rule modifier converter from uBO to ADG
 */
const UBO_MATCHES_PATH_OPERATOR = 'matches-path';
const ADG_PATH_MODIFIER = 'path';
/**
 * Special characters in modifier regexps that should be escaped
 */
const SPECIAL_MODIFIER_REGEX_CHARS = new Set([
    constants/* OPEN_SQUARE_BRACKET */.cU,
    constants/* CLOSE_SQUARE_BRACKET */.A1,
    constants/* COMMA */.KE,
    constants/* ESCAPE_CHARACTER */.Kx,
]);
/**
 * Helper class for converting cosmetic rule modifiers from uBO to ADG
 */
class AdgCosmeticRuleModifierConverter {
    /**
     * Converts a uBO cosmetic rule modifier list to ADG, if possible.
     *
     * @param modifierList Cosmetic rule modifier list node to convert
     * @returns An object which follows the {@link ConversionResult} interface. Its `result` property contains
     * the converted node, and its `isConverted` flag indicates whether the original node was converted.
     * If the node was not converted, the result will contain the original node with the same object reference
     * @throws If the modifier list cannot be converted
     * @see {@link https://github.com/gorhill/uBlock/wiki/Procedural-cosmetic-filters#cosmetic-filter-operators}
     */
    static convertFromUbo(modifierList) {
        const conversionMap = new MultiValueMap();
        modifierList.children.forEach((modifier, index) => {
            // :matches-path
            if (modifier.name.value === UBO_MATCHES_PATH_OPERATOR) {
                if (!modifier.value) {
                    throw new RuleConversionError(`'${UBO_MATCHES_PATH_OPERATOR}' operator requires a value`);
                }
                const value = RegExpUtils.isRegexPattern(modifier.value.value)
                    ? string/* StringUtils */.$x.escapeCharacters(modifier.value.value, SPECIAL_MODIFIER_REGEX_CHARS)
                    : modifier.value.value;
                // Convert uBO's `:matches-path(...)` operator to ADG's `$path=...` modifier
                conversionMap.add(index, createModifierNode(ADG_PATH_MODIFIER, 
                // We should negate the regexp if the modifier is an exception
                modifier.exception
                    // eslint-disable-next-line max-len
                    ? `${constants/* REGEX_MARKER */.Vb}${RegExpUtils.negateRegexPattern(RegExpUtils.patternToRegexp(value))}${constants/* REGEX_MARKER */.Vb}`
                    : value));
            }
        });
        // Check if we have any converted modifiers
        if (conversionMap.size) {
            const modifierListClone = clone(modifierList);
            // Replace the original modifiers with the converted ones
            modifierListClone.children = modifierListClone.children.map((modifier, index) => {
                const convertedModifier = conversionMap.get(index);
                return convertedModifier ?? modifier;
            }).flat();
            return createConversionResult(modifierListClone, true);
        }
        // Otherwise, just return the original modifier list
        return createConversionResult(modifierList, false);
    }
}



// EXTERNAL MODULE: ./node_modules/.pnpm/@adguard+agtree@3.1.3/node_modules/@adguard/agtree/dist/converter/data/css.js
var css = __webpack_require__(60003);
;// ./node_modules/.pnpm/@adguard+agtree@3.1.3/node_modules/@adguard/agtree/dist/converter/css/index.js
/*
 * AGTree v3.1.3 (build date: Tue, 29 Apr 2025 12:25:03 GMT)
 * (c) 2025 Adguard Software Ltd.
 * Released under the MIT license
 * https://github.com/AdguardTeam/tsurlfilter/tree/master/packages/agtree#readme
 */








const css_ERROR_MESSAGES = {
    // eslint-disable-next-line max-len
    INVALID_ATTRIBUTE_VALUE: `Expected '${(0,csstokenizer/* getFormattedTokenName */.bZ)(csstokenizer/* TokenType */.ks.Ident)}' or '${(0,csstokenizer/* getFormattedTokenName */.bZ)(csstokenizer/* TokenType */.ks.String)}' as attribute value, but got '%s' with value '%s`,
};
const css_PseudoClasses = {
    AbpContains: '-abp-contains',
    AbpHas: '-abp-has',
    Contains: 'contains',
    Has: 'has',
    HasText: 'has-text',
    MatchesCss: 'matches-css',
    MatchesCssAfter: 'matches-css-after',
    MatchesCssBefore: 'matches-css-before'};
const PseudoElements = {
    After: 'after',
    Before: 'before',
};
const PSEUDO_ELEMENT_NAMES = new Set([
    PseudoElements.After,
    PseudoElements.Before,
]);
/**
 * CSS selector converter
 *
 * @todo Implement `convertToUbo` and `convertToAbp`
 */
class CssSelectorConverter extends BaseConverter {
    /**
     * Converts Extended CSS elements to AdGuard-compatible ones
     *
     * @param selectorList Selector list to convert
     * @returns An object which follows the {@link ConversionResult} interface. Its `result` property contains
     * the converted node, and its `isConverted` flag indicates whether the original node was converted.
     * If the node was not converted, the result will contain the original node with the same object reference
     * @throws If the rule is invalid or incompatible
     */
    static convertToAdg(selectorList) {
        const stream = selectorList instanceof css_token_stream/* CssTokenStream */.d
            ? selectorList
            : new css_token_stream/* CssTokenStream */.d(selectorList);
        const converted = [];
        const convertAndPushPseudo = (pseudo) => {
            switch (pseudo) {
                case css_PseudoClasses.AbpContains:
                case css_PseudoClasses.HasText:
                    converted.push(css_PseudoClasses.Contains);
                    converted.push(constants/* OPEN_PARENTHESIS */.Cx);
                    break;
                case css_PseudoClasses.AbpHas:
                    converted.push(css_PseudoClasses.Has);
                    converted.push(constants/* OPEN_PARENTHESIS */.Cx);
                    break;
                // a bit special case:
                // - `:matches-css-before(...)` → `:matches-css(before, ...)`
                // - `:matches-css-after(...)`  → `:matches-css(after, ...)`
                case css_PseudoClasses.MatchesCssBefore:
                case css_PseudoClasses.MatchesCssAfter:
                    converted.push(css_PseudoClasses.MatchesCss);
                    converted.push(constants/* OPEN_PARENTHESIS */.Cx);
                    converted.push(pseudo.substring(css_PseudoClasses.MatchesCss.length + 1));
                    converted.push(constants/* COMMA */.KE);
                    break;
                default:
                    converted.push(pseudo);
                    converted.push(constants/* OPEN_PARENTHESIS */.Cx);
                    break;
            }
        };
        while (!stream.isEof()) {
            const token = stream.getOrFail();
            if (token.type === csstokenizer/* TokenType */.ks.Colon) {
                // Advance colon
                stream.advance();
                converted.push(constants/* COLON */.oH);
                const tempToken = stream.getOrFail();
                // Double colon is a pseudo-element
                if (tempToken.type === csstokenizer/* TokenType */.ks.Colon) {
                    stream.advance();
                    converted.push(constants/* COLON */.oH);
                    continue;
                }
                if (tempToken.type === csstokenizer/* TokenType */.ks.Ident) {
                    const name = stream.source.slice(tempToken.start, tempToken.end);
                    if (PSEUDO_ELEMENT_NAMES.has(name)) {
                        // Add an extra colon to the name
                        converted.push(constants/* COLON */.oH);
                        converted.push(name);
                    }
                    else {
                        // Add the name as is
                        converted.push(name);
                    }
                    // Advance the names
                    stream.advance();
                }
                else if (tempToken.type === csstokenizer/* TokenType */.ks.Function) {
                    const name = stream.source.slice(tempToken.start, tempToken.end - 1); // omit the last parenthesis
                    // :-abp-contains(...) → :contains(...)
                    // :has-text(...)      → :contains(...)
                    // :-abp-has(...)      → :has(...)
                    convertAndPushPseudo(name);
                    // Advance the function name
                    stream.advance();
                }
            }
            else if (token.type === csstokenizer/* TokenType */.ks.OpenSquareBracket) {
                let tempToken;
                const { start } = token;
                stream.advance();
                // Converts legacy Extended CSS selectors to the modern Extended CSS syntax.
                // For example:
                // - `[-ext-has=...]`                  → `:has(...)`
                // - `[-ext-contains=...]`             → `:contains(...)`
                // - `[-ext-matches-css-before=...]`   → `:matches-css(before, ...)`
                stream.skipWhitespace();
                stream.expect(csstokenizer/* TokenType */.ks.Ident);
                tempToken = stream.getOrFail();
                let attr = stream.source.slice(tempToken.start, tempToken.end);
                // Skip if the attribute name is not a legacy Extended CSS one
                if (!(attr.startsWith(css/* LEGACY_EXT_CSS_ATTRIBUTE_PREFIX */.at) || attr.startsWith(css/* ABP_EXT_CSS_PREFIX */.PY))) {
                    converted.push(stream.source.slice(start, tempToken.end));
                    stream.advance();
                    continue;
                }
                if (attr.startsWith(css/* LEGACY_EXT_CSS_ATTRIBUTE_PREFIX */.at)) {
                    attr = attr.slice(css/* LEGACY_EXT_CSS_ATTRIBUTE_PREFIX */.at.length);
                }
                stream.advance();
                stream.skipWhitespace();
                // Next token should be an equality operator (=), because Extended CSS attribute selectors
                // do not support other operators
                stream.expect(csstokenizer/* TokenType */.ks.Delim, { value: constants/* EQUALS */.UT });
                stream.advance();
                // Skip optional whitespace after the operator
                stream.skipWhitespace();
                // Parse attribute value
                tempToken = stream.getOrFail();
                // According to the spec, attribute value should be an identifier or a string
                if (tempToken.type !== csstokenizer/* TokenType */.ks.Ident && tempToken.type !== csstokenizer/* TokenType */.ks.String) {
                    throw new Error((0,sprintf.sprintf)(css_ERROR_MESSAGES.INVALID_ATTRIBUTE_VALUE, (0,csstokenizer/* getFormattedTokenName */.bZ)(tempToken.type), stream.source.slice(tempToken.start, tempToken.end)));
                }
                const value = stream.source.slice(tempToken.start, tempToken.end);
                // Advance the attribute value
                stream.advance();
                // Skip optional whitespace after the attribute value
                stream.skipWhitespace();
                // Next character should be a closing square bracket
                // We don't allow flags for Extended CSS attribute selectors
                stream.expect(csstokenizer/* TokenType */.ks.CloseSquareBracket);
                stream.advance();
                converted.push(constants/* COLON */.oH);
                convertAndPushPseudo(attr);
                let processedValue = value.slice(1, -1); // omit the quotes
                if (attr === css_PseudoClasses.Has) {
                    // TODO: Optimize this to avoid double tokenization
                    processedValue = CssSelectorConverter.convertToAdg(processedValue).result;
                }
                converted.push(processedValue);
                converted.push(constants/* CLOSE_PARENTHESIS */.s1);
            }
            else {
                converted.push(stream.source.slice(token.start, token.end));
                // Advance the token
                stream.advance();
            }
        }
        const convertedSelectorList = converted.join(constants/* EMPTY */.wg);
        return createConversionResult(convertedSelectorList, stream.source !== convertedSelectorList);
    }
}



;// ./node_modules/.pnpm/@adguard+agtree@3.1.3/node_modules/@adguard/agtree/dist/converter/cosmetic/css.js
/*
 * AGTree v3.1.3 (build date: Tue, 29 Apr 2025 12:25:03 GMT)
 * (c) 2025 Adguard Software Ltd.
 * Released under the MIT license
 * https://github.com/AdguardTeam/tsurlfilter/tree/master/packages/agtree#readme
 */








/**
 * @file CSS injection rule converter
 */
/**
 * CSS injection rule converter class
 *
 * @todo Implement `convertToUbo` and `convertToAbp`
 */
class CssInjectionRuleConverter extends RuleConverterBase {
    /**
     * Converts a CSS injection rule to AdGuard format, if possible.
     *
     * @param rule Rule node to convert
     * @returns An object which follows the {@link NodeConversionResult} interface. Its `result` property contains
     * the array of converted rule nodes, and its `isConverted` flag indicates whether the original rule was converted.
     * If the rule was not converted, the result array will contain the original node with the same object reference
     * @throws If the rule is invalid or cannot be converted
     */
    static convertToAdg(rule) {
        const separator = rule.separator.value;
        let convertedSeparator = separator;
        const stream = new css_token_stream/* CssTokenStream */.d(rule.body.selectorList.value);
        const convertedSelectorList = CssSelectorConverter.convertToAdg(stream);
        // Change the separator if the rule contains ExtendedCSS elements,
        // but do not force non-extended CSS separator if the rule does not contain any ExtendedCSS selectors,
        // because sometimes we use it to force executing ExtendedCSS library.
        if (stream.hasAnySelectorExtendedCssNodeStrict() || rule.body.remove) {
            convertedSeparator = rule.exception
                ? nodes/* CosmeticRuleSeparator */.p5.AdgExtendedCssInjectionException
                : nodes/* CosmeticRuleSeparator */.p5.AdgExtendedCssInjection;
        }
        else if (rule.syntax !== adblockers/* AdblockSyntax */.Y.Adg) {
            // If the original rule syntax is not AdGuard, use the default separator
            // e.g. if the input rule is from uBO, we need to convert ## to #$#.
            convertedSeparator = rule.exception
                ? nodes/* CosmeticRuleSeparator */.p5.AdgCssInjectionException
                : nodes/* CosmeticRuleSeparator */.p5.AdgCssInjection;
        }
        // Check if the rule needs to be converted
        if (!(rule.syntax === adblockers/* AdblockSyntax */.Y.Common || rule.syntax === adblockers/* AdblockSyntax */.Y.Adg)
            || separator !== convertedSeparator
            || convertedSelectorList.isConverted) {
            // TODO: Replace with custom clone method
            const ruleClone = clone(rule);
            ruleClone.syntax = adblockers/* AdblockSyntax */.Y.Adg;
            ruleClone.separator.value = convertedSeparator;
            ruleClone.body.selectorList.value = convertedSelectorList.result;
            return createNodeConversionResult([ruleClone], true);
        }
        // Otherwise, return the original rule
        return createNodeConversionResult([rule], false);
    }
}



;// ./node_modules/.pnpm/@adguard+agtree@3.1.3/node_modules/@adguard/agtree/dist/converter/cosmetic/element-hiding.js
/*
 * AGTree v3.1.3 (build date: Tue, 29 Apr 2025 12:25:03 GMT)
 * (c) 2025 Adguard Software Ltd.
 * Released under the MIT license
 * https://github.com/AdguardTeam/tsurlfilter/tree/master/packages/agtree#readme
 */








/**
 * @file Element hiding rule converter
 */
/**
 * Element hiding rule converter class
 *
 * @todo Implement `convertToUbo` and `convertToAbp`
 */
class ElementHidingRuleConverter extends RuleConverterBase {
    /**
     * Converts an element hiding rule to AdGuard format, if possible.
     *
     * @param rule Rule node to convert
     * @returns An object which follows the {@link NodeConversionResult} interface. Its `result` property contains
     * the array of converted rule nodes, and its `isConverted` flag indicates whether the original rule was converted.
     * If the rule was not converted, the result array will contain the original node with the same object reference
     * @throws If the rule is invalid or cannot be converted
     */
    static convertToAdg(rule) {
        const separator = rule.separator.value;
        let convertedSeparator = separator;
        const stream = new css_token_stream/* CssTokenStream */.d(rule.body.selectorList.value);
        const convertedSelectorList = CssSelectorConverter.convertToAdg(stream);
        // Change the separator if the rule contains ExtendedCSS elements,
        // but do not force non-extended CSS separator if the rule does not contain any ExtendedCSS selectors,
        // because sometimes we use it to force executing ExtendedCSS library.
        if (stream.hasAnySelectorExtendedCssNodeStrict()) {
            convertedSeparator = rule.exception
                ? nodes/* CosmeticRuleSeparator */.p5.ExtendedElementHidingException
                : nodes/* CosmeticRuleSeparator */.p5.ExtendedElementHiding;
        }
        // Check if the rule needs to be converted
        if (!(rule.syntax === adblockers/* AdblockSyntax */.Y.Common || rule.syntax === adblockers/* AdblockSyntax */.Y.Adg)
            || separator !== convertedSeparator
            || convertedSelectorList.isConverted) {
            // TODO: Replace with custom clone method
            const ruleClone = clone(rule);
            ruleClone.syntax = adblockers/* AdblockSyntax */.Y.Adg;
            ruleClone.separator.value = convertedSeparator;
            ruleClone.body.selectorList.value = convertedSelectorList.result;
            return createNodeConversionResult([ruleClone], true);
        }
        // Otherwise, return the original rule
        return createNodeConversionResult([rule], false);
    }
}



;// ./node_modules/.pnpm/@adguard+agtree@3.1.3/node_modules/@adguard/agtree/dist/ast-utils/network-rules.js
/*
 * AGTree v3.1.3 (build date: Tue, 29 Apr 2025 12:25:03 GMT)
 * (c) 2025 Adguard Software Ltd.
 * Released under the MIT license
 * https://github.com/AdguardTeam/tsurlfilter/tree/master/packages/agtree#readme
 */





/**
 * @file Utility functions for working with network rule nodes
 */
/**
 * Creates a network rule node
 *
 * @param pattern Rule pattern
 * @param modifiers Rule modifiers (optional, default: undefined)
 * @param exception Exception rule flag (optional, default: false)
 * @param syntax Adblock syntax (optional, default: Common)
 * @returns Network rule node
 */
function createNetworkRuleNode(pattern, modifiers = undefined, exception = false, syntax = adblockers/* AdblockSyntax */.Y.Common) {
    const result = {
        category: nodes/* RuleCategory */.$O.Network,
        type: nodes/* NetworkRuleType */.vY.NetworkRule,
        syntax,
        exception,
        pattern: {
            type: 'Value',
            value: pattern,
        },
    };
    if (!(0,type_guards/* isUndefined */.b0)(modifiers)) {
        result.modifiers = clone(modifiers);
    }
    return result;
}



;// ./node_modules/.pnpm/@adguard+agtree@3.1.3/node_modules/@adguard/agtree/dist/converter/cosmetic/header-removal.js
/*
 * AGTree v3.1.3 (build date: Tue, 29 Apr 2025 12:25:03 GMT)
 * (c) 2025 Adguard Software Ltd.
 * Released under the MIT license
 * https://github.com/AdguardTeam/tsurlfilter/tree/master/packages/agtree#readme
 */













/**
 * @file Converter for request header removal rules
 */
const UBO_RESPONSEHEADER_FN = 'responseheader';
const ADG_REMOVEHEADER_MODIFIER = 'removeheader';
const header_removal_ERROR_MESSAGES = {
    EMPTY_PARAMETER: `Empty parameter for '${UBO_RESPONSEHEADER_FN}' function`,
    EXPECTED_END_OF_RULE: "Expected end of rule, but got '%s'",
    MULTIPLE_DOMAINS_NOT_SUPPORTED: 'Multiple domains are not supported yet',
};
/**
 * Converter for request header removal rules
 *
 * @todo Implement `convertToUbo` (ABP currently doesn't support header removal rules)
 */
class HeaderRemovalRuleConverter extends RuleConverterBase {
    /**
     * Converts a header removal rule to AdGuard syntax, if possible.
     *
     * @param rule Rule node to convert
     * @returns An object which follows the {@link NodeConversionResult} interface. Its `result` property contains
     * the array of converted rule nodes, and its `isConverted` flag indicates whether the original rule was converted.
     * If the rule was not converted, the result array will contain the original node with the same object reference
     * @throws If the rule is invalid or cannot be converted
     * @example
     * If the input rule is:
     * ```adblock
     * example.com##^responseheader(header-name)
     * ```
     * The output will be:
     * ```adblock
     * ||example.com^$removeheader=header-name
     * ```
     */
    static convertToAdg(rule) {
        // TODO: Add support for ABP syntax once it starts supporting header removal rules
        // Leave the rule as is if it's not a header removal rule
        if (rule.category !== nodes/* RuleCategory */.$O.Cosmetic || rule.type !== nodes/* CosmeticRuleType */.k9.HtmlFilteringRule) {
            return createNodeConversionResult([rule], false);
        }
        const stream = new css_token_stream/* CssTokenStream */.d(rule.body.value);
        let token;
        // Skip leading whitespace
        stream.skipWhitespace();
        // Next token should be the `^` followed by a `responseheader` function
        token = stream.get();
        if (!token || token.type !== csstokenizer/* TokenType */.ks.Delim || rule.body.value[token.start] !== constants/* UBO_HTML_MASK */._h) {
            return createNodeConversionResult([rule], false);
        }
        stream.advance();
        token = stream.get();
        if (!token) {
            return createNodeConversionResult([rule], false);
        }
        const functionName = rule.body.value.slice(token.start, token.end - 1);
        if (functionName !== UBO_RESPONSEHEADER_FN) {
            return createNodeConversionResult([rule], false);
        }
        // Parse the parameter
        const paramStart = token.end;
        stream.skipUntilBalanced();
        const paramEnd = stream.getOrFail().end;
        const param = rule.body.value.slice(paramStart, paramEnd - 1).trim();
        // Do not allow empty parameter
        if (param.length === 0) {
            throw new RuleConversionError(header_removal_ERROR_MESSAGES.EMPTY_PARAMETER);
        }
        stream.expect(csstokenizer/* TokenType */.ks.CloseParenthesis);
        stream.advance();
        // Skip trailing whitespace after the function call
        stream.skipWhitespace();
        // Expect the end of the rule - so nothing should be left in the stream
        if (!stream.isEof()) {
            token = stream.getOrFail();
            throw new RuleConversionError((0,sprintf.sprintf)(header_removal_ERROR_MESSAGES.EXPECTED_END_OF_RULE, (0,csstokenizer/* getFormattedTokenName */.bZ)(token.type)));
        }
        // Prepare network rule pattern
        const pattern = [];
        if (rule.domains.children.length === 1) {
            // If the rule has only one domain, we can use a simple network rule pattern:
            // ||single-domain-from-the-rule^
            pattern.push(ADBLOCK_URL_START, rule.domains.children[0].value, ADBLOCK_URL_SEPARATOR);
        }
        else if (rule.domains.children.length > 1) {
            // TODO: Add support for multiple domains, for example:
            // example.com,example.org,example.net##^responseheader(header-name)
            // We should consider allowing $domain with $removeheader modifier,
            // for example:
            // $removeheader=header-name,domain=example.com|example.org|example.net
            throw new RuleConversionError(header_removal_ERROR_MESSAGES.MULTIPLE_DOMAINS_NOT_SUPPORTED);
        }
        // Prepare network rule modifiers
        const modifiers = createModifierListNode();
        modifiers.children.push(createModifierNode(ADG_REMOVEHEADER_MODIFIER, param));
        // Construct the network rule
        return createNodeConversionResult([
            createNetworkRuleNode(pattern.join(constants/* EMPTY */.wg), modifiers, 
            // Copy the exception flag
            rule.exception, adblockers/* AdblockSyntax */.Y.Adg),
        ], true);
    }
}



// EXTERNAL MODULE: ./node_modules/.pnpm/json5@2.2.3/node_modules/json5/dist/index.js
var dist = __webpack_require__(91801);
// EXTERNAL MODULE: ./node_modules/.pnpm/@adguard+agtree@3.1.3/node_modules/@adguard/agtree/dist/parser/misc/domain-list-parser.js + 1 modules
var domain_list_parser = __webpack_require__(2607);
// EXTERNAL MODULE: ./node_modules/.pnpm/tldts@5.7.112/node_modules/tldts/dist/es6/index.js + 12 modules
var es6 = __webpack_require__(13548);
// EXTERNAL MODULE: ./node_modules/.pnpm/is-ip@3.1.0/node_modules/is-ip/index.js
var is_ip = __webpack_require__(85183);
;// ./node_modules/.pnpm/@adguard+agtree@3.1.3/node_modules/@adguard/agtree/dist/converter/cosmetic/rule-modifiers/ubo.js
/*
 * AGTree v3.1.3 (build date: Tue, 29 Apr 2025 12:25:03 GMT)
 * (c) 2025 Adguard Software Ltd.
 * Released under the MIT license
 * https://github.com/AdguardTeam/tsurlfilter/tree/master/packages/agtree#readme
 */

















/**
 * @file Cosmetic rule modifier converter from ADG to uBO
 */
/**
 * Regular expression pattern for matching the main page
 * https://github.com/gorhill/uBlock/wiki/Procedural-cosmetic-filters#subjectmatches-patharg
 */
const UBO_MAIN_PAGE_MATCHER = '/^/$/';
/**
 * Special characters in modifier regexps that should be escaped
 */
const ubo_SPECIAL_MODIFIER_REGEX_CHARS = new Set([
    constants/* OPEN_SQUARE_BRACKET */.cU,
    constants/* CLOSE_SQUARE_BRACKET */.A1,
    constants/* COMMA_DOMAIN_LIST_SEPARATOR */.oo,
    constants/* ESCAPE_CHARACTER */.Kx,
]);
/**
 * Helper class for converting cosmetic rule modifiers from ADG to uBO
 */
class UboCosmeticRuleModifierConverter {
    /**
     * Converts a ADG cosmetic rule modifier list to uBO, if possible.
     *
     * @param modifierList Cosmetic rule modifier list node to convert
     * @returns An object which follows the {@link ConversionResult} interface. Its `result` property contains
     * the converted node, and its `isConverted` flag indicates whether the original node was converted.
     * If the node was not converted, the result will contain the original node with the same object reference
     * @throws If the modifier list cannot be converted
     * @see {@link https://github.com/gorhill/uBlock/wiki/Procedural-cosmetic-filters#cosmetic-filter-operators}
     */
    static convertFromAdg(modifierList) {
        const conversionMap = new MultiValueMap();
        let domainList = null;
        let regexDomainValue;
        modifierList.children.forEach((modifier, index) => {
            let value;
            let { exception } = modifier;
            switch (modifier.name.value) {
                // Special case: ADG's $app modifier
                case constants/* ADG_APP_MODIFIER */.Pe:
                    throw new Error('The $app modifier is not supported by uBO');
                // Special case: ADG's $domains modifier
                case constants/* ADG_DOMAINS_MODIFIER */.NW:
                    if (!domainList) {
                        domainList = {
                            type: nodes/* ListNodeType */.h6.DomainList,
                            separator: constants/* COMMA_DOMAIN_LIST_SEPARATOR */.oo,
                            children: [],
                            start: modifier.start,
                            end: modifier.end,
                        };
                    }
                    if (!modifier?.value?.value) {
                        return;
                    }
                    domainList = domain_list_parser/* DomainListParser */.y.parse(modifier.value.value, {}, modifier.start, constants/* PIPE_MODIFIER_SEPARATOR */.fW);
                    conversionMap.add(index, null);
                    break;
                // Special case: ADG's $url modifier
                case constants/* ADG_URL_MODIFIER */.Vw:
                    if (!domainList) {
                        domainList = {
                            type: nodes/* ListNodeType */.h6.DomainList,
                            separator: constants/* COMMA_DOMAIN_LIST_SEPARATOR */.oo,
                            children: [],
                            start: modifier.start,
                            end: modifier.end,
                        };
                    }
                    if (!modifier?.value?.value) {
                        return;
                    }
                    regexDomainValue = RegExpUtils.patternToRegexp(modifier.value.value);
                    domainList = {
                        type: nodes/* ListNodeType */.h6.DomainList,
                        separator: constants/* COMMA_DOMAIN_LIST_SEPARATOR */.oo,
                        children: [
                            {
                                type: nodes/* ListItemNodeType */.WR.Domain,
                                value: RegExpUtils.ensureSlashes(regexDomainValue),
                                exception: modifier?.exception ?? false,
                            },
                        ],
                        start: modifier.start,
                        end: modifier.end,
                    };
                    conversionMap.add(index, null);
                    break;
                // Special case: ADG's $path modifier
                case constants/* ADG_PATH_MODIFIER */.JD:
                    if (!modifier.value) {
                        value = UBO_MAIN_PAGE_MATCHER;
                    }
                    else if (RegExpUtils.isNegatedRegexPattern(modifier.value.value)) {
                        exception = true;
                        value = string/* StringUtils */.$x.escapeCharacters(RegExpUtils.removeNegationFromRegexPattern(modifier.value.value), ubo_SPECIAL_MODIFIER_REGEX_CHARS);
                    }
                    else {
                        value = RegExpUtils.isRegexPattern(modifier.value.value)
                            ? string/* StringUtils */.$x.escapeCharacters(modifier.value.value, ubo_SPECIAL_MODIFIER_REGEX_CHARS)
                            : modifier.value.value;
                    }
                    conversionMap.add(index, createModifierNode(constants/* UBO_MATCHES_PATH_OPERATOR */.I6, value, exception));
                    break;
            }
        });
        // Check if we have any converted modifiers
        if (conversionMap.size) {
            const modifierListClone = clone(modifierList);
            // Replace the original modifiers with the converted ones
            modifierListClone.children = modifierListClone.children
                .map((modifier, index) => {
                const convertedModifier = conversionMap.get(index);
                return convertedModifier ?? modifier;
            })
                .flat()
                .filter((modifier) => modifier !== null);
            return createConversionResult({ modifierList: modifierListClone, domains: domainList || undefined }, true);
        }
        // Otherwise, just return the original modifier list without any changes
        return createConversionResult({ modifierList, domains: undefined }, false);
    }
}



;// ./node_modules/.pnpm/@adguard+agtree@3.1.3/node_modules/@adguard/agtree/dist/converter/cosmetic/index.js
/*
 * AGTree v3.1.3 (build date: Tue, 29 Apr 2025 12:25:03 GMT)
 * (c) 2025 Adguard Software Ltd.
 * Released under the MIT license
 * https://github.com/AdguardTeam/tsurlfilter/tree/master/packages/agtree#readme
 */





















/**
 * @file Cosmetic rule converter
 */
/**
 * Cosmetic rule converter class (also known as "non-basic rule converter")
 *
 * @todo Implement `convertToUbo` and `convertToAbp`
 */
class CosmeticRuleConverter extends RuleConverterBase {
    /**
     * Converts a cosmetic rule to AdGuard syntax, if possible.
     *
     * @param rule Rule node to convert
     * @returns An object which follows the {@link NodeConversionResult} interface. Its `result` property contains
     * the array of converted rule nodes, and its `isConverted` flag indicates whether the original rule was converted.
     * If the rule was not converted, the result array will contain the original node with the same object reference
     * @throws If the rule is invalid or cannot be converted
     */
    static convertToAdg(rule) {
        let subconverterResult;
        // Convert cosmetic rule based on its type
        switch (rule.type) {
            case nodes/* CosmeticRuleType */.k9.ElementHidingRule:
                subconverterResult = ElementHidingRuleConverter.convertToAdg(rule);
                break;
            case nodes/* CosmeticRuleType */.k9.ScriptletInjectionRule:
                subconverterResult = ScriptletRuleConverter.convertToAdg(rule);
                break;
            case nodes/* CosmeticRuleType */.k9.CssInjectionRule:
                subconverterResult = CssInjectionRuleConverter.convertToAdg(rule);
                break;
            case nodes/* CosmeticRuleType */.k9.HtmlFilteringRule:
                // Handle special case: uBO response header filtering rule
                // TODO: Optimize double CSS tokenization here
                subconverterResult = HeaderRemovalRuleConverter.convertToAdg(rule);
                if (subconverterResult.isConverted) {
                    break;
                }
                subconverterResult = HtmlRuleConverter.convertToAdg(rule);
                break;
            // Note: Currently, only ADG supports JS injection rules, so we don't need to convert them
            case nodes/* CosmeticRuleType */.k9.JsInjectionRule:
                subconverterResult = createNodeConversionResult([rule], false);
                break;
            default:
                throw new RuleConversionError('Unsupported cosmetic rule type');
        }
        let convertedModifiers;
        // Convert cosmetic rule modifiers, if any
        if (rule.modifiers) {
            if (rule.syntax === adblockers/* AdblockSyntax */.Y.Ubo) {
                // uBO doesn't support this rule:
                // example.com##+js(set-constant.js, foo, bar):matches-path(/baz)
                if (rule.type === nodes/* CosmeticRuleType */.k9.ScriptletInjectionRule) {
                    throw new RuleConversionError('uBO scriptlet injection rules don\'t support cosmetic rule modifiers');
                }
                convertedModifiers = AdgCosmeticRuleModifierConverter.convertFromUbo(rule.modifiers);
            }
            else if (rule.syntax === adblockers/* AdblockSyntax */.Y.Abp) {
                // TODO: Implement once ABP starts supporting cosmetic rule modifiers
                throw new RuleConversionError('ABP don\'t support cosmetic rule modifiers');
            }
        }
        if ((subconverterResult.result.length > 1 || subconverterResult.isConverted)
            || (convertedModifiers && convertedModifiers.isConverted)) {
            // Add modifier list to the subconverter result rules
            subconverterResult.result.forEach((subconverterRule) => {
                if (convertedModifiers && subconverterRule.category === nodes/* RuleCategory */.$O.Cosmetic) {
                    // eslint-disable-next-line no-param-reassign
                    subconverterRule.modifiers = convertedModifiers.result;
                }
            });
            return subconverterResult;
        }
        return createNodeConversionResult([rule], false);
    }
    /**
     * Converts a cosmetic rule to uBlock Origin syntax, if possible.
     *
     * @param rule Rule node to convert
     * @returns An object which follows the {@link NodeConversionResult} interface. Its `result` property contains
     * the array of converted rule nodes, and its `isConverted` flag indicates whether the original rule was converted.
     * If the rule was not converted, the result array will contain the original node with the same object reference
     * @throws If the rule is invalid or cannot be converted
     */
    // TODO: Add support for other cosmetic rule types
    static convertToUbo(rule) {
        // Skip conversation if the rule is already in uBO format
        if (rule.syntax === adblockers/* AdblockSyntax */.Y.Ubo) {
            return createNodeConversionResult([rule], false);
        }
        // Check if the rule is a simple hiding rule
        // TODO: Handle elemhide rules with extended CSS pseudos even if type is not marked explicitly
        if (rule.type === nodes/* CosmeticRuleType */.k9.ElementHidingRule
            && (rule.separator.value === nodes/* CosmeticRuleSeparator */.p5.ElementHidingException
                || rule.separator.value === nodes/* CosmeticRuleSeparator */.p5.ElementHiding)
            && !rule.modifiers) {
            return createNodeConversionResult([rule], false);
        }
        // Convert cosmetic rule based on its type
        if (rule.type === nodes/* CosmeticRuleType */.k9.ScriptletInjectionRule) {
            if (rule.syntax === adblockers/* AdblockSyntax */.Y.Adg && rule.modifiers?.children.length) {
                // e.g. example.com##+js(set-constant.js, foo, bar):matches-path(/baz)
                throw new RuleConversionError('uBO scriptlet injection rules do not support cosmetic rule modifiers');
            }
            return ScriptletRuleConverter.convertToUbo(rule);
        }
        let convertedModifiers;
        // Convert cosmetic rule modifiers, if any
        if (rule.modifiers) {
            if (rule.syntax === adblockers/* AdblockSyntax */.Y.Abp) {
                // TODO: Implement once ABP starts supporting cosmetic rule modifiers
                throw new RuleConversionError('ABP does not support cosmetic rule modifiers');
            }
            else if (rule.syntax === adblockers/* AdblockSyntax */.Y.Adg) {
                convertedModifiers = UboCosmeticRuleModifierConverter.convertFromAdg(rule.modifiers);
            }
        }
        const result = clone(rule);
        result.syntax = adblockers/* AdblockSyntax */.Y.Ubo;
        if (convertedModifiers && convertedModifiers.isConverted) {
            result.modifiers = convertedModifiers.result.modifierList;
            if (convertedModifiers.result.domains) {
                result.domains = convertedModifiers.result.domains;
                result.domains.separator = constants/* COMMA */.KE;
            }
        }
        // Handle separator to uBO format
        let convertedSeparator = result.separator.value;
        convertedSeparator = rule.exception
            ? nodes/* CosmeticRuleSeparator */.p5.ElementHidingException
            : nodes/* CosmeticRuleSeparator */.p5.ElementHiding;
        result.separator.value = convertedSeparator;
        return createNodeConversionResult([result], true);
    }
}



;// ./node_modules/.pnpm/@adguard+agtree@3.1.3/node_modules/@adguard/agtree/dist/compatibility-tables/modifiers.js
/*
 * AGTree v3.1.3 (build date: Tue, 29 Apr 2025 12:25:03 GMT)
 * (c) 2025 Adguard Software Ltd.
 * Released under the MIT license
 * https://github.com/AdguardTeam/tsurlfilter/tree/master/packages/agtree#readme
 */





/**
 * @file Compatibility tables for modifiers.
 */
/**
 * Transforms the name of the modifier to a normalized form.
 * This is a special case: the noop modifier normally '_', but it can consist of any number of characters,
 * e.g. '____' is also valid. In this case, we need to normalize the name to '_'.
 *
 * @param name Modifier name to normalize.
 * @returns Normalized modifier name.
 */
const noopModifierNameNormalizer = (name) => {
    if (name.startsWith(constants/* UNDERSCORE */.fB)) {
        if (name.split(constants/* EMPTY */.wg).every((char) => char === constants/* UNDERSCORE */.fB)) {
            // in compatibility tables, we just store '_', so we need to reduce the number of underscores to 1
            // before checking the existence of the noop modifier
            return constants/* UNDERSCORE */.fB;
        }
    }
    return name;
};
/**
 * Compatibility table for modifiers.
 */
class ModifiersCompatibilityTable extends CompatibilityTableBase {
    /**
     * Creates a new instance of the compatibility table for modifiers.
     *
     * @param data Compatibility table data.
     */
    constructor(data) {
        super(data, noopModifierNameNormalizer);
    }
}
/**
 * Deep freeze the compatibility table data to avoid accidental modifications.
 */
deepFreeze(modifiersCompatibilityTableData);
/**
 * Compatibility table instance for modifiers.
 */
const modifiersCompatibilityTable = new ModifiersCompatibilityTable(modifiersCompatibilityTableData);



// EXTERNAL MODULE: ./node_modules/.pnpm/zod@3.21.4/node_modules/zod/lib/index.mjs
var lib = __webpack_require__(69509);
;// ./node_modules/.pnpm/@adguard+agtree@3.1.3/node_modules/@adguard/agtree/dist/compatibility-tables/schemas/resource-type.js
/*
 * AGTree v3.1.3 (build date: Tue, 29 Apr 2025 12:25:03 GMT)
 * (c) 2025 Adguard Software Ltd.
 * Released under the MIT license
 * https://github.com/AdguardTeam/tsurlfilter/tree/master/packages/agtree#readme
 */


/**
 * @file Resource type schema.
 */
/**
 * Resource type.
 *
 * @see {@link https://developer.chrome.com/docs/extensions/reference/declarativeNetRequest/#type-ResourceType}
 */
const ResourceType = {
    MainFrame: 'main_frame',
    SubFrame: 'sub_frame',
    Stylesheet: 'stylesheet',
    Script: 'script',
    Image: 'image',
    Font: 'font',
    Object: 'object',
    XmlHttpRequest: 'xmlhttprequest',
    Ping: 'ping',
    Media: 'media',
    WebSocket: 'websocket',
    Other: 'other',
};
/**
 * Resource type schema.
 */
const resourceTypeSchema = lib/* default.nativeEnum */.Ay.nativeEnum(ResourceType);



;// ./node_modules/.pnpm/@adguard+agtree@3.1.3/node_modules/@adguard/agtree/dist/compatibility-tables/utils/resource-type-helpers.js
/*
 * AGTree v3.1.3 (build date: Tue, 29 Apr 2025 12:25:03 GMT)
 * (c) 2025 Adguard Software Ltd.
 * Released under the MIT license
 * https://github.com/AdguardTeam/tsurlfilter/tree/master/packages/agtree#readme
 */




/**
 * Map of resource types to their corresponding adblock modifier names.
 *
 * @note Record type is used to ensure that all resource types are present in the map.
 */
const RESOURCE_TYPE_MODIFIER_MAP = Object.freeze({
    [ResourceType.MainFrame]: 'document',
    [ResourceType.SubFrame]: 'subdocument',
    [ResourceType.Stylesheet]: 'stylesheet',
    [ResourceType.Script]: 'script',
    [ResourceType.Image]: 'image',
    [ResourceType.Font]: 'font',
    [ResourceType.Object]: 'object',
    [ResourceType.XmlHttpRequest]: 'xmlhttprequest',
    [ResourceType.Ping]: 'ping',
    [ResourceType.Media]: 'media',
    [ResourceType.WebSocket]: 'websocket',
    [ResourceType.Other]: 'other',
});
/**
 * Gets the adblock modifier name for the given resource type.
 *
 * @param resourceType Resource type to get the modifier name for.
 * @param platform Platform to get the modifier for.
 *
 * @returns A string containing the adblock modifier name for the given resource type
 * or `null` if the modifier could not be found.
 */
const getResourceTypeModifier = (resourceType, platform) => {
    const modifierName = RESOURCE_TYPE_MODIFIER_MAP[resourceType];
    if (!modifierName) {
        return null;
    }
    const modifierData = modifiersCompatibilityTable.getFirst(modifierName, platform);
    if ((0,type_guards/* isNull */.kZ)(modifierData)) {
        return null;
    }
    return modifierData.name;
};
/**
 * Checks if the given resource type is valid.
 *
 * @param resourceType Resource type to check.
 *
 * @returns `true` if the resource type is valid, `false` otherwise.
 */
const isValidResourceType = (resourceType) => {
    return Object.values(ResourceType).includes(resourceType);
};



;// ./node_modules/.pnpm/@adguard+agtree@3.1.3/node_modules/@adguard/agtree/dist/compatibility-tables/redirects.js
/*
 * AGTree v3.1.3 (build date: Tue, 29 Apr 2025 12:25:03 GMT)
 * (c) 2025 Adguard Software Ltd.
 * Released under the MIT license
 * https://github.com/AdguardTeam/tsurlfilter/tree/master/packages/agtree#readme
 */







/**
 * @file Compatibility tables for redirects.
 */
/**
 * Prefix for resource redirection names.
 */
const ABP_RESOURCE_PREFIX = 'abp-resource:';
const ABP_RESOURCE_PREFIX_LENGTH = ABP_RESOURCE_PREFIX.length;
/**
 * Normalizes the redirect name.
 *
 * @param name Redirect name to normalize.
 *
 * @returns Normalized redirect name.
 *
 * @example
 * redirectNameNormalizer('abp-resource:my-resource') // => 'my-resource'
 * redirectNameNormalizer('noop.js:99') // => 'noop.js'
 */
const redirectNameNormalizer = (name) => {
    // Remove ABP resource prefix, if present
    if (name.startsWith(ABP_RESOURCE_PREFIX)) {
        return name.slice(ABP_RESOURCE_PREFIX_LENGTH);
    }
    // Remove :[integer] priority suffix from the name, if present
    // See:
    // - https://github.com/AdguardTeam/tsurlfilter/issues/59
    // - https://github.com/gorhill/uBlock/wiki/Static-filter-syntax#redirect
    const colonIndex = name.lastIndexOf(constants/* COLON */.oH);
    if (colonIndex !== -1 && /^\d+$/.test(name.slice(colonIndex + 1))) {
        return name.slice(0, colonIndex);
    }
    return name;
};
/**
 * Compatibility table for redirects.
 */
class RedirectsCompatibilityTable extends CompatibilityTableBase {
    /**
     * Creates a new instance of the compatibility table for redirects.
     *
     * @param data Compatibility table data.
     */
    constructor(data) {
        super(data, redirectNameNormalizer);
    }
    /**
     * Gets the resource type adblock modifiers for the redirect for the given platform
     * based on the `resourceTypes` field.
     *
     * @param redirect Redirect name or redirect data.
     * @param platform Platform to get the modifiers for.
     *
     * @returns Set of resource type modifiers or an empty set if the redirect is not found or has no resource types.
     */
    getResourceTypeModifiers(redirect, platform) {
        let redirectData = null;
        if ((0,type_guards/* isString */.Kg)(redirect)) {
            redirectData = this.getFirst(redirect, platform);
        }
        else {
            redirectData = redirect;
        }
        const modifierNames = new Set();
        if ((0,type_guards/* isNull */.kZ)(redirectData) || (0,type_guards/* isUndefined */.b0)(redirectData.resourceTypes)) {
            return modifierNames;
        }
        for (const resourceType of redirectData.resourceTypes) {
            const modifierName = getResourceTypeModifier(resourceType, platform);
            if ((0,type_guards/* isNull */.kZ)(modifierName)) {
                continue;
            }
            modifierNames.add(modifierName);
        }
        return modifierNames;
    }
}
/**
 * Deep freeze the compatibility table data to avoid accidental modifications.
 */
deepFreeze(redirectsCompatibilityTableData);
/**
 * Compatibility table instance for redirects.
 */
const redirectsCompatibilityTable = new RedirectsCompatibilityTable(redirectsCompatibilityTableData);



;// ./node_modules/.pnpm/@adguard+agtree@3.1.3/node_modules/@adguard/agtree/dist/converter/misc/network-rule-modifier.js
/*
 * AGTree v3.1.3 (build date: Tue, 29 Apr 2025 12:25:03 GMT)
 * (c) 2025 Adguard Software Ltd.
 * Released under the MIT license
 * https://github.com/AdguardTeam/tsurlfilter/tree/master/packages/agtree#readme
 */





















/**
 * @file Network rule modifier list converter.
 */
/**
 * @see {@link https://adguard.com/kb/general/ad-filtering/create-own-filters/#csp-modifier}
 */
const CSP_MODIFIER = 'csp';
const CSP_SEPARATOR = constants/* SEMICOLON */.I8 + constants/* SPACE */.t6;
/**
 * @see {@link https://adguard.com/kb/general/ad-filtering/create-own-filters/#csp-modifier}
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Security-Policy}
 */
const COMMON_CSP_PARAMS = '\'self\' \'unsafe-eval\' http: https: data: blob: mediastream: filesystem:';
/**
 * @see {@link https://help.adblockplus.org/hc/en-us/articles/360062733293#rewrite}
 */
const ABP_REWRITE_MODIFIER = 'rewrite';
/**
 * @see {@link https://adguard.com/kb/general/ad-filtering/create-own-filters/#redirect-modifier}
 */
const REDIRECT_MODIFIER = 'redirect';
/**
 * @see {@link https://adguard.com/kb/general/ad-filtering/create-own-filters/#redirect-rule-modifier}
 */
const REDIRECT_RULE_MODIFIER = 'redirect-rule';
/**
 * @see {@link https://github.com/gorhill/uBlock/wiki/Resources-Library#empty-redirect-resources}
 */
const UBO_NOOP_TEXT_RESOURCE = 'noop.txt';
/**
 * Redirect-related modifiers.
 */
const REDIRECT_MODIFIERS = new Set([
    ABP_REWRITE_MODIFIER,
    REDIRECT_MODIFIER,
    REDIRECT_RULE_MODIFIER,
]);
/**
 * Conversion map for ADG network rule modifiers.
 */
const ADG_CONVERSION_MAP = new Map([
    ['1p', [{ name: () => 'third-party', exception: (actual) => !actual }]],
    ['3p', [{ name: () => 'third-party' }]],
    ['css', [{ name: () => 'stylesheet' }]],
    ['doc', [{ name: () => 'document' }]],
    ['ehide', [{ name: () => 'elemhide' }]],
    ['empty', [{ name: () => 'redirect', value: () => 'nooptext' }]],
    ['first-party', [{ name: () => 'third-party', exception: (actual) => !actual }]],
    ['frame', [{ name: () => 'subdocument' }]],
    ['ghide', [{ name: () => 'generichide' }]],
    ['inline-font', [{ name: () => CSP_MODIFIER, value: () => `font-src ${COMMON_CSP_PARAMS}` }]],
    ['inline-script', [{ name: () => CSP_MODIFIER, value: () => `script-src ${COMMON_CSP_PARAMS}` }]],
    ['mp4', [{ name: () => 'redirect', value: () => 'noopmp4-1s' }, { name: () => 'media', value: () => undefined }]],
    ['queryprune', [{ name: () => 'removeparam' }]],
    ['shide', [{ name: () => 'specifichide' }]],
    ['xhr', [{ name: () => 'xmlhttprequest' }]],
]);
/**
 * Helper class for converting network rule modifier lists.
 *
 * @todo Implement `convertToUbo` and `convertToAbp`
 */
class NetworkRuleModifierListConverter extends BaseConverter {
    /**
     * Converts a network rule modifier list to AdGuard format, if possible.
     *
     * @param modifierList Network rule modifier list node to convert
     * @param isException If `true`, the rule is an exception rule
     * @returns An object which follows the {@link ConversionResult} interface. Its `result` property contains
     * the converted node, and its `isConverted` flag indicates whether the original node was converted.
     * If the node was not converted, the result will contain the original node with the same object reference
     * @throws If the conversion is not possible
     */
    static convertToAdg(modifierList, isException = false) {
        const conversionMap = new MultiValueMap();
        // Special case: $csp modifier
        let cspCount = 0;
        modifierList.children.forEach((modifierNode, index) => {
            const modifierConversions = ADG_CONVERSION_MAP.get(modifierNode.name.value);
            if (modifierConversions) {
                for (const modifierConversion of modifierConversions) {
                    const name = modifierConversion.name(modifierNode.name.value);
                    const exception = modifierConversion.exception
                        // If the exception value is undefined in the original modifier, it
                        // means that the modifier isn't negated
                        ? modifierConversion.exception(modifierNode.exception || false)
                        : modifierNode.exception;
                    const value = modifierConversion.value
                        ? modifierConversion.value(modifierNode.value?.value)
                        : modifierNode.value?.value;
                    // Check if the name or the value is different from the original modifier
                    // If so, add the converted modifier to the list
                    if (name !== modifierNode.name.value || value !== modifierNode.value?.value) {
                        conversionMap.add(index, createModifierNode(name, value, exception));
                    }
                    // Special case: $csp modifier
                    if (name === CSP_MODIFIER) {
                        cspCount += 1;
                    }
                }
                return;
            }
            // Handle special case: resource redirection modifiers
            if (REDIRECT_MODIFIERS.has(modifierNode.name.value)) {
                // Redirect modifiers can't be negated
                if (modifierNode.exception === true) {
                    throw new RuleConversionError(`Modifier '${modifierNode.name.value}' cannot be negated`);
                }
                // Convert the redirect resource name to ADG format
                const redirectResource = modifierNode.value?.value;
                // Special case: for exception rules, $redirect without value is allowed,
                // and in this case it means an exception for all redirects
                if (!redirectResource && !isException) {
                    throw new RuleConversionError(`No redirect resource specified for '${modifierNode.name.value}' modifier`);
                }
                // Leave $redirect and $redirect-rule modifiers as is, but convert $rewrite to $redirect
                const modifierName = modifierNode.name.value === ABP_REWRITE_MODIFIER
                    ? REDIRECT_MODIFIER
                    : modifierNode.name.value;
                const convertedRedirectResource = redirectResource
                    ? redirectsCompatibilityTable.getFirst(redirectResource, GenericPlatform.AdgAny)?.name
                    : undefined;
                // Check if the modifier name or the redirect resource name is different from the original modifier.
                // If so, add the converted modifier to the list
                if (modifierName !== modifierNode.name.value
                    || (convertedRedirectResource !== undefined && convertedRedirectResource !== redirectResource)) {
                    conversionMap.add(index, createModifierNode(modifierName, 
                    // If the redirect resource name is unknown, fall back to the original one
                    // Later, the validator will throw an error if the resource name is invalid
                    convertedRedirectResource || redirectResource, modifierNode.exception));
                }
            }
        });
        // Prepare the result if there are any converted modifiers or $csp modifiers
        if (conversionMap.size || cspCount) {
            const modifierListClone = cloneModifierListNode(modifierList);
            // Replace the original modifiers with the converted ones
            // One modifier may be replaced with multiple modifiers, so we need to flatten the array
            modifierListClone.children = modifierListClone.children.map((modifierNode, index) => {
                const conversionRecord = conversionMap.get(index);
                if (conversionRecord) {
                    return conversionRecord;
                }
                return modifierNode;
            }).flat();
            // Special case: $csp modifier: merge multiple $csp modifiers into one
            // and put it at the end of the modifier list
            if (cspCount) {
                const cspValues = [];
                modifierListClone.children = modifierListClone.children.filter((modifierNode) => {
                    if (modifierNode.name.value === CSP_MODIFIER) {
                        if (!modifierNode.value?.value) {
                            throw new RuleConversionError('$csp modifier value is missing');
                        }
                        cspValues.push(modifierNode.value?.value);
                        return false;
                    }
                    return true;
                });
                modifierListClone.children.push(createModifierNode(CSP_MODIFIER, cspValues.join(CSP_SEPARATOR)));
            }
            // Before returning the result, remove duplicated modifiers
            modifierListClone.children = modifierListClone.children.filter((modifierNode, index, self) => self.findIndex((m) => m.name.value === modifierNode.name.value
                && m.exception === modifierNode.exception
                && m.value?.value === modifierNode.value?.value) === index);
            return createConversionResult(modifierListClone, true);
        }
        return createConversionResult(modifierList, false);
    }
    /**
     * Converts a network rule modifier list to uBlock format, if possible.
     *
     * @param modifierList Network rule modifier list node to convert
     * @param isException If `true`, the rule is an exception rule
     * @returns An object which follows the {@link ConversionResult} interface. Its `result` property contains
     * the converted node, and its `isConverted` flag indicates whether the original node was converted.
     * If the node was not converted, the result will contain the original node with the same object reference
     * @throws If the conversion is not possible
     */
    // TODO: Optimize
    static convertToUbo(modifierList, isException = false) {
        const conversionMap = new MultiValueMap();
        const resourceTypeModifiersToAdd = new Set();
        modifierList.children.forEach((modifierNode, index) => {
            const originalModifierName = modifierNode.name.value;
            const modifierData = modifiersCompatibilityTable.getFirst(originalModifierName, GenericPlatform.UboAny);
            // Handle special case: resource redirection modifiers
            if (REDIRECT_MODIFIERS.has(originalModifierName)) {
                // Redirect modifiers cannot be negated
                if (modifierNode.exception === true) {
                    throw new RuleConversionError(`Modifier '${modifierNode.name.value}' cannot be negated`);
                }
                // Convert the redirect resource name to uBO format
                const redirectResourceName = modifierNode.value?.value;
                // Special case: for exception rules, $redirect without value is allowed,
                // and in this case it means an exception for all redirects
                if (!redirectResourceName && !isException) {
                    throw new RuleConversionError(`No redirect resource specified for '${modifierNode.name.value}' modifier`);
                }
                if (!redirectResourceName) {
                    // Jump to the next modifier if the redirect resource is not specified
                    return;
                }
                // Leave $redirect and $redirect-rule modifiers as is, but convert $rewrite to $redirect
                const modifierName = modifierNode.name.value === ABP_REWRITE_MODIFIER
                    ? REDIRECT_MODIFIER
                    : modifierNode.name.value;
                const convertedRedirectResourceData = redirectsCompatibilityTable.getFirst(redirectResourceName, GenericPlatform.UboAny);
                const convertedRedirectResourceName = convertedRedirectResourceData?.name ?? redirectResourceName;
                // uBlock requires the $redirect modifier to have a resource type
                // https://github.com/AdguardTeam/Scriptlets/issues/101
                if (convertedRedirectResourceData?.resourceTypes?.length) {
                    // Convert the resource types to uBO modifiers
                    const uboResourceTypeModifiers = redirectsCompatibilityTable.getResourceTypeModifiers(convertedRedirectResourceData, GenericPlatform.UboAny);
                    // Special case: noop text resource
                    // If any of resource type is already present, we don't need to add other resource types,
                    // otherwise, add all resource types
                    // TODO: Optimize this logic
                    // Check if the current resource is the noop text resource
                    const isNoopTextResource = convertedRedirectResourceName === UBO_NOOP_TEXT_RESOURCE;
                    // Determine if there are any valid resource types already present
                    const hasValidResourceType = modifierList.children.some((modifier) => {
                        const name = modifier.name.value;
                        if (!isValidResourceType(name)) {
                            return false;
                        }
                        const convertedModifierData = modifiersCompatibilityTable.getFirst(name, GenericPlatform.UboAny);
                        return uboResourceTypeModifiers.has(convertedModifierData?.name ?? name);
                    });
                    // If it's not the noop text resource or if no valid resource types are present
                    if (!isNoopTextResource || !hasValidResourceType) {
                        uboResourceTypeModifiers.forEach((resourceType) => {
                            resourceTypeModifiersToAdd.add(resourceType);
                        });
                    }
                }
                // Check if the modifier name or the redirect resource name is different from the original modifier.
                // If so, add the converted modifier to the list
                if (modifierName !== originalModifierName
                    || (!(0,type_guards/* isUndefined */.b0)(convertedRedirectResourceName)
                        && convertedRedirectResourceName !== redirectResourceName)) {
                    conversionMap.add(index, createModifierNode(modifierName, 
                    // If the redirect resource name is unknown, fall back to the original one
                    // Later, the validator will throw an error if the resource name is invalid
                    convertedRedirectResourceName || redirectResourceName, modifierNode.exception));
                }
                return;
            }
            // Generic modifier conversion
            if (modifierData && modifierData.name !== originalModifierName) {
                conversionMap.add(index, createModifierNode(modifierData.name, modifierNode.value?.value, modifierNode.exception));
            }
        });
        // Prepare the result if there are any converted modifiers or $csp modifiers
        if (conversionMap.size || resourceTypeModifiersToAdd.size) {
            const modifierListClone = cloneModifierListNode(modifierList);
            // Replace the original modifiers with the converted ones
            // One modifier may be replaced with multiple modifiers, so we need to flatten the array
            modifierListClone.children = modifierListClone.children.map((modifierNode, index) => {
                const conversionRecord = conversionMap.get(index);
                if (conversionRecord) {
                    return conversionRecord;
                }
                return modifierNode;
            }).flat();
            // Before returning the result, remove duplicated modifiers
            modifierListClone.children = modifierListClone.children.filter((modifierNode, index, self) => self.findIndex((m) => m.name.value === modifierNode.name.value
                && m.exception === modifierNode.exception
                && m.value?.value === modifierNode.value?.value) === index);
            if (resourceTypeModifiersToAdd.size) {
                const modifierNameSet = new Set(modifierList.children.map((m) => m.name.value));
                resourceTypeModifiersToAdd.forEach((resourceType) => {
                    if (!modifierNameSet.has(resourceType)) {
                        modifierListClone.children.push(createModifierNode(resourceType));
                    }
                });
            }
            return createConversionResult(modifierListClone, true);
        }
        return createConversionResult(modifierList, false);
    }
}



;// ./node_modules/.pnpm/@adguard+agtree@3.1.3/node_modules/@adguard/agtree/dist/converter/network/index.js
/*
 * AGTree v3.1.3 (build date: Tue, 29 Apr 2025 12:25:03 GMT)
 * (c) 2025 Adguard Software Ltd.
 * Released under the MIT license
 * https://github.com/AdguardTeam/tsurlfilter/tree/master/packages/agtree#readme
 */





/**
 * @file Network rule converter
 */
/**
 * Network rule converter class (also known as "basic rule converter")
 *
 * @todo Implement `convertToUbo` and `convertToAbp`
 */
class NetworkRuleConverter extends RuleConverterBase {
    /**
     * Converts a network rule to AdGuard format, if possible.
     *
     * @param rule Rule node to convert
     * @returns An object which follows the {@link NodeConversionResult} interface. Its `result` property contains
     * the array of converted rule nodes, and its `isConverted` flag indicates whether the original rule was converted.
     * If the rule was not converted, the result array will contain the original node with the same object reference
     * @throws If the rule is invalid or cannot be converted
     */
    static convertToAdg(rule) {
        // TODO: add support for host rules
        if (rule.type !== nodes/* NetworkRuleType */.vY.NetworkRule) {
            throw new Error(`Invalid rule type: ${rule.type}`);
        }
        if (rule.modifiers) {
            const modifiers = NetworkRuleModifierListConverter.convertToAdg(rule.modifiers, rule.exception);
            // If the object reference is different, it means that the modifiers were converted
            // In this case, we should clone the entire rule and replace the modifiers with the converted ones
            if (modifiers.isConverted) {
                return {
                    result: [{
                            category: nodes/* RuleCategory */.$O.Network,
                            type: nodes/* NetworkRuleType */.vY.NetworkRule,
                            syntax: rule.syntax,
                            exception: rule.exception,
                            pattern: {
                                type: 'Value',
                                value: rule.pattern.value,
                            },
                            modifiers: modifiers.result,
                        }],
                    isConverted: true,
                };
            }
        }
        // If the modifiers were not converted, return the original rule
        return createNodeConversionResult([rule], false);
    }
    /**
     * Converts a network rule to uBlock format, if possible.
     *
     * @param rule Rule node to convert
     * @returns An object which follows the {@link NodeConversionResult} interface. Its `result` property contains
     * the array of converted rule nodes, and its `isConverted` flag indicates whether the original rule was converted.
     * If the rule was not converted, the result array will contain the original node with the same object reference
     * @throws If the rule is invalid or cannot be converted
     */
    static convertToUbo(rule) {
        // TODO: add support for host rules
        if (rule.type !== nodes/* NetworkRuleType */.vY.NetworkRule) {
            throw new Error(`Invalid rule type: ${rule.type}`);
        }
        if (rule.modifiers) {
            const modifiers = NetworkRuleModifierListConverter.convertToUbo(rule.modifiers, rule.exception);
            // If the object reference is different, it means that the modifiers were converted
            // In this case, we should clone the entire rule and replace the modifiers with the converted ones
            if (modifiers.isConverted) {
                return {
                    result: [{
                            category: nodes/* RuleCategory */.$O.Network,
                            type: nodes/* NetworkRuleType */.vY.NetworkRule,
                            syntax: rule.syntax,
                            exception: rule.exception,
                            pattern: {
                                type: 'Value',
                                value: rule.pattern.value,
                            },
                            modifiers: modifiers.result,
                        }],
                    isConverted: true,
                };
            }
        }
        // If the modifiers were not converted, return the original rule
        return createNodeConversionResult([rule], false);
    }
}



;// ./node_modules/.pnpm/@adguard+agtree@3.1.3/node_modules/@adguard/agtree/dist/converter/rule.js
/*
 * AGTree v3.1.3 (build date: Tue, 29 Apr 2025 12:25:03 GMT)
 * (c) 2025 Adguard Software Ltd.
 * Released under the MIT license
 * https://github.com/AdguardTeam/tsurlfilter/tree/master/packages/agtree#readme
 */








/**
 * @file Adblock rule converter
 *
 * This file is the entry point for all rule converters
 * which automatically detects the rule type and calls
 * the corresponding "sub-converter".
 */
/**
 * Adblock filtering rule converter class
 *
 * @todo Implement `convertToUbo` and `convertToAbp`
 */
class RuleConverter extends RuleConverterBase {
    /**
     * Converts an adblock filtering rule to AdGuard format, if possible.
     *
     * @param rule Rule node to convert
     * @returns An object which follows the {@link NodeConversionResult} interface. Its `result` property contains
     * the array of converted rule nodes, and its `isConverted` flag indicates whether the original rule was converted.
     * If the rule was not converted, the result array will contain the original node with the same object reference
     * @throws If the rule is invalid or cannot be converted
     */
    static convertToAdg(rule) {
        // Delegate conversion to the corresponding sub-converter
        // based on the rule category
        switch (rule.category) {
            case nodes/* RuleCategory */.$O.Comment:
                return CommentRuleConverter.convertToAdg(rule);
            case nodes/* RuleCategory */.$O.Cosmetic:
                return CosmeticRuleConverter.convertToAdg(rule);
            case nodes/* RuleCategory */.$O.Network:
                // TODO: Handle hosts rules later
                if (rule.type === nodes/* NetworkRuleType */.vY.HostRule) {
                    return createConversionResult([rule], false);
                }
                return NetworkRuleConverter.convertToAdg(rule);
            case nodes/* RuleCategory */.$O.Invalid:
            case nodes/* RuleCategory */.$O.Empty:
                // Just forward the rule as is
                return createConversionResult([rule], false);
            default:
                // Never happens during normal operation
                throw new RuleConversionError('Unknown rule category');
        }
    }
    /**
     * Converts an adblock filtering rule to uBlock Origin format, if possible.
     *
     * @param rule Rule node to convert
     * @returns An object which follows the {@link NodeConversionResult} interface. Its `result` property contains
     * the array of converted rule nodes, and its `isConverted` flag indicates whether the original rule was converted.
     * If the rule was not converted, the result array will contain the original node with the same object reference
     * @throws If the rule is invalid or cannot be converted
     */
    // TODO: Add support for other rule types
    static convertToUbo(rule) {
        if (rule.category === nodes/* RuleCategory */.$O.Cosmetic) {
            return CosmeticRuleConverter.convertToUbo(rule);
        }
        if (rule.category === nodes/* RuleCategory */.$O.Network) {
            return NetworkRuleConverter.convertToUbo(rule);
        }
        return createConversionResult([rule], false);
    }
}




/***/ }),

/***/ 51935:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  Y: () => (/* binding */ RuleDeserializer)
});

// EXTERNAL MODULE: ./node_modules/.pnpm/@adguard+agtree@3.1.3/node_modules/@adguard/agtree/dist/errors/not-implemented-error.js
var not_implemented_error = __webpack_require__(74173);
;// ./node_modules/.pnpm/@adguard+agtree@3.1.3/node_modules/@adguard/agtree/dist/deserializer/base-deserializer.js
/*
 * AGTree v3.1.3 (build date: Tue, 29 Apr 2025 12:25:03 GMT)
 * (c) 2025 Adguard Software Ltd.
 * Released under the MIT license
 * https://github.com/AdguardTeam/tsurlfilter/tree/master/packages/agtree#readme
 */


/**
 * @file Base deserializer class.
 */
/**
 * Base class for deserializers. Each deserializer should extend this class.
 */
class BaseDeserializer {
    /**
     * Deserializes the AST node from a byte buffer.
     *
     * @param buffer Input byte buffer to read from.
     * @param node Destination node to write to.
     * @param args Additional, parser-specific arguments, if needed.
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    static deserialize(buffer, node, ...args) {
        throw new not_implemented_error/* NotImplementedError */.E();
    }
}



// EXTERNAL MODULE: ./node_modules/.pnpm/@adguard+agtree@3.1.3/node_modules/@adguard/agtree/dist/utils/constants.js
var constants = __webpack_require__(27895);
// EXTERNAL MODULE: ./node_modules/.pnpm/@adguard+agtree@3.1.3/node_modules/@adguard/agtree/dist/nodes/index.js
var nodes = __webpack_require__(91354);
// EXTERNAL MODULE: ./node_modules/.pnpm/@adguard+agtree@3.1.3/node_modules/@adguard/agtree/dist/utils/adblockers.js
var adblockers = __webpack_require__(73734);
// EXTERNAL MODULE: ./node_modules/.pnpm/@adguard+agtree@3.1.3/node_modules/@adguard/agtree/dist/marshalling-utils/comment/agent-comment-common.js
var agent_comment_common = __webpack_require__(23070);
// EXTERNAL MODULE: ./node_modules/.pnpm/@adguard+agtree@3.1.3/node_modules/@adguard/agtree/dist/marshalling-utils/comment/agent-common.js
var agent_common = __webpack_require__(60390);
// EXTERNAL MODULE: ./node_modules/.pnpm/@adguard+agtree@3.1.3/node_modules/@adguard/agtree/dist/common/agent-common.js
var common_agent_common = __webpack_require__(38303);
// EXTERNAL MODULE: ./node_modules/.pnpm/@adguard+agtree@3.1.3/node_modules/@adguard/agtree/dist/marshalling-utils/misc/value-common.js
var value_common = __webpack_require__(54749);
// EXTERNAL MODULE: ./node_modules/.pnpm/@adguard+agtree@3.1.3/node_modules/@adguard/agtree/dist/marshalling-utils/misc/binary-type-common.js
var binary_type_common = __webpack_require__(82938);
;// ./node_modules/.pnpm/@adguard+agtree@3.1.3/node_modules/@adguard/agtree/dist/deserializer/misc/value-deserializer.js
/*
 * AGTree v3.1.3 (build date: Tue, 29 Apr 2025 12:25:03 GMT)
 * (c) 2025 Adguard Software Ltd.
 * Released under the MIT license
 * https://github.com/AdguardTeam/tsurlfilter/tree/master/packages/agtree#readme
 */





/**
 * Value deserializer.
 */
class ValueDeserializer extends BaseDeserializer {
    /**
     * Deserializes a value node from binary format.
     *
     * @param buffer ByteBuffer for reading binary data.
     * @param node Destination node.
     * @param frequentValuesMap Optional map of frequent values.
     * @throws If the binary data is malformed.
     */
    static deserialize(buffer, node, frequentValuesMap) {
        buffer.assertUint8(binary_type_common/* BinaryTypeMarshallingMap */.u.ValueNode);
        node.type = 'Value';
        let prop = buffer.readUint8();
        while (prop !== constants/* NULL */.Cq) {
            switch (prop) {
                case value_common/* ValueNodeMarshallingMap */.e.Value:
                    node.value = buffer.readString();
                    break;
                case value_common/* ValueNodeMarshallingMap */.e.FrequentValue:
                    node.value = frequentValuesMap?.get(buffer.readUint8()) ?? constants/* EMPTY */.wg;
                    break;
                case value_common/* ValueNodeMarshallingMap */.e.Start:
                    node.start = buffer.readUint32();
                    break;
                case value_common/* ValueNodeMarshallingMap */.e.End:
                    node.end = buffer.readUint32();
                    break;
                default:
                    throw new Error(`Invalid property: ${prop}`);
            }
            prop = buffer.readUint8();
        }
    }
}



;// ./node_modules/.pnpm/@adguard+agtree@3.1.3/node_modules/@adguard/agtree/dist/deserializer/comment/agent-deserializer.js
/*
 * AGTree v3.1.3 (build date: Tue, 29 Apr 2025 12:25:03 GMT)
 * (c) 2025 Adguard Software Ltd.
 * Released under the MIT license
 * https://github.com/AdguardTeam/tsurlfilter/tree/master/packages/agtree#readme
 */







/* eslint-disable no-param-reassign */
/**
 * `AgentDeserializer` is responsible for deserializing single adblock agent elements.
 *
 * @example
 * If the adblock agent rule is
 * ```adblock
 * [Adblock Plus 2.0; AdGuard]
 * ```
 * then the adblock agents are `Adblock Plus 2.0` and `AdGuard`, and this
 * class is responsible for parsing them. The rule itself is parsed by
 * `AgentCommentSerializer`, which uses this class to parse single agents.
 */
class AgentDeserializer extends BaseDeserializer {
    /**
     * Deserializes an agent node from binary format.
     *
     * @param buffer ByteBuffer for reading binary data.
     * @param node Destination node.
     * @throws If the binary data is malformed.
     */
    static deserialize(buffer, node) {
        buffer.assertUint8(binary_type_common/* BinaryTypeMarshallingMap */.u.AgentNode);
        node.type = 'Agent';
        let prop = buffer.readUint8();
        while (prop !== constants/* NULL */.Cq) {
            switch (prop) {
                case agent_common/* AgentNodeMarshallingMap */.o.Adblock:
                    // eslint-disable-next-line max-len
                    ValueDeserializer.deserialize(buffer, node.adblock = {}, agent_common/* FREQUENT_AGENTS_DESERIALIZATION_MAP */.h);
                    if (node.adblock) {
                        node.syntax = (0,common_agent_common/* getAdblockSyntax */.w)(node.adblock.value);
                    }
                    break;
                case agent_common/* AgentNodeMarshallingMap */.o.Version:
                    ValueDeserializer.deserialize(buffer, node.version = {});
                    break;
                case agent_common/* AgentNodeMarshallingMap */.o.Start:
                    node.start = buffer.readUint32();
                    break;
                case agent_common/* AgentNodeMarshallingMap */.o.End:
                    node.end = buffer.readUint32();
                    break;
                default:
                    throw new Error(`Invalid property: ${prop}`);
            }
            prop = buffer.readUint8();
        }
    }
}



;// ./node_modules/.pnpm/@adguard+agtree@3.1.3/node_modules/@adguard/agtree/dist/deserializer/comment/agent-comment-deserializer.js
/*
 * AGTree v3.1.3 (build date: Tue, 29 Apr 2025 12:25:03 GMT)
 * (c) 2025 Adguard Software Ltd.
 * Released under the MIT license
 * https://github.com/AdguardTeam/tsurlfilter/tree/master/packages/agtree#readme
 */








/* eslint-disable no-param-reassign */
/**
 * `AgentCommentDeserializer` is responsible for deserializing an Adblock agent comments.
 * Adblock agent comment marks that the filter list is supposed to
 * be used by the specified ad blockers.
 *
 * @example
 *  - ```adblock
 *    [AdGuard]
 *    ```
 *  - ```adblock
 *    [Adblock Plus 2.0]
 *    ```
 *  - ```adblock
 *    [uBlock Origin]
 *    ```
 *  - ```adblock
 *    [uBlock Origin 1.45.3]
 *    ```
 *  - ```adblock
 *    [Adblock Plus 2.0; AdGuard]
 *    ```
 */
class AgentCommentDeserializer extends BaseDeserializer {
    /**
     * Deserializes an agent list node from binary format.
     *
     * @param buffer ByteBuffer for reading binary data.
     * @param node Destination node.
     */
    static deserialize(buffer, node) {
        buffer.assertUint8(binary_type_common/* BinaryTypeMarshallingMap */.u.AgentRuleNode);
        node.type = nodes/* CommentRuleType */.gV.AgentCommentRule;
        node.syntax = adblockers/* AdblockSyntax */.Y.Common;
        node.category = nodes/* RuleCategory */.$O.Comment;
        let prop = buffer.readUint8();
        while (prop !== constants/* NULL */.Cq) {
            switch (prop) {
                case agent_comment_common/* AgentCommentMarshallingMap */.j.Children:
                    node.children = new Array(buffer.readUint8());
                    // read children
                    for (let i = 0; i < node.children.length; i += 1) {
                        AgentDeserializer.deserialize(buffer, node.children[i] = {});
                    }
                    break;
                case agent_comment_common/* AgentCommentMarshallingMap */.j.Start:
                    node.start = buffer.readUint32();
                    break;
                case agent_comment_common/* AgentCommentMarshallingMap */.j.End:
                    node.end = buffer.readUint32();
                    break;
                default:
                    throw new Error(`Invalid property: ${prop}`);
            }
            prop = buffer.readUint8();
        }
        // Maybe children are not present in the binary data,
        // in this case, we should initialize it as an empty array.
        if (!node.children) {
            node.children = [];
        }
    }
}



// EXTERNAL MODULE: ./node_modules/.pnpm/@adguard+agtree@3.1.3/node_modules/@adguard/agtree/dist/marshalling-utils/comment/config-comment-common.js
var config_comment_common = __webpack_require__(92379);
// EXTERNAL MODULE: ./node_modules/.pnpm/@adguard+agtree@3.1.3/node_modules/@adguard/agtree/dist/marshalling-utils/misc/parameter-list-common.js
var parameter_list_common = __webpack_require__(21434);
;// ./node_modules/.pnpm/@adguard+agtree@3.1.3/node_modules/@adguard/agtree/dist/deserializer/misc/parameter-list-deserializer.js
/*
 * AGTree v3.1.3 (build date: Tue, 29 Apr 2025 12:25:03 GMT)
 * (c) 2025 Adguard Software Ltd.
 * Released under the MIT license
 * https://github.com/AdguardTeam/tsurlfilter/tree/master/packages/agtree#readme
 */






/**
 * Deserializes binary data into parameter list nodes.
 * Optionally uses a map of frequent values for optimization.
 */
class ParameterListDeserializer extends BaseDeserializer {
    /**
     * Deserializes a parameter list node from binary format.
     *
     * @param buffer ByteBuffer for reading binary data.
     * @param node Destination node.
     * @param frequentValuesMap Optional map of frequent values.
     * @throws If the binary data is malformed.
     */
    static deserialize(buffer, node, frequentValuesMap) {
        buffer.assertUint8(binary_type_common/* BinaryTypeMarshallingMap */.u.ParameterListNode);
        node.type = 'ParameterList';
        let prop = buffer.readUint8();
        while (prop !== constants/* NULL */.Cq) {
            switch (prop) {
                case parameter_list_common/* ParameterListNodeMarshallingMap */._.Children:
                    node.children = new Array(buffer.readUint32());
                    // read children
                    for (let i = 0; i < node.children.length; i += 1) {
                        switch (buffer.peekUint8()) {
                            case binary_type_common/* BinaryTypeMarshallingMap */.u.Null:
                                buffer.readUint8();
                                node.children[i] = null;
                                break;
                            case binary_type_common/* BinaryTypeMarshallingMap */.u.ValueNode:
                                // eslint-disable-next-line max-len
                                ValueDeserializer.deserialize(buffer, node.children[i] = {}, frequentValuesMap);
                                break;
                            default:
                                throw new Error(`Invalid child type: ${buffer.peekUint8()}`);
                        }
                    }
                    break;
                case parameter_list_common/* ParameterListNodeMarshallingMap */._.Start:
                    node.start = buffer.readUint32();
                    break;
                case parameter_list_common/* ParameterListNodeMarshallingMap */._.End:
                    node.end = buffer.readUint32();
                    break;
                default:
                    throw new Error(`Invalid property: ${prop}`);
            }
            prop = buffer.readUint8();
        }
    }
}



;// ./node_modules/.pnpm/@adguard+agtree@3.1.3/node_modules/@adguard/agtree/dist/deserializer/comment/config-comment-deserializer.js
/*
 * AGTree v3.1.3 (build date: Tue, 29 Apr 2025 12:25:03 GMT)
 * (c) 2025 Adguard Software Ltd.
 * Released under the MIT license
 * https://github.com/AdguardTeam/tsurlfilter/tree/master/packages/agtree#readme
 */









/* eslint-disable no-param-reassign */
/**
 * Value map for binary deserialization. This helps to reduce the size of the serialized data,
 * as it allows us to use a single byte to represent frequently used values.
 */
let frequentCommandsDeserializationMap;
const getFrequentCommandsDeserializationMap = () => {
    if (!frequentCommandsDeserializationMap) {
        frequentCommandsDeserializationMap = new Map(Array.from(config_comment_common/* FREQUENT_COMMANDS_SERIALIZATION_MAP */.O6).map(([key, value]) => [value, key]));
    }
    return frequentCommandsDeserializationMap;
};
/**
 * `ConfigCommentDeserializer` is responsible for deserializing inline AGLint configuration rules.
 * Generally, the idea is inspired by ESLint inline configuration comments.
 *
 * @see {@link https://eslint.org/docs/latest/user-guide/configuring/rules#using-configuration-comments}
 */
class ConfigCommentDeserializer extends BaseDeserializer {
    /**
     * Deserializes a metadata comment node from binary format.
     *
     * @param buffer ByteBuffer for reading binary data.
     * @param node Destination node.
     * @throws If the binary data is malformed.
     */
    static deserializeConfigNode(buffer, node) {
        buffer.assertUint8(binary_type_common/* BinaryTypeMarshallingMap */.u.ConfigNode);
        node.type = 'ConfigNode';
        let prop = buffer.readUint8();
        while (prop !== constants/* NULL */.Cq) {
            switch (prop) {
                case config_comment_common/* ConfigNodeMarshallingMap */.H4.Value:
                    // note: it is safe to use JSON.parse here, because we serialized it with JSON.stringify
                    node.value = JSON.parse(buffer.readString());
                    break;
                case config_comment_common/* ConfigNodeMarshallingMap */.H4.Start:
                    node.start = buffer.readUint32();
                    break;
                case config_comment_common/* ConfigNodeMarshallingMap */.H4.End:
                    node.end = buffer.readUint32();
                    break;
                default:
                    throw new Error(`Invalid property: ${prop}.`);
            }
            prop = buffer.readUint8();
        }
    }
    /**
     * Deserializes a metadata comment node from binary format.
     *
     * @param buffer ByteBuffer for reading binary data.
     * @param node Destination node.
     * @throws If the binary data is malformed.
     */
    static deserialize(buffer, node) {
        buffer.assertUint8(binary_type_common/* BinaryTypeMarshallingMap */.u.ConfigCommentRuleNode);
        node.type = nodes/* CommentRuleType */.gV.ConfigCommentRule;
        node.category = nodes/* RuleCategory */.$O.Comment;
        node.syntax = adblockers/* AdblockSyntax */.Y.Common;
        let prop = buffer.readUint8();
        while (prop !== constants/* NULL */.Cq) {
            switch (prop) {
                case config_comment_common/* ConfigCommentRuleMarshallingMap */.E0.Marker:
                    ValueDeserializer.deserialize(buffer, node.marker = {});
                    break;
                case config_comment_common/* ConfigCommentRuleMarshallingMap */.E0.Command:
                    // eslint-disable-next-line max-len
                    ValueDeserializer.deserialize(buffer, node.command = {}, getFrequentCommandsDeserializationMap());
                    break;
                case config_comment_common/* ConfigCommentRuleMarshallingMap */.E0.Params:
                    if (buffer.peekUint8() === binary_type_common/* BinaryTypeMarshallingMap */.u.ConfigNode) {
                        ConfigCommentDeserializer.deserializeConfigNode(buffer, node.params = {});
                    }
                    else {
                        ParameterListDeserializer.deserialize(buffer, node.params = {});
                    }
                    break;
                case config_comment_common/* ConfigCommentRuleMarshallingMap */.E0.Comment:
                    ValueDeserializer.deserialize(buffer, node.comment = {});
                    break;
                case config_comment_common/* ConfigCommentRuleMarshallingMap */.E0.Start:
                    node.start = buffer.readUint32();
                    break;
                case config_comment_common/* ConfigCommentRuleMarshallingMap */.E0.End:
                    node.end = buffer.readUint32();
                    break;
                default:
                    throw new Error(`Invalid property: ${prop}`);
            }
            prop = buffer.readUint8();
        }
    }
}



// EXTERNAL MODULE: ./node_modules/.pnpm/@adguard+agtree@3.1.3/node_modules/@adguard/agtree/dist/marshalling-utils/comment/hint-common.js
var hint_common = __webpack_require__(1622);
;// ./node_modules/.pnpm/@adguard+agtree@3.1.3/node_modules/@adguard/agtree/dist/deserializer/comment/hint-deserializer.js
/*
 * AGTree v3.1.3 (build date: Tue, 29 Apr 2025 12:25:03 GMT)
 * (c) 2025 Adguard Software Ltd.
 * Released under the MIT license
 * https://github.com/AdguardTeam/tsurlfilter/tree/master/packages/agtree#readme
 */







/* eslint-disable no-param-reassign */
/**
 * Value map for binary deserialization. This helps to reduce the size of the serialized data,
 * as it allows us to use a single byte to represent frequently used values.
 */
let frequentHintsDeserializationMap;
const getFrequentHintsDeserializationMap = () => {
    if (!frequentHintsDeserializationMap) {
        frequentHintsDeserializationMap = new Map(Array.from(hint_common/* FREQUENT_HINTS_SERIALIZATION_MAP */.EX).map(([key, value]) => [value, key]));
    }
    return frequentHintsDeserializationMap;
};
/**
 * Value map for binary deserialization. This helps to reduce the size of the serialized data,
 * as it allows us to use a single byte to represent frequently used values.
 */
let frequentPlatformsDeserializationMap;
const getFrequentPlatformsDeserializationMap = () => {
    if (!frequentPlatformsDeserializationMap) {
        frequentPlatformsDeserializationMap = new Map(Array.from(hint_common/* FREQUENT_PLATFORMS_SERIALIZATION_MAP */.QE).map(([key, value]) => [value, key]));
    }
    return frequentPlatformsDeserializationMap;
};
/**
 * `HintDeserializer` is responsible for deserializing AdGuard hints.
 *
 * @example
 * If the hint rule is
 * ```adblock
 * !+ NOT_OPTIMIZED PLATFORM(windows)
 * ```
 * then the hints are `NOT_OPTIMIZED` and `PLATFORM(windows)`, and this
 * class is responsible for parsing them. The rule itself is parsed by
 * the `HintRuleParser`, which uses this class to parse single hints.
 */
class HintDeserializer extends BaseDeserializer {
    /**
     * Deserializes a hint node from binary format.
     *
     * @param buffer ByteBuffer for reading binary data.
     * @param node Destination node.
     * @throws If the binary data is malformed.
     */
    static deserialize(buffer, node) {
        buffer.assertUint8(binary_type_common/* BinaryTypeMarshallingMap */.u.HintNode);
        node.type = 'Hint';
        let prop = buffer.readUint8();
        while (prop !== constants/* NULL */.Cq) {
            switch (prop) {
                case hint_common/* HintNodeMarshallingMap */.ae.Name:
                    // eslint-disable-next-line max-len
                    ValueDeserializer.deserialize(buffer, node.name = {}, getFrequentHintsDeserializationMap());
                    break;
                case hint_common/* HintNodeMarshallingMap */.ae.Params:
                    // eslint-disable-next-line max-len
                    ParameterListDeserializer.deserialize(buffer, node.params = {}, getFrequentPlatformsDeserializationMap());
                    break;
                case hint_common/* HintNodeMarshallingMap */.ae.Start:
                    node.start = buffer.readUint32();
                    break;
                case hint_common/* HintNodeMarshallingMap */.ae.End:
                    node.end = buffer.readUint32();
                    break;
                default:
                    throw new Error(`Invalid property: ${prop}`);
            }
            prop = buffer.readUint8();
        }
    }
}



// EXTERNAL MODULE: ./node_modules/.pnpm/@adguard+agtree@3.1.3/node_modules/@adguard/agtree/dist/marshalling-utils/comment/hint-comment-common.js
var hint_comment_common = __webpack_require__(89518);
// EXTERNAL MODULE: ./node_modules/.pnpm/@adguard+agtree@3.1.3/node_modules/@adguard/agtree/dist/marshalling-utils/syntax-serialization-map.js
var syntax_serialization_map = __webpack_require__(42912);
;// ./node_modules/.pnpm/@adguard+agtree@3.1.3/node_modules/@adguard/agtree/dist/deserializer/syntax-deserialization-map.js
/*
 * AGTree v3.1.3 (build date: Tue, 29 Apr 2025 12:25:03 GMT)
 * (c) 2025 Adguard Software Ltd.
 * Released under the MIT license
 * https://github.com/AdguardTeam/tsurlfilter/tree/master/packages/agtree#readme
 */


/**
 * Value map for binary deserialization. This helps to reduce the size of the serialized data,
 * as it allows us to use a single byte to represent frequently used values.
 */
let syntaxDeserializationMap;
const getSyntaxDeserializationMap = () => {
    if (!syntaxDeserializationMap) {
        syntaxDeserializationMap = new Map(Array.from((0,syntax_serialization_map/* getSyntaxSerializationMap */.M)(), ([key, value]) => [value, key]));
    }
    return syntaxDeserializationMap;
};



;// ./node_modules/.pnpm/@adguard+agtree@3.1.3/node_modules/@adguard/agtree/dist/deserializer/comment/hint-comment-deserializer.js
/*
 * AGTree v3.1.3 (build date: Tue, 29 Apr 2025 12:25:03 GMT)
 * (c) 2025 Adguard Software Ltd.
 * Released under the MIT license
 * https://github.com/AdguardTeam/tsurlfilter/tree/master/packages/agtree#readme
 */









/* eslint-disable no-param-reassign */
/**
 * `HintCommentDeserializer` is responsible for deserializing AdGuard hint rules.
 *
 * @example
 * The following hint rule
 * ```adblock
 * !+ NOT_OPTIMIZED PLATFORM(windows)
 * ```
 * contains two hints: `NOT_OPTIMIZED` and `PLATFORM`.
 * @see {@link https://kb.adguard.com/en/general/how-to-create-your-own-ad-filters#hints}
 */
class HintCommentDeserializer extends BaseDeserializer {
    /**
     * Deserializes a hint rule node from binary format.
     *
     * @param buffer ByteBuffer for reading binary data.
     * @param node Destination node.
     * @throws If the binary data is malformed.
     */
    static deserialize(buffer, node) {
        buffer.assertUint8(binary_type_common/* BinaryTypeMarshallingMap */.u.HintRuleNode);
        node.category = nodes/* RuleCategory */.$O.Comment;
        node.type = nodes/* CommentRuleType */.gV.HintCommentRule;
        let prop = buffer.readUint8();
        while (prop !== constants/* NULL */.Cq) {
            switch (prop) {
                case hint_comment_common/* HintCommentMarshallingMap */.r.Syntax:
                    node.syntax = getSyntaxDeserializationMap().get(buffer.readUint8()) ?? adblockers/* AdblockSyntax */.Y.Common;
                    break;
                case hint_comment_common/* HintCommentMarshallingMap */.r.Children:
                    node.children = new Array(buffer.readUint8());
                    // read children
                    for (let i = 0; i < node.children.length; i += 1) {
                        HintDeserializer.deserialize(buffer, node.children[i] = {});
                    }
                    break;
                case hint_comment_common/* HintCommentMarshallingMap */.r.Start:
                    node.start = buffer.readUint32();
                    break;
                case hint_comment_common/* HintCommentMarshallingMap */.r.End:
                    node.end = buffer.readUint32();
                    break;
                default:
                    throw new Error(`Invalid property: ${prop}`);
            }
            prop = buffer.readUint8();
        }
        // Maybe children are not present in the binary data,
        // in this case, we should initialize it as an empty array.
        if (!node.children) {
            node.children = [];
        }
    }
}



// EXTERNAL MODULE: ./node_modules/.pnpm/@adguard+agtree@3.1.3/node_modules/@adguard/agtree/dist/marshalling-utils/comment/metadata-comment-common.js
var metadata_comment_common = __webpack_require__(218);
;// ./node_modules/.pnpm/@adguard+agtree@3.1.3/node_modules/@adguard/agtree/dist/deserializer/comment/metadata-comment-deserializer.js
/*
 * AGTree v3.1.3 (build date: Tue, 29 Apr 2025 12:25:03 GMT)
 * (c) 2025 Adguard Software Ltd.
 * Released under the MIT license
 * https://github.com/AdguardTeam/tsurlfilter/tree/master/packages/agtree#readme
 */








/* eslint-disable no-param-reassign */
/**
 * `MetadataCommentDeserializer` is responsible for deserializing metadata comments.
 * Metadata comments are special comments that specify some properties of the list.
 *
 * @example
 * For example, in the case of
 * ```adblock
 * ! Title: My List
 * ```
 * the name of the header is `Title`, and the value is `My List`, which means that
 * the list title is `My List`, and it can be used in the adblocker UI.
 * @see {@link https://help.eyeo.com/adblockplus/how-to-write-filters#special-comments}
 */
class MetadataCommentDeserializer extends BaseDeserializer {
    /**
     * Deserializes a metadata comment node from binary format.
     *
     * @param buffer ByteBuffer for reading binary data.
     * @param node Destination node.
     * @throws If the binary data is malformed.
     */
    static deserialize(buffer, node) {
        buffer.assertUint8(binary_type_common/* BinaryTypeMarshallingMap */.u.MetadataCommentRuleNode);
        node.type = nodes/* CommentRuleType */.gV.MetadataCommentRule;
        node.category = nodes/* RuleCategory */.$O.Comment;
        node.syntax = adblockers/* AdblockSyntax */.Y.Common;
        let prop = buffer.readUint8();
        while (prop !== constants/* NULL */.Cq) {
            switch (prop) {
                case metadata_comment_common/* MetadataCommentMarshallingMap */.Z.Marker:
                    ValueDeserializer.deserialize(buffer, node.marker = {});
                    break;
                case metadata_comment_common/* MetadataCommentMarshallingMap */.Z.Header:
                    // eslint-disable-next-line max-len
                    ValueDeserializer.deserialize(buffer, node.header = {}, metadata_comment_common/* FREQUENT_HEADERS_DESERIALIZATION_MAP */.l);
                    break;
                case metadata_comment_common/* MetadataCommentMarshallingMap */.Z.Value:
                    ValueDeserializer.deserialize(buffer, node.value = {});
                    break;
                case metadata_comment_common/* MetadataCommentMarshallingMap */.Z.Start:
                    node.start = buffer.readUint32();
                    break;
                case metadata_comment_common/* MetadataCommentMarshallingMap */.Z.End:
                    node.end = buffer.readUint32();
                    break;
                default:
                    throw new Error(`Invalid property: ${prop}`);
            }
            prop = buffer.readUint8();
        }
    }
}



// EXTERNAL MODULE: ./node_modules/.pnpm/@adguard+agtree@3.1.3/node_modules/@adguard/agtree/dist/marshalling-utils/comment/pre-processor-comment-common.js
var pre_processor_comment_common = __webpack_require__(3025);
// EXTERNAL MODULE: ./node_modules/.pnpm/@adguard+agtree@3.1.3/node_modules/@adguard/agtree/dist/marshalling-utils/misc/logical-expression-common.js
var logical_expression_common = __webpack_require__(93828);
// EXTERNAL MODULE: ./node_modules/.pnpm/@adguard+agtree@3.1.3/node_modules/@adguard/agtree/dist/serializer/misc/logical-expression-serializer.js
var logical_expression_serializer = __webpack_require__(63113);
// EXTERNAL MODULE: ./node_modules/.pnpm/@adguard+agtree@3.1.3/node_modules/@adguard/agtree/dist/utils/type-guards.js
var type_guards = __webpack_require__(8123);
;// ./node_modules/.pnpm/@adguard+agtree@3.1.3/node_modules/@adguard/agtree/dist/deserializer/misc/logical-expression-deserializer.js
/*
 * AGTree v3.1.3 (build date: Tue, 29 Apr 2025 12:25:03 GMT)
 * (c) 2025 Adguard Software Ltd.
 * Released under the MIT license
 * https://github.com/AdguardTeam/tsurlfilter/tree/master/packages/agtree#readme
 */







let logicalExpressionOperatorMarshallingMapReverse;
const getOperatorBinaryMapReverse = () => {
    if (!logicalExpressionOperatorMarshallingMapReverse) {
        logicalExpressionOperatorMarshallingMapReverse = new Map(Array.from(logical_expression_common/* LOGICAL_EXPRESSION_OPERATOR_SERIALISATION_MAP */.td).map(([key, value]) => [value, key]));
    }
    return logicalExpressionOperatorMarshallingMapReverse;
};
/**
 * Gets the string representation of the operator from the binary representation.
 *
 * @param binary Binary representation of the operator
 * @returns String representation of the operator
 * @throws If the operator is unknown
 */
const getOperatorOrFail = (binary) => {
    const operator = getOperatorBinaryMapReverse().get(binary);
    if ((0,type_guards/* isUndefined */.b0)(operator)) {
        throw new Error(`Unknown operator: ${binary}`);
    }
    return operator;
};
/**
 * Deserialization map for known variables.
 */
let knownVariablesMapReverse;
const getKnownVariablesMapReverse = () => {
    if (!knownVariablesMapReverse) {
        knownVariablesMapReverse = new Map(Array.from(logical_expression_common/* KNOWN_VARIABLES_SERIALIZATION_MAP */.Y5).map(([key, value]) => [value, key]));
    }
    return knownVariablesMapReverse;
};
/**
 * Gets the frequent name of the variable from the binary representation.
 *
 * @param binary Binary representation of the variable
 * @returns Frequent name of the variable
 * @throws If the variable is unknown
 */
const getFrequentNameOrFail = (binary) => {
    const name = getKnownVariablesMapReverse().get(binary);
    if ((0,type_guards/* isUndefined */.b0)(name)) {
        throw new Error(`Unknown frequent name: ${binary}`);
    }
    return name;
};
/**
 * `LogicalExpressionDeserializer` is responsible for deserializing logical expressions.
 *
 * @example
 * From the following rule:
 * ```adblock
 * !#if (adguard_ext_android_cb || adguard_ext_safari)
 * ```
 * this parser will parse the expression `(adguard_ext_android_cb || adguard_ext_safari)`.
 */
// TODO: Refactor this class
class LogicalExpressionDeserializer extends BaseDeserializer {
    /**
     * Deserializes a variable node from binary format.
     *
     * @param buffer ByteBuffer for reading binary data.
     * @param node Destination node.
     * @throws If the binary data is malformed.
     */
    static deserializeVariableNode(buffer, node) {
        buffer.assertUint8(binary_type_common/* BinaryTypeMarshallingMap */.u.ExpressionVariableNode);
        node.type = logical_expression_serializer/* NodeType */.Z.Variable;
        let prop = buffer.readUint8();
        while (prop !== constants/* NULL */.Cq) {
            switch (prop) {
                case logical_expression_common/* VariableNodeBinaryPropMarshallingMap */.Tf.Name:
                    node.name = buffer.readString();
                    break;
                case logical_expression_common/* VariableNodeBinaryPropMarshallingMap */.Tf.FrequentName:
                    node.name = getFrequentNameOrFail(buffer.readUint8());
                    break;
                case logical_expression_common/* VariableNodeBinaryPropMarshallingMap */.Tf.Start:
                    node.start = buffer.readUint32();
                    break;
                case logical_expression_common/* VariableNodeBinaryPropMarshallingMap */.Tf.End:
                    node.end = buffer.readUint32();
                    break;
                default:
                    throw new Error(`Invalid property: ${prop}`);
            }
            prop = buffer.readUint8();
        }
    }
    /**
     * Deserializes a parenthesis node from binary format.
     *
     * @param buffer ByteBuffer for reading binary data.
     * @param node Destination node.
     * @throws If the binary data is malformed.
     */
    static deserializeParenthesisNode(buffer, node) {
        buffer.assertUint8(binary_type_common/* BinaryTypeMarshallingMap */.u.ExpressionParenthesisNode);
        node.type = logical_expression_serializer/* NodeType */.Z.Parenthesis;
        let prop = buffer.readUint8();
        while (prop !== constants/* NULL */.Cq) {
            switch (prop) {
                case logical_expression_common/* ParenthesisNodeBinaryPropMarshallingMap */.z0.Expression:
                    LogicalExpressionDeserializer.deserialize(buffer, node.expression = {});
                    break;
                case logical_expression_common/* ParenthesisNodeBinaryPropMarshallingMap */.z0.Start:
                    node.start = buffer.readUint32();
                    break;
                case logical_expression_common/* ParenthesisNodeBinaryPropMarshallingMap */.z0.End:
                    node.end = buffer.readUint32();
                    break;
                default:
                    throw new Error(`Invalid property: ${prop}`);
            }
            prop = buffer.readUint8();
        }
    }
    /**
     * Deserializes an operator node from binary format.
     *
     * @param buffer ByteBuffer for reading binary data.
     * @param node Destination node.
     * @throws If the binary data is malformed.
     */
    static deserializeOperatorNode(buffer, node) {
        buffer.assertUint8(binary_type_common/* BinaryTypeMarshallingMap */.u.ExpressionOperatorNode);
        node.type = logical_expression_serializer/* NodeType */.Z.Operator;
        let prop = buffer.readUint8();
        while (prop !== constants/* NULL */.Cq) {
            switch (prop) {
                case logical_expression_common/* OperatorNodeBinaryPropMarshallingMap */.hc.Operator:
                    node.operator = getOperatorOrFail(buffer.readUint8());
                    break;
                case logical_expression_common/* OperatorNodeBinaryPropMarshallingMap */.hc.Left:
                    LogicalExpressionDeserializer.deserialize(buffer, node.left = {});
                    break;
                case logical_expression_common/* OperatorNodeBinaryPropMarshallingMap */.hc.Right:
                    LogicalExpressionDeserializer.deserialize(buffer, node.right = {});
                    break;
                case logical_expression_common/* OperatorNodeBinaryPropMarshallingMap */.hc.Start:
                    node.start = buffer.readUint32();
                    break;
                case logical_expression_common/* OperatorNodeBinaryPropMarshallingMap */.hc.End:
                    node.end = buffer.readUint32();
                    break;
                default:
                    throw new Error(`Invalid property: ${prop}`);
            }
            prop = buffer.readUint8();
        }
    }
    /**
     * Deserializes a logical expression node from binary format.
     *
     * @param buffer ByteBuffer for reading binary data.
     * @param node Destination node.
     * @throws If the binary data is malformed.
     */
    static deserialize(buffer, node) {
        // note: we just do a simple lookahead here, because advancing the buffer is done in the
        // 'sub-deserialize' methods
        let type = buffer.peekUint8();
        while (type !== constants/* NULL */.Cq) {
            switch (type) {
                case binary_type_common/* BinaryTypeMarshallingMap */.u.ExpressionVariableNode:
                    LogicalExpressionDeserializer.deserializeVariableNode(buffer, node);
                    break;
                case binary_type_common/* BinaryTypeMarshallingMap */.u.ExpressionOperatorNode:
                    LogicalExpressionDeserializer.deserializeOperatorNode(buffer, node);
                    break;
                case binary_type_common/* BinaryTypeMarshallingMap */.u.ExpressionParenthesisNode:
                    LogicalExpressionDeserializer.deserializeParenthesisNode(buffer, node);
                    break;
                default:
                    throw new Error(`Unexpected node type: ${type}`);
            }
            type = buffer.peekUint8();
        }
        // consume NULL
        buffer.readUint8();
    }
}



;// ./node_modules/.pnpm/@adguard+agtree@3.1.3/node_modules/@adguard/agtree/dist/deserializer/comment/pre-processor-comment-deserializer.js
/*
 * AGTree v3.1.3 (build date: Tue, 29 Apr 2025 12:25:03 GMT)
 * (c) 2025 Adguard Software Ltd.
 * Released under the MIT license
 * https://github.com/AdguardTeam/tsurlfilter/tree/master/packages/agtree#readme
 */











/* eslint-disable no-param-reassign */
/**
 * Value map for binary deserialization. This helps to reduce the size of the serialized data,
 * as it allows us to use a single byte to represent frequently used values.
 */
let frequentDirectivesDeserializationMap;
const getFrequentDirectivesDeserializationMap = () => {
    if (!frequentDirectivesDeserializationMap) {
        frequentDirectivesDeserializationMap = new Map(Array.from(pre_processor_comment_common/* FREQUENT_DIRECTIVES_SERIALIZATION_MAP */.u_).map(([key, value]) => [value, key]));
    }
    return frequentDirectivesDeserializationMap;
};
/**
 * Value map for binary deserialization. This helps to reduce the size of the serialized data,
 * as it allows us to use a single byte to represent frequently used values.
 */
let frequentParamsDeserializationMap;
const getFrequentParamsDeserializationMap = () => {
    if (!frequentParamsDeserializationMap) {
        frequentParamsDeserializationMap = new Map(Array.from(pre_processor_comment_common/* FREQUENT_PARAMS_SERIALIZATION_MAP */.k7).map(([key, value]) => [value, key]));
    }
    return frequentParamsDeserializationMap;
};
/**
 * `PreProcessorCommentDeserializer` is responsible for deserializing preprocessor rules.
 * Pre-processor comments are special comments that are used to control the behavior of the filter list processor.
 * Please note that this parser only handles general syntax for now, and does not validate the parameters at
 * the parsing stage.
 *
 * @example
 * If your rule is
 * ```adblock
 * !#if (adguard)
 * ```
 * then the directive's name is `if` and its value is `(adguard)`, but the parameter list
 * is not parsed / validated further.
 * @see {@link https://kb.adguard.com/en/general/how-to-create-your-own-ad-filters#pre-processor-directives}
 * @see {@link https://github.com/gorhill/uBlock/wiki/Static-filter-syntax#pre-parsing-directives}
 */
class PreProcessorCommentDeserializer extends BaseDeserializer {
    /**
     * Deserializes a pre-processor comment node from binary format.
     *
     * @param buffer ByteBuffer for reading binary data.
     * @param node Destination node.
     * @throws If the binary data is malformed.
     */
    static deserialize(buffer, node) {
        buffer.assertUint8(binary_type_common/* BinaryTypeMarshallingMap */.u.PreProcessorCommentRuleNode);
        node.type = nodes/* CommentRuleType */.gV.PreProcessorCommentRule;
        node.category = nodes/* RuleCategory */.$O.Comment;
        node.syntax = adblockers/* AdblockSyntax */.Y.Common;
        let prop = buffer.readUint8();
        while (prop !== constants/* NULL */.Cq) {
            switch (prop) {
                case pre_processor_comment_common/* PreProcessorRuleMarshallingMap */.Qz.Name:
                    // eslint-disable-next-line max-len
                    ValueDeserializer.deserialize(buffer, node.name = {}, getFrequentDirectivesDeserializationMap());
                    break;
                case pre_processor_comment_common/* PreProcessorRuleMarshallingMap */.Qz.Syntax:
                    node.syntax = getSyntaxDeserializationMap().get(buffer.readUint8()) ?? adblockers/* AdblockSyntax */.Y.Common;
                    break;
                case pre_processor_comment_common/* PreProcessorRuleMarshallingMap */.Qz.Params:
                    switch (buffer.peekUint8()) {
                        case binary_type_common/* BinaryTypeMarshallingMap */.u.ValueNode:
                            ValueDeserializer.deserialize(buffer, node.params = {});
                            break;
                        case binary_type_common/* BinaryTypeMarshallingMap */.u.ParameterListNode:
                            // eslint-disable-next-line max-len
                            ParameterListDeserializer.deserialize(buffer, node.params = {}, getFrequentParamsDeserializationMap());
                            break;
                        case binary_type_common/* BinaryTypeMarshallingMap */.u.ExpressionOperatorNode:
                        case binary_type_common/* BinaryTypeMarshallingMap */.u.ExpressionParenthesisNode:
                        case binary_type_common/* BinaryTypeMarshallingMap */.u.ExpressionVariableNode:
                            LogicalExpressionDeserializer.deserialize(buffer, node.params = {});
                            break;
                        default:
                            throw new Error(`Invalid binary type: ${prop}`);
                    }
                    break;
                case pre_processor_comment_common/* PreProcessorRuleMarshallingMap */.Qz.Start:
                    node.start = buffer.readUint32();
                    break;
                case pre_processor_comment_common/* PreProcessorRuleMarshallingMap */.Qz.End:
                    node.end = buffer.readUint32();
                    break;
                default:
                    throw new Error(`Invalid property: ${prop}`);
            }
            prop = buffer.readUint8();
        }
    }
}



// EXTERNAL MODULE: ./node_modules/.pnpm/@adguard+agtree@3.1.3/node_modules/@adguard/agtree/dist/marshalling-utils/comment/simple-comment-common.js
var simple_comment_common = __webpack_require__(94807);
;// ./node_modules/.pnpm/@adguard+agtree@3.1.3/node_modules/@adguard/agtree/dist/deserializer/comment/simple-comment-deserializer.js
/*
 * AGTree v3.1.3 (build date: Tue, 29 Apr 2025 12:25:03 GMT)
 * (c) 2025 Adguard Software Ltd.
 * Released under the MIT license
 * https://github.com/AdguardTeam/tsurlfilter/tree/master/packages/agtree#readme
 */








/* eslint-disable no-param-reassign */
/**
 * `SimpleCommentDeserializer` is responsible for deserializing simple comments.
 *
 * Some comments have a special meaning in adblock syntax, like agent comments or hints,
 * but this parser is only responsible for parsing regular comments,
 * whose only purpose is to provide some human-readable information.
 *
 * @example
 * ```adblock
 * ! This is a simple comment
 * # This is a simple comment, but in host-like syntax
 * ```
 */
class SimpleCommentDeserializer extends BaseDeserializer {
    /**
     * Deserializes a simple comment node from binary format.
     *
     * @param buffer ByteBuffer for reading binary data.
     * @param node Destination node.
     * @throws If the binary data is malformed.
     */
    static deserialize(buffer, node) {
        buffer.assertUint8(binary_type_common/* BinaryTypeMarshallingMap */.u.CommentRuleNode);
        node.type = nodes/* CommentRuleType */.gV.CommentRule;
        node.category = nodes/* RuleCategory */.$O.Comment;
        node.syntax = adblockers/* AdblockSyntax */.Y.Common;
        let prop = buffer.readUint8();
        while (prop !== constants/* NULL */.Cq) {
            switch (prop) {
                case simple_comment_common/* SimpleCommentMarshallingMap */.i.Marker:
                    ValueDeserializer.deserialize(buffer, node.marker = {});
                    break;
                case simple_comment_common/* SimpleCommentMarshallingMap */.i.Text:
                    ValueDeserializer.deserialize(buffer, node.text = {});
                    break;
                case simple_comment_common/* SimpleCommentMarshallingMap */.i.Start:
                    node.start = buffer.readUint32();
                    break;
                case simple_comment_common/* SimpleCommentMarshallingMap */.i.End:
                    node.end = buffer.readUint32();
                    break;
                default:
                    throw new Error(`Invalid property: ${prop}`);
            }
            prop = buffer.readUint8();
        }
    }
}



;// ./node_modules/.pnpm/@adguard+agtree@3.1.3/node_modules/@adguard/agtree/dist/deserializer/comment/comment-rule-deserializer.js
/*
 * AGTree v3.1.3 (build date: Tue, 29 Apr 2025 12:25:03 GMT)
 * (c) 2025 Adguard Software Ltd.
 * Released under the MIT license
 * https://github.com/AdguardTeam/tsurlfilter/tree/master/packages/agtree#readme
 */









/**
 * `CommentRuleDeserializer` is responsible for deserializing any comment-like adblock rules.
 */
class CommentRuleDeserializer extends BaseDeserializer {
    /**
     * Deserializes a comment rule node from binary format.
     *
     * @param buffer ByteBuffer for reading binary data.
     * @param node Destination node.
     * @throws If the binary data is malformed.
     */
    static deserialize(buffer, node) {
        const type = buffer.peekUint8();
        switch (type) {
            case binary_type_common/* BinaryTypeMarshallingMap */.u.AgentRuleNode:
                AgentCommentDeserializer.deserialize(buffer, node);
                return;
            case binary_type_common/* BinaryTypeMarshallingMap */.u.HintRuleNode:
                HintCommentDeserializer.deserialize(buffer, node);
                return;
            case binary_type_common/* BinaryTypeMarshallingMap */.u.PreProcessorCommentRuleNode:
                PreProcessorCommentDeserializer.deserialize(buffer, node);
                return;
            case binary_type_common/* BinaryTypeMarshallingMap */.u.MetadataCommentRuleNode:
                MetadataCommentDeserializer.deserialize(buffer, node);
                return;
            case binary_type_common/* BinaryTypeMarshallingMap */.u.ConfigCommentRuleNode:
                ConfigCommentDeserializer.deserialize(buffer, node);
                return;
            case binary_type_common/* BinaryTypeMarshallingMap */.u.CommentRuleNode:
                SimpleCommentDeserializer.deserialize(buffer, node);
                return;
            default:
                throw new Error(`Unknown comment rule type: ${type}`);
        }
    }
}



// EXTERNAL MODULE: ./node_modules/.pnpm/@adguard+agtree@3.1.3/node_modules/@adguard/agtree/dist/marshalling-utils/misc/domain-list-common.js
var domain_list_common = __webpack_require__(53967);
// EXTERNAL MODULE: ./node_modules/.pnpm/@adguard+agtree@3.1.3/node_modules/@adguard/agtree/dist/marshalling-utils/misc/list-item-common.js
var list_item_common = __webpack_require__(4402);
;// ./node_modules/.pnpm/@adguard+agtree@3.1.3/node_modules/@adguard/agtree/dist/deserializer/misc/list-item-deserializer.js
/*
 * AGTree v3.1.3 (build date: Tue, 29 Apr 2025 12:25:03 GMT)
 * (c) 2025 Adguard Software Ltd.
 * Released under the MIT license
 * https://github.com/AdguardTeam/tsurlfilter/tree/master/packages/agtree#readme
 */






/* eslint-disable no-param-reassign */
/**
 * `ListItemDeserializer` is responsible for deserializing list item nodes from binary format.
 *
 * @example
 * `app`, `domain`, `method`, `stealth-option`
 */
class ListItemDeserializer extends BaseDeserializer {
    /**
     * Deserializes a list item from binary format.
     *
     * @param buffer Input byte buffer.
     * @param node Partial list item to deserialize.
     * @template T Type of the list item.
     */
    static deserialize = (buffer, node) => {
        const type = buffer.readUint8();
        switch (type) {
            case binary_type_common/* BinaryTypeMarshallingMap */.u.AppNode:
                node.type = nodes/* ListItemNodeType */.WR.App;
                break;
            case binary_type_common/* BinaryTypeMarshallingMap */.u.DomainNode:
                node.type = nodes/* ListItemNodeType */.WR.Domain;
                break;
            case binary_type_common/* BinaryTypeMarshallingMap */.u.MethodNode:
                node.type = nodes/* ListItemNodeType */.WR.Method;
                break;
            case binary_type_common/* BinaryTypeMarshallingMap */.u.StealthOptionNode:
                node.type = nodes/* ListItemNodeType */.WR.StealthOption;
                break;
            default:
                throw new Error(`Invalid list item type: ${type}`);
        }
        let prop = buffer.readUint8();
        while (prop !== constants/* NULL */.Cq) {
            switch (prop) {
                case list_item_common/* ListItemMarshallingMap */.i.Exception:
                    node.exception = buffer.readUint8() === 1;
                    break;
                case list_item_common/* ListItemMarshallingMap */.i.Value:
                    node.value = buffer.readString();
                    break;
                case list_item_common/* ListItemMarshallingMap */.i.Start:
                    node.start = buffer.readUint32();
                    break;
                case list_item_common/* ListItemMarshallingMap */.i.End:
                    node.end = buffer.readUint32();
                    break;
                default:
                    throw new Error(`Invalid property: ${type}`);
            }
            prop = buffer.readUint8();
        }
    };
}



;// ./node_modules/.pnpm/@adguard+agtree@3.1.3/node_modules/@adguard/agtree/dist/deserializer/misc/list-items-deserializer.js
/*
 * AGTree v3.1.3 (build date: Tue, 29 Apr 2025 12:25:03 GMT)
 * (c) 2025 Adguard Software Ltd.
 * Released under the MIT license
 * https://github.com/AdguardTeam/tsurlfilter/tree/master/packages/agtree#readme
 */


/**
 * Deserializes lists of items from binary format.
 * Converts binary data to structured item nodes.
 */
class ListItemsDeserializer {
    /**
     * Deserializes a list of items from binary format.
     *
     * @param buffer Input byte buffer.
     * @param items Partial list of items to deserialize.
     * @template T Type of the list items.
     */
    static deserialize = (buffer, items) => {
        const length = buffer.readUint16();
        items.length = length;
        for (let i = 0; i < length; i += 1) {
            ListItemDeserializer.deserialize(buffer, items[i] = {});
        }
    };
}



;// ./node_modules/.pnpm/@adguard+agtree@3.1.3/node_modules/@adguard/agtree/dist/deserializer/misc/domain-list-deserializer.js
/*
 * AGTree v3.1.3 (build date: Tue, 29 Apr 2025 12:25:03 GMT)
 * (c) 2025 Adguard Software Ltd.
 * Released under the MIT license
 * https://github.com/AdguardTeam/tsurlfilter/tree/master/packages/agtree#readme
 */







/* eslint-disable no-param-reassign */
/**
 * Value map for binary deserialization. This helps to reduce the size of the serialized data,
 * as it allows us to use a single byte to represent frequently used values.
 */
let separatorDeserializationMap;
const getSeparatorDeserializationMap = () => {
    if (!separatorDeserializationMap) {
        separatorDeserializationMap = new Map(Array.from(domain_list_common/* SEPARATOR_SERIALIZATION_MAP */._)
            .map(([key, value]) => [value, key]));
    }
    return separatorDeserializationMap;
};
/**
 * `DomainListDeserializer` is responsible for deserializing a domain list.
 */
class DomainListDeserializer extends BaseDeserializer {
    /**
     * Deserializes a modifier list node from binary format.
     *
     * @param buffer ByteBuffer for reading binary data.
     * @param node Destination node.
     */
    static deserialize(buffer, node) {
        buffer.assertUint8(binary_type_common/* BinaryTypeMarshallingMap */.u.DomainListNode);
        node.type = nodes/* ListNodeType */.h6.DomainList;
        let prop = buffer.readUint8();
        while (prop !== constants/* NULL */.Cq) {
            switch (prop) {
                case domain_list_common/* DomainListMarshallingMap */.T.Separator:
                    // eslint-disable-next-line max-len
                    node.separator = (getSeparatorDeserializationMap().get(buffer.readUint8()) ?? constants/* COMMA */.KE);
                    break;
                case domain_list_common/* DomainListMarshallingMap */.T.Children:
                    ListItemsDeserializer.deserialize(buffer, node.children = []);
                    break;
                case domain_list_common/* DomainListMarshallingMap */.T.Start:
                    node.start = buffer.readUint32();
                    break;
                case domain_list_common/* DomainListMarshallingMap */.T.End:
                    node.end = buffer.readUint32();
                    break;
                default:
                    throw new Error(`Invalid property: ${prop}.`);
            }
            prop = buffer.readUint8();
        }
    }
}



// EXTERNAL MODULE: ./node_modules/.pnpm/@adguard+agtree@3.1.3/node_modules/@adguard/agtree/dist/marshalling-utils/cosmetic/body/abp-snippet-injection-body-common.js
var abp_snippet_injection_body_common = __webpack_require__(7552);
;// ./node_modules/.pnpm/@adguard+agtree@3.1.3/node_modules/@adguard/agtree/dist/deserializer/cosmetic/scriptlet-body/scriptlet-body-deserializer.js
/*
 * AGTree v3.1.3 (build date: Tue, 29 Apr 2025 12:25:03 GMT)
 * (c) 2025 Adguard Software Ltd.
 * Released under the MIT license
 * https://github.com/AdguardTeam/tsurlfilter/tree/master/packages/agtree#readme
 */






/**
 * Deserializes binary data into scriptlet body nodes.
 * Optionally uses a map of frequently used scriptlet arguments.
 */
class ScriptletBodyDeserializer extends BaseDeserializer {
    /**
     * Deserializes a hint rule node from binary format.
     *
     * @param buffer ByteBuffer for reading binary data.
     * @param node Destination node.
     * @param frequentScriptletArgs Map of frequently used scriptlet names / arguments
     * and their serialization index (optional).
     * @throws If the binary data is malformed.
     */
    static deserialize = (buffer, node, frequentScriptletArgs) => {
        buffer.assertUint8(binary_type_common/* BinaryTypeMarshallingMap */.u.ScriptletInjectionRuleBodyNode);
        node.type = 'ScriptletInjectionRuleBody';
        let prop = buffer.readUint8();
        while (prop !== constants/* NULL */.Cq) {
            switch (prop) {
                case abp_snippet_injection_body_common/* AbpSnippetBodyMarshallingMap */.f.Children:
                    node.children = new Array(buffer.readUint8());
                    // read children
                    for (let i = 0; i < node.children.length; i += 1) {
                        ParameterListDeserializer.deserialize(buffer, node.children[i] = {}, frequentScriptletArgs);
                    }
                    break;
                case abp_snippet_injection_body_common/* AbpSnippetBodyMarshallingMap */.f.Start:
                    node.start = buffer.readUint32();
                    break;
                case abp_snippet_injection_body_common/* AbpSnippetBodyMarshallingMap */.f.End:
                    node.end = buffer.readUint32();
                    break;
                default:
                    throw new Error(`Invalid property: ${prop}`);
            }
            prop = buffer.readUint8();
        }
    };
}



;// ./node_modules/.pnpm/@adguard+agtree@3.1.3/node_modules/@adguard/agtree/dist/deserializer/cosmetic/scriptlet-body/abp-snippet-injection-body-deserializer.js
/*
 * AGTree v3.1.3 (build date: Tue, 29 Apr 2025 12:25:03 GMT)
 * (c) 2025 Adguard Software Ltd.
 * Released under the MIT license
 * https://github.com/AdguardTeam/tsurlfilter/tree/master/packages/agtree#readme
 */




/**
 * Value map for binary deserialization. This helps to reduce the size of the serialized data,
 * as it allows us to use a single byte to represent frequently used values.
 */
let frequentAbpSnippetArgsDeserializationMap;
const getFrequentAbpSnippetArgsDeserializationMap = () => {
    if (!frequentAbpSnippetArgsDeserializationMap) {
        frequentAbpSnippetArgsDeserializationMap = new Map(Array.from(abp_snippet_injection_body_common/* FREQUENT_ABP_SNIPPET_ARGS_SERIALIZATION_MAP */.T).map(([key, value]) => [value, key]));
    }
    return frequentAbpSnippetArgsDeserializationMap;
};
/**
 * Deserializer for ABP snippet injection rule body nodes.
 * Converts binary data into a structured format using a map of frequently used arguments.
 */
class AbpSnippetInjectionBodyDeserializer extends BaseDeserializer {
    /**
     * Deserializes a scriptlet call body node from binary format.
     *
     * @param buffer ByteBuffer for reading binary data.
     * @param node Destination node.
     * @throws If the binary data is malformed.
     */
    static deserialize(buffer, node) {
        ScriptletBodyDeserializer.deserialize(buffer, node, getFrequentAbpSnippetArgsDeserializationMap());
    }
}



// EXTERNAL MODULE: ./node_modules/.pnpm/@adguard+agtree@3.1.3/node_modules/@adguard/agtree/dist/marshalling-utils/cosmetic/body/ubo-scriptlet-injection-body-common.js
var ubo_scriptlet_injection_body_common = __webpack_require__(26108);
;// ./node_modules/.pnpm/@adguard+agtree@3.1.3/node_modules/@adguard/agtree/dist/deserializer/cosmetic/scriptlet-body/ubo-scriptlet-injection-body-deserializer.js
/*
 * AGTree v3.1.3 (build date: Tue, 29 Apr 2025 12:25:03 GMT)
 * (c) 2025 Adguard Software Ltd.
 * Released under the MIT license
 * https://github.com/AdguardTeam/tsurlfilter/tree/master/packages/agtree#readme
 */




/**
 * Value map for binary deserialization. This helps to reduce the size of the serialized data,
 * as it allows us to use a single byte to represent frequently used values.
 */
let frequentUboScriptletArgsDeserializationMap;
const ubo_scriptlet_injection_body_deserializer_getFrequentPlatformsDeserializationMap = () => {
    if (!frequentUboScriptletArgsDeserializationMap) {
        frequentUboScriptletArgsDeserializationMap = new Map(Array.from(ubo_scriptlet_injection_body_common/* FREQUENT_UBO_SCRIPTLET_ARGS_SERIALIZATION_MAP */.Z).map(([key, value]) => [value, key]));
    }
    return frequentUboScriptletArgsDeserializationMap;
};
/**
 * Deserializes uBlock Origin scriptlet injection body nodes from binary data.
 */
class UboScriptletInjectionBodyDeserializer extends BaseDeserializer {
    /**
     * Deserializes a scriptlet call body node from binary format.
     *
     * @param buffer ByteBuffer for reading binary data.
     * @param node Destination node to populate with deserialized data.
     * @throws If the binary data is malformed.
     */
    static deserialize(buffer, node) {
        ScriptletBodyDeserializer.deserialize(buffer, node, ubo_scriptlet_injection_body_deserializer_getFrequentPlatformsDeserializationMap());
    }
}



// EXTERNAL MODULE: ./node_modules/.pnpm/@adguard+agtree@3.1.3/node_modules/@adguard/agtree/dist/marshalling-utils/cosmetic/body/adg-scriptlet-injection-body-common.js
var adg_scriptlet_injection_body_common = __webpack_require__(15078);
;// ./node_modules/.pnpm/@adguard+agtree@3.1.3/node_modules/@adguard/agtree/dist/deserializer/cosmetic/scriptlet-body/adg-scriptlet-injection-body-deserializer.js
/*
 * AGTree v3.1.3 (build date: Tue, 29 Apr 2025 12:25:03 GMT)
 * (c) 2025 Adguard Software Ltd.
 * Released under the MIT license
 * https://github.com/AdguardTeam/tsurlfilter/tree/master/packages/agtree#readme
 */




/**
 * Value map for binary deserialization. This helps to reduce the size of the serialized data,
 * as it allows us to use a single byte to represent frequently used values.
 */
let frequentAdgScriptletArgsDeserializationMap;
const getFrequentAdgScriptletArgsDeserializationMap = () => {
    if (!frequentAdgScriptletArgsDeserializationMap) {
        frequentAdgScriptletArgsDeserializationMap = new Map(Array.from(adg_scriptlet_injection_body_common/* FREQUENT_ADG_SCRIPTLET_ARGS_SERIALIZATION_MAP */.T).map(([key, value]) => [value, key]));
    }
    return frequentAdgScriptletArgsDeserializationMap;
};
/**
 * Deserializer for AdGuard scriptlet injection body nodes.
 * Converts binary data into a structured scriptlet call body node specific to AdGuard,
 * using a predefined deserialization map for frequently used scriptlet arguments.
 */
class AdgScriptletInjectionBodyDeserializer extends BaseDeserializer {
    /**
     * Deserializes a scriptlet call body node from binary format.
     *
     * @param buffer ByteBuffer for reading binary data.
     * @param node Destination node.
     * @throws If the binary data is malformed.
     */
    static deserialize(buffer, node) {
        ScriptletBodyDeserializer.deserialize(buffer, node, getFrequentAdgScriptletArgsDeserializationMap());
    }
}



// EXTERNAL MODULE: ./node_modules/.pnpm/@adguard+agtree@3.1.3/node_modules/@adguard/agtree/dist/marshalling-utils/cosmetic/body/element-hiding-body-common.js
var element_hiding_body_common = __webpack_require__(66335);
;// ./node_modules/.pnpm/@adguard+agtree@3.1.3/node_modules/@adguard/agtree/dist/deserializer/cosmetic/element-hiding-body-deserializer.js
/*
 * AGTree v3.1.3 (build date: Tue, 29 Apr 2025 12:25:03 GMT)
 * (c) 2025 Adguard Software Ltd.
 * Released under the MIT license
 * https://github.com/AdguardTeam/tsurlfilter/tree/master/packages/agtree#readme
 */






/* eslint-disable no-param-reassign */
/**
 * Deserializes element hiding rule body nodes from binary data.
 * Populates the provided node with the deserialized data.
 */
class ElementHidingBodyDeserializer extends BaseDeserializer {
    /**
     * Deserializes an element hiding rule body node from binary format.
     *
     * @param buffer ByteBuffer for reading binary data.
     * @param node Destination node.
     */
    static deserializeElementHidingBody(buffer, node) {
        buffer.assertUint8(binary_type_common/* BinaryTypeMarshallingMap */.u.ElementHidingRuleBody);
        node.type = 'ElementHidingRuleBody';
        let prop = buffer.readUint8();
        while (prop !== constants/* NULL */.Cq) {
            switch (prop) {
                case element_hiding_body_common/* ElementHidingRuleMarshallingMap */.G.SelectorList:
                    ValueDeserializer.deserialize(buffer, node.selectorList = {});
                    break;
                case element_hiding_body_common/* ElementHidingRuleMarshallingMap */.G.Start:
                    node.start = buffer.readUint32();
                    break;
                case element_hiding_body_common/* ElementHidingRuleMarshallingMap */.G.End:
                    node.end = buffer.readUint32();
                    break;
                default:
                    throw new Error(`Unknown property: ${prop}`);
            }
            prop = buffer.readUint8();
        }
    }
}



// EXTERNAL MODULE: ./node_modules/.pnpm/@adguard+agtree@3.1.3/node_modules/@adguard/agtree/dist/marshalling-utils/cosmetic/body/css-injection-body-common.js
var css_injection_body_common = __webpack_require__(38950);
;// ./node_modules/.pnpm/@adguard+agtree@3.1.3/node_modules/@adguard/agtree/dist/deserializer/cosmetic/css-injection-body-deserializer.js
/*
 * AGTree v3.1.3 (build date: Tue, 29 Apr 2025 12:25:03 GMT)
 * (c) 2025 Adguard Software Ltd.
 * Released under the MIT license
 * https://github.com/AdguardTeam/tsurlfilter/tree/master/packages/agtree#readme
 */






/**
 * Deserializes CSS injection rule body nodes from binary format.
 */
class CssInjectionBodyDeserializer extends BaseDeserializer {
    /**
     * Deserializes CSS injection rule body node from binary format.
     *
     * @param buffer ByteBuffer for reading binary data.
     * @param node Destination node.
     */
    static deserialize(buffer, node) {
        buffer.assertUint8(binary_type_common/* BinaryTypeMarshallingMap */.u.CssInjectionRuleBody);
        node.type = 'CssInjectionRuleBody';
        node.remove = false;
        let prop = buffer.readUint8();
        while (prop !== constants/* NULL */.Cq) {
            switch (prop) {
                case css_injection_body_common/* CssInjectionRuleMarshallingMap */.V.MediaQueryList:
                    ValueDeserializer.deserialize(buffer, node.mediaQueryList = {});
                    break;
                case css_injection_body_common/* CssInjectionRuleMarshallingMap */.V.SelectorList:
                    ValueDeserializer.deserialize(buffer, node.selectorList = {});
                    break;
                case css_injection_body_common/* CssInjectionRuleMarshallingMap */.V.DeclarationList:
                    ValueDeserializer.deserialize(buffer, node.declarationList = {});
                    break;
                case css_injection_body_common/* CssInjectionRuleMarshallingMap */.V.Remove:
                    node.remove = true;
                    break;
                case css_injection_body_common/* CssInjectionRuleMarshallingMap */.V.Start:
                    node.start = buffer.readUint32();
                    break;
                case css_injection_body_common/* CssInjectionRuleMarshallingMap */.V.End:
                    node.end = buffer.readUint32();
                    break;
                default:
                    throw new Error(`Unknown property: ${prop}`);
            }
            prop = buffer.readUint8();
        }
    }
}



// EXTERNAL MODULE: ./node_modules/.pnpm/@adguard+agtree@3.1.3/node_modules/@adguard/agtree/dist/marshalling-utils/misc/modifier-common.js
var modifier_common = __webpack_require__(42471);
;// ./node_modules/.pnpm/@adguard+agtree@3.1.3/node_modules/@adguard/agtree/dist/deserializer/misc/modifier-deserializer.js
/*
 * AGTree v3.1.3 (build date: Tue, 29 Apr 2025 12:25:03 GMT)
 * (c) 2025 Adguard Software Ltd.
 * Released under the MIT license
 * https://github.com/AdguardTeam/tsurlfilter/tree/master/packages/agtree#readme
 */






/* eslint-disable no-param-reassign */
/**
 * Value map for binary deserialization. This helps to reduce the size of the serialized data,
 * as it allows us to use a single byte to represent frequently used values.
 *
 * @note Only 256 values can be represented this way.
 */
let frequentModifiersDeserializationMap;
const getFrequentModifiersDeserializationMap = () => {
    if (!frequentModifiersDeserializationMap) {
        frequentModifiersDeserializationMap = new Map(Array.from(modifier_common/* FREQUENT_MODIFIERS_SERIALIZATION_MAP */.uu).map(([key, value]) => [value, key]));
    }
    return frequentModifiersDeserializationMap;
};
/**
 * Value map for binary deserialization. This helps to reduce the size of the serialized data,
 * as it allows us to use a single byte to represent frequently used values.
 */
let frequentValuesDeserializationMaps;
const getFrequentValuesDeserializationMaps = () => {
    if (!frequentValuesDeserializationMaps) {
        frequentValuesDeserializationMaps = new Map(Array.from(modifier_common/* FREQUENT_REDIRECT_MODIFIERS_SERIALIZATION_MAP */.vG, ([modifier, valueMap]) => [modifier, new Map(Array.from(valueMap, ([key, value]) => [value, key]))]));
    }
    return frequentValuesDeserializationMaps;
};
/**
 * `ModifierDeserializer` is responsible for deserializing modifiers.
 *
 * @example
 * `match-case`, `~third-party`, `domain=example.com|~example.org`
 */
class ModifierDeserializer extends BaseDeserializer {
    /**
     * Deserializes a modifier node from binary format.
     *
     * @param buffer ByteBuffer for reading binary data.
     * @param node Destination node.
     */
    static deserialize(buffer, node) {
        buffer.assertUint8(binary_type_common/* BinaryTypeMarshallingMap */.u.ModifierNode);
        node.type = 'Modifier';
        let prop = buffer.readUint8();
        while (prop !== constants/* NULL */.Cq) {
            switch (prop) {
                case modifier_common/* ModifierNodeMarshallingMap */.sD.Name:
                    // eslint-disable-next-line max-len
                    ValueDeserializer.deserialize(buffer, node.name = {}, getFrequentModifiersDeserializationMap());
                    break;
                case modifier_common/* ModifierNodeMarshallingMap */.sD.Value:
                    if (node.name) {
                        // eslint-disable-next-line max-len
                        ValueDeserializer.deserialize(buffer, node.value = {}, getFrequentValuesDeserializationMaps().get(node.name.value));
                    }
                    else {
                        ValueDeserializer.deserialize(buffer, node.value = {});
                    }
                    break;
                case modifier_common/* ModifierNodeMarshallingMap */.sD.Exception:
                    node.exception = buffer.readUint8() === 1;
                    break;
                case modifier_common/* ModifierNodeMarshallingMap */.sD.Start:
                    node.start = buffer.readUint32();
                    break;
                case modifier_common/* ModifierNodeMarshallingMap */.sD.End:
                    node.end = buffer.readUint32();
                    break;
                default:
                    throw new Error(`Invalid property: ${prop}.`);
            }
            prop = buffer.readUint8();
        }
    }
}



// EXTERNAL MODULE: ./node_modules/.pnpm/@adguard+agtree@3.1.3/node_modules/@adguard/agtree/dist/marshalling-utils/misc/modifier-list-common.js
var modifier_list_common = __webpack_require__(26882);
;// ./node_modules/.pnpm/@adguard+agtree@3.1.3/node_modules/@adguard/agtree/dist/deserializer/misc/modifier-list-deserializer.js
/*
 * AGTree v3.1.3 (build date: Tue, 29 Apr 2025 12:25:03 GMT)
 * (c) 2025 Adguard Software Ltd.
 * Released under the MIT license
 * https://github.com/AdguardTeam/tsurlfilter/tree/master/packages/agtree#readme
 */






/* eslint-disable no-param-reassign */
/**
 * `ModifierListDeserializer` is responsible for deserializing modifier lists. Please note that the name is not
 * uniform, "modifiers" are also known as "options".
 *
 * @see {@link https://kb.adguard.com/en/general/how-to-create-your-own-ad-filters#basic-rules-modifiers}
 * @see {@link https://kb.adguard.com/en/general/how-to-create-your-own-ad-filters#non-basic-rules-modifiers}
 * @see {@link https://help.eyeo.com/adblockplus/how-to-write-filters#options}
 */
class ModifierListDeserializer extends BaseDeserializer {
    /**
     * Deserializes a modifier list node from binary format.
     *
     * @param buffer ByteBuffer for reading binary data.
     * @param node Destination node.
     */
    static deserialize(buffer, node) {
        buffer.assertUint8(binary_type_common/* BinaryTypeMarshallingMap */.u.ModifierListNode);
        node.type = 'ModifierList';
        let prop = buffer.readUint8();
        while (prop !== constants/* NULL */.Cq) {
            switch (prop) {
                case modifier_list_common/* ModifierListNodeMarshallingMap */.I.Children:
                    node.children = new Array(buffer.readUint16());
                    // read children
                    for (let i = 0; i < node.children.length; i += 1) {
                        ModifierDeserializer.deserialize(buffer, node.children[i] = {});
                    }
                    break;
                case modifier_list_common/* ModifierListNodeMarshallingMap */.I.Start:
                    node.start = buffer.readUint32();
                    break;
                case modifier_list_common/* ModifierListNodeMarshallingMap */.I.End:
                    node.end = buffer.readUint32();
                    break;
                default:
                    throw new Error(`Invalid property: ${prop}.`);
            }
            prop = buffer.readUint8();
        }
        // Maybe children are not present in the binary data,
        // in this case, we should initialize it as an empty array.
        if (!node.children) {
            node.children = [];
        }
    }
}



// EXTERNAL MODULE: ./node_modules/.pnpm/@adguard+agtree@3.1.3/node_modules/@adguard/agtree/dist/marshalling-utils/cosmetic/cosmetic-rule-common.js
var cosmetic_rule_common = __webpack_require__(51787);
;// ./node_modules/.pnpm/@adguard+agtree@3.1.3/node_modules/@adguard/agtree/dist/deserializer/cosmetic/cosmetic-rule-deserializer.js
/*
 * AGTree v3.1.3 (build date: Tue, 29 Apr 2025 12:25:03 GMT)
 * (c) 2025 Adguard Software Ltd.
 * Released under the MIT license
 * https://github.com/AdguardTeam/tsurlfilter/tree/master/packages/agtree#readme
 */

















/* eslint-disable no-param-reassign */
/**
 * Value map for binary deserialization. This helps to reduce the size of the serialized data,
 * as it allows us to use a single byte to represent frequently used values.
 */
let cosmeticRuleSeparatorDeserializationMap;
const getCosmeticRuleSeparatorDeserializationMap = () => {
    if (!cosmeticRuleSeparatorDeserializationMap) {
        cosmeticRuleSeparatorDeserializationMap = new Map(Array.from(cosmetic_rule_common/* COSMETIC_RULE_SEPARATOR_SERIALIZATION_MAP */.h).map(([key, value]) => [value, key]));
    }
    return cosmeticRuleSeparatorDeserializationMap;
};
/**
 * Value map for binary deserialization. This helps to reduce the size of the serialized data,
 * as it allows us to use a single byte to represent frequently used values.
 */
const COSMETIC_RULE_TYPE_DESERIALIZATION_MAP = new Map([
    [binary_type_common/* BinaryTypeMarshallingMap */.u.ElementHidingRule, nodes/* CosmeticRuleType */.k9.ElementHidingRule],
    [binary_type_common/* BinaryTypeMarshallingMap */.u.CssInjectionRule, nodes/* CosmeticRuleType */.k9.CssInjectionRule],
    [binary_type_common/* BinaryTypeMarshallingMap */.u.ScriptletInjectionRule, nodes/* CosmeticRuleType */.k9.ScriptletInjectionRule],
    [binary_type_common/* BinaryTypeMarshallingMap */.u.JsInjectionRule, nodes/* CosmeticRuleType */.k9.JsInjectionRule],
    [binary_type_common/* BinaryTypeMarshallingMap */.u.HtmlFilteringRule, nodes/* CosmeticRuleType */.k9.HtmlFilteringRule],
]);
/**
 * Deserializer for cosmetic rules.
 * Converts binary data into structured cosmetic rule nodes, supporting various types
 * like element hiding, CSS injection, scriptlet injection, JavaScript injection, and HTML filtering.
 * Handles rule type, syntax, exceptions, separators, modifiers, and domain lists.
 */
class CosmeticRuleDeserializer extends BaseDeserializer {
    /**
     * Deserializes a cosmetic rule node from binary format.
     *
     * @param buffer ByteBuffer for reading binary data.
     * @param node Destination node.
     */
    static deserialize(buffer, node) {
        const type = COSMETIC_RULE_TYPE_DESERIALIZATION_MAP.get(buffer.readUint8());
        if ((0,type_guards/* isUndefined */.b0)(type)) {
            throw new Error(`Unknown rule type: ${type}`);
        }
        node.type = type;
        node.category = nodes/* RuleCategory */.$O.Cosmetic;
        const syntax = getSyntaxDeserializationMap().get(buffer.readUint8()) ?? adblockers/* AdblockSyntax */.Y.Common;
        node.syntax = syntax;
        node.modifiers = undefined;
        switch (type) {
            case nodes/* CosmeticRuleType */.k9.ElementHidingRule:
                ElementHidingBodyDeserializer.deserializeElementHidingBody(buffer, node.body = {});
                break;
            case nodes/* CosmeticRuleType */.k9.CssInjectionRule:
                CssInjectionBodyDeserializer.deserialize(buffer, node.body = {});
                break;
            case nodes/* CosmeticRuleType */.k9.JsInjectionRule:
                ValueDeserializer.deserialize(buffer, node.body = {});
                break;
            case nodes/* CosmeticRuleType */.k9.HtmlFilteringRule:
                ValueDeserializer.deserialize(buffer, node.body = {});
                break;
            case nodes/* CosmeticRuleType */.k9.ScriptletInjectionRule:
                switch (syntax) {
                    case adblockers/* AdblockSyntax */.Y.Adg:
                        AdgScriptletInjectionBodyDeserializer.deserialize(buffer, node.body = {});
                        break;
                    case adblockers/* AdblockSyntax */.Y.Abp:
                        AbpSnippetInjectionBodyDeserializer.deserialize(buffer, node.body = {});
                        break;
                    case adblockers/* AdblockSyntax */.Y.Ubo:
                        UboScriptletInjectionBodyDeserializer.deserialize(buffer, node.body = {});
                        break;
                    default:
                        throw new Error('Scriptlet rule should have an explicit syntax');
                }
                break;
            default:
                throw new Error('Unknown cosmetic rule type');
        }
        let prop = buffer.readUint8();
        while (prop !== constants/* NULL */.Cq) {
            switch (prop) {
                case cosmetic_rule_common/* CosmeticRuleMarshallingMap */.U.Exception:
                    node.exception = buffer.readUint8() === 1;
                    break;
                case cosmetic_rule_common/* CosmeticRuleMarshallingMap */.U.Separator:
                    ValueDeserializer.deserialize(buffer, node.separator = {}, getCosmeticRuleSeparatorDeserializationMap());
                    break;
                case cosmetic_rule_common/* CosmeticRuleMarshallingMap */.U.Modifiers:
                    node.modifiers = {};
                    ModifierListDeserializer.deserialize(buffer, node.modifiers);
                    break;
                case cosmetic_rule_common/* CosmeticRuleMarshallingMap */.U.Domains:
                    DomainListDeserializer.deserialize(buffer, node.domains = {});
                    break;
                case cosmetic_rule_common/* CosmeticRuleMarshallingMap */.U.Start:
                    node.start = buffer.readUint32();
                    break;
                case cosmetic_rule_common/* CosmeticRuleMarshallingMap */.U.End:
                    node.end = buffer.readUint32();
                    break;
                default:
                    throw new Error(`Unknown property: ${prop}`);
            }
            prop = buffer.readUint8();
        }
    }
}



// EXTERNAL MODULE: ./node_modules/.pnpm/@adguard+agtree@3.1.3/node_modules/@adguard/agtree/dist/marshalling-utils/misc/hostname-list-common.js
var hostname_list_common = __webpack_require__(28894);
;// ./node_modules/.pnpm/@adguard+agtree@3.1.3/node_modules/@adguard/agtree/dist/deserializer/network/hostname-list-deserializer.js
/*
 * AGTree v3.1.3 (build date: Tue, 29 Apr 2025 12:25:03 GMT)
 * (c) 2025 Adguard Software Ltd.
 * Released under the MIT license
 * https://github.com/AdguardTeam/tsurlfilter/tree/master/packages/agtree#readme
 */






/* eslint-disable no-param-reassign */
/**
 * Deserializes hostname list nodes from binary format.
 */
class HostnameListDeserializer extends BaseDeserializer {
    /**
     * Deserializes a hostname list node from binary format.
     *
     * @param buffer ByteBuffer for reading binary data.
     * @param node Destination node.
     */
    static deserialize(buffer, node) {
        buffer.assertUint8(binary_type_common/* BinaryTypeMarshallingMap */.u.HostnameListNode);
        node.type = 'HostnameList';
        let prop = buffer.readUint8();
        while (prop !== constants/* NULL */.Cq) {
            switch (prop) {
                case hostname_list_common/* HostnameListNodeMarshallingMap */.W.Children:
                    node.children = new Array(buffer.readUint16());
                    // read children
                    for (let i = 0; i < node.children.length; i += 1) {
                        ValueDeserializer.deserialize(buffer, node.children[i] = {});
                    }
                    break;
                case hostname_list_common/* HostnameListNodeMarshallingMap */.W.Start:
                    node.start = buffer.readUint32();
                    break;
                case hostname_list_common/* HostnameListNodeMarshallingMap */.W.End:
                    node.end = buffer.readUint32();
                    break;
                default:
                    throw new Error(`Unknown property: ${prop}`);
            }
            prop = buffer.readUint8();
        }
        // Maybe children are not present in the binary data,
        // in this case, we should initialize it as an empty array.
        if (!node.children) {
            node.children = [];
        }
    }
}



// EXTERNAL MODULE: ./node_modules/.pnpm/@adguard+agtree@3.1.3/node_modules/@adguard/agtree/dist/marshalling-utils/misc/host-rule-common.js
var host_rule_common = __webpack_require__(49107);
;// ./node_modules/.pnpm/@adguard+agtree@3.1.3/node_modules/@adguard/agtree/dist/deserializer/network/host-rule-deserializer.js
/*
 * AGTree v3.1.3 (build date: Tue, 29 Apr 2025 12:25:03 GMT)
 * (c) 2025 Adguard Software Ltd.
 * Released under the MIT license
 * https://github.com/AdguardTeam/tsurlfilter/tree/master/packages/agtree#readme
 */










/* eslint-disable no-param-reassign */
/**
 * `HostRuleDeserializer` is responsible for deserializing hosts-like rules.
 *
 * HostRule is a structure for simple host-level rules (i.e. /etc/hosts syntax).
 * It also supports "just domain" syntax. In this case, the IP will be set to 0.0.0.0.
 */
class HostRuleDeserializer extends BaseDeserializer {
    /**
     * Deserializes a host rule node from binary format.
     *
     * @param buffer Input byte buffer to read from.
     * @param node Destination node to write to.
     */
    static deserialize(buffer, node) {
        buffer.assertUint8(binary_type_common/* BinaryTypeMarshallingMap */.u.HostRuleNode);
        node.category = nodes/* RuleCategory */.$O.Network;
        node.type = nodes/* NetworkRuleType */.vY.HostRule;
        let prop = buffer.readUint8();
        while (prop !== constants/* NULL */.Cq) {
            switch (prop) {
                case host_rule_common/* HostRuleMarshallingMap */.J.Syntax:
                    node.syntax = getSyntaxDeserializationMap().get(buffer.readUint8()) ?? adblockers/* AdblockSyntax */.Y.Common;
                    break;
                case host_rule_common/* HostRuleMarshallingMap */.J.Ip:
                    node.ip = {};
                    ValueDeserializer.deserialize(buffer, node.ip);
                    break;
                case host_rule_common/* HostRuleMarshallingMap */.J.HostnameList:
                    node.hostnames = {};
                    HostnameListDeserializer.deserialize(buffer, node.hostnames);
                    break;
                case host_rule_common/* HostRuleMarshallingMap */.J.Comment:
                    node.comment = {};
                    ValueDeserializer.deserialize(buffer, node.comment);
                    break;
                case host_rule_common/* HostRuleMarshallingMap */.J.Start:
                    node.start = buffer.readUint32();
                    break;
                case host_rule_common/* HostRuleMarshallingMap */.J.End:
                    node.end = buffer.readUint32();
                    break;
                default:
                    throw new Error(`Invalid property: ${prop}.`);
            }
            prop = buffer.readUint8();
        }
    }
}



// EXTERNAL MODULE: ./node_modules/.pnpm/@adguard+agtree@3.1.3/node_modules/@adguard/agtree/dist/marshalling-utils/network/network-rule-common.js
var network_rule_common = __webpack_require__(1447);
;// ./node_modules/.pnpm/@adguard+agtree@3.1.3/node_modules/@adguard/agtree/dist/deserializer/network/network-rule-deserializer.js
/*
 * AGTree v3.1.3 (build date: Tue, 29 Apr 2025 12:25:03 GMT)
 * (c) 2025 Adguard Software Ltd.
 * Released under the MIT license
 * https://github.com/AdguardTeam/tsurlfilter/tree/master/packages/agtree#readme
 */










/* eslint-disable no-param-reassign */
/**
 * `NetworkRuleDeserializer` is responsible for deserializing network rules.
 *
 * @see {@link https://kb.adguard.com/en/general/how-to-create-your-own-ad-filters#basic-rules}
 * @see {@link https://help.eyeo.com/adblockplus/how-to-write-filters#basic}
 */
class NetworkRuleDeserializer extends BaseDeserializer {
    /**
     * Deserializes a network rule node from binary format.
     *
     * @param buffer ByteBuffer for reading binary data.
     * @param node Destination node.
     */
    static deserialize(buffer, node) {
        buffer.assertUint8(binary_type_common/* BinaryTypeMarshallingMap */.u.NetworkRuleNode);
        node.type = nodes/* NetworkRuleType */.vY.NetworkRule;
        node.category = nodes/* RuleCategory */.$O.Network;
        node.modifiers = undefined;
        let prop = buffer.readUint8();
        while (prop !== constants/* NULL */.Cq) {
            switch (prop) {
                case network_rule_common/* NetworkRuleMarshallingMap */.v.Syntax:
                    node.syntax = getSyntaxDeserializationMap().get(buffer.readUint8()) ?? adblockers/* AdblockSyntax */.Y.Common;
                    break;
                case network_rule_common/* NetworkRuleMarshallingMap */.v.Exception:
                    node.exception = buffer.readUint8() === 1;
                    break;
                case network_rule_common/* NetworkRuleMarshallingMap */.v.Pattern:
                    ValueDeserializer.deserialize(buffer, node.pattern = {});
                    break;
                case network_rule_common/* NetworkRuleMarshallingMap */.v.ModifierList:
                    ModifierListDeserializer.deserialize(buffer, node.modifiers = {});
                    break;
                case network_rule_common/* NetworkRuleMarshallingMap */.v.Start:
                    node.start = buffer.readUint32();
                    break;
                case network_rule_common/* NetworkRuleMarshallingMap */.v.End:
                    node.end = buffer.readUint32();
                    break;
                default:
                    throw new Error(`Invalid property: ${prop}.`);
            }
            prop = buffer.readUint8();
        }
    }
}



// EXTERNAL MODULE: ./node_modules/.pnpm/@adguard+agtree@3.1.3/node_modules/@adguard/agtree/dist/marshalling-utils/empty-rule-common.js
var empty_rule_common = __webpack_require__(42585);
;// ./node_modules/.pnpm/@adguard+agtree@3.1.3/node_modules/@adguard/agtree/dist/deserializer/empty-rule-deserializer.js
/*
 * AGTree v3.1.3 (build date: Tue, 29 Apr 2025 12:25:03 GMT)
 * (c) 2025 Adguard Software Ltd.
 * Released under the MIT license
 * https://github.com/AdguardTeam/tsurlfilter/tree/master/packages/agtree#readme
 */







/* eslint-disable no-param-reassign */
/**
 * Deserializer for empty rule nodes.
 * This class handles the deserialization of empty rule nodes from binary format.
 */
class EmptyRuleDeserializer extends BaseDeserializer {
    /**
     * Deserializes an empty rule node from binary format.
     *
     * @param buffer ByteBuffer for reading binary data.
     * @param node Destination node.
     */
    static deserialize(buffer, node) {
        buffer.assertUint8(binary_type_common/* BinaryTypeMarshallingMap */.u.EmptyRule);
        node.type = 'EmptyRule';
        node.category = nodes/* RuleCategory */.$O.Empty;
        node.syntax = adblockers/* AdblockSyntax */.Y.Common;
        let prop = buffer.readUint8();
        while (prop !== constants/* NULL */.Cq) {
            switch (prop) {
                case empty_rule_common/* EmptyRuleMarshallingMap */.K.Start:
                    node.start = buffer.readUint32();
                    break;
                case empty_rule_common/* EmptyRuleMarshallingMap */.K.End:
                    node.end = buffer.readUint32();
                    break;
                default:
                    throw new Error(`Invalid property: ${prop}.`);
            }
            prop = buffer.readUint8();
        }
    }
}



// EXTERNAL MODULE: ./node_modules/.pnpm/@adguard+agtree@3.1.3/node_modules/@adguard/agtree/dist/marshalling-utils/invalid-rule-error-node-common.js
var invalid_rule_error_node_common = __webpack_require__(73561);
;// ./node_modules/.pnpm/@adguard+agtree@3.1.3/node_modules/@adguard/agtree/dist/deserializer/invalid-rule-error-node-deserializer.js
/*
 * AGTree v3.1.3 (build date: Tue, 29 Apr 2025 12:25:03 GMT)
 * (c) 2025 Adguard Software Ltd.
 * Released under the MIT license
 * https://github.com/AdguardTeam/tsurlfilter/tree/master/packages/agtree#readme
 */





/* eslint-disable no-param-reassign */
/**
 * Deserializer for invalid rule error nodes.
 * Converts binary data into invalid rule error nodes.
 */
class InvalidRuleErrorNodeDeserializer extends BaseDeserializer {
    /**
     * Deserializes an invalid rule error node from binary format.
     *
     * @param buffer ByteBuffer for reading binary data.
     * @param node Destination node.
     */
    static deserialize(buffer, node) {
        buffer.assertUint8(binary_type_common/* BinaryTypeMarshallingMap */.u.InvalidRuleErrorNode);
        node.type = 'InvalidRuleError';
        let prop = buffer.readUint8();
        while (prop !== constants/* NULL */.Cq) {
            switch (prop) {
                case invalid_rule_error_node_common/* InvalidRuleErrorNodeMarshallingMap */.K.Name:
                    node.name = buffer.readString();
                    break;
                case invalid_rule_error_node_common/* InvalidRuleErrorNodeMarshallingMap */.K.Message:
                    node.message = buffer.readString();
                    break;
                case invalid_rule_error_node_common/* InvalidRuleErrorNodeMarshallingMap */.K.Start:
                    node.start = buffer.readUint32();
                    break;
                case invalid_rule_error_node_common/* InvalidRuleErrorNodeMarshallingMap */.K.End:
                    node.end = buffer.readUint32();
                    break;
                default:
                    throw new Error(`Invalid property: ${prop}.`);
            }
            prop = buffer.readUint8();
        }
    }
}



// EXTERNAL MODULE: ./node_modules/.pnpm/@adguard+agtree@3.1.3/node_modules/@adguard/agtree/dist/marshalling-utils/invalid-rule-common.js
var invalid_rule_common = __webpack_require__(33955);
;// ./node_modules/.pnpm/@adguard+agtree@3.1.3/node_modules/@adguard/agtree/dist/deserializer/invalid-rule-deserializer.js
/*
 * AGTree v3.1.3 (build date: Tue, 29 Apr 2025 12:25:03 GMT)
 * (c) 2025 Adguard Software Ltd.
 * Released under the MIT license
 * https://github.com/AdguardTeam/tsurlfilter/tree/master/packages/agtree#readme
 */







/* eslint-disable no-param-reassign */
/**
 * Deserializer for invalid rule nodes.
 * Converts binary data into invalid rule nodes.
 */
class InvalidRuleDeserializer extends BaseDeserializer {
    /**
     * Deserializes an invalid rule node from binary format.
     *
     * @param buffer ByteBuffer for reading binary data.
     * @param node Destination node.
     */
    static deserialize(buffer, node) {
        buffer.assertUint8(binary_type_common/* BinaryTypeMarshallingMap */.u.InvalidRule);
        node.type = 'InvalidRule';
        node.category = nodes/* RuleCategory */.$O.Invalid;
        let prop = buffer.readUint8();
        while (prop !== constants/* NULL */.Cq) {
            switch (prop) {
                case invalid_rule_common/* InvalidRuleMarshallingMap */.W.Error:
                    InvalidRuleErrorNodeDeserializer.deserialize(buffer, node.error = {});
                    break;
                case invalid_rule_common/* InvalidRuleMarshallingMap */.W.Start:
                    node.start = buffer.readUint32();
                    break;
                case invalid_rule_common/* InvalidRuleMarshallingMap */.W.End:
                    node.end = buffer.readUint32();
                    break;
                default:
                    throw new Error(`Invalid property: ${prop}.`);
            }
            prop = buffer.readUint8();
        }
    }
}



;// ./node_modules/.pnpm/@adguard+agtree@3.1.3/node_modules/@adguard/agtree/dist/deserializer/rule-deserializer.js
/*
 * AGTree v3.1.3 (build date: Tue, 29 Apr 2025 12:25:03 GMT)
 * (c) 2025 Adguard Software Ltd.
 * Released under the MIT license
 * https://github.com/AdguardTeam/tsurlfilter/tree/master/packages/agtree#readme
 */









/**
 * `RuleDeserializer` is responsible for deserializing the rules.
 *
 * It automatically determines the category and syntax of the rule, so you can pass any kind of rule to it.
 */
class RuleDeserializer extends BaseDeserializer {
    /**
     * Deserializes a rule node from binary format.
     *
     * @param buffer ByteBuffer for reading binary data.
     * @param node Destination node.
     */
    static deserialize(buffer, node) {
        // lookup instead of storing +1 byte
        const type = buffer.peekUint8();
        switch (type) {
            case binary_type_common/* BinaryTypeMarshallingMap */.u.AgentRuleNode:
            case binary_type_common/* BinaryTypeMarshallingMap */.u.HintRuleNode:
            case binary_type_common/* BinaryTypeMarshallingMap */.u.PreProcessorCommentRuleNode:
            case binary_type_common/* BinaryTypeMarshallingMap */.u.MetadataCommentRuleNode:
            case binary_type_common/* BinaryTypeMarshallingMap */.u.ConfigCommentRuleNode:
            case binary_type_common/* BinaryTypeMarshallingMap */.u.CommentRuleNode:
                CommentRuleDeserializer.deserialize(buffer, node);
                break;
            case binary_type_common/* BinaryTypeMarshallingMap */.u.ElementHidingRule:
            case binary_type_common/* BinaryTypeMarshallingMap */.u.CssInjectionRule:
            case binary_type_common/* BinaryTypeMarshallingMap */.u.ScriptletInjectionRule:
            case binary_type_common/* BinaryTypeMarshallingMap */.u.HtmlFilteringRule:
            case binary_type_common/* BinaryTypeMarshallingMap */.u.JsInjectionRule:
                CosmeticRuleDeserializer.deserialize(buffer, node);
                break;
            case binary_type_common/* BinaryTypeMarshallingMap */.u.NetworkRuleNode:
                NetworkRuleDeserializer.deserialize(buffer, node);
                break;
            case binary_type_common/* BinaryTypeMarshallingMap */.u.HostRuleNode:
                HostRuleDeserializer.deserialize(buffer, node);
                break;
            case binary_type_common/* BinaryTypeMarshallingMap */.u.EmptyRule:
                EmptyRuleDeserializer.deserialize(buffer, node);
                break;
            case binary_type_common/* BinaryTypeMarshallingMap */.u.InvalidRule:
                InvalidRuleDeserializer.deserialize(buffer, node);
                break;
            default:
                throw new Error('Unknown rule category');
        }
    }
}




/***/ }),

/***/ 23029:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   q: () => (/* binding */ AdblockSyntaxError)
/* harmony export */ });
/*
 * AGTree v3.1.3 (build date: Tue, 29 Apr 2025 12:25:03 GMT)
 * (c) 2025 Adguard Software Ltd.
 * Released under the MIT license
 * https://github.com/AdguardTeam/tsurlfilter/tree/master/packages/agtree#readme
 */
/**
 * @file Customized syntax error class for Adblock Filter Parser.
 */
const ERROR_NAME = 'AdblockSyntaxError';
/**
 * Customized syntax error class for Adblock Filter Parser,
 * which contains the location range of the error.
 */
class AdblockSyntaxError extends SyntaxError {
    /**
     * Start offset of the error.
     */
    start;
    /**
     * End offset of the error.
     */
    end;
    /**
     * Constructs a new `AdblockSyntaxError` instance.
     *
     * @param message Error message.
     * @param start Start offset of the error.
     * @param end End offset of the error.
     */
    constructor(message, start, end) {
        super(message);
        this.name = ERROR_NAME;
        this.start = start;
        this.end = end;
    }
}




/***/ }),

/***/ 74173:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   E: () => (/* binding */ NotImplementedError)
/* harmony export */ });
/*
 * AGTree v3.1.3 (build date: Tue, 29 Apr 2025 12:25:03 GMT)
 * (c) 2025 Adguard Software Ltd.
 * Released under the MIT license
 * https://github.com/AdguardTeam/tsurlfilter/tree/master/packages/agtree#readme
 */
/**
 * @file Customized error class for not implemented features.
 */
const ERROR_NAME = 'NotImplementedError';
const BASE_MESSAGE = 'Not implemented';
/**
 * Customized error class for not implemented features.
 */
class NotImplementedError extends Error {
    /**
     * Constructs a new `NotImplementedError` instance.
     *
     * @param message Additional error message (optional)
     */
    constructor(message = undefined) {
        // Prepare the full error message
        const fullMessage = message
            ? `${BASE_MESSAGE}: ${message}`
            : BASE_MESSAGE;
        super(fullMessage);
        this.name = ERROR_NAME;
    }
}




/***/ }),

/***/ 41161:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   t: () => (/* binding */ BaseGenerator)
/* harmony export */ });
/* harmony import */ var _errors_not_implemented_error_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(74173);
/*
 * AGTree v3.1.3 (build date: Tue, 29 Apr 2025 12:25:03 GMT)
 * (c) 2025 Adguard Software Ltd.
 * Released under the MIT license
 * https://github.com/AdguardTeam/tsurlfilter/tree/master/packages/agtree#readme
 */


/* eslint-disable @typescript-eslint/no-unused-vars */
/**
 * @file Base generator class.
 */
/**
 * Base class for generators. Each generator should extend this class.
 */
class BaseGenerator {
    /**
     * Generates a string from the AST node.
     *
     * @param node AST node to generate a string from.
     */
    static generate(node) {
        throw new _errors_not_implemented_error_js__WEBPACK_IMPORTED_MODULE_0__/* .NotImplementedError */ .E();
    }
}




/***/ }),

/***/ 67918:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  H: () => (/* binding */ CosmeticRuleBodyGenerator)
});

// EXTERNAL MODULE: ./node_modules/.pnpm/@adguard+agtree@3.1.3/node_modules/@adguard/agtree/dist/generator/base-generator.js
var base_generator = __webpack_require__(41161);
// EXTERNAL MODULE: ./node_modules/.pnpm/@adguard+agtree@3.1.3/node_modules/@adguard/agtree/dist/nodes/index.js
var nodes = __webpack_require__(91354);
// EXTERNAL MODULE: ./node_modules/.pnpm/@adguard+agtree@3.1.3/node_modules/@adguard/agtree/dist/utils/constants.js
var constants = __webpack_require__(27895);
// EXTERNAL MODULE: ./node_modules/.pnpm/@adguard+agtree@3.1.3/node_modules/@adguard/agtree/dist/utils/adblockers.js
var adblockers = __webpack_require__(73734);
// EXTERNAL MODULE: ./node_modules/.pnpm/@adguard+agtree@3.1.3/node_modules/@adguard/agtree/dist/generator/misc/parameter-list-generator.js
var parameter_list_generator = __webpack_require__(94477);
;// ./node_modules/.pnpm/@adguard+agtree@3.1.3/node_modules/@adguard/agtree/dist/generator/cosmetic/body/adg-scriptlet-injection-body-generator.js
/*
 * AGTree v3.1.3 (build date: Tue, 29 Apr 2025 12:25:03 GMT)
 * (c) 2025 Adguard Software Ltd.
 * Released under the MIT license
 * https://github.com/AdguardTeam/tsurlfilter/tree/master/packages/agtree#readme
 */




/**
 * AdGuard scriptlet injection body generator.
 */
class AdgScriptletInjectionBodyGenerator extends base_generator/* BaseGenerator */.t {
    /**
     * Error messages used by the generator.
     */
    static ERROR_MESSAGES = {
        NO_MULTIPLE_SCRIPTLET_CALLS: 'ADG syntaxes does not support multiple scriptlet calls within one single rule',
    };
    /**
     * Generates a string representation of the AdGuard scriptlet call body.
     *
     * @param node Scriptlet injection rule body
     * @returns String representation of the rule body
     * @throws Error if the scriptlet call has multiple parameters
     */
    static generate(node) {
        const result = [];
        if (node.children.length > 1) {
            throw new Error(AdgScriptletInjectionBodyGenerator.ERROR_MESSAGES.NO_MULTIPLE_SCRIPTLET_CALLS);
        }
        result.push(constants/* ADG_SCRIPTLET_MASK */.x$);
        result.push(constants/* OPEN_PARENTHESIS */.Cx);
        if (node.children.length > 0) {
            result.push(parameter_list_generator/* ParameterListGenerator */.H.generate(node.children[0]));
        }
        result.push(constants/* CLOSE_PARENTHESIS */.s1);
        return result.join(constants/* EMPTY */.wg);
    }
}



// EXTERNAL MODULE: ./node_modules/.pnpm/@adguard+agtree@3.1.3/node_modules/@adguard/agtree/dist/parser/css/adg-css-injection-parser.js
var adg_css_injection_parser = __webpack_require__(95452);
;// ./node_modules/.pnpm/@adguard+agtree@3.1.3/node_modules/@adguard/agtree/dist/generator/css/adg-css-injection-generator.js
/*
 * AGTree v3.1.3 (build date: Tue, 29 Apr 2025 12:25:03 GMT)
 * (c) 2025 Adguard Software Ltd.
 * Released under the MIT license
 * https://github.com/AdguardTeam/tsurlfilter/tree/master/packages/agtree#readme
 */




/**
 * AdGuard CSS injection generator.
 */
class AdgCssInjectionGenerator extends base_generator/* BaseGenerator */.t {
    static removeDeclaration = `${adg_css_injection_parser/* REMOVE_PROPERTY */.JX}${constants/* COLON */.oH}${constants/* SPACE */.t6}${adg_css_injection_parser/* REMOVE_VALUE */.FH}${constants/* SEMICOLON */.I8}`;
    /**
     * Serializes an AdGuard CSS injection node into a raw string.
     *
     * @param node Node to serialize.
     * @returns Raw string.
     */
    static generate(node) {
        const result = [];
        if (node.mediaQueryList) {
            result.push(constants/* CSS_MEDIA_MARKER */.Ae, constants/* SPACE */.t6, node.mediaQueryList.value, constants/* SPACE */.t6, constants/* OPEN_CURLY_BRACKET */.sV, constants/* SPACE */.t6);
        }
        result.push(node.selectorList.value, constants/* SPACE */.t6, constants/* OPEN_CURLY_BRACKET */.sV, constants/* SPACE */.t6);
        if (node.remove) {
            result.push(AdgCssInjectionGenerator.removeDeclaration);
        }
        else if (node.declarationList?.value) {
            result.push(node.declarationList.value);
        }
        result.push(constants/* SPACE */.t6, constants/* CLOSE_CURLY_BRACKET */.wU);
        if (node.mediaQueryList) {
            result.push(constants/* SPACE */.t6, constants/* CLOSE_CURLY_BRACKET */.wU);
        }
        return result.join(constants/* EMPTY */.wg);
    }
}



// EXTERNAL MODULE: ./node_modules/.pnpm/@adguard+agtree@3.1.3/node_modules/@adguard/agtree/dist/common/abp-snippet-injection-body-common.js
var abp_snippet_injection_body_common = __webpack_require__(10434);
;// ./node_modules/.pnpm/@adguard+agtree@3.1.3/node_modules/@adguard/agtree/dist/generator/cosmetic/body/abp-snippet-injection-body-generator.js
/*
 * AGTree v3.1.3 (build date: Tue, 29 Apr 2025 12:25:03 GMT)
 * (c) 2025 Adguard Software Ltd.
 * Released under the MIT license
 * https://github.com/AdguardTeam/tsurlfilter/tree/master/packages/agtree#readme
 */





/**
 * Adblock Plus snippet injection body generator.
 */
class AbpSnippetInjectionBodyGenerator extends base_generator/* BaseGenerator */.t {
    /**
     * Generates a string representation of the Adblock Plus-style snippet call body.
     *
     * @param node Scriptlet injection rule body
     * @returns String representation of the rule body
     * @throws Error if the scriptlet call is empty
     */
    static generate(node) {
        const result = [];
        if (node.children.length === 0) {
            throw new Error(abp_snippet_injection_body_common/* AbpSnippetInjectionBodyCommon */.H.ERROR_MESSAGES.EMPTY_SCRIPTLET_CALL);
        }
        for (const scriptletCall of node.children) {
            if (scriptletCall.children.length === 0) {
                throw new Error(abp_snippet_injection_body_common/* AbpSnippetInjectionBodyCommon */.H.ERROR_MESSAGES.EMPTY_SCRIPTLET_CALL);
            }
            result.push(parameter_list_generator/* ParameterListGenerator */.H.generate(scriptletCall, constants/* SPACE */.t6));
        }
        return result.join(constants/* SEMICOLON */.I8 + constants/* SPACE */.t6);
    }
}



;// ./node_modules/.pnpm/@adguard+agtree@3.1.3/node_modules/@adguard/agtree/dist/generator/cosmetic/body/ubo-scriptlet-injection-body-generator.js
/*
 * AGTree v3.1.3 (build date: Tue, 29 Apr 2025 12:25:03 GMT)
 * (c) 2025 Adguard Software Ltd.
 * Released under the MIT license
 * https://github.com/AdguardTeam/tsurlfilter/tree/master/packages/agtree#readme
 */




/**
 * uBlock scriptlet injection body generator.
 */
class UboScriptletInjectionBodyGenerator extends base_generator/* BaseGenerator */.t {
    /**
     * Error messages used by the generator.
     */
    static ERROR_MESSAGES = {
        NO_MULTIPLE_SCRIPTLET_CALLS: 'uBO syntaxes does not support multiple scriptlet calls within one single rule',
    };
    /**
     * Generates a string representation of the uBlock scriptlet call body.
     *
     * @param node Scriptlet injection rule body
     * @returns String representation of the rule body
     * @throws Error if the scriptlet call has multiple parameters
     */
    static generate(node) {
        const result = [];
        if (node.children.length > 1) {
            throw new Error(UboScriptletInjectionBodyGenerator.ERROR_MESSAGES.NO_MULTIPLE_SCRIPTLET_CALLS);
        }
        // During generation, we only support the modern scriptlet mask
        result.push(constants/* UBO_SCRIPTLET_MASK */.Rq);
        result.push(constants/* OPEN_PARENTHESIS */.Cx);
        if (node.children.length > 0) {
            const [parameterListNode] = node.children;
            result.push(parameter_list_generator/* ParameterListGenerator */.H.generate(parameterListNode));
        }
        result.push(constants/* CLOSE_PARENTHESIS */.s1);
        return result.join(constants/* EMPTY */.wg);
    }
}



// EXTERNAL MODULE: ./node_modules/.pnpm/@adguard+agtree@3.1.3/node_modules/@adguard/agtree/dist/common/ubo-selector-common.js
var ubo_selector_common = __webpack_require__(5596);
;// ./node_modules/.pnpm/@adguard+agtree@3.1.3/node_modules/@adguard/agtree/dist/generator/cosmetic/cosmetic-rule-body-generator.js
/*
 * AGTree v3.1.3 (build date: Tue, 29 Apr 2025 12:25:03 GMT)
 * (c) 2025 Adguard Software Ltd.
 * Released under the MIT license
 * https://github.com/AdguardTeam/tsurlfilter/tree/master/packages/agtree#readme
 */










/**
 * Cosmetic rule body generator.
 */
class CosmeticRuleBodyGenerator extends base_generator/* BaseGenerator */.t {
    /**
     * Generates the rule body from the node.
     *
     * @param node Cosmetic rule node
     * @returns Raw rule body
     * @example
     * - '##.foo' → '.foo'
     * - 'example.com,example.org##.foo' → '.foo'
     * - 'example.com#%#//scriptlet('foo')' → '//scriptlet('foo')'
     *
     * @throws Error if the rule type is unknown
     */
    static generate(node) {
        let result = constants/* EMPTY */.wg;
        switch (node.type) {
            case nodes/* CosmeticRuleType */.k9.ElementHidingRule:
                result = node.body.selectorList.value;
                break;
            case nodes/* CosmeticRuleType */.k9.CssInjectionRule:
                if (node.syntax === adblockers/* AdblockSyntax */.Y.Adg || node.syntax === adblockers/* AdblockSyntax */.Y.Abp) {
                    result = AdgCssInjectionGenerator.generate(node.body);
                }
                else if (node.syntax === adblockers/* AdblockSyntax */.Y.Ubo) {
                    if (node.body.mediaQueryList) {
                        result += constants/* COLON */.oH;
                        result += ubo_selector_common/* UboPseudoName */.S.MatchesMedia;
                        result += constants/* OPEN_PARENTHESIS */.Cx;
                        result += node.body.mediaQueryList.value;
                        result += constants/* CLOSE_PARENTHESIS */.s1;
                        result += constants/* SPACE */.t6;
                    }
                    result += node.body.selectorList.value;
                    if (node.body.remove) {
                        result += constants/* COLON */.oH;
                        result += ubo_selector_common/* UboPseudoName */.S.Remove;
                        result += constants/* OPEN_PARENTHESIS */.Cx;
                        result += constants/* CLOSE_PARENTHESIS */.s1;
                    }
                    else if (node.body.declarationList) {
                        result += constants/* COLON */.oH;
                        result += ubo_selector_common/* UboPseudoName */.S.Style;
                        result += constants/* OPEN_PARENTHESIS */.Cx;
                        result += node.body.declarationList.value;
                        result += constants/* CLOSE_PARENTHESIS */.s1;
                    }
                }
                break;
            case nodes/* CosmeticRuleType */.k9.HtmlFilteringRule:
            case nodes/* CosmeticRuleType */.k9.JsInjectionRule:
                result = node.body.value;
                break;
            case nodes/* CosmeticRuleType */.k9.ScriptletInjectionRule:
                switch (node.syntax) {
                    case adblockers/* AdblockSyntax */.Y.Adg:
                        result = AdgScriptletInjectionBodyGenerator.generate(node.body);
                        break;
                    case adblockers/* AdblockSyntax */.Y.Abp:
                        result = AbpSnippetInjectionBodyGenerator.generate(node.body);
                        break;
                    case adblockers/* AdblockSyntax */.Y.Ubo:
                        result = UboScriptletInjectionBodyGenerator.generate(node.body);
                        break;
                    default:
                        throw new Error('Scriptlet rule should have an explicit syntax');
                }
                break;
            default:
                throw new Error('Unknown cosmetic rule type');
        }
        return result;
    }
}




/***/ }),

/***/ 94477:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   H: () => (/* binding */ ParameterListGenerator)
/* harmony export */ });
/* harmony import */ var _utils_constants_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(27895);
/* harmony import */ var _base_generator_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(41161);
/* harmony import */ var _value_generator_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(8466);
/*
 * AGTree v3.1.3 (build date: Tue, 29 Apr 2025 12:25:03 GMT)
 * (c) 2025 Adguard Software Ltd.
 * Released under the MIT license
 * https://github.com/AdguardTeam/tsurlfilter/tree/master/packages/agtree#readme
 */




/**
 * Generator for parameter list nodes.
 */
class ParameterListGenerator extends _base_generator_js__WEBPACK_IMPORTED_MODULE_0__/* .BaseGenerator */ .t {
    /**
     * Converts a parameter list AST to a string.
     *
     * @param params Parameter list AST
     * @param separator Separator character (default: comma)
     * @param allowSpace Allow space between parameters (default: true)
     * @returns String representation of the parameter list
     */
    static generate(params, separator = _utils_constants_js__WEBPACK_IMPORTED_MODULE_1__/* .COMMA */ .KE, allowSpace = true) {
        const collection = [];
        let i = 0;
        for (; i < params.children.length; i += 1) {
            const param = params.children[i];
            if (param === null) {
                collection.push(_utils_constants_js__WEBPACK_IMPORTED_MODULE_1__/* .EMPTY */ .wg);
            }
            else {
                collection.push(_value_generator_js__WEBPACK_IMPORTED_MODULE_2__/* .ValueGenerator */ .R.generate(param));
            }
        }
        let result = _utils_constants_js__WEBPACK_IMPORTED_MODULE_1__/* .EMPTY */ .wg;
        // if allowSpace is true, join with a single separator
        // without space
        if (!allowSpace && separator !== _utils_constants_js__WEBPACK_IMPORTED_MODULE_1__/* .SPACE */ .t6) {
            result = collection.join(separator);
        }
        else {
            // join parameters with separator
            // if the separator is a space, join with a single space
            result = collection.join(separator === _utils_constants_js__WEBPACK_IMPORTED_MODULE_1__/* .SPACE */ .t6 ? separator : `${separator}${_utils_constants_js__WEBPACK_IMPORTED_MODULE_1__/* .SPACE */ .t6}`);
        }
        return result;
    }
}




/***/ }),

/***/ 8466:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   R: () => (/* binding */ ValueGenerator)
/* harmony export */ });
/* harmony import */ var _base_generator_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(41161);
/*
 * AGTree v3.1.3 (build date: Tue, 29 Apr 2025 12:25:03 GMT)
 * (c) 2025 Adguard Software Ltd.
 * Released under the MIT license
 * https://github.com/AdguardTeam/tsurlfilter/tree/master/packages/agtree#readme
 */


/**
 * Generator for value nodes.
 */
class ValueGenerator extends _base_generator_js__WEBPACK_IMPORTED_MODULE_0__/* .BaseGenerator */ .t {
    /**
     * Converts a value node to a string.
     *
     * @param node Value node.
     * @returns Raw string.
     */
    static generate(node) {
        return node.value;
    }
}




/***/ }),

/***/ 98154:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  u: () => (/* binding */ RuleGenerator)
});

// EXTERNAL MODULE: ./node_modules/.pnpm/@adguard+agtree@3.1.3/node_modules/@adguard/agtree/dist/generator/base-generator.js
var base_generator = __webpack_require__(41161);
// EXTERNAL MODULE: ./node_modules/.pnpm/@adguard+agtree@3.1.3/node_modules/@adguard/agtree/dist/nodes/index.js
var nodes = __webpack_require__(91354);
// EXTERNAL MODULE: ./node_modules/.pnpm/@adguard+agtree@3.1.3/node_modules/@adguard/agtree/dist/utils/constants.js
var constants = __webpack_require__(27895);
// EXTERNAL MODULE: ./node_modules/.pnpm/@adguard+agtree@3.1.3/node_modules/@adguard/agtree/dist/utils/type-guards.js
var type_guards = __webpack_require__(8123);
;// ./node_modules/.pnpm/@adguard+agtree@3.1.3/node_modules/@adguard/agtree/dist/generator/comment/agent-generator.js
/*
 * AGTree v3.1.3 (build date: Tue, 29 Apr 2025 12:25:03 GMT)
 * (c) 2025 Adguard Software Ltd.
 * Released under the MIT license
 * https://github.com/AdguardTeam/tsurlfilter/tree/master/packages/agtree#readme
 */




/**
 * Generator for adblock agent nodes.
 * This class is responsible for converting adblock agent nodes into their string representation.
 */
class AgentGenerator extends base_generator/* BaseGenerator */.t {
    /**
     * Converts an adblock agent node to a string.
     *
     * @param value Agent node
     * @returns Raw string
     */
    static generate(value) {
        let result = constants/* EMPTY */.wg;
        // Agent adblock name
        result += value.adblock.value;
        // Agent adblock version (if present)
        if (!(0,type_guards/* isUndefined */.b0)(value.version)) {
            // Add a space between the name and the version
            result += constants/* SPACE */.t6;
            result += value.version.value;
        }
        return result;
    }
}



;// ./node_modules/.pnpm/@adguard+agtree@3.1.3/node_modules/@adguard/agtree/dist/generator/comment/agent-comment-generator.js
/*
 * AGTree v3.1.3 (build date: Tue, 29 Apr 2025 12:25:03 GMT)
 * (c) 2025 Adguard Software Ltd.
 * Released under the MIT license
 * https://github.com/AdguardTeam/tsurlfilter/tree/master/packages/agtree#readme
 */




/**
 * Generator for agent comment rules.
 */
class AgentCommentGenerator extends base_generator/* BaseGenerator */.t {
    /**
     * Converts an adblock agent AST to a string.
     *
     * @param ast Agent rule AST
     * @returns Raw string
     */
    static generate(ast) {
        let result = constants/* OPEN_SQUARE_BRACKET */.cU;
        result += ast.children
            .map(AgentGenerator.generate)
            .join(constants/* SEMICOLON */.I8 + constants/* SPACE */.t6);
        result += constants/* CLOSE_SQUARE_BRACKET */.A1;
        return result;
    }
}



// EXTERNAL MODULE: ./node_modules/.pnpm/@adguard+agtree@3.1.3/node_modules/@adguard/agtree/dist/generator/misc/parameter-list-generator.js
var parameter_list_generator = __webpack_require__(94477);
;// ./node_modules/.pnpm/@adguard+agtree@3.1.3/node_modules/@adguard/agtree/dist/generator/comment/hint-generator.js
/*
 * AGTree v3.1.3 (build date: Tue, 29 Apr 2025 12:25:03 GMT)
 * (c) 2025 Adguard Software Ltd.
 * Released under the MIT license
 * https://github.com/AdguardTeam/tsurlfilter/tree/master/packages/agtree#readme
 */




/**
 * Hint generator.
 */
class HintGenerator extends base_generator/* BaseGenerator */.t {
    /**
     * Generates a string representation of a hint.
     *
     * @param hint Hint AST node
     * @returns String representation of the hint
     */
    static generate(hint) {
        let result = constants/* EMPTY */.wg;
        result += hint.name.value;
        if (hint.params && hint.params.children.length > 0) {
            result += constants/* OPEN_PARENTHESIS */.Cx;
            result += parameter_list_generator/* ParameterListGenerator */.H.generate(hint.params, constants/* COMMA */.KE);
            result += constants/* CLOSE_PARENTHESIS */.s1;
        }
        return result;
    }
}



;// ./node_modules/.pnpm/@adguard+agtree@3.1.3/node_modules/@adguard/agtree/dist/generator/comment/hint-comment-generator.js
/*
 * AGTree v3.1.3 (build date: Tue, 29 Apr 2025 12:25:03 GMT)
 * (c) 2025 Adguard Software Ltd.
 * Released under the MIT license
 * https://github.com/AdguardTeam/tsurlfilter/tree/master/packages/agtree#readme
 */




/**
 * Hint comment generator.
 */
class HintCommentGenerator extends base_generator/* BaseGenerator */.t {
    /**
     * Converts a hint rule node to a raw string.
     *
     * @param node Hint rule node
     * @returns Raw string
     */
    static generate(node) {
        let result = constants/* HINT_MARKER */.j6 + constants/* SPACE */.t6;
        result += node.children.map(HintGenerator.generate).join(constants/* SPACE */.t6);
        return result;
    }
}



// EXTERNAL MODULE: ./node_modules/.pnpm/@adguard+agtree@3.1.3/node_modules/@adguard/agtree/dist/generator/misc/value-generator.js
var value_generator = __webpack_require__(8466);
// EXTERNAL MODULE: ./node_modules/.pnpm/@adguard+agtree@3.1.3/node_modules/@adguard/agtree/dist/parser/misc/logical-expression-parser.js
var logical_expression_parser = __webpack_require__(11951);
;// ./node_modules/.pnpm/@adguard+agtree@3.1.3/node_modules/@adguard/agtree/dist/generator/misc/logical-expression-generator.js
/*
 * AGTree v3.1.3 (build date: Tue, 29 Apr 2025 12:25:03 GMT)
 * (c) 2025 Adguard Software Ltd.
 * Released under the MIT license
 * https://github.com/AdguardTeam/tsurlfilter/tree/master/packages/agtree#readme
 */




/**
 * Generator for logical expression nodes.
 */
class LogicalExpressionGenerator extends base_generator/* BaseGenerator */.t {
    /**
     * Generates a string representation of the logical expression (serialization).
     *
     * @param node Expression node
     * @returns String representation of the logical expression
     */
    static generate(node) {
        if (node.type === logical_expression_parser/* NodeType */.Z.Variable) {
            return node.name;
        }
        if (node.type === logical_expression_parser/* NodeType */.Z.Operator) {
            const left = LogicalExpressionGenerator.generate(node.left);
            const right = node.right ? LogicalExpressionGenerator.generate(node.right) : undefined;
            const { operator } = node;
            // Special case for NOT operator
            if (operator === nodes/* OperatorValue */.oC.Not) {
                return `${operator}${left}`;
            }
            // Right operand is required for AND and OR operators
            if (!right) {
                throw new Error('Expected right operand');
            }
            return `${left} ${operator} ${right}`;
        }
        if (node.type === logical_expression_parser/* NodeType */.Z.Parenthesis) {
            const expressionString = LogicalExpressionGenerator.generate(node.expression);
            return `(${expressionString})`;
        }
        // Theoretically, this shouldn't happen if the library is used correctly
        throw new Error('Unexpected node type');
    }
}



;// ./node_modules/.pnpm/@adguard+agtree@3.1.3/node_modules/@adguard/agtree/dist/generator/comment/pre-processor-comment-generator.js
/*
 * AGTree v3.1.3 (build date: Tue, 29 Apr 2025 12:25:03 GMT)
 * (c) 2025 Adguard Software Ltd.
 * Released under the MIT license
 * https://github.com/AdguardTeam/tsurlfilter/tree/master/packages/agtree#readme
 */






/**
 * Pre-processor comment generator.
 */
class PreProcessorCommentGenerator extends base_generator/* BaseGenerator */.t {
    /**
     * Converts a pre-processor comment node to a string.
     *
     * @param node Pre-processor comment node
     * @returns Raw string
     */
    static generate(node) {
        let result = constants/* EMPTY */.wg;
        result += constants/* PREPROCESSOR_MARKER */.PD;
        result += node.name.value;
        if (node.params) {
            let allowSpaceBetweenParams = true;
            // Space between cb is not allowed for "safari_cb_affinity" directive.
            if (node.name.value === constants/* SAFARI_CB_AFFINITY */.us) {
                allowSpaceBetweenParams = false;
            }
            // Space is not allowed after "safari_cb_affinity" directive, so we need to handle it separately.
            if (node.name.value !== constants/* SAFARI_CB_AFFINITY */.us) {
                result += constants/* SPACE */.t6;
            }
            if (node.params.type === 'Value') {
                result += value_generator/* ValueGenerator */.R.generate(node.params);
            }
            else if (node.params.type === 'ParameterList') {
                result += constants/* OPEN_PARENTHESIS */.Cx;
                result += parameter_list_generator/* ParameterListGenerator */.H.generate(node.params, constants/* COMMA */.KE, allowSpaceBetweenParams);
                result += constants/* CLOSE_PARENTHESIS */.s1;
            }
            else {
                result += LogicalExpressionGenerator.generate(node.params);
            }
        }
        return result;
    }
}



;// ./node_modules/.pnpm/@adguard+agtree@3.1.3/node_modules/@adguard/agtree/dist/generator/comment/metadata-comment-generator.js
/*
 * AGTree v3.1.3 (build date: Tue, 29 Apr 2025 12:25:03 GMT)
 * (c) 2025 Adguard Software Ltd.
 * Released under the MIT license
 * https://github.com/AdguardTeam/tsurlfilter/tree/master/packages/agtree#readme
 */




/**
 * Metadata comment generator.
 */
class MetadataCommentGenerator extends base_generator/* BaseGenerator */.t {
    /**
     * Converts a metadata comment rule node to a string.
     *
     * @param node Metadata comment rule node.
     * @returns Raw string.
     */
    static generate(node) {
        let result = constants/* EMPTY */.wg;
        result += value_generator/* ValueGenerator */.R.generate(node.marker);
        result += constants/* SPACE */.t6;
        result += value_generator/* ValueGenerator */.R.generate(node.header);
        result += constants/* COLON */.oH;
        result += constants/* SPACE */.t6;
        result += value_generator/* ValueGenerator */.R.generate(node.value);
        return result;
    }
}



;// ./node_modules/.pnpm/@adguard+agtree@3.1.3/node_modules/@adguard/agtree/dist/generator/comment/config-comment-generator.js
/*
 * AGTree v3.1.3 (build date: Tue, 29 Apr 2025 12:25:03 GMT)
 * (c) 2025 Adguard Software Ltd.
 * Released under the MIT license
 * https://github.com/AdguardTeam/tsurlfilter/tree/master/packages/agtree#readme
 */




/**
 * Converts inline configuration comment nodes to their string format.
 */
class ConfigCommentGenerator extends base_generator/* BaseGenerator */.t {
    /**
     * Converts an inline configuration comment node to a string.
     *
     * @param node Inline configuration comment node
     * @returns Raw string
     */
    static generate(node) {
        let result = constants/* EMPTY */.wg;
        result += node.marker.value;
        result += constants/* SPACE */.t6;
        result += node.command.value;
        if (node.params) {
            result += constants/* SPACE */.t6;
            if (node.params.type === 'ParameterList') {
                result += parameter_list_generator/* ParameterListGenerator */.H.generate(node.params, constants/* COMMA */.KE);
            }
            else {
                // Trim JSON boundaries
                result += JSON.stringify(node.params.value).slice(1, -1).trim();
            }
        }
        // Add comment within the config comment
        if (node.comment) {
            result += constants/* SPACE */.t6;
            result += node.comment.value;
        }
        return result;
    }
}



;// ./node_modules/.pnpm/@adguard+agtree@3.1.3/node_modules/@adguard/agtree/dist/generator/comment/simple-comment-generator.js
/*
 * AGTree v3.1.3 (build date: Tue, 29 Apr 2025 12:25:03 GMT)
 * (c) 2025 Adguard Software Ltd.
 * Released under the MIT license
 * https://github.com/AdguardTeam/tsurlfilter/tree/master/packages/agtree#readme
 */




/**
 * Simple comment generator.
 */
class SimpleCommentGenerator extends base_generator/* BaseGenerator */.t {
    /**
     * Converts a comment rule node to a string.
     *
     * @param node Comment rule node.
     * @returns Raw string.
     */
    static generate(node) {
        let result = constants/* EMPTY */.wg;
        result += value_generator/* ValueGenerator */.R.generate(node.marker);
        result += value_generator/* ValueGenerator */.R.generate(node.text);
        return result;
    }
}



;// ./node_modules/.pnpm/@adguard+agtree@3.1.3/node_modules/@adguard/agtree/dist/generator/comment/comment-rule-generator.js
/*
 * AGTree v3.1.3 (build date: Tue, 29 Apr 2025 12:25:03 GMT)
 * (c) 2025 Adguard Software Ltd.
 * Released under the MIT license
 * https://github.com/AdguardTeam/tsurlfilter/tree/master/packages/agtree#readme
 */









/* eslint-disable no-param-reassign */
/**
 * `CommentRuleGenerator` is responsible for generating any comment-like adblock rules.
 */
class CommentRuleGenerator extends base_generator/* BaseGenerator */.t {
    /**
     * Converts a comment rule node to a string.
     *
     * @param node Comment rule node
     * @returns Raw string
     */
    static generate(node) {
        switch (node.type) {
            case nodes/* CommentRuleType */.gV.AgentCommentRule:
                return AgentCommentGenerator.generate(node);
            case nodes/* CommentRuleType */.gV.HintCommentRule:
                return HintCommentGenerator.generate(node);
            case nodes/* CommentRuleType */.gV.PreProcessorCommentRule:
                return PreProcessorCommentGenerator.generate(node);
            case nodes/* CommentRuleType */.gV.MetadataCommentRule:
                return MetadataCommentGenerator.generate(node);
            case nodes/* CommentRuleType */.gV.ConfigCommentRule:
                return ConfigCommentGenerator.generate(node);
            case nodes/* CommentRuleType */.gV.CommentRule:
                return SimpleCommentGenerator.generate(node);
            default:
                throw new Error('Unknown comment rule type');
        }
    }
}



// EXTERNAL MODULE: ./node_modules/.pnpm/@adguard+agtree@3.1.3/node_modules/@adguard/agtree/dist/utils/adblockers.js
var adblockers = __webpack_require__(73734);
;// ./node_modules/.pnpm/@adguard+agtree@3.1.3/node_modules/@adguard/agtree/dist/generator/misc/modifier-generator.js
/*
 * AGTree v3.1.3 (build date: Tue, 29 Apr 2025 12:25:03 GMT)
 * (c) 2025 Adguard Software Ltd.
 * Released under the MIT license
 * https://github.com/AdguardTeam/tsurlfilter/tree/master/packages/agtree#readme
 */



/**
 * Generator for modifier nodes.
 */
class ModifierGenerator extends base_generator/* BaseGenerator */.t {
    /**
     * Converts a modifier AST node to a string.
     *
     * @param modifier Modifier AST node to convert
     * @returns String representation of the modifier
     */
    static generate(modifier) {
        let result = constants/* EMPTY */.wg;
        if (modifier.exception) {
            result += constants/* NEGATION_MARKER */.bP;
        }
        result += modifier.name.value;
        if (modifier.value !== undefined) {
            result += constants/* MODIFIER_ASSIGN_OPERATOR */.li;
            result += modifier.value.value;
        }
        return result;
    }
}



;// ./node_modules/.pnpm/@adguard+agtree@3.1.3/node_modules/@adguard/agtree/dist/generator/misc/modifier-list-generator.js
/*
 * AGTree v3.1.3 (build date: Tue, 29 Apr 2025 12:25:03 GMT)
 * (c) 2025 Adguard Software Ltd.
 * Released under the MIT license
 * https://github.com/AdguardTeam/tsurlfilter/tree/master/packages/agtree#readme
 */




/**
 * Generator for modifier list nodes.
 */
class ModifierListGenerator extends base_generator/* BaseGenerator */.t {
    /**
     * Converts a modifier list AST to a string.
     *
     * @param ast Modifier list AST
     * @returns Raw string
     */
    static generate(ast) {
        const result = ast.children
            .map(ModifierGenerator.generate)
            .join(constants/* MODIFIERS_SEPARATOR */.b9);
        return result;
    }
}



;// ./node_modules/.pnpm/@adguard+agtree@3.1.3/node_modules/@adguard/agtree/dist/generator/misc/list-items-generator.js
/*
 * AGTree v3.1.3 (build date: Tue, 29 Apr 2025 12:25:03 GMT)
 * (c) 2025 Adguard Software Ltd.
 * Released under the MIT license
 * https://github.com/AdguardTeam/tsurlfilter/tree/master/packages/agtree#readme
 */


/**
 * Utility class for generating string representations of list items.
 */
class ListItemsGenerator {
    /**
     * Generates a string representation of a list item.
     *
     * @param item List item to generate.
     * @template T Type of the list item.
     *
     * @returns String representation of the list item.
     */
    static generateListItem = (item) => {
        return `${item.exception ? constants/* NEGATION_MARKER */.bP : constants/* EMPTY */.wg}${item.value}`;
    };
    /**
     * Generates a string representation of a list of items.
     *
     * @param items List of items to generate.
     * @param separator Separator character.
     * @template T Type of the list items.
     *
     * @returns String representation of the list of items.
     */
    static generate = (items, separator) => {
        return items.map(ListItemsGenerator.generateListItem)
            .join(separator);
    };
}



;// ./node_modules/.pnpm/@adguard+agtree@3.1.3/node_modules/@adguard/agtree/dist/generator/misc/domain-list-generator.js
/*
 * AGTree v3.1.3 (build date: Tue, 29 Apr 2025 12:25:03 GMT)
 * (c) 2025 Adguard Software Ltd.
 * Released under the MIT license
 * https://github.com/AdguardTeam/tsurlfilter/tree/master/packages/agtree#readme
 */



/**
 * Domain list generator.
 */
class DomainListGenerator extends base_generator/* BaseGenerator */.t {
    /**
     * Converts a domain list node to a string.
     *
     * @param node Domain list node.
     *
     * @returns Raw string.
     */
    static generate(node) {
        return ListItemsGenerator.generate(node.children, node.separator);
    }
}



;// ./node_modules/.pnpm/@adguard+agtree@3.1.3/node_modules/@adguard/agtree/dist/generator/cosmetic/cosmetic-rule-pattern-generator.js
/*
 * AGTree v3.1.3 (build date: Tue, 29 Apr 2025 12:25:03 GMT)
 * (c) 2025 Adguard Software Ltd.
 * Released under the MIT license
 * https://github.com/AdguardTeam/tsurlfilter/tree/master/packages/agtree#readme
 */






/**
 * Cosmetic rule pattern generator.
 */
class CosmeticRulePatternGenerator extends base_generator/* BaseGenerator */.t {
    /**
     * Generates the rule pattern from the AST.
     *
     * @param node Cosmetic rule node
     * @returns Raw rule pattern
     * @example
     * - '##.foo' → ''
     * - 'example.com,example.org##.foo' → 'example.com,example.org'
     * - '[$path=/foo/bar]example.com##.foo' → '[$path=/foo/bar]example.com'
     */
    static generate(node) {
        let result = constants/* EMPTY */.wg;
        // AdGuard modifiers (if any)
        if (node.syntax === adblockers/* AdblockSyntax */.Y.Adg && node.modifiers && node.modifiers.children.length > 0) {
            result += constants/* OPEN_SQUARE_BRACKET */.cU;
            result += constants/* DOLLAR_SIGN */.nj;
            result += ModifierListGenerator.generate(node.modifiers);
            result += constants/* CLOSE_SQUARE_BRACKET */.A1;
        }
        // Domain list (if any)
        result += DomainListGenerator.generate(node.domains);
        return result;
    }
}



// EXTERNAL MODULE: ./node_modules/.pnpm/@adguard+agtree@3.1.3/node_modules/@adguard/agtree/dist/generator/cosmetic/cosmetic-rule-body-generator.js + 4 modules
var cosmetic_rule_body_generator = __webpack_require__(67918);
;// ./node_modules/.pnpm/@adguard+agtree@3.1.3/node_modules/@adguard/agtree/dist/generator/cosmetic/cosmetic-rule-generator.js
/*
 * AGTree v3.1.3 (build date: Tue, 29 Apr 2025 12:25:03 GMT)
 * (c) 2025 Adguard Software Ltd.
 * Released under the MIT license
 * https://github.com/AdguardTeam/tsurlfilter/tree/master/packages/agtree#readme
 */






/**
 * `CosmeticRuleGenerator` is responsible for generating cosmetic rules from their AST representation.
 *
 * This class takes a parsed cosmetic rule Abstract Syntax Tree (AST) and converts it back into a raw string format.
 * It handles the generation of the pattern, separator, uBO rule modifiers, and the rule body.
 */
class CosmeticRuleGenerator extends base_generator/* BaseGenerator */.t {
    /**
     * Converts a cosmetic rule AST into a string.
     *
     * @param node Cosmetic rule AST
     * @returns Raw string
     */
    static generate(node) {
        let result = constants/* EMPTY */.wg;
        // Pattern
        result += CosmeticRulePatternGenerator.generate(node);
        // Separator
        result += node.separator.value;
        // uBO rule modifiers
        if (node.syntax === adblockers/* AdblockSyntax */.Y.Ubo && node.modifiers) {
            node.modifiers.children.forEach((modifier) => {
                if (modifier.exception) {
                    result += constants/* COLON */.oH;
                    result += constants/* CSS_NOT_PSEUDO */.vr;
                    result += constants/* OPEN_PARENTHESIS */.Cx;
                }
                result += constants/* COLON */.oH;
                result += modifier.name.value;
                if (modifier.value) {
                    result += constants/* OPEN_PARENTHESIS */.Cx;
                    result += modifier.value.value;
                    result += constants/* CLOSE_PARENTHESIS */.s1;
                }
                if (modifier.exception) {
                    result += constants/* CLOSE_PARENTHESIS */.s1;
                }
            });
            // If there are at least one modifier, add a space
            if (node.modifiers.children.some((modifier) => modifier?.name.value)) {
                result += constants/* SPACE */.t6;
            }
        }
        // Body
        result += cosmetic_rule_body_generator/* CosmeticRuleBodyGenerator */.H.generate(node);
        return result;
    }
}



;// ./node_modules/.pnpm/@adguard+agtree@3.1.3/node_modules/@adguard/agtree/dist/generator/network/host-rule-generator.js
/*
 * AGTree v3.1.3 (build date: Tue, 29 Apr 2025 12:25:03 GMT)
 * (c) 2025 Adguard Software Ltd.
 * Released under the MIT license
 * https://github.com/AdguardTeam/tsurlfilter/tree/master/packages/agtree#readme
 */



/**
 * Generator for host rule nodes.
 */
class HostRuleGenerator extends base_generator/* BaseGenerator */.t {
    /**
     * Converts a host rule node to a raw string.
     *
     * @param node Host rule node.
     * @returns Raw string.
     */
    static generate(node) {
        const result = [];
        if (node.ip) {
            result.push(node.ip.value);
        }
        if (node.hostnames) {
            result.push(constants/* SPACE */.t6);
            result.push(node.hostnames.children.map(({ value }) => value).join(constants/* SPACE */.t6));
        }
        if (node.comment) {
            result.push(constants/* SPACE */.t6);
            result.push(constants/* HASHMARK */.C);
            result.push(constants/* SPACE */.t6);
            result.push(node.comment.value);
        }
        return result.join(constants/* EMPTY */.wg);
    }
}



;// ./node_modules/.pnpm/@adguard+agtree@3.1.3/node_modules/@adguard/agtree/dist/generator/network/network-rule-generator.js
/*
 * AGTree v3.1.3 (build date: Tue, 29 Apr 2025 12:25:03 GMT)
 * (c) 2025 Adguard Software Ltd.
 * Released under the MIT license
 * https://github.com/AdguardTeam/tsurlfilter/tree/master/packages/agtree#readme
 */




/**
 * Generator for network rule nodes.
 */
class NetworkRuleGenerator extends base_generator/* BaseGenerator */.t {
    /**
     * Generates a string from a network rule AST node.
     *
     * @param node Network rule node to generate a string from.
     * @returns Generated string representation of the network rule.
     */
    static generate(node) {
        let result = constants/* EMPTY */.wg;
        // If the rule is an exception, add the exception marker: `@@||example.org`
        if (node.exception) {
            result += constants/* NETWORK_RULE_EXCEPTION_MARKER */.rF;
        }
        // Add the pattern: `||example.org`
        result += node.pattern.value;
        // If there are modifiers, add a separator and the modifiers: `||example.org$important`
        if (node.modifiers && node.modifiers.children.length > 0) {
            result += constants/* NETWORK_RULE_SEPARATOR */.Xj;
            result += ModifierListGenerator.generate(node.modifiers);
        }
        return result;
    }
}



;// ./node_modules/.pnpm/@adguard+agtree@3.1.3/node_modules/@adguard/agtree/dist/generator/rule-generator.js
/*
 * AGTree v3.1.3 (build date: Tue, 29 Apr 2025 12:25:03 GMT)
 * (c) 2025 Adguard Software Ltd.
 * Released under the MIT license
 * https://github.com/AdguardTeam/tsurlfilter/tree/master/packages/agtree#readme
 */








/**
 * RuleGenerator is responsible for converting adblock rule ASTs to their string representation.
 */
class RuleGenerator extends base_generator/* BaseGenerator */.t {
    /**
     * Converts a rule AST to a string.
     *
     * @param ast - Adblock rule AST
     * @returns Raw string
     * @example
     * Take a look at the following example:
     * ```js
     * // Parse the rule to the AST
     * const ast = RuleParser.parse("example.org##.banner");
     * // Generate the rule from the AST
     * const raw = RuleParser.generate(ast);
     * // Print the generated rule
     * console.log(raw); // "example.org##.banner"
     * ```
     */
    static generate(ast) {
        switch (ast.category) {
            // Empty lines
            case nodes/* RuleCategory */.$O.Empty:
                return constants/* EMPTY */.wg;
            // Invalid rules
            case nodes/* RuleCategory */.$O.Invalid:
                return ast.raw;
            // Comment rules
            case nodes/* RuleCategory */.$O.Comment:
                return CommentRuleGenerator.generate(ast);
            // Cosmetic / non-basic rules
            case nodes/* RuleCategory */.$O.Cosmetic:
                return CosmeticRuleGenerator.generate(ast);
            // Network / basic rules
            case nodes/* RuleCategory */.$O.Network:
                switch (ast.type) {
                    case nodes/* NetworkRuleType */.vY.HostRule:
                        return HostRuleGenerator.generate(ast);
                    case nodes/* NetworkRuleType */.vY.NetworkRule:
                        return NetworkRuleGenerator.generate(ast);
                    default:
                        throw new Error('Unknown network rule type');
                }
            default:
                throw new Error('Unknown rule category');
        }
    }
}




/***/ }),

/***/ 23070:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   j: () => (/* binding */ AgentCommentMarshallingMap)
/* harmony export */ });
/*
 * AGTree v3.1.3 (build date: Tue, 29 Apr 2025 12:25:03 GMT)
 * (c) 2025 Adguard Software Ltd.
 * Released under the MIT license
 * https://github.com/AdguardTeam/tsurlfilter/tree/master/packages/agtree#readme
 */
/**
 * Property map for binary serialization. This helps to reduce the size of the serialized data,
 * as it allows us to use a single byte to represent a property.
 *
 * ! IMPORTANT: If you change values here, please update the {@link BINARY_SCHEMA_VERSION}!
 *
 * @note Only 256 values can be represented this way.
 */
const AgentCommentMarshallingMap = {
    Children: 1,
    Start: 2,
    End: 3,
};




/***/ }),

/***/ 60390:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   h: () => (/* binding */ FREQUENT_AGENTS_DESERIALIZATION_MAP),
/* harmony export */   o: () => (/* binding */ AgentNodeMarshallingMap)
/* harmony export */ });
/*
 * AGTree v3.1.3 (build date: Tue, 29 Apr 2025 12:25:03 GMT)
 * (c) 2025 Adguard Software Ltd.
 * Released under the MIT license
 * https://github.com/AdguardTeam/tsurlfilter/tree/master/packages/agtree#readme
 */
/**
 * Property map for binary serialization. This helps to reduce the size of the serialized data,
 * as it allows us to use a single byte to represent a property.
 *
 * ! IMPORTANT: If you change values here, please update the {@link BINARY_SCHEMA_VERSION}!
 *
 * @note Only 256 values can be represented this way.
 */
const AgentNodeMarshallingMap = {
    Adblock: 1,
    Version: 2,
    Start: 3,
    End: 4,
};
/**
 * Value map for binary deserialization. This helps to reduce the size of the serialized data,
 * as it allows us to use a single byte to represent frequently used values.
 */
const FREQUENT_AGENTS_DESERIALIZATION_MAP = new Map([
    // AdGuard
    [0, 'AdGuard'],
    [1, 'ADG'],
    // uBlock Origin
    [2, 'uBlock Origin'],
    [3, 'uBlock'],
    [4, 'uBO'],
    // Adblock Plus
    [5, 'Adblock Plus'],
    [6, 'AdblockPlus'],
    [7, 'ABP'],
    [8, 'AdBlock'],
]);




/***/ }),

/***/ 92379:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   E0: () => (/* binding */ ConfigCommentRuleMarshallingMap),
/* harmony export */   H4: () => (/* binding */ ConfigNodeMarshallingMap),
/* harmony export */   O6: () => (/* binding */ FREQUENT_COMMANDS_SERIALIZATION_MAP)
/* harmony export */ });
/*
 * AGTree v3.1.3 (build date: Tue, 29 Apr 2025 12:25:03 GMT)
 * (c) 2025 Adguard Software Ltd.
 * Released under the MIT license
 * https://github.com/AdguardTeam/tsurlfilter/tree/master/packages/agtree#readme
 */
/**
 * Property map for binary serialization. This helps to reduce the size of the serialized data,
 * as it allows us to use a single byte to represent a property.
 *
 * ! IMPORTANT: If you change values here, please update the {@link BINARY_SCHEMA_VERSION}!
 *
 * @note Only 256 values can be represented this way.
 */
const ConfigCommentRuleMarshallingMap = {
    Marker: 1,
    Command: 2,
    Params: 3,
    Comment: 4,
    Start: 5,
    End: 6,
};
/**
 * Property map for binary serialization. This helps to reduce the size of the serialized data,
 * as it allows us to use a single byte to represent a property.
 *
 * ! IMPORTANT: If you change values here, please update the {@link BINARY_SCHEMA_VERSION}!
 *
 * @note Only 256 values can be represented this way.
 */
const ConfigNodeMarshallingMap = {
    Value: 1,
    Start: 2,
    End: 3,
};
/**
 * Value map for binary serialization. This helps to reduce the size of the serialized data,
 * as it allows us to use a single byte to represent frequently used values.
 *
 * ! IMPORTANT: If you change values here, please update the {@link BINARY_SCHEMA_VERSION}!
 *
 * @note Only 256 values can be represented this way.
 *
 * @see {@link https://github.com/AdguardTeam/AGLint/blob/master/src/linter/inline-config.ts}
 */
const FREQUENT_COMMANDS_SERIALIZATION_MAP = new Map([
    ['aglint', 0],
    ['aglint-disable', 1],
    ['aglint-enable', 2],
    ['aglint-disable-next-line', 3],
    ['aglint-enable-next-line', 4],
]);




/***/ }),

/***/ 89518:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   r: () => (/* binding */ HintCommentMarshallingMap)
/* harmony export */ });
/*
 * AGTree v3.1.3 (build date: Tue, 29 Apr 2025 12:25:03 GMT)
 * (c) 2025 Adguard Software Ltd.
 * Released under the MIT license
 * https://github.com/AdguardTeam/tsurlfilter/tree/master/packages/agtree#readme
 */
/**
 * Property map for binary serialization. This helps to reduce the size of the serialized data,
 * as it allows us to use a single byte to represent a property.
 *
 * ! IMPORTANT: If you change values here, please update the {@link BINARY_SCHEMA_VERSION}!
 *
 * @note Only 256 values can be represented this way.
 */
const HintCommentMarshallingMap = {
    Syntax: 1,
    Children: 2,
    Start: 3,
    End: 4,
};




/***/ }),

/***/ 1622:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   EX: () => (/* binding */ FREQUENT_HINTS_SERIALIZATION_MAP),
/* harmony export */   QE: () => (/* binding */ FREQUENT_PLATFORMS_SERIALIZATION_MAP),
/* harmony export */   ae: () => (/* binding */ HintNodeMarshallingMap)
/* harmony export */ });
/*
 * AGTree v3.1.3 (build date: Tue, 29 Apr 2025 12:25:03 GMT)
 * (c) 2025 Adguard Software Ltd.
 * Released under the MIT license
 * https://github.com/AdguardTeam/tsurlfilter/tree/master/packages/agtree#readme
 */
/**
 * Property map for binary serialization. This helps to reduce the size of the serialized data,
 * as it allows us to use a single byte to represent a property.
 *
 * ! IMPORTANT: If you change values here, please update the {@link BINARY_SCHEMA_VERSION}!
 *
 * @note Only 256 values can be represented this way.
 */
const HintNodeMarshallingMap = {
    Name: 1,
    Params: 2,
    Start: 3,
    End: 4,
};
/**
 * Value map for binary serialization. This helps to reduce the size of the serialized data,
 * as it allows us to use a single byte to represent frequently used values.
 *
 * ! IMPORTANT: If you change values here, please update the {@link BINARY_SCHEMA_VERSION}!
 *
 * @note Only 256 values can be represented this way.
 */
const FREQUENT_HINTS_SERIALIZATION_MAP = new Map([
    ['NOT_OPTIMIZED', 0],
    ['PLATFORM', 1],
    ['NOT_PLATFORM', 2],
]);
/**
 * Value map for binary serialization. This helps to reduce the size of the serialized data,
 * as it allows us to use a single byte to represent frequently used values.
 *
 * ! IMPORTANT: If you change values here, please update the {@link BINARY_SCHEMA_VERSION}!
 *
 * @note Only 256 values can be represented this way.
 */
const FREQUENT_PLATFORMS_SERIALIZATION_MAP = new Map([
    ['windows', 0],
    ['mac', 1],
    ['android', 2],
    ['ios', 3],
    ['ext_chromium', 4],
    ['ext_ff', 5],
    ['ext_edge', 6],
    ['ext_opera', 7],
    ['ext_safari', 8],
    ['ext_android_cb', 9],
    ['ext_ublock', 10],
]);




/***/ }),

/***/ 218:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Z: () => (/* binding */ MetadataCommentMarshallingMap),
/* harmony export */   l: () => (/* binding */ FREQUENT_HEADERS_DESERIALIZATION_MAP)
/* harmony export */ });
/*
 * AGTree v3.1.3 (build date: Tue, 29 Apr 2025 12:25:03 GMT)
 * (c) 2025 Adguard Software Ltd.
 * Released under the MIT license
 * https://github.com/AdguardTeam/tsurlfilter/tree/master/packages/agtree#readme
 */
/**
 * Property map for binary serialization. This helps to reduce the size of the serialized data,
 * as it allows us to use a single byte to represent a property.
 *
 * ! IMPORTANT: If you change values here, please update the {@link BINARY_SCHEMA_VERSION}!
 *
 * @note Only 256 values can be represented this way.
 */
const MetadataCommentMarshallingMap = {
    Marker: 1,
    Header: 2,
    Value: 3,
    Start: 4,
    End: 5,
};
/**
 * Value map for binary deserialization. This helps to reduce the size of the serialized data,
 * as it allows us to use a single byte to represent frequently used values.
 */
const FREQUENT_HEADERS_DESERIALIZATION_MAP = new Map([
    [1, 'Checksum'],
    [2, 'Description'],
    [3, 'Expires'],
    [4, 'Homepage'],
    [5, 'Last Modified'],
    [6, 'LastModified'],
    [7, 'Licence'],
    [8, 'License'],
    [9, 'Time Updated'],
    [10, 'TimeUpdated'],
    [11, 'Version'],
    [12, 'Title'],
]);




/***/ }),

/***/ 3025:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Qz: () => (/* binding */ PreProcessorRuleMarshallingMap),
/* harmony export */   k7: () => (/* binding */ FREQUENT_PARAMS_SERIALIZATION_MAP),
/* harmony export */   u_: () => (/* binding */ FREQUENT_DIRECTIVES_SERIALIZATION_MAP)
/* harmony export */ });
/*
 * AGTree v3.1.3 (build date: Tue, 29 Apr 2025 12:25:03 GMT)
 * (c) 2025 Adguard Software Ltd.
 * Released under the MIT license
 * https://github.com/AdguardTeam/tsurlfilter/tree/master/packages/agtree#readme
 */
/**
 * Property map for binary serialization. This helps to reduce the size of the serialized data,
 * as it allows us to use a single byte to represent a property.
 *
 * ! IMPORTANT: If you change values here, please update the {@link BINARY_SCHEMA_VERSION}!
 *
 * @note Only 256 values can be represented this way.
 */
const PreProcessorRuleMarshallingMap = {
    Name: 1,
    Params: 2,
    Syntax: 3,
    Start: 4,
    End: 5,
};
/**
 * Value map for binary serialization. This helps to reduce the size of the serialized data,
 * as it allows us to use a single byte to represent frequently used values.
 *
 * ! IMPORTANT: If you change values here, please update the {@link BINARY_SCHEMA_VERSION}!
 *
 * @note Only 256 values can be represented this way.
 *
 * @see {@link https://adguard.com/kb/general/ad-filtering/create-own-filters/#preprocessor-directives}
 * @see {@link https://github.com/gorhill/uBlock/wiki/Static-filter-syntax#pre-parsing-directives}
 */
const FREQUENT_DIRECTIVES_SERIALIZATION_MAP = new Map([
    ['if', 0],
    ['else', 1],
    ['endif', 2],
    ['include', 3],
    ['safari_cb_affinity', 4],
]);
/**
 * Value map for binary serialization. This helps to reduce the size of the serialized data,
 * as it allows us to use a single byte to represent frequently used values.
 *
 * ! IMPORTANT: If you change values here, please update the {@link BINARY_SCHEMA_VERSION}!
 *
 * @note Only 256 values can be represented this way.
 */
const FREQUENT_PARAMS_SERIALIZATION_MAP = new Map([
    // safari_cb_affinity parameters
    ['general', 0],
    ['privacy', 1],
    ['social', 2],
    ['security', 3],
    ['other', 4],
    ['custom', 5],
    ['all', 6],
]);




/***/ }),

/***/ 94807:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   i: () => (/* binding */ SimpleCommentMarshallingMap)
/* harmony export */ });
/*
 * AGTree v3.1.3 (build date: Tue, 29 Apr 2025 12:25:03 GMT)
 * (c) 2025 Adguard Software Ltd.
 * Released under the MIT license
 * https://github.com/AdguardTeam/tsurlfilter/tree/master/packages/agtree#readme
 */
/**
 * Property map for binary serialization. This helps to reduce the size of the serialized data,
 * as it allows us to use a single byte to represent a property.
 *
 * ! IMPORTANT: If you change values here, please update the {@link BINARY_SCHEMA_VERSION}!
 *
 * @note Only 256 values can be represented this way.
 */
const SimpleCommentMarshallingMap = {
    Marker: 1,
    Text: 2,
    Start: 3,
    End: 4,
};




/***/ }),

/***/ 7552:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   T: () => (/* binding */ FREQUENT_ABP_SNIPPET_ARGS_SERIALIZATION_MAP),
/* harmony export */   f: () => (/* binding */ AbpSnippetBodyMarshallingMap)
/* harmony export */ });
/*
 * AGTree v3.1.3 (build date: Tue, 29 Apr 2025 12:25:03 GMT)
 * (c) 2025 Adguard Software Ltd.
 * Released under the MIT license
 * https://github.com/AdguardTeam/tsurlfilter/tree/master/packages/agtree#readme
 */
/**
 * Property map for binary serialization. This helps to reduce the size of the serialized data,
 * as it allows us to use a single byte to represent a property.
 *
 * ! IMPORTANT: If you change values here, please update the {@link BINARY_SCHEMA_VERSION}!
 *
 * @note Only 256 values can be represented this way.
 */
const AbpSnippetBodyMarshallingMap = {
    Children: 1,
    Start: 2,
    End: 3,
};
/**
 * Value map for binary serialization. This helps to reduce the size of the serialized data,
 * as it allows us to use a single byte to represent frequently used values.
 *
 * ! IMPORTANT: If you change values here, please update the {@link BINARY_SCHEMA_VERSION}!
 *
 * @note Only 256 values can be represented this way.
 */
// TODO: Update this map with the actual values
const FREQUENT_ABP_SNIPPET_ARGS_SERIALIZATION_MAP = new Map([
    ['abort-current-inline-script', 0],
    ['abort-on-property-read', 1],
    ['abort-on-property-write', 2],
    ['json-prune', 3],
    ['log', 4],
    ['prevent-listener', 5],
    ['cookie-remover', 6],
    ['override-property-read', 7],
    ['abort-on-iframe-property-read', 8],
    ['abort-on-iframe-property-write', 9],
    ['freeze-element', 10],
    ['json-override', 11],
    ['simulate-mouse-event', 12],
    ['strip-fetch-query-parameter', 13],
    ['hide-if-contains', 14],
    ['hide-if-contains-image', 15],
    ['hide-if-contains-image-hash', 16],
    ['hide-if-contains-similar-text', 17],
    ['hide-if-contains-visible-text', 18],
    ['hide-if-contains-and-matches-style', 19],
    ['hide-if-graph-matches', 20],
    ['hide-if-has-and-matches-style', 21],
    ['hide-if-labelled-by', 22],
    ['hide-if-matches-xpath', 23],
    ['hide-if-matches-computed-xpath', 24],
    ['hide-if-shadow-contains', 25],
    ['debug', 26],
    ['trace', 27],
    ['race', 28],
]);




/***/ }),

/***/ 15078:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   T: () => (/* binding */ FREQUENT_ADG_SCRIPTLET_ARGS_SERIALIZATION_MAP)
/* harmony export */ });
/*
 * AGTree v3.1.3 (build date: Tue, 29 Apr 2025 12:25:03 GMT)
 * (c) 2025 Adguard Software Ltd.
 * Released under the MIT license
 * https://github.com/AdguardTeam/tsurlfilter/tree/master/packages/agtree#readme
 */
/**
 * Value map for binary serialization. This helps to reduce the size of the serialized data,
 * as it allows us to use a single byte to represent frequently used values.
 *
 * ! IMPORTANT: If you change values here, please update the {@link BINARY_SCHEMA_VERSION}!
 *
 * @note Only 256 values can be represented this way.
 */
// TODO: Update this map with the actual values
const FREQUENT_ADG_SCRIPTLET_ARGS_SERIALIZATION_MAP = new Map([
    ['abort-current-inline-script', 0],
    ['abort-on-property-read', 1],
    ['abort-on-property-write', 2],
    ['abort-on-stack-trace', 3],
    ['adjust-setInterval', 4],
    ['adjust-setTimeout', 5],
    ['close-window', 6],
    ['debug-current-inline-script', 7],
    ['debug-on-property-read', 8],
    ['debug-on-property-write', 9],
    ['dir-string', 10],
    ['disable-newtab-links', 11],
    ['evaldata-prune', 12],
    ['json-prune', 13],
    ['log', 14],
    ['log-addEventListener', 15],
    ['log-eval', 16],
    ['log-on-stack-trace', 17],
    ['m3u-prune', 18],
    ['noeval', 19],
    ['nowebrtc', 20],
    ['no-topics', 21],
    ['prevent-addEventListener', 22],
    ['prevent-adfly', 23],
    ['prevent-bab', 24],
    ['prevent-eval-if', 25],
    ['prevent-fab-3.2.0', 26],
    ['prevent-fetch', 27],
    ['prevent-xhr', 28],
    ['prevent-popads-net', 29],
    ['prevent-refresh', 30],
    ['prevent-requestAnimationFrame', 31],
    ['prevent-setInterval', 32],
    ['prevent-setTimeout', 33],
    ['prevent-window-open', 34],
    ['remove-attr', 35],
    ['remove-class', 36],
    ['remove-cookie', 37],
    ['remove-node-text', 38],
    ['set-attr', 39],
    ['set-constant', 40],
    ['set-cookie', 41],
    ['set-cookie-reload', 42],
    ['set-local-storage-item', 43],
    ['set-popads-dummy', 44],
    ['set-session-storage-item', 45],
    ['xml-prune', 46],
]);




/***/ }),

/***/ 38950:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   V: () => (/* binding */ CssInjectionRuleMarshallingMap)
/* harmony export */ });
/*
 * AGTree v3.1.3 (build date: Tue, 29 Apr 2025 12:25:03 GMT)
 * (c) 2025 Adguard Software Ltd.
 * Released under the MIT license
 * https://github.com/AdguardTeam/tsurlfilter/tree/master/packages/agtree#readme
 */
/**
 * Property map for binary serialization. This helps to reduce the size of the serialized data,
 * as it allows us to use a single byte to represent a property.
 *
 * ! IMPORTANT: If you change values here, please update the {@link BINARY_SCHEMA_VERSION}!
 *
 * @note Only 256 values can be represented this way.
 */
const CssInjectionRuleMarshallingMap = {
    SelectorList: 1,
    DeclarationList: 2,
    MediaQueryList: 3,
    Remove: 4,
    Start: 5,
    End: 6,
};




/***/ }),

/***/ 66335:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   G: () => (/* binding */ ElementHidingRuleMarshallingMap)
/* harmony export */ });
/*
 * AGTree v3.1.3 (build date: Tue, 29 Apr 2025 12:25:03 GMT)
 * (c) 2025 Adguard Software Ltd.
 * Released under the MIT license
 * https://github.com/AdguardTeam/tsurlfilter/tree/master/packages/agtree#readme
 */
/**
 * Property map for binary serialization. This helps to reduce the size of the serialized data,
 * as it allows us to use a single byte to represent a property.
 *
 * ! IMPORTANT: If you change values here, please update the {@link BINARY_SCHEMA_VERSION}
 *
 * @note Only 256 values can be represented this way.
 */
const ElementHidingRuleMarshallingMap = {
    SelectorList: 1,
    Start: 2,
    End: 3,
};




/***/ }),

/***/ 26108:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Z: () => (/* binding */ FREQUENT_UBO_SCRIPTLET_ARGS_SERIALIZATION_MAP)
/* harmony export */ });
/*
 * AGTree v3.1.3 (build date: Tue, 29 Apr 2025 12:25:03 GMT)
 * (c) 2025 Adguard Software Ltd.
 * Released under the MIT license
 * https://github.com/AdguardTeam/tsurlfilter/tree/master/packages/agtree#readme
 */
/**
 * Value map for binary serialization. This helps to reduce the size of the serialized data,
 * as it allows us to use a single byte to represent frequently used values.
 *
 * ! IMPORTANT: If you change values here, please update the {@link BINARY_SCHEMA_VERSION}!
 *
 * @note Only 256 values can be represented this way.
 */
// TODO: Update this map with the actual values
const FREQUENT_UBO_SCRIPTLET_ARGS_SERIALIZATION_MAP = new Map([
    ['abort-current-script.js', 0],
    ['acs.js', 1],
    ['abort-current-inline-script.js', 2],
    ['acis.js', 3],
    ['abort-on-property-read.js', 4],
    ['aopr.js', 5],
    ['abort-on-property-write.js', 6],
    ['aopw.js', 7],
    ['abort-on-stack-trace.js', 8],
    ['aost.js', 9],
    ['adjust-setInterval.js', 10],
    ['nano-setInterval-booster.js', 11],
    ['nano-sib.js', 12],
    ['adjust-setTimeout.js', 13],
    ['nano-setTimeout-booster.js', 14],
    ['nano-stb.js', 15],
    ['close-window.js', 16],
    ['window-close-if.js', 17],
    ['disable-newtab-links.js', 18],
    ['evaldata-prune.js', 19],
    ['json-prune.js', 20],
    ['addEventListener-logger.js', 21],
    ['aell.js', 22],
    ['m3u-prune.js', 23],
    ['nowebrtc.js', 24],
    ['addEventListener-defuser.js', 25],
    ['aeld.js', 26],
    ['prevent-addEventListener.js', 27],
    ['adfly-defuser.js', 28],
    ['noeval-if.js', 29],
    ['prevent-eval-if.js', 30],
    ['no-fetch-if.js', 31],
    ['prevent-fetch.js', 32],
    ['no-xhr-if.js', 33],
    ['prevent-xhr.js', 34],
    ['prevent-refresh.js', 35],
    ['refresh-defuser.js', 36],
    ['no-requestAnimationFrame-if.js', 37],
    ['norafif.js', 38],
    ['prevent-requestAnimationFrame.js', 39],
    ['no-setInterval-if.js', 40],
    ['nosiif.js', 41],
    ['prevent-setInterval.js', 42],
    ['setInterval-defuser.js', 43],
    ['no-setTimeout-if.js', 44],
    ['nostif.js', 45],
    ['prevent-setTimeout.js', 46],
    ['setTimeout-defuser.js', 47],
    ['no-window-open-if.js', 48],
    ['nowoif.js', 49],
    ['prevent-window-open.js', 50],
    ['window.open-defuser.js', 51],
    ['remove-attr.js', 52],
    ['ra.js', 53],
    ['remove-class.js', 54],
    ['rc.js', 55],
    ['remove-cookie.js', 56],
    ['cookie-remover.js', 57],
    ['remove-node-text.js', 58],
    ['rmnt.js', 59],
    ['set-attr.js', 60],
    ['set-constant.js', 61],
    ['set.js', 62],
    ['set-cookie.js', 63],
    ['set-local-storage-item.js', 64],
    ['set-session-storage-item.js', 65],
    ['xml-prune.js', 66],
    ['webrtc-if.js', 67],
    ['overlay-buster.js', 68],
    ['alert-buster.js', 69],
    ['golem.de.js', 70],
    ['href-sanitizer.js', 71],
    ['call-nothrow.js', 72],
    ['window.name-defuser.js', 73],
    ['spoof-css.js', 74],
    ['trusted-set-constant.js', 75],
    ['trusted-set.js', 76],
    ['trusted-set-cookie.js', 77],
    ['trusted-set-local-storage-item.js', 78],
    ['trusted-replace-fetch-response.js', 79],
    ['json-prune-fetch-response.js', 80],
    ['json-prune-xhr-response.js', 81],
    ['trusted-replace-xhr-response.js', 82],
    ['multiup.js', 83],
    ['prevent-canvas.js', 84],
    ['set-cookie-reload.js', 85],
    ['trusted-set-cookie-reload.js', 86],
    ['trusted-click-element.js', 87],
    ['trusted-prune-inbound-object.js', 88],
    ['trusted-prune-outbound-object.js', 89],
    ['trusted-set-session-storage-item.js', 90],
    ['trusted-replace-node-text.js', 91],
    ['trusted-rpnt.js', 92],
    ['replace-node-text.js', 93],
    ['rpnt.js', 94],
]);




/***/ }),

/***/ 51787:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   U: () => (/* binding */ CosmeticRuleMarshallingMap),
/* harmony export */   h: () => (/* binding */ COSMETIC_RULE_SEPARATOR_SERIALIZATION_MAP)
/* harmony export */ });
/*
 * AGTree v3.1.3 (build date: Tue, 29 Apr 2025 12:25:03 GMT)
 * (c) 2025 Adguard Software Ltd.
 * Released under the MIT license
 * https://github.com/AdguardTeam/tsurlfilter/tree/master/packages/agtree#readme
 */
/**
 * Property map for binary serialization. This helps to reduce the size of the serialized data,
 * as it allows us to use a single byte to represent a property.
 *
 * ! IMPORTANT: If you change values here, please update the {@link BINARY_SCHEMA_VERSION}!
 *
 * @note Only 256 values can be represented this way.
 */
const CosmeticRuleMarshallingMap = {
    Exception: 2,
    Separator: 3,
    Modifiers: 4,
    Domains: 5,
    Start: 7,
    End: 8,
};
/**
 * Value map for binary serialization. This helps to reduce the size of the serialized data,
 * as it allows us to use a single byte to represent frequently used values.
 *
 * ! IMPORTANT: If you change values here, please update the {@link BINARY_SCHEMA_VERSION}!
 *
 * @note Only 256 values can be represented this way.
 */
const COSMETIC_RULE_SEPARATOR_SERIALIZATION_MAP = new Map([
    ['##', 0],
    ['#@#', 1],
    ['#?#', 2],
    ['#@?#', 3],
    ['#$#', 4],
    ['#$?#', 5],
    ['#@$#', 6],
    ['#@$?#', 7],
    ['#%#', 8],
    ['#@%#', 9],
    ['$$', 10],
    ['$@$', 11],
]);




/***/ }),

/***/ 42585:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   K: () => (/* binding */ EmptyRuleMarshallingMap)
/* harmony export */ });
/*
 * AGTree v3.1.3 (build date: Tue, 29 Apr 2025 12:25:03 GMT)
 * (c) 2025 Adguard Software Ltd.
 * Released under the MIT license
 * https://github.com/AdguardTeam/tsurlfilter/tree/master/packages/agtree#readme
 */
/**
 * Property map for binary serialization. This helps to reduce the size of the serialized data,
 * as it allows us to use a single byte to represent a property.
 *
 * ! IMPORTANT: If you change values here, please update the {@link BINARY_SCHEMA_VERSION}!
 *
 * @note Only 256 values can be represented this way.
 */
const EmptyRuleMarshallingMap = {
    Start: 1,
    End: 2,
};




/***/ }),

/***/ 33955:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   W: () => (/* binding */ InvalidRuleMarshallingMap)
/* harmony export */ });
/*
 * AGTree v3.1.3 (build date: Tue, 29 Apr 2025 12:25:03 GMT)
 * (c) 2025 Adguard Software Ltd.
 * Released under the MIT license
 * https://github.com/AdguardTeam/tsurlfilter/tree/master/packages/agtree#readme
 */
/**
 * Property map for binary serialization. This helps to reduce the size of the serialized data,
 * as it allows us to use a single byte to represent a property.
 *
 * ! IMPORTANT: If you change values here, please update the {@link BINARY_SCHEMA_VERSION}!!
 *
 * @note Only 256 values can be represented this way.
 */
const InvalidRuleMarshallingMap = {
    Error: 1,
    Start: 2,
    End: 3,
};




/***/ }),

/***/ 73561:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   K: () => (/* binding */ InvalidRuleErrorNodeMarshallingMap)
/* harmony export */ });
/*
 * AGTree v3.1.3 (build date: Tue, 29 Apr 2025 12:25:03 GMT)
 * (c) 2025 Adguard Software Ltd.
 * Released under the MIT license
 * https://github.com/AdguardTeam/tsurlfilter/tree/master/packages/agtree#readme
 */
/**
 * Property map for binary serialization. This helps to reduce the size of the serialized data,
 * as it allows us to use a single byte to represent a property.
 *
 * ! IMPORTANT: If you change values here, please update the {@link BINARY_SCHEMA_VERSION}!
 *
 * @note Only 256 values can be represented this way.
 */
const InvalidRuleErrorNodeMarshallingMap = {
    Name: 1,
    Message: 2,
    Start: 3,
    End: 4,
};




/***/ }),

/***/ 82938:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   u: () => (/* binding */ BinaryTypeMarshallingMap)
/* harmony export */ });
/*
 * AGTree v3.1.3 (build date: Tue, 29 Apr 2025 12:25:03 GMT)
 * (c) 2025 Adguard Software Ltd.
 * Released under the MIT license
 * https://github.com/AdguardTeam/tsurlfilter/tree/master/packages/agtree#readme
 */
/**
 * Type map for binary serialization.
 *
 * @note Values should be fit into 8 bits.
 */
const BinaryTypeMarshallingMap = {
    // Basic types
    Null: 1,
    // AGTree nodes
    FilterListNode: 8,
    EmptyRule: 9,
    InvalidRule: 10,
    CommentRuleNode: 11,
    AgentNode: 12,
    AgentRuleNode: 13,
    HintNode: 14,
    HintRuleNode: 15,
    MetadataCommentRuleNode: 16,
    ConfigCommentRuleNode: 17,
    PreProcessorCommentRuleNode: 18,
    ConfigNode: 19,
    NetworkRuleNode: 20,
    HostRuleNode: 21,
    ElementHidingRule: 22,
    CssInjectionRule: 23,
    ScriptletInjectionRule: 24,
    JsInjectionRule: 25,
    HtmlFilteringRule: 26,
    ScriptletInjectionRuleBodyNode: 27,
    ElementHidingRuleBody: 28,
    CssInjectionRuleBody: 29,
    ValueNode: 32,
    ModifierNode: 34,
    ModifierListNode: 35,
    ParameterListNode: 36,
    DomainListNode: 37,
    DomainNode: 38,
    MethodNode: 40,
    StealthOptionNode: 42,
    AppNode: 44,
    HostnameListNode: 45,
    InvalidRuleErrorNode: 46,
    ExpressionVariableNode: 47,
    ExpressionOperatorNode: 48,
    ExpressionParenthesisNode: 49,
};




/***/ }),

/***/ 53967:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   T: () => (/* binding */ DomainListMarshallingMap),
/* harmony export */   _: () => (/* binding */ SEPARATOR_SERIALIZATION_MAP)
/* harmony export */ });
/* harmony import */ var _utils_constants_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(27895);
/*
 * AGTree v3.1.3 (build date: Tue, 29 Apr 2025 12:25:03 GMT)
 * (c) 2025 Adguard Software Ltd.
 * Released under the MIT license
 * https://github.com/AdguardTeam/tsurlfilter/tree/master/packages/agtree#readme
 */


/**
 * Property map for binary serialization. This helps to reduce the size of the serialized data,
 * as it allows us to use a single byte to represent a property.
 *
 * ! IMPORTANT: If you change values here, please update the {@link BINARY_SCHEMA_VERSION}!
 *
 * @note Only 256 values can be represented this way.
 */
const DomainListMarshallingMap = {
    Separator: 1,
    Children: 2,
    Start: 3,
    End: 4,
};
/**
 * Value map for binary serialization. This helps to reduce the size of the serialized data,
 * as it allows us to use a single byte to represent frequently used values.
 *
 * ! IMPORTANT: If you change values here, please update the {@link BINARY_SCHEMA_VERSION}!
 *
 * @note Only 256 values can be represented this way.
 */
const SEPARATOR_SERIALIZATION_MAP = new Map([
    [_utils_constants_js__WEBPACK_IMPORTED_MODULE_0__/* .COMMA */ .KE, 0],
    [_utils_constants_js__WEBPACK_IMPORTED_MODULE_0__/* .PIPE */ .L5, 1],
]);




/***/ }),

/***/ 49107:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   J: () => (/* binding */ HostRuleMarshallingMap)
/* harmony export */ });
/*
 * AGTree v3.1.3 (build date: Tue, 29 Apr 2025 12:25:03 GMT)
 * (c) 2025 Adguard Software Ltd.
 * Released under the MIT license
 * https://github.com/AdguardTeam/tsurlfilter/tree/master/packages/agtree#readme
 */
/**
 * Property map for binary serialization. This helps to reduce the size of the serialized data,
 * as it allows us to use a single byte to represent a property.
 *
 * ! IMPORTANT: If you change values here, please update the {@link BINARY_SCHEMA_VERSION}!
 *
 * @note Only 256 values can be represented this way.
 */
const HostRuleMarshallingMap = {
    Syntax: 1,
    Ip: 3,
    HostnameList: 4,
    Comment: 5,
    Start: 6,
    End: 7,
};




/***/ }),

/***/ 28894:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   W: () => (/* binding */ HostnameListNodeMarshallingMap)
/* harmony export */ });
/*
 * AGTree v3.1.3 (build date: Tue, 29 Apr 2025 12:25:03 GMT)
 * (c) 2025 Adguard Software Ltd.
 * Released under the MIT license
 * https://github.com/AdguardTeam/tsurlfilter/tree/master/packages/agtree#readme
 */
/**
 * Property map for binary serialization. This helps to reduce the size of the serialized data,
 * as it allows us to use a single byte to represent a property.
 *
 * ! IMPORTANT: If you change values here, please update the {@link BINARY_SCHEMA_VERSION}!
 *
 * @note Only 256 values can be represented this way.
 */
const HostnameListNodeMarshallingMap = {
    Children: 1,
    Start: 2,
    End: 3,
};




/***/ }),

/***/ 4402:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   i: () => (/* binding */ ListItemMarshallingMap)
/* harmony export */ });
/*
 * AGTree v3.1.3 (build date: Tue, 29 Apr 2025 12:25:03 GMT)
 * (c) 2025 Adguard Software Ltd.
 * Released under the MIT license
 * https://github.com/AdguardTeam/tsurlfilter/tree/master/packages/agtree#readme
 */
/**
 * Property map for binary serialization. This helps to reduce the size of the serialized data,
 * as it allows us to use a single byte to represent a property.
 *
 * ! IMPORTANT: If you change values here, please update the {@link BINARY_SCHEMA_VERSION}!
 *
 * @note Only 256 values can be represented this way.
 */
const ListItemMarshallingMap = {
    Exception: 1,
    Value: 2,
    Start: 3,
    End: 4,
};




/***/ }),

/***/ 93828:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Tf: () => (/* binding */ VariableNodeBinaryPropMarshallingMap),
/* harmony export */   Y5: () => (/* binding */ KNOWN_VARIABLES_SERIALIZATION_MAP),
/* harmony export */   hc: () => (/* binding */ OperatorNodeBinaryPropMarshallingMap),
/* harmony export */   td: () => (/* binding */ LOGICAL_EXPRESSION_OPERATOR_SERIALISATION_MAP),
/* harmony export */   z0: () => (/* binding */ ParenthesisNodeBinaryPropMarshallingMap)
/* harmony export */ });
/* harmony import */ var _nodes_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(91354);
/*
 * AGTree v3.1.3 (build date: Tue, 29 Apr 2025 12:25:03 GMT)
 * (c) 2025 Adguard Software Ltd.
 * Released under the MIT license
 * https://github.com/AdguardTeam/tsurlfilter/tree/master/packages/agtree#readme
 */


/**
 * Property map for binary serialization.
 *
 * ! IMPORTANT: If you change values here, please update the {@link BINARY_SCHEMA_VERSION} !
 */
const VariableNodeBinaryPropMarshallingMap = {
    Name: 1,
    FrequentName: 2,
    Start: 3,
    End: 4,
};
/**
 * Property map for binary serialization.
 *
 * ! IMPORTANT: If you change values here, please update the {@link BINARY_SCHEMA_VERSION} !
 */
const OperatorNodeBinaryPropMarshallingMap = {
    Operator: 1,
    Left: 2,
    Right: 3,
    Start: 4,
    End: 5,
};
/**
 * Property map for binary serialization.
 *
 * ! IMPORTANT: If you change values here, please update the {@link BINARY_SCHEMA_VERSION} !
 */
const ParenthesisNodeBinaryPropMarshallingMap = {
    Expression: 1,
    Start: 2,
    End: 3,
};
/**
 * Property map for binary serialization.
 *
 * ! IMPORTANT: If you change values here, please update the {@link BINARY_SCHEMA_VERSION} !
 */
const LOGICAL_EXPRESSION_OPERATOR_SERIALISATION_MAP = new Map([
    [_nodes_index_js__WEBPACK_IMPORTED_MODULE_0__/* .OperatorValue */ .oC.Not, 0],
    [_nodes_index_js__WEBPACK_IMPORTED_MODULE_0__/* .OperatorValue */ .oC.And, 1],
    [_nodes_index_js__WEBPACK_IMPORTED_MODULE_0__/* .OperatorValue */ .oC.Or, 2],
]);
/**
 * Serialization map for known variables.
 */
const KNOWN_VARIABLES_SERIALIZATION_MAP = new Map([
    ['ext_abp', 0],
    ['ext_ublock', 1],
    ['ext_ubol', 2],
    ['ext_devbuild', 3],
    ['env_chromium', 4],
    ['env_edge', 5],
    ['env_firefox', 6],
    ['env_mobile', 7],
    ['env_safari', 8],
    ['env_mv3', 9],
    ['false', 10],
    ['cap_html_filtering', 11],
    ['cap_user_stylesheet', 12],
    ['adguard', 13],
    ['adguard_app_windows', 14],
    ['adguard_app_mac', 15],
    ['adguard_app_android', 16],
    ['adguard_app_ios', 17],
    ['adguard_ext_safari', 18],
    ['adguard_ext_chromium', 19],
    ['adguard_ext_firefox', 20],
    ['adguard_ext_edge', 21],
    ['adguard_ext_opera', 22],
    ['adguard_ext_android_cb', 23],
    // TODO: Add 'adguard_ext_chromium_mv3' to the list
]);




/***/ }),

/***/ 42471:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   sD: () => (/* binding */ ModifierNodeMarshallingMap),
/* harmony export */   uu: () => (/* binding */ FREQUENT_MODIFIERS_SERIALIZATION_MAP),
/* harmony export */   vG: () => (/* binding */ FREQUENT_REDIRECT_MODIFIERS_SERIALIZATION_MAP)
/* harmony export */ });
/* unused harmony export FREQUENT_REDIRECT_VALUES_SERIALIZATION_MAP */
/*
 * AGTree v3.1.3 (build date: Tue, 29 Apr 2025 12:25:03 GMT)
 * (c) 2025 Adguard Software Ltd.
 * Released under the MIT license
 * https://github.com/AdguardTeam/tsurlfilter/tree/master/packages/agtree#readme
 */
/**
 * Property map for binary serialization. This helps to reduce the size of the serialized data,
 * as it allows us to use a single byte to represent a property.
 *
 * ! IMPORTANT: If you change values here, please update the {@link BINARY_SCHEMA_VERSION}!
 *
 * @note Only 256 values can be represented this way.
 */
const ModifierNodeMarshallingMap = {
    Name: 1,
    Value: 2,
    Exception: 3,
    Start: 4,
    End: 5,
};
/**
 * Value map for binary serialization. This helps to reduce the size of the serialized data,
 * as it allows us to use a single byte to represent frequently used values.
 *
 * ! IMPORTANT: If you change values here, please update the {@link BINARY_SCHEMA_VERSION}!
 *
 * @note Only 256 values can be represented this way.
 */
const FREQUENT_MODIFIERS_SERIALIZATION_MAP = new Map([
    ['_', 0],
    ['all', 1],
    ['app', 2],
    ['badfilter', 3],
    ['cname', 4],
    ['content', 5],
    ['cookie', 6],
    ['csp', 7],
    ['denyallow', 8],
    ['document', 9],
    ['doc', 10],
    ['domain', 11],
    ['from', 12],
    ['elemhide', 13],
    ['ehide', 14],
    ['empty', 15],
    ['first-party', 16],
    ['1p', 17],
    ['extension', 18],
    ['font', 19],
    ['genericblock', 20],
    ['generichide', 21],
    ['ghide', 22],
    ['header', 23],
    ['hls', 24],
    ['image', 25],
    ['important', 26],
    ['inline-font', 27],
    ['inline-script', 28],
    ['jsinject', 29],
    ['jsonprune', 30],
    ['match-case', 31],
    ['media', 32],
    ['method', 33],
    ['mp4', 34],
    ['network', 35],
    ['object-subrequest', 36],
    ['object', 37],
    ['other', 38],
    ['permissions', 39],
    ['ping', 40],
    ['popunder', 41],
    ['popup', 42],
    ['redirect-rule', 43],
    ['redirect', 44],
    ['rewrite', 45],
    ['referrerpolicy', 46],
    ['removeheader', 47],
    ['removeparam', 48],
    ['replace', 49],
    ['script', 50],
    ['specifichide', 51],
    ['shide', 52],
    ['stealth', 53],
    ['strict1p', 54],
    ['strict3p', 55],
    ['stylesheet', 56],
    ['css', 57],
    ['subdocument', 58],
    ['frame', 59],
    ['third-party', 60],
    ['3p', 61],
    ['to', 62],
    ['urlblock', 63],
    ['webrtc', 64],
    ['websocket', 65],
    ['xmlhttprequest', 66],
    ['xhr', 67],
    // TODO: add new modifiers here
]);
/**
 * Value map for binary serialization. This helps to reduce the size of the serialized data,
 * as it allows us to use a single byte to represent frequently used values.
 *
 * ! IMPORTANT: If you change values here, please update the binary schema version
 *
 * @note Only 256 values can be represented this way.
 */
const FREQUENT_REDIRECT_VALUES_SERIALIZATION_MAP = new Map([
    // AdGuard
    ['1x1-transparent.gif', 0],
    ['2x2-transparent.png', 1],
    ['3x2-transparent.png', 2],
    ['32x32-transparent.png', 3],
    ['amazon-apstag', 4],
    ['ati-smarttag', 5],
    ['didomi-loader', 6],
    ['click2load.html', 7],
    ['fingerprintjs2', 8],
    ['fingerprintjs3', 9],
    ['google-analytics', 10],
    ['google-analytics-ga', 11],
    ['googlesyndication-adsbygoogle', 12],
    ['googlesyndication-adsbygoogle', 13],
    ['googletagmanager-gtm', 14],
    ['googletagmanager-gtm', 15],
    ['googletagservices-gpt', 16],
    ['google-ima3', 17],
    ['gemius', 18],
    ['matomo', 19],
    ['metrika-yandex-watch', 20],
    ['metrika-yandex-tag', 21],
    ['naver-wcslog', 22],
    ['noeval', 23],
    ['noopcss', 24],
    ['noopframe', 25],
    ['noopjs', 26],
    ['noopjson', 27],
    ['nooptext', 28],
    ['noopmp3-0.1s', 29],
    ['noopmp4-1s', 30],
    ['noopvmap-1.0', 31],
    ['noopvast-2.0', 32],
    ['noopvast-3.0', 33],
    ['noopvast-4.0', 34],
    ['prebid', 35],
    ['pardot-1.0', 36],
    ['prevent-bab', 37],
    ['prevent-bab2', 38],
    ['prevent-fab-3.2.0', 39],
    ['prevent-fab-3.2.0', 40],
    ['prevent-popads-net', 41],
    ['scorecardresearch-beacon', 42],
    ['set-popads-dummy', 43],
    ['empty', 44],
    ['prebid-ads', 45],
    // empty slots for future use
    // uBlock Origin
    ['1x1.gif', 60],
    ['2x2.png', 61],
    ['3x2.png', 62],
    ['32x32.png', 63],
    ['amazon_apstag.js', 64],
    ['click2load.html', 65],
    ['fingerprint2.js', 66],
    ['fingerprint3.js', 67],
    ['google-analytics_analytics.js', 68],
    ['google-analytics_ga.js', 69],
    ['googlesyndication_adsbygoogle.js', 70],
    ['googlesyndication.com/adsbygoogle.js', 71],
    ['google-analytics_ga.js', 72],
    ['googletagmanager_gtm.js', 73],
    ['googletagservices_gpt.js', 74],
    ['google-ima.js', 75],
    ['noeval-silent.js', 76],
    ['noop.css', 77],
    ['noop.html', 78],
    ['noop.js', 79],
    ['noop.json', 80],
    ['noop.txt', 81],
    ['noop-0.1s.mp3', 82],
    ['noop-1s.mp4', 83],
    ['noop-vmap1.0.xml', 84],
    ['nobab.js', 85],
    ['nobab2.js', 86],
    ['nofab.js', 87],
    ['fuckadblock.js-3.2.0', 88],
    ['popads.js', 89],
    ['scorecardresearch_beacon.js', 90],
    ['popads-dummy.js', 91],
    ['empty', 92],
    ['prebid-ads.js', 93],
    // empty slots for future use
    // Adblock Plus
    ['1x1-transparent-gif', 105],
    ['2x2-transparent-png', 106],
    ['3x2-transparent-png', 107],
    ['32x32-transparent-png', 108],
    ['blank-css', 109],
    ['blank-html', 110],
    ['blank-js', 111],
    ['blank-text', 112],
    ['blank-mp3', 113],
    ['blank-mp4', 114],
    // empty slots for future use
    ['abp-resource:1x1-transparent-gif', 120],
    ['abp-resource:2x2-transparent-png', 121],
    ['abp-resource:3x2-transparent-png', 122],
    ['abp-resource:32x32-transparent-png', 123],
    ['abp-resource:blank-css', 124],
    ['abp-resource:blank-html', 125],
    ['abp-resource:blank-js', 126],
    ['abp-resource:blank-text', 127],
    ['abp-resource:blank-mp3', 128],
    ['abp-resource:blank-mp4', 129],
    // TODO: add other common values
]);
/**
 * Value map for binary serialization. This helps to reduce the size of the serialized data,
 * as it allows us to use a single byte to represent frequently used values.
 *
 * @note This is a special map which allows us to use different value maps for different modifiers.
 */
const FREQUENT_REDIRECT_MODIFIERS_SERIALIZATION_MAP = new Map([
    ['redirect', FREQUENT_REDIRECT_VALUES_SERIALIZATION_MAP],
    ['redirect-rule', FREQUENT_REDIRECT_VALUES_SERIALIZATION_MAP],
    ['rewrite', FREQUENT_REDIRECT_VALUES_SERIALIZATION_MAP],
    // TODO: Add other modifiers here
]);




/***/ }),

/***/ 26882:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   I: () => (/* binding */ ModifierListNodeMarshallingMap)
/* harmony export */ });
/*
 * AGTree v3.1.3 (build date: Tue, 29 Apr 2025 12:25:03 GMT)
 * (c) 2025 Adguard Software Ltd.
 * Released under the MIT license
 * https://github.com/AdguardTeam/tsurlfilter/tree/master/packages/agtree#readme
 */
/**
 * Property map for binary serialization. This helps to reduce the size of the serialized data,
 * as it allows us to use a single byte to represent a property.
 *
 * ! IMPORTANT: If you change values here, please update the {@link BINARY_SCHEMA_VERSION}!
 *
 * @note Only 256 values can be represented this way.
 */
const ModifierListNodeMarshallingMap = {
    Children: 1,
    Start: 2,
    End: 3,
};




/***/ }),

/***/ 21434:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   _: () => (/* binding */ ParameterListNodeMarshallingMap)
/* harmony export */ });
/*
 * AGTree v3.1.3 (build date: Tue, 29 Apr 2025 12:25:03 GMT)
 * (c) 2025 Adguard Software Ltd.
 * Released under the MIT license
 * https://github.com/AdguardTeam/tsurlfilter/tree/master/packages/agtree#readme
 */
/**
 * Property map for binary serialization. This helps to reduce the size of the serialized data,
 * as it allows us to use a single byte to represent a property.
 *
 * ! IMPORTANT: If you change values here, please update the {@link BINARY_SCHEMA_VERSION}!
 *
 * @note Only 256 values can be represented this way.
 */
const ParameterListNodeMarshallingMap = {
    Children: 1,
    Start: 2,
    End: 3,
};




/***/ }),

/***/ 54749:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   e: () => (/* binding */ ValueNodeMarshallingMap)
/* harmony export */ });
/*
 * AGTree v3.1.3 (build date: Tue, 29 Apr 2025 12:25:03 GMT)
 * (c) 2025 Adguard Software Ltd.
 * Released under the MIT license
 * https://github.com/AdguardTeam/tsurlfilter/tree/master/packages/agtree#readme
 */
/**
 * Property map for binary serialization. This helps to reduce the size of the serialized data,
 * as it allows us to use a single byte to represent a property.
 *
 * ! IMPORTANT: If you change values here, please update the {@link BINARY_SCHEMA_VERSION}!
 *
 * @note Only 256 values can be represented this way.
 */
const ValueNodeMarshallingMap = {
    Value: 1,
    FrequentValue: 2,
    Start: 3,
    End: 4,
};




/***/ }),

/***/ 1447:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   v: () => (/* binding */ NetworkRuleMarshallingMap)
/* harmony export */ });
/*
 * AGTree v3.1.3 (build date: Tue, 29 Apr 2025 12:25:03 GMT)
 * (c) 2025 Adguard Software Ltd.
 * Released under the MIT license
 * https://github.com/AdguardTeam/tsurlfilter/tree/master/packages/agtree#readme
 */
/**
 * Property map for binary serialization. This helps to reduce the size of the serialized data,
 * as it allows us to use a single byte to represent a property.
 *
 * ! IMPORTANT: If you change values here, please update the {@link BINARY_SCHEMA_VERSION}!
 *
 * @note Only 256 values can be represented this way.
 */
const NetworkRuleMarshallingMap = {
    Syntax: 1,
    Exception: 3,
    Pattern: 4,
    ModifierList: 5,
    Start: 6,
    End: 7,
};




/***/ }),

/***/ 42912:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   M: () => (/* binding */ getSyntaxSerializationMap)
/* harmony export */ });
/* harmony import */ var _utils_adblockers_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(73734);
/*
 * AGTree v3.1.3 (build date: Tue, 29 Apr 2025 12:25:03 GMT)
 * (c) 2025 Adguard Software Ltd.
 * Released under the MIT license
 * https://github.com/AdguardTeam/tsurlfilter/tree/master/packages/agtree#readme
 */


/**
 * Value map for binary serialization. This helps to reduce the size of the serialized data,
 * as it allows us to use a single byte to represent frequently used values.
 *
 * ! IMPORTANT: If you change values here, please update the {@link BINARY_SCHEMA_VERSION}!
 *
 * @note Only 256 values can be represented this way.
 */
let syntaxSerializationMap;
const getSyntaxSerializationMap = () => {
    if (!syntaxSerializationMap) {
        syntaxSerializationMap = new Map([
            [_utils_adblockers_js__WEBPACK_IMPORTED_MODULE_0__/* .AdblockSyntax */ .Y.Common, 0],
            [_utils_adblockers_js__WEBPACK_IMPORTED_MODULE_0__/* .AdblockSyntax */ .Y.Abp, 1],
            [_utils_adblockers_js__WEBPACK_IMPORTED_MODULE_0__/* .AdblockSyntax */ .Y.Adg, 2],
            [_utils_adblockers_js__WEBPACK_IMPORTED_MODULE_0__/* .AdblockSyntax */ .Y.Ubo, 3],
        ]);
    }
    return syntaxSerializationMap;
};




/***/ }),

/***/ 91354:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   $O: () => (/* binding */ RuleCategory),
/* harmony export */   WR: () => (/* binding */ ListItemNodeType),
/* harmony export */   gV: () => (/* binding */ CommentRuleType),
/* harmony export */   h6: () => (/* binding */ ListNodeType),
/* harmony export */   k9: () => (/* binding */ CosmeticRuleType),
/* harmony export */   oC: () => (/* binding */ OperatorValue),
/* harmony export */   p5: () => (/* binding */ CosmeticRuleSeparator),
/* harmony export */   vY: () => (/* binding */ NetworkRuleType),
/* harmony export */   yg: () => (/* binding */ CommentMarker)
/* harmony export */ });
/*
 * AGTree v3.1.3 (build date: Tue, 29 Apr 2025 12:25:03 GMT)
 * (c) 2025 Adguard Software Ltd.
 * Released under the MIT license
 * https://github.com/AdguardTeam/tsurlfilter/tree/master/packages/agtree#readme
 */
const OperatorValue = {
    Not: '!',
    And: '&&',
    Or: '||',
};
/**
 * Represents the different comment markers that can be used in an adblock rule.
 *
 * @example
 * - If the rule is `! This is just a comment`, then the marker will be `!`.
 * - If the rule is `# This is just a comment`, then the marker will be `#`.
 */
const CommentMarker = {
    /**
     * Regular comment marker. It is supported by all ad blockers.
     */
    Regular: '!',
    /**
     * Hashmark comment marker. It is supported by uBlock Origin and AdGuard,
     * and also used in hosts files.
     */
    Hashmark: '#',
};
/**
 * Represents the main categories that an adblock rule can belong to.
 * Of course, these include additional subcategories.
 */
const RuleCategory = {
    /**
     * Empty "rules" that are only containing whitespaces. These rules are handled just for convenience.
     */
    Empty: 'Empty',
    /**
     * Syntactically invalid rules (tolerant mode only).
     */
    Invalid: 'Invalid',
    /**
     * Comment rules, such as comment rules, metadata rules, preprocessor rules, etc.
     */
    Comment: 'Comment',
    /**
     * Cosmetic rules, such as element hiding rules, CSS rules, scriptlet rules, HTML rules, and JS rules.
     */
    Cosmetic: 'Cosmetic',
    /**
     * Network rules, such as basic network rules, header remover network rules, redirect network rules,
     * response header filtering rules, etc.
     */
    Network: 'Network',
};
/**
 * Represents similar types of modifiers values
 * which may be separated by a comma `,` (only for DomainList) or a pipe `|`.
 */
const ListNodeType = {
    AppList: 'AppList',
    DomainList: 'DomainList',
    MethodList: 'MethodList',
    StealthOptionList: 'StealthOptionList',
};
/**
 * Represents child items for {@link ListNodeType}.
 */
const ListItemNodeType = {
    Unknown: 'Unknown',
    App: 'App',
    Domain: 'Domain',
    Method: 'Method',
    StealthOption: 'StealthOption',
};
/**
 * Represents possible comment types.
 */
const CommentRuleType = {
    AgentCommentRule: 'AgentCommentRule',
    CommentRule: 'CommentRule',
    ConfigCommentRule: 'ConfigCommentRule',
    HintCommentRule: 'HintCommentRule',
    MetadataCommentRule: 'MetadataCommentRule',
    PreProcessorCommentRule: 'PreProcessorCommentRule',
};
/**
 * Represents possible cosmetic rule types.
 */
const CosmeticRuleType = {
    ElementHidingRule: 'ElementHidingRule',
    CssInjectionRule: 'CssInjectionRule',
    ScriptletInjectionRule: 'ScriptletInjectionRule',
    HtmlFilteringRule: 'HtmlFilteringRule',
    JsInjectionRule: 'JsInjectionRule',
};
/**
 * Represents possible cosmetic rule separators.
 */
const CosmeticRuleSeparator = {
    /**
     * @see {@link https://help.eyeo.com/adblockplus/how-to-write-filters#elemhide_basic}
     */
    ElementHiding: '##',
    /**
     * @see {@link https://help.eyeo.com/adblockplus/how-to-write-filters#elemhide_basic}
     */
    ElementHidingException: '#@#',
    /**
     * @see {@link https://help.eyeo.com/adblockplus/how-to-write-filters#elemhide_basic}
     */
    ExtendedElementHiding: '#?#',
    /**
     * @see {@link https://help.eyeo.com/adblockplus/how-to-write-filters#elemhide_basic}
     */
    ExtendedElementHidingException: '#@?#',
    /**
     * @see {@link https://help.eyeo.com/adblockplus/how-to-write-filters#elemhide_basic}
     */
    AbpSnippet: '#$#',
    /**
     * @see {@link https://help.eyeo.com/adblockplus/how-to-write-filters#elemhide_basic}
     */
    AbpSnippetException: '#@$#',
    /**
     * @see {@link https://kb.adguard.com/en/general/how-to-create-your-own-ad-filters#cosmetic-css-rules}
     */
    AdgCssInjection: '#$#',
    /**
     * @see {@link https://kb.adguard.com/en/general/how-to-create-your-own-ad-filters#cosmetic-css-rules}
     */
    AdgCssInjectionException: '#@$#',
    /**
     * @see {@link https://kb.adguard.com/en/general/how-to-create-your-own-ad-filters#cosmetic-css-rules}
     */
    AdgExtendedCssInjection: '#$?#',
    /**
     * @see {@link https://kb.adguard.com/en/general/how-to-create-your-own-ad-filters#cosmetic-css-rules}
     */
    AdgExtendedCssInjectionException: '#@$?#',
    /**
     * @see {@link https://kb.adguard.com/en/general/how-to-create-your-own-ad-filters#scriptlets}
     */
    AdgJsInjection: '#%#',
    /**
     * @see {@link https://kb.adguard.com/en/general/how-to-create-your-own-ad-filters#scriptlets}
     */
    AdgJsInjectionException: '#@%#',
    /**
     * @see {@link https://kb.adguard.com/en/general/how-to-create-your-own-ad-filters#html-filtering-rules}
     */
    AdgHtmlFiltering: '$$',
    /**
     * @see {@link https://kb.adguard.com/en/general/how-to-create-your-own-ad-filters#html-filtering-rules}
     */
    AdgHtmlFilteringException: '$@$',
};
/**
 * Represents the different types of network rules.
 */
const NetworkRuleType = {
    NetworkRule: 'NetworkRule',
    HostRule: 'HostRule',
};




/***/ }),

/***/ 21593:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   V: () => (/* binding */ BaseParser)
/* harmony export */ });
/* harmony import */ var _errors_not_implemented_error_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(74173);
/*
 * AGTree v3.1.3 (build date: Tue, 29 Apr 2025 12:25:03 GMT)
 * (c) 2025 Adguard Software Ltd.
 * Released under the MIT license
 * https://github.com/AdguardTeam/tsurlfilter/tree/master/packages/agtree#readme
 */


/**
 * @file Base parser class.
 */
/**
 * Base class for parsers. Each parser should extend this class.
 */
class BaseParser {
    /**
     * Parses the input string and returns the AST node.
     *
     * @param input Input string to parse.
     * @param options Parser options, see {@link ParserOptions}.
     * @param baseOffset Base offset. Locations in the AST node will be relative to this offset.
     * @param args Additional, parser-specific arguments, if needed.
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    static parse(input, options, baseOffset, ...args) {
        throw new _errors_not_implemented_error_js__WEBPACK_IMPORTED_MODULE_0__/* .NotImplementedError */ .E();
    }
}




/***/ }),

/***/ 95452:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   FH: () => (/* binding */ REMOVE_VALUE),
/* harmony export */   JX: () => (/* binding */ REMOVE_PROPERTY),
/* harmony export */   Ye: () => (/* binding */ AdgCssInjectionParser)
/* harmony export */ });
/* unused harmony export ERROR_MESSAGES */
/* harmony import */ var _adguard_css_tokenizer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(25651);
/* harmony import */ var _errors_adblock_syntax_error_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(23029);
/* harmony import */ var _utils_constants_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(27895);
/* harmony import */ var _css_token_stream_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(6034);
/* harmony import */ var _options_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(49604);
/* harmony import */ var _base_parser_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(21593);
/*
 * AGTree v3.1.3 (build date: Tue, 29 Apr 2025 12:25:03 GMT)
 * (c) 2025 Adguard Software Ltd.
 * Released under the MIT license
 * https://github.com/AdguardTeam/tsurlfilter/tree/master/packages/agtree#readme
 */







/**
 * @file Parser for AdGuard CSS injections.
 */
const REMOVE_PROPERTY = 'remove';
const REMOVE_VALUE = 'true';
const ERROR_MESSAGES = {
    MEDIA_QUERY_LIST_IS_EMPTY: 'Media query list is empty',
    SELECTOR_LIST_IS_EMPTY: 'Selector list is empty',
    DECLARATION_LIST_IS_EMPTY: 'Declaration list is empty',
};
/**
 * Parser for AdGuard CSS injection.
 */
class AdgCssInjectionParser extends _base_parser_js__WEBPACK_IMPORTED_MODULE_1__/* .BaseParser */ .V {
    /**
     * Parses an AdGuard CSS injection.
     *
     * @param raw Raw input to parse.
     * @param options Global parser options.
     * @param baseOffset Starting offset of the input. Node locations are calculated relative to this offset.
     *
     * @returns Parsed AdGuard CSS injection {@link CssInjectionRuleBody}.
     * @throws An {@link AdblockSyntaxError} if the selector list is syntactically invalid.
     */
    static parse(raw, options = _options_js__WEBPACK_IMPORTED_MODULE_2__/* .defaultParserOptions */ .n, baseOffset = 0) {
        let mediaQueryList;
        const selectorList = { type: 'Value', value: _utils_constants_js__WEBPACK_IMPORTED_MODULE_3__/* .EMPTY */ .wg };
        const declarationList = { type: 'Value', value: _utils_constants_js__WEBPACK_IMPORTED_MODULE_3__/* .EMPTY */ .wg };
        const stream = new _css_token_stream_js__WEBPACK_IMPORTED_MODULE_4__/* .CssTokenStream */ .d(raw, baseOffset);
        // Skip leading whitespace characters
        stream.skipWhitespace();
        // We have two possible CSS injection formats:
        // 1. @media (media-query-list) { selector list { declarations separated by semicolons } }
        // 2. selector list { declarations separated by semicolons }
        // Handle '@media' case:
        let balanceShift = 0;
        if (stream.getOrFail().type === _adguard_css_tokenizer__WEBPACK_IMPORTED_MODULE_0__/* .TokenType */ .ks.AtKeyword) {
            // Currently only '@media' is supported, we should throw an error if we encounter anything else,
            // like '@supports' or '@charset', etc.
            stream.expect(_adguard_css_tokenizer__WEBPACK_IMPORTED_MODULE_0__/* .TokenType */ .ks.AtKeyword, { value: _utils_constants_js__WEBPACK_IMPORTED_MODULE_3__/* .CSS_MEDIA_MARKER */ .Ae, balance: 0 });
            stream.advance();
            // Skip whitespace characters after @media keyword, if any
            // @media (media-query-list) { ...
            //       ↑
            //       └ this one (if any)
            stream.skipWhitespace();
            const mediaQueryListStart = stream.getOrFail().start;
            // Skip everything until we found the opening curly bracket of the declaration block
            // @media media-query-list { ...
            //                         ↑
            //                         └ this one
            let lastNonWsIndex = -1;
            while (!stream.isEof()) {
                const token = stream.getOrFail();
                if (token.type === _adguard_css_tokenizer__WEBPACK_IMPORTED_MODULE_0__/* .TokenType */ .ks.OpenCurlyBracket && token.balance === 1) {
                    break;
                }
                if (token.type !== _adguard_css_tokenizer__WEBPACK_IMPORTED_MODULE_0__/* .TokenType */ .ks.Whitespace) {
                    lastNonWsIndex = token.end;
                }
                stream.advance();
            }
            // If the skipped tokens count is 0 without leading and trailing whitespace characters, then the media query
            // list is empty
            if (lastNonWsIndex === -1) {
                throw new _errors_adblock_syntax_error_js__WEBPACK_IMPORTED_MODULE_5__/* .AdblockSyntaxError */ .q(ERROR_MESSAGES.MEDIA_QUERY_LIST_IS_EMPTY, baseOffset + mediaQueryListStart, baseOffset + raw.length);
            }
            // It is safe to use non-null assertion here, because we have already checked previous tokens.
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            const mediaQueryListEnd = lastNonWsIndex;
            mediaQueryList = {
                type: 'Value',
                value: raw.slice(mediaQueryListStart, mediaQueryListEnd),
            };
            if (options.isLocIncluded) {
                mediaQueryList.start = baseOffset + mediaQueryListStart;
                mediaQueryList.end = baseOffset + mediaQueryListEnd;
            }
            // Next token should be an open curly bracket
            // @media (media-query-list) { ...
            //                           ↑
            //                           └ this one
            stream.expect(_adguard_css_tokenizer__WEBPACK_IMPORTED_MODULE_0__/* .TokenType */ .ks.OpenCurlyBracket);
            stream.advance();
            // '@media' at-rule wrap increases the balance level by 1 for the rule within the at-rule, because it
            // has its own { ... } block
            balanceShift = 1;
        }
        // Skip leading whitespace before the rule, if any
        // Note: rule = selector list { declarations separated by semicolons }
        stream.skipWhitespace();
        const selectorStart = stream.getOrFail().start;
        // Jump to the opening curly bracket of the declaration block, based on the balance level
        // .selector { padding-top: 10px; padding-bottom: 10px; }
        //           ↑
        //           └ this one
        const { skippedTrimmed: selectorTokensLength } = stream.skipUntilExt(_adguard_css_tokenizer__WEBPACK_IMPORTED_MODULE_0__/* .TokenType */ .ks.OpenCurlyBracket, balanceShift + 1);
        stream.expect(_adguard_css_tokenizer__WEBPACK_IMPORTED_MODULE_0__/* .TokenType */ .ks.OpenCurlyBracket);
        // If the skipped tokens count is 0 without leading and trailing whitespace characters, then the selector list
        // is empty
        if (selectorTokensLength === 0) {
            throw new _errors_adblock_syntax_error_js__WEBPACK_IMPORTED_MODULE_5__/* .AdblockSyntaxError */ .q(ERROR_MESSAGES.SELECTOR_LIST_IS_EMPTY, baseOffset + selectorStart, baseOffset + raw.length);
        }
        // It is safe to use non-null assertion here, because we have already checked previous tokens.
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        const selectorEnd = stream.lookbehindForNonWs().end;
        selectorList.value = raw.slice(selectorStart, selectorEnd);
        if (options.isLocIncluded) {
            selectorList.start = baseOffset + selectorStart;
            selectorList.end = baseOffset + selectorEnd;
        }
        // Jump to the next token after the opening curly bracket of the declaration block
        // .selector { padding-top: 10px; padding-bottom: 10px; }
        //            ↑
        //            └ this one
        stream.advance();
        // Skip whitespace characters after the opening curly bracket of the declaration block, if any
        stream.skipWhitespace();
        // Jump to the closing curly bracket of the declaration block, based on the balance level
        // .selector { padding-top: 10px; padding-bottom: 10px; }
        //                                                      ↑
        //                                                      └ this one
        const declarationsStart = stream.getOrFail().start;
        const declarations = new Set();
        let declarationsEnd = -1;
        let remove = false;
        let lastNonWsIndex = -1;
        while (!stream.isEof()) {
            const token = stream.getOrFail();
            if (token.type === _adguard_css_tokenizer__WEBPACK_IMPORTED_MODULE_0__/* .TokenType */ .ks.CloseCurlyBracket && stream.getBalance() === balanceShift) {
                declarationsEnd = lastNonWsIndex;
                break;
            }
            if (token.type !== _adguard_css_tokenizer__WEBPACK_IMPORTED_MODULE_0__/* .TokenType */ .ks.Whitespace) {
                lastNonWsIndex = token.end;
            }
            if (token.type === _adguard_css_tokenizer__WEBPACK_IMPORTED_MODULE_0__/* .TokenType */ .ks.Ident && stream.lookahead()?.type === _adguard_css_tokenizer__WEBPACK_IMPORTED_MODULE_0__/* .TokenType */ .ks.Colon) {
                const ident = raw.slice(token.start, token.end);
                declarations.add(ident);
                // Consume ident and colon
                stream.advance();
                stream.advance();
                // only 'remove: true' is allowed
                if (ident === REMOVE_PROPERTY) {
                    // Skip whitespace after colon, if any
                    stream.skipWhitespace();
                    // Next token should be an ident, with value 'true'
                    stream.expect(_adguard_css_tokenizer__WEBPACK_IMPORTED_MODULE_0__/* .TokenType */ .ks.Ident, { value: REMOVE_VALUE });
                    stream.advance();
                    remove = true;
                }
            }
            else {
                stream.advance();
            }
        }
        if (declarationsEnd === -1) {
            throw new _errors_adblock_syntax_error_js__WEBPACK_IMPORTED_MODULE_5__/* .AdblockSyntaxError */ .q(ERROR_MESSAGES.DECLARATION_LIST_IS_EMPTY, baseOffset + declarationsStart, baseOffset + raw.length);
        }
        declarationList.value = raw.slice(declarationsStart, declarationsEnd);
        if (options.isLocIncluded) {
            declarationList.start = baseOffset + declarationsStart;
            declarationList.end = baseOffset + declarationsEnd;
        }
        // Eat the close curly bracket of the declaration block
        // .selector { padding-top: 10px; padding-bottom: 10px; }
        //                                                      ↑
        //                                                      └ this one
        stream.expect(_adguard_css_tokenizer__WEBPACK_IMPORTED_MODULE_0__/* .TokenType */ .ks.CloseCurlyBracket);
        stream.advance();
        // Skip whitespace after the rule, if any
        stream.skipWhitespace();
        // If we have a media query, we should have an extra close curly bracket
        if (balanceShift === 1) {
            stream.expect(_adguard_css_tokenizer__WEBPACK_IMPORTED_MODULE_0__/* .TokenType */ .ks.CloseCurlyBracket);
            stream.advance();
        }
        const result = {
            type: 'CssInjectionRuleBody',
            selectorList,
            declarationList,
            remove,
        };
        if (options.isLocIncluded) {
            result.start = baseOffset;
            result.end = baseOffset + raw.length;
        }
        if (mediaQueryList) {
            result.mediaQueryList = mediaQueryList;
        }
        return result;
    }
}




/***/ }),

/***/ 19613:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   g: () => (/* binding */ tokenizeFnBalanced),
/* harmony export */   u: () => (/* binding */ tokenizeBalanced)
/* harmony export */ });
/* harmony import */ var _adguard_css_tokenizer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(25651);
/* harmony import */ var sprintf_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(63607);
/* harmony import */ var _errors_adblock_syntax_error_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(23029);
/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(50211);
/*
 * AGTree v3.1.3 (build date: Tue, 29 Apr 2025 12:25:03 GMT)
 * (c) 2025 Adguard Software Ltd.
 * Released under the MIT license
 * https://github.com/AdguardTeam/tsurlfilter/tree/master/packages/agtree#readme
 */





/**
 * @file Tokenizer helpers for balanced pairs.
 */
/**
 * Map of opening tokens to their corresponding closing tokens.
 */
const standardTokenPairs = new Map([
    [_adguard_css_tokenizer__WEBPACK_IMPORTED_MODULE_0__/* .TokenType */ .ks.Function, _adguard_css_tokenizer__WEBPACK_IMPORTED_MODULE_0__/* .TokenType */ .ks.CloseParenthesis],
    [_adguard_css_tokenizer__WEBPACK_IMPORTED_MODULE_0__/* .TokenType */ .ks.OpenParenthesis, _adguard_css_tokenizer__WEBPACK_IMPORTED_MODULE_0__/* .TokenType */ .ks.CloseParenthesis],
    [_adguard_css_tokenizer__WEBPACK_IMPORTED_MODULE_0__/* .TokenType */ .ks.OpenSquareBracket, _adguard_css_tokenizer__WEBPACK_IMPORTED_MODULE_0__/* .TokenType */ .ks.CloseSquareBracket],
    [_adguard_css_tokenizer__WEBPACK_IMPORTED_MODULE_0__/* .TokenType */ .ks.OpenCurlyBracket, _adguard_css_tokenizer__WEBPACK_IMPORTED_MODULE_0__/* .TokenType */ .ks.CloseCurlyBracket],
]);
/**
 * Map of opening tokens to their corresponding closing tokens just for function calls. This makes possible a more
 * lightweight and tolerant check for balanced pairs in some cases.
 */
const functionTokenPairs = new Map([
    [_adguard_css_tokenizer__WEBPACK_IMPORTED_MODULE_0__/* .TokenType */ .ks.Function, _adguard_css_tokenizer__WEBPACK_IMPORTED_MODULE_0__/* .TokenType */ .ks.CloseParenthesis],
    [_adguard_css_tokenizer__WEBPACK_IMPORTED_MODULE_0__/* .TokenType */ .ks.OpenParenthesis, _adguard_css_tokenizer__WEBPACK_IMPORTED_MODULE_0__/* .TokenType */ .ks.CloseParenthesis],
]);
/**
 * Helper function to tokenize and ensure balanced pairs.
 *
 * @param raw Raw CSS string to tokenize
 * @param onToken Callback which will be invoked for each token, extended with a `balance` parameter
 * @param onError Error callback which is called when a parsing error is found (optional)
 * @param functionHandlers Custom function handlers (optional)
 * @param tokenPairs Map of opening tokens to their corresponding closing tokens
 * @throws If the input is not balanced
 * @todo Consider adding a `tolerant` flag if error throwing seems too aggressive in the future
 */
const tokenizeWithBalancedPairs = (raw, onToken, onError = () => { }, functionHandlers, tokenPairs = standardTokenPairs) => {
    const stack = [];
    const values = new Set(tokenPairs.values());
    (0,_adguard_css_tokenizer__WEBPACK_IMPORTED_MODULE_0__/* .tokenizeExtended */ .jz)(raw, (type, start, end, props, stop) => {
        if (tokenPairs.has(type)) {
            // If the token is an opening token, push its corresponding closing token to the stack.
            // It is safe to use non-null assertion here, because we have checked that the token exists in the map.
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            stack.push(tokenPairs.get(type));
        }
        else if (values.has(type)) {
            // If the token is a closing token, check if it matches the last opening token, and if so, pop it.
            if (stack[stack.length - 1] === type) {
                stack.pop();
            }
            else {
                throw new _errors_adblock_syntax_error_js__WEBPACK_IMPORTED_MODULE_2__/* .AdblockSyntaxError */ .q((0,sprintf_js__WEBPACK_IMPORTED_MODULE_1__.sprintf)(_constants_js__WEBPACK_IMPORTED_MODULE_3__/* .ERROR_MESSAGES */ .U.EXPECTED_TOKEN_BUT_GOT, (0,_adguard_css_tokenizer__WEBPACK_IMPORTED_MODULE_0__/* .getFormattedTokenName */ .bZ)(stack[stack.length - 1]), (0,_adguard_css_tokenizer__WEBPACK_IMPORTED_MODULE_0__/* .getFormattedTokenName */ .bZ)(type)), start, raw.length);
            }
        }
        onToken(type, start, end, props, stack.length, stop);
    }, onError, functionHandlers);
    // If the stack is not empty, then there are some opening tokens that were not closed.
    if (stack.length > 0) {
        throw new _errors_adblock_syntax_error_js__WEBPACK_IMPORTED_MODULE_2__/* .AdblockSyntaxError */ .q((0,sprintf_js__WEBPACK_IMPORTED_MODULE_1__.sprintf)(_constants_js__WEBPACK_IMPORTED_MODULE_3__/* .ERROR_MESSAGES */ .U.EXPECTED_TOKEN_BUT_GOT, (0,_adguard_css_tokenizer__WEBPACK_IMPORTED_MODULE_0__/* .getFormattedTokenName */ .bZ)(stack[stack.length - 1]), _constants_js__WEBPACK_IMPORTED_MODULE_3__/* .END_OF_INPUT */ .F), raw.length - 1, raw.length);
    }
};
/**
 * Tokenize and ensure balanced pairs for standard CSS.
 *
 * @param raw Raw CSS string to tokenize
 * @param onToken Callback which will be invoked for each token, extended with a `balance` parameter
 * @param onError Error callback which is called when a parsing error is found (optional)
 * @param functionHandlers Custom function handlers (optional)
 * @throws If the input is not balanced
 */
const tokenizeBalanced = (raw, onToken, onError = () => { }, functionHandlers) => {
    tokenizeWithBalancedPairs(raw, onToken, onError, functionHandlers);
};
/**
 * Tokenize and ensure balanced pairs for function calls.
 *
 * @param raw Raw CSS string to tokenize
 * @param onToken Callback which will be invoked for each token, extended with a `balance` parameter
 * @param onError Error callback which is called when a parsing error is found (optional)
 * @param functionHandlers Custom function handlers (optional)
 * @throws If the input is not balanced
 */
const tokenizeFnBalanced = (raw, onToken, onError = () => { }, functionHandlers) => {
    tokenizeWithBalancedPairs(raw, onToken, onError, functionHandlers, functionTokenPairs);
};




/***/ }),

/***/ 50211:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   F: () => (/* binding */ END_OF_INPUT),
/* harmony export */   U: () => (/* binding */ ERROR_MESSAGES)
/* harmony export */ });
/*
 * AGTree v3.1.3 (build date: Tue, 29 Apr 2025 12:25:03 GMT)
 * (c) 2025 Adguard Software Ltd.
 * Released under the MIT license
 * https://github.com/AdguardTeam/tsurlfilter/tree/master/packages/agtree#readme
 */
/**
 * @file Error messages for CSS token stream and balancer.
 */
const END_OF_INPUT = 'end of input';
const ERROR_MESSAGES = {
    EXPECTED_ANY_TOKEN_BUT_GOT: "Expected a token, but got '%s'",
    EXPECTED_TOKEN_BUT_GOT: "Expected '%s', but got '%s'",
    EXPECTED_TOKEN_WITH_BALANCE_BUT_GOT: "Expected '%s' with balance '%d', but got '%d'",
    EXPECTED_TOKEN_WITH_VALUE_BUT_GOT: "Expected '%s' with value '%s', but got '%s'",
};




/***/ }),

/***/ 6034:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   d: () => (/* binding */ CssTokenStream)
/* harmony export */ });
/* harmony import */ var _adguard_css_tokenizer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(25651);
/* harmony import */ var sprintf_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(63607);
/* harmony import */ var _balancing_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(19613);
/* harmony import */ var _utils_constants_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(27895);
/* harmony import */ var _errors_adblock_syntax_error_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(23029);
/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(50211);
/* harmony import */ var _converter_data_css_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(60003);
/*
 * AGTree v3.1.3 (build date: Tue, 29 Apr 2025 12:25:03 GMT)
 * (c) 2025 Adguard Software Ltd.
 * Released under the MIT license
 * https://github.com/AdguardTeam/tsurlfilter/tree/master/packages/agtree#readme
 */








/**
 * @file CSS token stream.
 */
/**
 * Represents a stream of CSS tokens.
 */
class CssTokenStream {
    /**
     * The tokens in the stream.
     */
    tokens = [];
    /**
     * The source string.
     */
    source = _utils_constants_js__WEBPACK_IMPORTED_MODULE_2__/* .EMPTY */ .wg;
    /**
     * The current index in the stream.
     */
    index = 0;
    /**
     * The base offset of the source string.
     */
    baseOffset;
    /**
     * Initializes a new instance of the TokenStream class.
     *
     * @param source The source string to tokenize.
     * @param baseOffset The base offset of the source string.
     */
    constructor(source, baseOffset = 0) {
        this.source = source;
        // Tokenize the source string with the CSS tokenizer and add balance level to each token.
        // 'onToken' callback is invoked when a token is found in the source string.
        // Passed parameters:
        // - type: type of the token
        // - start: start index of the token
        // - end: end index of the token
        // - props: additional properties of the token, if any (we don't use it here, this is why we use underscore)
        // - balance: balance level of the token
        try {
            (0,_balancing_js__WEBPACK_IMPORTED_MODULE_3__/* .tokenizeBalanced */ .u)(source, (type, start, end, _, balance) => {
                this.tokens.push({
                    type,
                    start,
                    end,
                    balance,
                });
            });
        }
        catch (error) {
            // If the error is an AdblockSyntaxError, adjust the error positions to the base offset
            if (error instanceof _errors_adblock_syntax_error_js__WEBPACK_IMPORTED_MODULE_4__/* .AdblockSyntaxError */ .q) {
                error.start += baseOffset;
                error.end += baseOffset;
                throw error;
            }
        }
        this.index = 0;
        this.baseOffset = baseOffset;
    }
    /**
     * Gets the number of tokens in the stream.
     *
     * @returns The number of tokens in the stream.
     */
    get length() {
        return this.tokens.length;
    }
    /**
     * Checks if the end of the token stream is reached.
     *
     * @returns True if the end of the stream is reached, otherwise false.
     */
    isEof() {
        return this.index >= this.tokens.length;
    }
    /**
     * Gets the token at the specified index.
     *
     * @param index The index of the token to retrieve.
     * @returns The token at the specified index or undefined if the index is out of bounds.
     */
    get(index = this.index) {
        return this.tokens[index];
    }
    /**
     * Gets the token at the specified index or throws if no token is found at the specified index.
     *
     * @param index The index of the token to retrieve.
     * @returns The token at the specified index or undefined if the index is out of bounds.
     * @throws If no token is found at the specified index.
     */
    getOrFail(index = this.index) {
        const token = this.get(index);
        if (!token) {
            throw new _errors_adblock_syntax_error_js__WEBPACK_IMPORTED_MODULE_4__/* .AdblockSyntaxError */ .q((0,sprintf_js__WEBPACK_IMPORTED_MODULE_1__.sprintf)(_constants_js__WEBPACK_IMPORTED_MODULE_5__/* .ERROR_MESSAGES */ .U.EXPECTED_ANY_TOKEN_BUT_GOT, _constants_js__WEBPACK_IMPORTED_MODULE_5__/* .END_OF_INPUT */ .F), this.baseOffset + this.source.length - 1, this.baseOffset + this.source.length);
        }
        return token;
    }
    /**
     * Gets the source fragment of the token at the specified index.
     *
     * @param index The index of the token to retrieve the fragment for.
     * @returns The source fragment of the token or an empty string if the index is out of bounds.
     */
    fragment(index = this.index) {
        const token = this.get(index);
        if (token) {
            return this.source.slice(token.start, token.end);
        }
        return _utils_constants_js__WEBPACK_IMPORTED_MODULE_2__/* .EMPTY */ .wg;
    }
    /**
     * Moves the index to the next token and returns it.
     *
     * @returns The next token or undefined if the end of the stream is reached.
     */
    advance() {
        if (this.isEof()) {
            return undefined;
        }
        this.index += 1;
        return this.tokens[this.index];
    }
    /**
     * Looks ahead in the stream without changing the index.
     *
     * @param index The relative index to look ahead to, starting from the current index.
     * @returns The next token or undefined if the end of the stream is reached.
     */
    lookahead(index = 1) {
        return this.tokens[this.index + Math.max(1, index)];
    }
    /**
     * Looks behind in the stream without changing the index.
     *
     * @param index The relative index to look behind to, starting from the current index.
     * @returns The previous token or undefined if the current token is the first in the stream.
     */
    lookbehind(index = 1) {
        if (this.index === 0) {
            return undefined;
        }
        return this.tokens[this.index - Math.max(1, index)];
    }
    /**
     * Looks behind in the stream for the previous non-whitespace token without changing the index.
     *
     * @returns The previous non-whitespace token or undefined if it could not be found.
     */
    lookbehindForNonWs() {
        for (let i = this.index - 1; i >= 0; i -= 1) {
            if (this.tokens[i].type !== _adguard_css_tokenizer__WEBPACK_IMPORTED_MODULE_0__/* .TokenType */ .ks.Whitespace) {
                return this.tokens[i];
            }
        }
        return undefined;
    }
    /**
     * Skips whitespace tokens in the stream.
     */
    skipWhitespace() {
        while (this.get()?.type === _adguard_css_tokenizer__WEBPACK_IMPORTED_MODULE_0__/* .TokenType */ .ks.Whitespace) {
            this.index += 1;
        }
    }
    /**
     * Skips tokens until the current balance level is reached.
     *
     * @returns The number of tokens skipped.
     */
    skipUntilBalanced() {
        if (this.isEof()) {
            return 0;
        }
        // It is safe to use ! here, because we check for EOF above
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        const currentBalance = this.get().balance;
        // If the current balance is 0, do nothing
        if (currentBalance === 0) {
            return 0;
        }
        // Otherwise, skip tokens until the balance is the current balance - 1
        let skipped = 0;
        while (!this.isEof() && this.get()?.balance !== currentBalance - 1) {
            this.index += 1;
            skipped += 1;
        }
        return skipped;
    }
    /**
     * Skips tokens until a token with the specified type or the end of the stream is reached.
     *
     * @param type The type of token to skip until.
     * @param balance The balance level of the token to skip until.
     * @returns The number of tokens skipped.
     */
    skipUntil(type, balance) {
        let skipped = 0;
        while (!this.isEof()
            && (this.get()?.type !== type || (balance !== undefined && this.get()?.balance !== balance))) {
            this.index += 1;
            skipped += 1;
        }
        return skipped;
    }
    /**
     * Skips tokens until a token with the specified type or the end of the stream is reached. This is an extended
     * version of skipUntil that also returns the number of tokens skipped without calculating leading and trailing
     * whitespace tokens.
     *
     * @param type The type of token to skip until.
     * @param balance The balance level of the token to skip until.
     * @returns An array containing the number of tokens skipped and the number of tokens skipped without leading and
     * trailing whitespace tokens.
     */
    skipUntilExt(type, balance) {
        let i = this.index;
        let firstNonWsToken = -1; // -1 means no non-whitespace token found yet
        let lastNonWsToken = -1; // -1 means no non-whitespace token found yet
        while (i < this.tokens.length) {
            const currentToken = this.tokens[i];
            if (currentToken.type === _adguard_css_tokenizer__WEBPACK_IMPORTED_MODULE_0__/* .TokenType */ .ks.Whitespace) {
                i += 1;
                continue;
            }
            else if (currentToken.type === type && currentToken.balance === balance) {
                break;
            }
            if (firstNonWsToken === -1) {
                firstNonWsToken = i;
            }
            lastNonWsToken = i;
            i += 1;
        }
        const skipped = i - this.index;
        this.index = i;
        return {
            skipped,
            // if firstNonWsToken is -1, then lastNonWsToken is also -1
            skippedTrimmed: firstNonWsToken === -1 ? 0 : lastNonWsToken - firstNonWsToken + 1,
        };
    }
    /**
     * Expects that the end of the stream is not reached.
     */
    expectNotEof() {
        if (this.isEof()) {
            throw new _errors_adblock_syntax_error_js__WEBPACK_IMPORTED_MODULE_4__/* .AdblockSyntaxError */ .q('Unexpected end of input', this.baseOffset + this.source.length - 1, this.baseOffset + this.source.length);
        }
    }
    /**
     * Expects the current token to have a specific type and optional value and balance level.
     *
     * @param type The expected token type.
     * @param data Optional expectation data.
     * @throws If the end of the stream is reached or if the token type or expectation data does not match.
     */
    expect(type, data) {
        const token = this.get();
        if (!token) {
            throw new _errors_adblock_syntax_error_js__WEBPACK_IMPORTED_MODULE_4__/* .AdblockSyntaxError */ .q((0,sprintf_js__WEBPACK_IMPORTED_MODULE_1__.sprintf)(_constants_js__WEBPACK_IMPORTED_MODULE_5__/* .ERROR_MESSAGES */ .U.EXPECTED_TOKEN_BUT_GOT, (0,_adguard_css_tokenizer__WEBPACK_IMPORTED_MODULE_0__/* .getFormattedTokenName */ .bZ)(type), _constants_js__WEBPACK_IMPORTED_MODULE_5__/* .END_OF_INPUT */ .F), this.baseOffset + this.source.length - 1, this.baseOffset + this.source.length);
        }
        if (token.type !== type) {
            throw new _errors_adblock_syntax_error_js__WEBPACK_IMPORTED_MODULE_4__/* .AdblockSyntaxError */ .q((0,sprintf_js__WEBPACK_IMPORTED_MODULE_1__.sprintf)(_constants_js__WEBPACK_IMPORTED_MODULE_5__/* .ERROR_MESSAGES */ .U.EXPECTED_TOKEN_BUT_GOT, (0,_adguard_css_tokenizer__WEBPACK_IMPORTED_MODULE_0__/* .getFormattedTokenName */ .bZ)(type), (0,_adguard_css_tokenizer__WEBPACK_IMPORTED_MODULE_0__/* .getFormattedTokenName */ .bZ)(token.type)), this.baseOffset + token.start, this.baseOffset + token.end);
        }
        if (data?.balance !== undefined && token.balance !== data.balance) {
            throw new _errors_adblock_syntax_error_js__WEBPACK_IMPORTED_MODULE_4__/* .AdblockSyntaxError */ .q((0,sprintf_js__WEBPACK_IMPORTED_MODULE_1__.sprintf)(_constants_js__WEBPACK_IMPORTED_MODULE_5__/* .ERROR_MESSAGES */ .U.EXPECTED_TOKEN_WITH_BALANCE_BUT_GOT, (0,_adguard_css_tokenizer__WEBPACK_IMPORTED_MODULE_0__/* .getFormattedTokenName */ .bZ)(type), data.balance, token.balance), this.baseOffset + token.start, this.baseOffset + token.end);
        }
        if (data?.value && this.fragment() !== data.value) {
            throw new _errors_adblock_syntax_error_js__WEBPACK_IMPORTED_MODULE_4__/* .AdblockSyntaxError */ .q((0,sprintf_js__WEBPACK_IMPORTED_MODULE_1__.sprintf)(_constants_js__WEBPACK_IMPORTED_MODULE_5__/* .ERROR_MESSAGES */ .U.EXPECTED_TOKEN_WITH_VALUE_BUT_GOT, (0,_adguard_css_tokenizer__WEBPACK_IMPORTED_MODULE_0__/* .getFormattedTokenName */ .bZ)(type), data.value, this.fragment()), this.baseOffset + token.start, this.baseOffset + token.end);
        }
    }
    /**
     * Gets the balance level of the token at the specified index.
     *
     * @param index The index of the token to retrieve the balance level for.
     * @returns The balance level of the token or 0 if the index is out of bounds.
     */
    getBalance(index = this.index) {
        return this.tokens[index]?.balance || 0;
    }
    /**
     * Checks whether the token stream contains any Extended CSS elements, such as `:contains()`, etc.
     *
     * @returns `true` if the stream contains any Extended CSS elements, otherwise `false`.
     */
    hasAnySelectorExtendedCssNode() {
        return this.hasAnySelectorExtendedCssNodeInternal(_converter_data_css_js__WEBPACK_IMPORTED_MODULE_6__/* .EXT_CSS_PSEUDO_CLASSES */ .Ss);
    }
    /**
     * Strictly checks whether the token stream contains any Extended CSS elements, such as `:contains()`.
     * Some Extended CSS elements are natively supported by browsers, like `:has()`.
     * This method is used to check for Extended CSS elements that are not natively supported by browsers,
     * this is why it called "strict", because it strictly checks for Extended CSS elements.
     *
     * @returns `true` if the stream contains any Extended CSS elements, otherwise `false`.
     */
    hasAnySelectorExtendedCssNodeStrict() {
        return this.hasAnySelectorExtendedCssNodeInternal(_converter_data_css_js__WEBPACK_IMPORTED_MODULE_6__/* .EXT_CSS_PSEUDO_CLASSES_STRICT */ .ig);
    }
    /**
     * Checks whether the token stream contains any Extended CSS elements, such as `:has()`, `:contains()`, etc.
     *
     * @param pseudos Set of pseudo-classes to check for.
     *
     * @returns `true` if the stream contains any Extended CSS elements, otherwise `false`.
     */
    hasAnySelectorExtendedCssNodeInternal(pseudos) {
        for (let i = 0; i < this.tokens.length; i += 1) {
            const token = this.tokens[i];
            if (token.type === _adguard_css_tokenizer__WEBPACK_IMPORTED_MODULE_0__/* .TokenType */ .ks.Function) {
                const name = this.source.slice(token.start, token.end - 1); // omit the last parenthesis
                if (pseudos.has(name)) {
                    return true;
                }
            }
            else if (token.type === _adguard_css_tokenizer__WEBPACK_IMPORTED_MODULE_0__/* .TokenType */ .ks.OpenSquareBracket) {
                let j = i + 1;
                // skip whitespace
                while (j < this.tokens.length && this.tokens[j].type === _adguard_css_tokenizer__WEBPACK_IMPORTED_MODULE_0__/* .TokenType */ .ks.Whitespace) {
                    j += 1;
                }
                if (j < this.tokens.length && this.tokens[j].type === _adguard_css_tokenizer__WEBPACK_IMPORTED_MODULE_0__/* .TokenType */ .ks.Ident) {
                    const attr = this.source.slice(this.tokens[j].start, this.tokens[j].end);
                    // [-ext-<name>=...] or [-abp-<name>=...]
                    if (attr.startsWith(_converter_data_css_js__WEBPACK_IMPORTED_MODULE_6__/* .LEGACY_EXT_CSS_ATTRIBUTE_PREFIX */ .at) || attr.startsWith(_converter_data_css_js__WEBPACK_IMPORTED_MODULE_6__/* .ABP_EXT_CSS_PREFIX */ .PY)) {
                        return true;
                    }
                }
                // do not check these tokens again
                i = j;
            }
        }
        return false;
    }
}




/***/ }),

/***/ 2607:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  y: () => (/* binding */ DomainListParser)
});

// EXTERNAL MODULE: ./node_modules/.pnpm/@adguard+agtree@3.1.3/node_modules/@adguard/agtree/dist/utils/constants.js
var constants = __webpack_require__(27895);
// EXTERNAL MODULE: ./node_modules/.pnpm/@adguard+agtree@3.1.3/node_modules/@adguard/agtree/dist/nodes/index.js
var nodes = __webpack_require__(91354);
// EXTERNAL MODULE: ./node_modules/.pnpm/@adguard+agtree@3.1.3/node_modules/@adguard/agtree/dist/parser/options.js
var parser_options = __webpack_require__(49604);
// EXTERNAL MODULE: ./node_modules/.pnpm/@adguard+agtree@3.1.3/node_modules/@adguard/agtree/dist/parser/base-parser.js
var base_parser = __webpack_require__(21593);
// EXTERNAL MODULE: ./node_modules/.pnpm/@adguard+agtree@3.1.3/node_modules/@adguard/agtree/dist/utils/string.js
var string = __webpack_require__(38949);
// EXTERNAL MODULE: ./node_modules/.pnpm/@adguard+agtree@3.1.3/node_modules/@adguard/agtree/dist/errors/adblock-syntax-error.js
var adblock_syntax_error = __webpack_require__(23029);
;// ./node_modules/.pnpm/@adguard+agtree@3.1.3/node_modules/@adguard/agtree/dist/parser/misc/list-items-parser.js
/*
 * AGTree v3.1.3 (build date: Tue, 29 Apr 2025 12:25:03 GMT)
 * (c) 2025 Adguard Software Ltd.
 * Released under the MIT license
 * https://github.com/AdguardTeam/tsurlfilter/tree/master/packages/agtree#readme
 */






/**
 * Prefixes for error messages which are used for parsing of value lists.
 */
const LIST_PARSE_ERROR_PREFIX = {
    EMPTY_ITEM: 'Empty value specified in the list',
    NO_MULTIPLE_NEGATION: 'Exception marker cannot be followed by another exception marker',
    NO_SEPARATOR_AFTER_NEGATION: 'Exception marker cannot be followed by a separator',
    NO_SEPARATOR_AT_THE_BEGINNING: 'Value list cannot start with a separator',
    NO_SEPARATOR_AT_THE_END: 'Value list cannot end with a separator',
    NO_WHITESPACE_AFTER_NEGATION: 'Exception marker cannot be followed by whitespace',
};
/**
 * Parser for list items in modifiers.
 */
class ListItemsParser {
    /**
     * Parses a `raw` modifier value which may be represented as a list of items separated by `separator`.
     * Needed for $app, $denyallow, $domain, $method.
     *
     * @param raw Raw input to parse.
     * @param options Global parser options.
     * @param baseOffset Starting offset of the input. Node locations are calculated relative to this offset.
     * @param separator Separator character (default: comma)
     * @param type Type of the list items (default: {@link ListItemNodeType.Domain}).
     * @template T Type of the list items.
     *
     * @returns List of parsed items.
     * @throws An {@link AdblockSyntaxError} if the list is syntactically invalid
     *
     * @example
     * - parses an app list — `com.example.app|Example.exe`
     * - parses a domain list — `example.com,example.org,~example.org` or `example.com|~example.org`
     * - parses a method list — `~post|~put`
     */
    static parse(raw, options = parser_options/* defaultParserOptions */.n, baseOffset = 0, separator = constants/* COMMA */.KE, type = nodes/* ListItemNodeType */.WR.Unknown) {
        // Function body here
        const rawListItems = [];
        let offset = 0;
        // Skip whitespace before the list
        offset = string/* StringUtils */.$x.skipWS(raw, offset);
        // If the first character is a separator, then the list is invalid
        // and no need to continue parsing
        if (raw[offset] === separator) {
            throw new adblock_syntax_error/* AdblockSyntaxError */.q(LIST_PARSE_ERROR_PREFIX.NO_SEPARATOR_AT_THE_BEGINNING, baseOffset + offset, baseOffset + raw.length);
        }
        // If the last character is a separator, then the list item is invalid
        // and no need to continue parsing
        const realEndIndex = string/* StringUtils */.$x.skipWSBack(raw);
        if (raw[realEndIndex] === separator) {
            throw new adblock_syntax_error/* AdblockSyntaxError */.q(LIST_PARSE_ERROR_PREFIX.NO_SEPARATOR_AT_THE_END, baseOffset + realEndIndex, baseOffset + realEndIndex + 1);
        }
        // Split list items by unescaped separators
        while (offset < raw.length) {
            // Skip whitespace before the list item
            offset = string/* StringUtils */.$x.skipWS(raw, offset);
            let itemStart = offset;
            // Find the index of the first unescaped separator character
            const separatorStartIndex = string/* StringUtils */.$x.findNextUnescapedCharacter(raw, separator, offset);
            const itemEnd = separatorStartIndex === -1
                ? string/* StringUtils */.$x.skipWSBack(raw) + 1
                : string/* StringUtils */.$x.skipWSBack(raw, separatorStartIndex - 1) + 1;
            const exception = raw[itemStart] === constants/* NEGATION_MARKER */.bP;
            // Skip the exception marker
            if (exception) {
                itemStart += 1;
                const item = raw[itemStart];
                // Exception marker cannot be followed by another exception marker
                if (item === constants/* NEGATION_MARKER */.bP) {
                    throw new adblock_syntax_error/* AdblockSyntaxError */.q(LIST_PARSE_ERROR_PREFIX.NO_MULTIPLE_NEGATION, baseOffset + itemStart, baseOffset + itemStart + 1);
                }
                // Exception marker cannot be followed by a separator
                if (item === separator) {
                    throw new adblock_syntax_error/* AdblockSyntaxError */.q(LIST_PARSE_ERROR_PREFIX.NO_SEPARATOR_AFTER_NEGATION, baseOffset + itemStart, baseOffset + itemStart + 1);
                }
                // Exception marker cannot be followed by whitespace
                if (string/* StringUtils */.$x.isWhitespace(item)) {
                    throw new adblock_syntax_error/* AdblockSyntaxError */.q(LIST_PARSE_ERROR_PREFIX.NO_WHITESPACE_AFTER_NEGATION, baseOffset + itemStart, baseOffset + itemStart + 1);
                }
            }
            // List item can't be empty
            // Note we use '<=' instead of '===' because we have bidirectional trim
            // This is needed to handle cases like 'example.com, ,example.org'
            if (itemEnd <= itemStart) {
                throw new adblock_syntax_error/* AdblockSyntaxError */.q(LIST_PARSE_ERROR_PREFIX.EMPTY_ITEM, baseOffset + itemStart, baseOffset + raw.length);
            }
            const listItem = {
                type,
                value: raw.slice(itemStart, itemEnd),
                exception,
            };
            if (options.isLocIncluded) {
                listItem.start = baseOffset + itemStart;
                listItem.end = baseOffset + itemEnd;
            }
            // Collect list item
            rawListItems.push(listItem);
            // Increment the offset to the next list item (or the end of the string)
            offset = separatorStartIndex === -1 ? raw.length : separatorStartIndex + 1;
        }
        return rawListItems;
    }
}



;// ./node_modules/.pnpm/@adguard+agtree@3.1.3/node_modules/@adguard/agtree/dist/parser/misc/domain-list-parser.js
/*
 * AGTree v3.1.3 (build date: Tue, 29 Apr 2025 12:25:03 GMT)
 * (c) 2025 Adguard Software Ltd.
 * Released under the MIT license
 * https://github.com/AdguardTeam/tsurlfilter/tree/master/packages/agtree#readme
 */






/**
 * `DomainListParser` is responsible for parsing a domain list.
 *
 * @example
 * - If the rule is `example.com,~example.net##.ads`, the domain list is `example.com,~example.net`.
 * - If the rule is `ads.js^$script,domains=example.com|~example.org`, the domain list is `example.com|~example.org`.
 * This parser is responsible for parsing these domain lists.
 * @see {@link https://help.eyeo.com/adblockplus/how-to-write-filters#elemhide_domains}
 */
class DomainListParser extends base_parser/* BaseParser */.V {
    /**
     * Parses a domain list, eg. `example.com,example.org,~example.org`
     *
     * @param raw Raw input to parse.
     * @param options Global parser options.
     * @param baseOffset Starting offset of the input. Node locations are calculated relative to this offset.
     * @param separator Separator character (default: comma)
     *
     * @returns Domain list AST.
     * @throws An {@link AdblockSyntaxError} if the domain list is syntactically invalid.
     * @throws An {@link Error} if the options are invalid.
     */
    static parse(raw, options = parser_options/* defaultParserOptions */.n, baseOffset = 0, separator = constants/* COMMA */.KE) {
        if (separator !== constants/* COMMA */.KE && separator !== constants/* PIPE */.L5) {
            throw new Error(`Invalid separator: ${separator}`);
        }
        const result = {
            type: nodes/* ListNodeType */.h6.DomainList,
            separator,
            children: ListItemsParser.parse(raw, options, baseOffset, separator, nodes/* ListItemNodeType */.WR.Domain),
        };
        if (options.isLocIncluded) {
            result.start = baseOffset;
            result.end = baseOffset + raw.length;
        }
        return result;
    }
}




/***/ }),

/***/ 11951:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Z: () => (/* binding */ NodeType),
/* harmony export */   f: () => (/* binding */ LogicalExpressionParser)
/* harmony export */ });
/* harmony import */ var _utils_string_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(38949);
/* harmony import */ var _nodes_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(91354);
/* harmony import */ var _utils_constants_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(27895);
/* harmony import */ var _errors_adblock_syntax_error_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(23029);
/* harmony import */ var _options_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(49604);
/* harmony import */ var _base_parser_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(21593);
/*
 * AGTree v3.1.3 (build date: Tue, 29 Apr 2025 12:25:03 GMT)
 * (c) 2025 Adguard Software Ltd.
 * Released under the MIT license
 * https://github.com/AdguardTeam/tsurlfilter/tree/master/packages/agtree#readme
 */







/**
 * Possible token types in the logical expression.
 */
const TokenType = {
    Variable: 0,
    Operator: 1,
    Parenthesis: 2,
};
/**
 * Possible node types in the logical expression.
 */
const NodeType = {
    Variable: 'Variable',
    Operator: 'Operator',
    Parenthesis: 'Parenthesis',
};
/**
 * Precedence of the operators, larger number means higher precedence.
 */
const OPERATOR_PRECEDENCE = {
    [_nodes_index_js__WEBPACK_IMPORTED_MODULE_0__/* .OperatorValue */ .oC.Not]: 3,
    [_nodes_index_js__WEBPACK_IMPORTED_MODULE_0__/* .OperatorValue */ .oC.And]: 2,
    [_nodes_index_js__WEBPACK_IMPORTED_MODULE_0__/* .OperatorValue */ .oC.Or]: 1,
};
/**
 * `LogicalExpressionParser` is responsible for parsing logical expressions.
 *
 * @example
 * From the following rule:
 * ```adblock
 * !#if (adguard_ext_android_cb || adguard_ext_safari)
 * ```
 * this parser will parse the expression `(adguard_ext_android_cb || adguard_ext_safari)`.
 */
// TODO: Refactor this class
class LogicalExpressionParser extends _base_parser_js__WEBPACK_IMPORTED_MODULE_1__/* .BaseParser */ .V {
    /**
     * Split the expression into tokens.
     *
     * @param raw Source code of the expression
     * @param baseOffset Starting offset of the input. Node locations are calculated relative to this offset.
     * @returns Token list
     * @throws {AdblockSyntaxError} If the expression is invalid
     */
    static tokenize(raw, baseOffset = 0) {
        const tokens = [];
        let offset = 0;
        while (offset < raw.length) {
            const char = raw[offset];
            if (_utils_string_js__WEBPACK_IMPORTED_MODULE_2__/* .StringUtils */ .$x.isWhitespace(char)) {
                // Ignore whitespace
                offset += 1;
            }
            else if (_utils_string_js__WEBPACK_IMPORTED_MODULE_2__/* .StringUtils */ .$x.isLetter(char)) {
                // Save the start offset of the variable name
                const nameStart = offset;
                // Variable name shouldn't start with a number or underscore,
                // but can contain them
                while (offset + 1 < raw.length
                    && (_utils_string_js__WEBPACK_IMPORTED_MODULE_2__/* .StringUtils */ .$x.isAlphaNumeric(raw[offset + 1]) || raw[offset + 1] === _utils_constants_js__WEBPACK_IMPORTED_MODULE_3__/* .UNDERSCORE */ .fB)) {
                    offset += 1;
                }
                tokens.push({
                    type: TokenType.Variable,
                    start: nameStart,
                    end: offset + 1,
                });
                offset += 1;
            }
            else if (char === _utils_constants_js__WEBPACK_IMPORTED_MODULE_3__/* .OPEN_PARENTHESIS */ .Cx || char === _utils_constants_js__WEBPACK_IMPORTED_MODULE_3__/* .CLOSE_PARENTHESIS */ .s1) {
                // Parenthesis
                tokens.push({
                    type: TokenType.Parenthesis,
                    start: offset,
                    end: offset + 1,
                });
                offset += 1;
            }
            else if (char === _utils_constants_js__WEBPACK_IMPORTED_MODULE_3__/* .AMPERSAND */ .e0 || char === _utils_constants_js__WEBPACK_IMPORTED_MODULE_3__/* .PIPE */ .L5) {
                // Parse operator
                if (offset + 1 < raw.length && raw[offset + 1] === char) {
                    tokens.push({
                        type: TokenType.Operator,
                        start: offset,
                        end: offset + 2,
                    });
                    offset += 2;
                }
                else {
                    throw new _errors_adblock_syntax_error_js__WEBPACK_IMPORTED_MODULE_4__/* .AdblockSyntaxError */ .q(`Unexpected character "${char}"`, baseOffset + offset, baseOffset + offset + 1);
                }
            }
            else if (char === _utils_constants_js__WEBPACK_IMPORTED_MODULE_3__/* .EXCLAMATION_MARK */ .Ec) {
                tokens.push({
                    type: TokenType.Operator,
                    start: offset,
                    end: offset + 1,
                });
                offset += 1;
            }
            else {
                throw new _errors_adblock_syntax_error_js__WEBPACK_IMPORTED_MODULE_4__/* .AdblockSyntaxError */ .q(`Unexpected character "${char}"`, baseOffset + offset, baseOffset + offset + 1);
            }
        }
        return tokens;
    }
    /**
     * Parses a logical expression.
     *
     * @param raw Raw input to parse.
     * @param options Global parser options.
     * @param baseOffset Starting offset of the input. Node locations are calculated relative to this offset.
     * @returns Parsed expression
     * @throws {AdblockSyntaxError} If the expression is invalid
     */
    // TODO: Create a separate TokenStream class
    static parse(raw, options = _options_js__WEBPACK_IMPORTED_MODULE_5__/* .defaultParserOptions */ .n, baseOffset = 0) {
        // Tokenize the source (produces an array of tokens)
        const tokens = LogicalExpressionParser.tokenize(raw, baseOffset);
        // Current token index
        let tokenIndex = 0;
        /**
         * Consumes a token of the expected type.
         *
         * @param type Expected token type
         * @returns The consumed token
         */
        function consume(type) {
            const token = tokens[tokenIndex];
            if (!token) {
                throw new _errors_adblock_syntax_error_js__WEBPACK_IMPORTED_MODULE_4__/* .AdblockSyntaxError */ .q(`Expected token of type "${type}", but reached end of input`, baseOffset, baseOffset + raw.length);
            }
            // We only use this function internally, so we can safely ignore this
            // from the coverage report
            // istanbul ignore next
            if (token.type !== type) {
                throw new _errors_adblock_syntax_error_js__WEBPACK_IMPORTED_MODULE_4__/* .AdblockSyntaxError */ .q(`Expected token of type "${type}", but got "${token.type}"`, baseOffset + token.start, baseOffset + token.end);
            }
            tokenIndex += 1;
            return token;
        }
        /**
         * Parses a variable.
         *
         * @returns Variable node
         */
        function parseVariable() {
            const token = consume(TokenType.Variable);
            const result = {
                type: NodeType.Variable,
                name: raw.slice(token.start, token.end),
            };
            if (options.isLocIncluded) {
                result.start = baseOffset + token.start;
                result.end = baseOffset + token.end;
            }
            return result;
        }
        /**
         * Parses a binary expression.
         *
         * @param left Left-hand side of the expression
         * @param minPrecedence Minimum precedence of the operator
         * @returns Binary expression node
         */
        function parseBinaryExpression(left, minPrecedence = 0) {
            let node = left;
            let operatorToken;
            while (tokens[tokenIndex]) {
                operatorToken = tokens[tokenIndex];
                if (!operatorToken || operatorToken.type !== TokenType.Operator) {
                    break;
                }
                // It is safe to cast here, because we already checked the type
                const operator = raw.slice(operatorToken.start, operatorToken.end);
                const precedence = OPERATOR_PRECEDENCE[operator];
                if (precedence < minPrecedence) {
                    break;
                }
                tokenIndex += 1;
                // eslint-disable-next-line @typescript-eslint/no-use-before-define
                const right = parseExpression(precedence + 1);
                const newNode = {
                    type: NodeType.Operator,
                    operator,
                    left: node,
                    right,
                };
                if (options.isLocIncluded) {
                    newNode.start = node.start ?? baseOffset + operatorToken.start;
                    newNode.end = right.end ?? baseOffset + operatorToken.end;
                }
                node = newNode;
            }
            return node;
        }
        /**
         * Parses a parenthesized expression.
         *
         * @returns Parenthesized expression node
         */
        function parseParenthesizedExpression() {
            consume(TokenType.Parenthesis);
            // eslint-disable-next-line @typescript-eslint/no-use-before-define
            const expression = parseExpression();
            consume(TokenType.Parenthesis);
            const result = {
                type: NodeType.Parenthesis,
                expression,
            };
            if (options.isLocIncluded) {
                result.start = expression.start;
                result.end = expression.end;
            }
            return result;
        }
        /**
         * Parses an expression.
         *
         * @param minPrecedence Minimum precedence of the operator
         * @returns Expression node
         */
        function parseExpression(minPrecedence = 0) {
            let node;
            const token = tokens[tokenIndex];
            const value = raw.slice(token.start, token.end);
            if (token.type === TokenType.Variable) {
                node = parseVariable();
            }
            else if (token.type === TokenType.Operator && value === _nodes_index_js__WEBPACK_IMPORTED_MODULE_0__/* .OperatorValue */ .oC.Not) {
                tokenIndex += 1;
                const expression = parseExpression(OPERATOR_PRECEDENCE[_nodes_index_js__WEBPACK_IMPORTED_MODULE_0__/* .OperatorValue */ .oC.Not]);
                node = {
                    type: NodeType.Operator,
                    operator: _nodes_index_js__WEBPACK_IMPORTED_MODULE_0__/* .OperatorValue */ .oC.Not,
                    left: expression,
                };
                if (options.isLocIncluded) {
                    if (expression.end) {
                        node.start = baseOffset + token.start;
                        // no need to shift the node location, because it's already shifted
                        node.end = expression.end;
                    }
                    else {
                        node.start = baseOffset + token.start;
                        node.end = baseOffset + token.end;
                    }
                }
            }
            else if (token.type === TokenType.Parenthesis && value === _utils_constants_js__WEBPACK_IMPORTED_MODULE_3__/* .OPEN_PARENTHESIS */ .Cx) {
                node = parseParenthesizedExpression();
            }
            else {
                throw new _errors_adblock_syntax_error_js__WEBPACK_IMPORTED_MODULE_4__/* .AdblockSyntaxError */ .q(`Unexpected token "${value}"`, baseOffset + token.start, baseOffset + token.end);
            }
            return parseBinaryExpression(node, minPrecedence);
        }
        const expression = parseExpression();
        if (tokenIndex !== tokens.length) {
            throw new _errors_adblock_syntax_error_js__WEBPACK_IMPORTED_MODULE_4__/* .AdblockSyntaxError */ .q(`Unexpected token "${tokens[tokenIndex].type}"`, baseOffset + tokens[tokenIndex].start, baseOffset + tokens[tokenIndex].end);
        }
        return expression;
    }
}




/***/ }),

/***/ 49604:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   n: () => (/* binding */ defaultParserOptions)
/* harmony export */ });
/*
 * AGTree v3.1.3 (build date: Tue, 29 Apr 2025 12:25:03 GMT)
 * (c) 2025 Adguard Software Ltd.
 * Released under the MIT license
 * https://github.com/AdguardTeam/tsurlfilter/tree/master/packages/agtree#readme
 */
/**
 * @file Common options for all parsers.
 */
/**
 * Default parser options.
 */
const defaultParserOptions = Object.freeze({
    tolerant: false,
    isLocIncluded: true,
    parseAbpSpecificRules: true,
    parseUboSpecificRules: true,
    includeRaws: true,
    ignoreComments: false,
    parseHostRules: false,
});




/***/ }),

/***/ 12320:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  G: () => (/* binding */ RuleParser)
});

// EXTERNAL MODULE: ./node_modules/.pnpm/@adguard+agtree@3.1.3/node_modules/@adguard/agtree/dist/utils/adblockers.js
var adblockers = __webpack_require__(73734);
// EXTERNAL MODULE: ./node_modules/.pnpm/@adguard+agtree@3.1.3/node_modules/@adguard/agtree/dist/utils/constants.js
var constants = __webpack_require__(27895);
// EXTERNAL MODULE: ./node_modules/.pnpm/@adguard+agtree@3.1.3/node_modules/@adguard/agtree/dist/utils/string.js
var string = __webpack_require__(38949);
// EXTERNAL MODULE: ./node_modules/.pnpm/@adguard+agtree@3.1.3/node_modules/@adguard/agtree/dist/nodes/index.js
var nodes = __webpack_require__(91354);
// EXTERNAL MODULE: ./node_modules/.pnpm/@adguard+agtree@3.1.3/node_modules/@adguard/agtree/dist/errors/adblock-syntax-error.js
var adblock_syntax_error = __webpack_require__(23029);
// EXTERNAL MODULE: ./node_modules/.pnpm/@adguard+agtree@3.1.3/node_modules/@adguard/agtree/dist/parser/base-parser.js
var base_parser = __webpack_require__(21593);
// EXTERNAL MODULE: ./node_modules/.pnpm/@adguard+agtree@3.1.3/node_modules/@adguard/agtree/dist/parser/options.js
var parser_options = __webpack_require__(49604);
;// ./node_modules/.pnpm/@adguard+agtree@3.1.3/node_modules/@adguard/agtree/dist/parser/misc/value-parser.js
/*
 * AGTree v3.1.3 (build date: Tue, 29 Apr 2025 12:25:03 GMT)
 * (c) 2025 Adguard Software Ltd.
 * Released under the MIT license
 * https://github.com/AdguardTeam/tsurlfilter/tree/master/packages/agtree#readme
 */



/**
 * Value parser.
 * This parser is very simple, it just exists to provide a consistent interface for parsing.
 */
class ValueParser extends base_parser/* BaseParser */.V {
    /**
     * Parses a value.
     *
     * @param raw Raw input to parse.
     * @param options Global parser options.
     * @param baseOffset Starting offset of the input. Node locations are calculated relative to this offset.
     *
     * @returns Value node.
     */
    static parse(raw, options = parser_options/* defaultParserOptions */.n, baseOffset = 0) {
        const result = {
            type: 'Value',
            value: raw,
        };
        if (options.isLocIncluded) {
            result.start = baseOffset;
            result.end = baseOffset + raw.length;
        }
        return result;
    }
}



// EXTERNAL MODULE: ./node_modules/.pnpm/@adguard+agtree@3.1.3/node_modules/@adguard/agtree/dist/utils/type-guards.js
var type_guards = __webpack_require__(8123);
// EXTERNAL MODULE: ./node_modules/.pnpm/@adguard+agtree@3.1.3/node_modules/@adguard/agtree/dist/common/agent-common.js
var agent_common = __webpack_require__(38303);
;// ./node_modules/.pnpm/@adguard+agtree@3.1.3/node_modules/@adguard/agtree/dist/parser/comment/agent-parser.js
/*
 * AGTree v3.1.3 (build date: Tue, 29 Apr 2025 12:25:03 GMT)
 * (c) 2025 Adguard Software Ltd.
 * Released under the MIT license
 * https://github.com/AdguardTeam/tsurlfilter/tree/master/packages/agtree#readme
 */









/**
 * `AgentParser` is responsible for parsing single adblock agent elements.
 *
 * @example
 * If the adblock agent rule is
 * ```adblock
 * [Adblock Plus 2.0; AdGuard]
 * ```
 * then the adblock agents are `Adblock Plus 2.0` and `AdGuard`, and this
 * class is responsible for parsing them. The rule itself is parsed by
 * `AgentCommentParser`, which uses this class to parse single agents.
 */
class AgentParser extends base_parser/* BaseParser */.V {
    /**
     * Regex to match a version inside a string.
     */
    static VERSION_REGEX = /\b\d+\.\d+(\.\d+)?\b/;
    /**
     * Checks if the string is a valid version.
     *
     * The string can have a version in formats like
     * [Adblock Plus 2.0], or [Adblock Plus 3.1; AdGuard].
     *
     * @param str String to check
     * @returns `true` if the string is a valid version, `false` otherwise
     */
    static isValidVersion(str) {
        // Check if the string contains a valid version pattern
        return AgentParser.VERSION_REGEX.test(str);
    }
    /**
     * Parses a raw rule as an adblock agent comment.
     *
     * @param raw Raw input to parse.
     * @param options Global parser options.
     * @param baseOffset Starting offset of the input. Node locations are calculated relative to this offset.
     * @returns Agent rule AST
     * @throws {AdblockSyntaxError} If the raw rule cannot be parsed as an adblock agent
     */
    static parse(raw, options = parser_options/* defaultParserOptions */.n, baseOffset = 0) {
        let offset = 0;
        // Save name start position
        const nameStartIndex = offset;
        let nameEndIndex = offset;
        // Prepare variables for name and version
        let name;
        let version;
        // default value for the syntax
        let syntax = adblockers/* AdblockSyntax */.Y.Common;
        // Get agent parts by splitting it by spaces. The last part may be a version.
        // Example: "Adblock Plus 2.0"
        while (offset < raw.length) {
            // Skip whitespace before the part
            offset = string/* StringUtils */.$x.skipWS(raw, offset);
            const partEnd = string/* StringUtils */.$x.findNextWhitespaceCharacter(raw, offset);
            const part = raw.slice(offset, partEnd);
            if (AgentParser.isValidVersion(part)) {
                if (!(0,type_guards/* isUndefined */.b0)(version)) {
                    throw new adblock_syntax_error/* AdblockSyntaxError */.q('Duplicated versions are not allowed', baseOffset + offset, baseOffset + partEnd);
                }
                const parsedNamePart = raw.slice(nameStartIndex, nameEndIndex);
                name = ValueParser.parse(parsedNamePart, options, baseOffset + nameStartIndex);
                version = ValueParser.parse(part, options, baseOffset + offset);
                syntax = (0,agent_common/* getAdblockSyntax */.w)(parsedNamePart);
            }
            else {
                nameEndIndex = partEnd;
            }
            // Skip whitespace after the part
            offset = string/* StringUtils */.$x.skipWS(raw, partEnd);
        }
        // If we didn't find a version, the whole string is the name
        if ((0,type_guards/* isUndefined */.b0)(name)) {
            const parsedNamePart = raw.slice(nameStartIndex, nameEndIndex);
            name = ValueParser.parse(parsedNamePart, options, baseOffset + nameStartIndex);
            syntax = (0,agent_common/* getAdblockSyntax */.w)(parsedNamePart);
        }
        // Agent name cannot be empty
        if (name.value.length === 0) {
            throw new adblock_syntax_error/* AdblockSyntaxError */.q('Agent name cannot be empty', baseOffset, baseOffset + raw.length);
        }
        const result = {
            type: 'Agent',
            adblock: name,
            syntax,
        };
        // only add version if it's present
        if (version) {
            result.version = version;
        }
        if (options.isLocIncluded) {
            result.start = baseOffset;
            result.end = baseOffset + raw.length;
        }
        return result;
    }
}



// EXTERNAL MODULE: ./node_modules/.pnpm/@adguard+agtree@3.1.3/node_modules/@adguard/agtree/dist/utils/cosmetic-rule-separator.js
var cosmetic_rule_separator = __webpack_require__(80576);
;// ./node_modules/.pnpm/@adguard+agtree@3.1.3/node_modules/@adguard/agtree/dist/parser/comment/agent-comment-parser.js
/*
 * AGTree v3.1.3 (build date: Tue, 29 Apr 2025 12:25:03 GMT)
 * (c) 2025 Adguard Software Ltd.
 * Released under the MIT license
 * https://github.com/AdguardTeam/tsurlfilter/tree/master/packages/agtree#readme
 */











/**
 * `AgentParser` is responsible for parsing an Adblock agent rules.
 * Adblock agent comment marks that the filter list is supposed to
 * be used by the specified ad blockers.
 *
 * @example
 *  - ```adblock
 *    [AdGuard]
 *    ```
 *  - ```adblock
 *    [Adblock Plus 2.0]
 *    ```
 *  - ```adblock
 *    [uBlock Origin]
 *    ```
 *  - ```adblock
 *    [uBlock Origin 1.45.3]
 *    ```
 *  - ```adblock
 *    [Adblock Plus 2.0; AdGuard]
 *    ```
 */
class AgentCommentParser extends base_parser/* BaseParser */.V {
    /**
     * Checks if the raw rule is an adblock agent comment.
     *
     * @param raw Raw rule
     * @returns `true` if the rule is an adblock agent, `false` otherwise
     */
    static isAgentRule(raw) {
        const rawTrimmed = raw.trim();
        if (rawTrimmed.startsWith(constants/* OPEN_SQUARE_BRACKET */.cU) && rawTrimmed.endsWith(constants/* CLOSE_SQUARE_BRACKET */.A1)) {
            // Avoid this case: [$adg-modifier]##[class^="adg-"]
            return (0,type_guards/* isNull */.kZ)(cosmetic_rule_separator/* CosmeticRuleSeparatorUtils */.m.find(rawTrimmed));
        }
        return false;
    }
    /**
     * Parses a raw rule as an adblock agent comment.
     *
     * @param raw Raw input to parse.
     * @param options Global parser options.
     * @param baseOffset Starting offset of the input. Node locations are calculated relative to this offset.
     * @returns Agent rule AST or null (if the raw rule cannot be parsed as an adblock agent comment)
     */
    static parse(raw, options = parser_options/* defaultParserOptions */.n, baseOffset = 0) {
        // Ignore non-agent rules
        if (!AgentCommentParser.isAgentRule(raw)) {
            return null;
        }
        let offset = 0;
        // Skip whitespace characters before the rule
        offset = string/* StringUtils */.$x.skipWS(raw, offset);
        // Skip opening bracket
        offset += 1;
        // last character should be a closing bracket
        const closingBracketIndex = string/* StringUtils */.$x.skipWSBack(raw, raw.length - 1);
        if (closingBracketIndex === -1 || raw[closingBracketIndex] !== constants/* CLOSE_SQUARE_BRACKET */.A1) {
            throw new adblock_syntax_error/* AdblockSyntaxError */.q('Missing closing bracket', offset, offset + raw.length);
        }
        // Initialize the agent list
        const result = {
            type: nodes/* CommentRuleType */.gV.AgentCommentRule,
            syntax: adblockers/* AdblockSyntax */.Y.Common,
            category: nodes/* RuleCategory */.$O.Comment,
            children: [],
        };
        if (options.includeRaws) {
            result.raws = {
                text: raw,
            };
        }
        if (options.isLocIncluded) {
            result.start = baseOffset;
            result.end = baseOffset + raw.length;
        }
        while (offset < closingBracketIndex) {
            // Skip whitespace characters before the agent
            offset = string/* StringUtils */.$x.skipWS(raw, offset);
            // Find the separator or the closing bracket
            let separatorIndex = raw.indexOf(constants/* SEMICOLON */.I8, offset);
            if (separatorIndex === -1) {
                separatorIndex = closingBracketIndex;
            }
            // Find the last non-whitespace character of the agent
            // [AdGuard  ; Adblock Plus 2.0]
            //        ^
            // (if we have spaces between the agent name and the separator)
            const agentEndIndex = string/* StringUtils */.$x.findLastNonWhitespaceCharacter(raw.slice(offset, separatorIndex)) + offset + 1;
            // Collect the agent
            result.children.push(AgentParser.parse(raw.slice(offset, agentEndIndex), options, baseOffset + offset));
            // Set the offset to the next agent or the end of the rule
            offset = separatorIndex + 1;
        }
        if (result.children.length === 0) {
            throw new adblock_syntax_error/* AdblockSyntaxError */.q('Empty agent list', baseOffset, baseOffset + raw.length);
        }
        return result;
    }
}



// EXTERNAL MODULE: ./node_modules/.pnpm/json5@2.2.3/node_modules/json5/dist/index.js
var dist = __webpack_require__(91801);
;// ./node_modules/.pnpm/@adguard+agtree@3.1.3/node_modules/@adguard/agtree/dist/parser/misc/parameter-list-parser.js
/*
 * AGTree v3.1.3 (build date: Tue, 29 Apr 2025 12:25:03 GMT)
 * (c) 2025 Adguard Software Ltd.
 * Released under the MIT license
 * https://github.com/AdguardTeam/tsurlfilter/tree/master/packages/agtree#readme
 */






/**
 * Parser for parameter lists.
 */
class ParameterListParser extends base_parser/* BaseParser */.V {
    /**
     * Parses a raw parameter list.
     *
     * @param raw Raw input to parse.
     * @param options Global parser options.
     * @param baseOffset Starting offset of the input. Node locations are calculated relative to this offset.
     * @param separator Separator character (default: comma)
     * @returns Parameter list AST
     */
    static parse(raw, options = parser_options/* defaultParserOptions */.n, baseOffset = 0, separator = constants/* COMMA */.KE) {
        // Prepare the parameter list node
        const params = {
            type: 'ParameterList',
            children: [],
        };
        const { length } = raw;
        if (options.isLocIncluded) {
            params.start = baseOffset;
            params.end = baseOffset + length;
        }
        let offset = 0;
        // Parse parameters: skip whitespace before and after each parameter, and
        // split parameters by the separator character.
        while (offset < length) {
            // Skip whitespace before parameter
            offset = string/* StringUtils */.$x.skipWS(raw, offset);
            // Parameter may only contain whitespace
            // In this case, we reached the end of the parameter list
            if (raw[offset] === separator || offset === length) {
                // Add a null for empty parameter
                params.children.push(null);
                // Skip separator
                offset += 1;
            }
            else {
                // Get parameter start position
                const paramStart = offset;
                // Get next unescaped separator position
                const nextSeparator = string/* StringUtils */.$x.findUnescapedNonStringNonRegexChar(raw, separator, offset);
                // Get parameter end position
                const paramEnd = nextSeparator !== -1
                    ? string/* StringUtils */.$x.skipWSBack(raw, nextSeparator - 1)
                    : string/* StringUtils */.$x.skipWSBack(raw);
                // Add parameter to the list
                const param = ValueParser.parse(raw.slice(paramStart, paramEnd + 1), options, baseOffset + paramStart);
                params.children.push(param);
                // Set offset to the next separator position + 1
                offset = nextSeparator !== -1 ? nextSeparator + 1 : length;
            }
        }
        // If the last character was a separator, add an additional null parameter
        if (raw[length - 1] === separator) {
            params.children.push(null);
        }
        return params;
    }
}



;// ./node_modules/.pnpm/@adguard+agtree@3.1.3/node_modules/@adguard/agtree/dist/parser/comment/config-comment-parser.js
/*
 * AGTree v3.1.3 (build date: Tue, 29 Apr 2025 12:25:03 GMT)
 * (c) 2025 Adguard Software Ltd.
 * Released under the MIT license
 * https://github.com/AdguardTeam/tsurlfilter/tree/master/packages/agtree#readme
 */










/**
 * @file AGLint configuration comments. Inspired by ESLint inline configuration comments.
 * @see {@link https://eslint.org/docs/latest/user-guide/configuring/rules#using-configuration-comments}
 */
/**
 * `ConfigCommentParser` is responsible for parsing inline AGLint configuration rules.
 * Generally, the idea is inspired by ESLint inline configuration comments.
 *
 * @see {@link https://eslint.org/docs/latest/user-guide/configuring/rules#using-configuration-comments}
 */
class ConfigCommentParser extends base_parser/* BaseParser */.V {
    /**
     * Checks if the raw rule is an inline configuration comment rule.
     *
     * @param raw Raw rule
     * @returns `true` if the rule is an inline configuration comment rule, otherwise `false`.
     */
    static isConfigComment(raw) {
        const trimmed = raw.trim();
        if (trimmed[0] === nodes/* CommentMarker */.yg.Regular || trimmed[0] === nodes/* CommentMarker */.yg.Hashmark) {
            // Skip comment marker and trim comment text (it is necessary because of "!     something")
            const text = raw.slice(1).trim();
            // The code below is "not pretty", but it runs fast, which is necessary, since it will run on EVERY comment
            // The essence of the indicator is that the control comment always starts with the "aglint" prefix
            return ((text[0] === 'a' || text[0] === 'A')
                && (text[1] === 'g' || text[1] === 'G')
                && (text[2] === 'l' || text[2] === 'L')
                && (text[3] === 'i' || text[3] === 'I')
                && (text[4] === 'n' || text[4] === 'N')
                && (text[5] === 't' || text[5] === 'T'));
        }
        return false;
    }
    /**
     * Parses a raw rule as an inline configuration comment.
     *
     * @param raw Raw input to parse.
     * @param options Global parser options.
     * @param baseOffset Starting offset of the input. Node locations are calculated relative to this offset.
     * @returns
     * Inline configuration comment AST or null (if the raw rule cannot be parsed as configuration comment)
     */
    static parse(raw, options = parser_options/* defaultParserOptions */.n, baseOffset = 0) {
        if (!ConfigCommentParser.isConfigComment(raw)) {
            return null;
        }
        let offset = 0;
        // Skip leading whitespace (if any)
        offset = string/* StringUtils */.$x.skipWS(raw, offset);
        // Get comment marker
        const marker = ValueParser.parse(raw[offset], options, baseOffset + offset);
        // Skip marker
        offset += 1;
        // Skip whitespace (if any)
        offset = string/* StringUtils */.$x.skipWS(raw, offset);
        // Save the command start position
        const commandStart = offset;
        // Get comment text, for example: "aglint-disable-next-line"
        offset = string/* StringUtils */.$x.findNextWhitespaceCharacter(raw, offset);
        const command = ValueParser.parse(raw.slice(commandStart, offset), options, baseOffset + commandStart);
        // Skip whitespace after command
        offset = string/* StringUtils */.$x.skipWS(raw, offset);
        // Get comment (if any)
        const commentStart = raw.indexOf(constants/* AGLINT_CONFIG_COMMENT_MARKER */.Ez, offset);
        const commentEnd = commentStart !== -1 ? string/* StringUtils */.$x.skipWSBack(raw) + 1 : -1;
        let comment;
        // Check if there is a comment
        if (commentStart !== -1) {
            comment = ValueParser.parse(raw.slice(commentStart, commentEnd), options, baseOffset + commentStart);
        }
        // Get parameter
        const paramsStart = offset;
        const paramsEnd = commentStart !== -1
            ? string/* StringUtils */.$x.skipWSBack(raw, commentStart - 1) + 1
            : string/* StringUtils */.$x.skipWSBack(raw) + 1;
        let params;
        // `! aglint ...` config comment
        if (command.value === constants/* AGLINT_COMMAND_PREFIX */.BH) {
            params = {
                type: 'ConfigNode',
                // It is necessary to use JSON5.parse instead of JSON.parse because JSON5 allows unquoted keys.
                // But don't forget to add { } to the beginning and end of the string,
                // otherwise JSON5 will not be able to parse it.
                // TODO: Better solution? ESLint uses "levn" package for parsing these comments.
                value: dist.parse(`{${raw.slice(paramsStart, paramsEnd)}}`),
            };
            if (options.isLocIncluded) {
                params.start = paramsStart;
                params.end = paramsEnd;
            }
            // Throw error for empty config
            if (Object.keys(params.value).length === 0) {
                throw new Error('Empty AGLint config');
            }
        }
        else if (paramsStart < paramsEnd) {
            params = ParameterListParser.parse(raw.slice(paramsStart, paramsEnd), options, baseOffset + paramsStart, constants/* COMMA */.KE);
        }
        const result = {
            type: nodes/* CommentRuleType */.gV.ConfigCommentRule,
            category: nodes/* RuleCategory */.$O.Comment,
            syntax: adblockers/* AdblockSyntax */.Y.Common,
            marker,
            command,
            params,
            comment,
        };
        if (options.includeRaws) {
            result.raws = {
                text: raw,
            };
        }
        if (options.isLocIncluded) {
            result.start = baseOffset;
            result.end = baseOffset + raw.length;
        }
        return result;
    }
}



;// ./node_modules/.pnpm/@adguard+agtree@3.1.3/node_modules/@adguard/agtree/dist/parser/comment/hint-parser.js
/*
 * AGTree v3.1.3 (build date: Tue, 29 Apr 2025 12:25:03 GMT)
 * (c) 2025 Adguard Software Ltd.
 * Released under the MIT license
 * https://github.com/AdguardTeam/tsurlfilter/tree/master/packages/agtree#readme
 */








/* eslint-disable no-param-reassign */
/**
 * @file AdGuard Hints
 * @see {@link https://kb.adguard.com/en/general/how-to-create-your-own-ad-filters#hints}
 */
/**
 * `HintParser` is responsible for parsing AdGuard hints.
 *
 * @example
 * If the hint rule is
 * ```adblock
 * !+ NOT_OPTIMIZED PLATFORM(windows)
 * ```
 * then the hints are `NOT_OPTIMIZED` and `PLATFORM(windows)`, and this
 * class is responsible for parsing them. The rule itself is parsed by
 * the `HintRuleParser`, which uses this class to parse single hints.
 */
class HintParser extends base_parser/* BaseParser */.V {
    /**
     * Parses a raw rule as a hint.
     *
     * @param raw Raw input to parse.
     * @param options Global parser options.
     * @param baseOffset Starting offset of the input. Node locations are calculated relative to this offset.
     * @returns Hint rule AST or null
     * @throws If the syntax is invalid
     */
    static parse(raw, options = parser_options/* defaultParserOptions */.n, baseOffset = 0) {
        let offset = 0;
        // Skip whitespace characters before the hint
        offset = string/* StringUtils */.$x.skipWS(raw);
        // Hint should start with the hint name in every case
        // Save the start offset of the hint name
        const nameStartIndex = offset;
        // Parse the hint name
        for (; offset < raw.length; offset += 1) {
            const char = raw[offset];
            // Abort consuming the hint name if we encounter a whitespace character
            // or an opening parenthesis, which means 'HIT_NAME(' case
            if (char === constants/* OPEN_PARENTHESIS */.Cx || char === constants/* SPACE */.t6) {
                break;
            }
            // Hint name should only contain letters, digits, and underscores
            if (!string/* StringUtils */.$x.isAlphaNumeric(char) && char !== constants/* UNDERSCORE */.fB) {
                throw new adblock_syntax_error/* AdblockSyntaxError */.q(`Invalid character "${char}" in hint name: "${char}"`, baseOffset + nameStartIndex, baseOffset + offset);
            }
        }
        // Save the end offset of the hint name
        const nameEndIndex = offset;
        // Save the hint name token
        const name = raw.slice(nameStartIndex, nameEndIndex);
        // Hint name cannot be empty
        if (name === constants/* EMPTY */.wg) {
            throw new adblock_syntax_error/* AdblockSyntaxError */.q('Empty hint name', baseOffset, baseOffset + nameEndIndex);
        }
        // Now we have two case:
        //  1. We have HINT_NAME and should return it
        //  2. We have HINT_NAME(PARAMS) and should continue parsing
        // Skip whitespace characters after the hint name
        offset = string/* StringUtils */.$x.skipWS(raw, offset);
        // Throw error for 'HINT_NAME (' case
        if (offset > nameEndIndex && raw[offset] === constants/* OPEN_PARENTHESIS */.Cx) {
            throw new adblock_syntax_error/* AdblockSyntaxError */.q('Unexpected whitespace(s) between hint name and opening parenthesis', baseOffset + nameEndIndex, baseOffset + offset);
        }
        // Create the hint name node (we can reuse it in the 'HINT_NAME' case, if needed)
        const nameNode = ValueParser.parse(name, options, baseOffset + nameStartIndex);
        // Just return the hint name if we have 'HINT_NAME' case (no params)
        if (raw[offset] !== constants/* OPEN_PARENTHESIS */.Cx) {
            const result = {
                type: 'Hint',
                name: nameNode,
            };
            if (options.isLocIncluded) {
                result.start = baseOffset;
                result.end = baseOffset + offset;
            }
            return result;
        }
        // Skip the opening parenthesis
        offset += 1;
        // Find closing parenthesis
        const closeParenthesisIndex = raw.lastIndexOf(constants/* CLOSE_PARENTHESIS */.s1);
        // Throw error if we don't have closing parenthesis
        if (closeParenthesisIndex === -1) {
            throw new adblock_syntax_error/* AdblockSyntaxError */.q(`Missing closing parenthesis for hint "${name}"`, baseOffset + nameStartIndex, baseOffset + raw.length);
        }
        // Save the start and end index of the params
        const paramsStartIndex = offset;
        const paramsEndIndex = closeParenthesisIndex;
        // Parse the params
        const params = ParameterListParser.parse(raw.slice(paramsStartIndex, paramsEndIndex), options, baseOffset + paramsStartIndex, constants/* COMMA */.KE);
        offset = closeParenthesisIndex + 1;
        // Skip whitespace characters after the closing parenthesis
        offset = string/* StringUtils */.$x.skipWS(raw, offset);
        // Throw error if we don't reach the end of the input
        if (offset !== raw.length) {
            throw new adblock_syntax_error/* AdblockSyntaxError */.q(
            // eslint-disable-next-line max-len
            `Unexpected input after closing parenthesis for hint "${name}": "${raw.slice(closeParenthesisIndex + 1, offset + 1)}"`, baseOffset + closeParenthesisIndex + 1, baseOffset + offset + 1);
        }
        // Return the HINT_NAME(PARAMS) case AST
        const result = {
            type: 'Hint',
            name: nameNode,
            params,
        };
        if (options.isLocIncluded) {
            result.start = baseOffset;
            result.end = baseOffset + offset;
        }
        return result;
    }
}



;// ./node_modules/.pnpm/@adguard+agtree@3.1.3/node_modules/@adguard/agtree/dist/parser/comment/hint-comment-parser.js
/*
 * AGTree v3.1.3 (build date: Tue, 29 Apr 2025 12:25:03 GMT)
 * (c) 2025 Adguard Software Ltd.
 * Released under the MIT license
 * https://github.com/AdguardTeam/tsurlfilter/tree/master/packages/agtree#readme
 */









/**
 * `HintRuleParser` is responsible for parsing AdGuard hint rules.
 *
 * @example
 * The following hint rule
 * ```adblock
 * !+ NOT_OPTIMIZED PLATFORM(windows)
 * ```
 * contains two hints: `NOT_OPTIMIZED` and `PLATFORM`.
 * @see {@link https://kb.adguard.com/en/general/how-to-create-your-own-ad-filters#hints}
 */
class HintCommentParser extends base_parser/* BaseParser */.V {
    /**
     * Checks if the raw rule is a hint rule.
     *
     * @param raw Raw rule
     * @returns `true` if the rule is a hint rule, `false` otherwise
     */
    static isHintRule(raw) {
        return raw.trim().startsWith(constants/* HINT_MARKER */.j6);
    }
    /**
     * Parses a raw rule as a hint comment.
     *
     * @param raw Raw input to parse.
     * @param options Global parser options.
     * @param baseOffset Starting offset of the input. Node locations are calculated relative to this offset.
     * @returns Hint AST or null (if the raw rule cannot be parsed as a hint comment)
     * @throws If the input matches the HINT pattern but syntactically invalid
     * @see {@link https://kb.adguard.com/en/general/how-to-create-your-own-ad-filters#hints-1}
     */
    static parse(raw, options = parser_options/* defaultParserOptions */.n, baseOffset = 0) {
        // Ignore non-hint rules
        if (!HintCommentParser.isHintRule(raw)) {
            return null;
        }
        let offset = 0;
        // Skip whitespace characters before the rule
        offset = string/* StringUtils */.$x.skipWS(raw);
        // Skip hint marker
        offset += constants/* HINT_MARKER_LEN */.BR;
        const hints = [];
        // Collect hints. Each hint is a string, optionally followed by a parameter list,
        // enclosed in parentheses. One rule can contain multiple hints.
        while (offset < raw.length) {
            // Split rule into raw hints (e.g. 'HINT_NAME' or 'HINT_NAME(PARAMS)')
            // Hints are separated by whitespace characters, but we should ignore
            // whitespace characters inside the parameter list
            // Ignore whitespace characters before the hint
            offset = string/* StringUtils */.$x.skipWS(raw, offset);
            // Save the start index of the hint
            const hintStartIndex = offset;
            // Find the end of the hint
            let hintEndIndex = offset;
            let balance = 0;
            while (hintEndIndex < raw.length) {
                if (raw[hintEndIndex] === constants/* OPEN_PARENTHESIS */.Cx && raw[hintEndIndex - 1] !== constants/* BACKSLASH */.r_) {
                    balance += 1;
                    // Throw error for nesting
                    if (balance > 1) {
                        throw new adblock_syntax_error/* AdblockSyntaxError */.q('Invalid hint: nested parentheses are not allowed', baseOffset + hintStartIndex, baseOffset + hintEndIndex);
                    }
                }
                else if (raw[hintEndIndex] === constants/* CLOSE_PARENTHESIS */.s1 && raw[hintEndIndex - 1] !== constants/* BACKSLASH */.r_) {
                    balance -= 1;
                }
                else if (string/* StringUtils */.$x.isWhitespace(raw[hintEndIndex]) && balance === 0) {
                    break;
                }
                hintEndIndex += 1;
            }
            offset = hintEndIndex;
            // Skip whitespace characters after the hint
            offset = string/* StringUtils */.$x.skipWS(raw, offset);
            // Parse the hint
            const hint = HintParser.parse(raw.slice(hintStartIndex, hintEndIndex), options, baseOffset + hintStartIndex);
            hints.push(hint);
        }
        // Throw error if no hints were found
        if (hints.length === 0) {
            throw new adblock_syntax_error/* AdblockSyntaxError */.q('Empty hint rule', baseOffset, baseOffset + offset);
        }
        const result = {
            type: nodes/* CommentRuleType */.gV.HintCommentRule,
            category: nodes/* RuleCategory */.$O.Comment,
            syntax: adblockers/* AdblockSyntax */.Y.Adg,
            children: hints,
        };
        if (options.includeRaws) {
            result.raws = {
                text: raw,
            };
        }
        if (options.isLocIncluded) {
            result.start = baseOffset;
            result.end = baseOffset + offset;
        }
        return result;
    }
}



;// ./node_modules/.pnpm/@adguard+agtree@3.1.3/node_modules/@adguard/agtree/dist/parser/comment/metadata-comment-parser.js
/*
 * AGTree v3.1.3 (build date: Tue, 29 Apr 2025 12:25:03 GMT)
 * (c) 2025 Adguard Software Ltd.
 * Released under the MIT license
 * https://github.com/AdguardTeam/tsurlfilter/tree/master/packages/agtree#readme
 */








/**
 * @file Metadata comments
 */
/**
 * Set of known metadata headers. This helps to quickly identify and validate
 * metadata headers in the comments.
 */
const KNOWN_METADATA_HEADERS = new Set([
    'Checksum',
    'Description',
    'Expires',
    'Homepage',
    'Last Modified',
    'LastModified',
    'Licence',
    'License',
    'Time Updated',
    'TimeUpdated',
    'Version',
    'Title',
]);
/**
 * `MetadataParser` is responsible for parsing metadata comments.
 * Metadata comments are special comments that specify some properties of the list.
 *
 * @example
 * For example, in the case of
 * ```adblock
 * ! Title: My List
 * ```
 * the name of the header is `Title`, and the value is `My List`, which means that
 * the list title is `My List`, and it can be used in the adblocker UI.
 * @see {@link https://help.eyeo.com/adblockplus/how-to-write-filters#special-comments}
 */
class MetadataCommentParser extends base_parser/* BaseParser */.V {
    /**
     * Parses a raw rule as a metadata comment.
     *
     * @param raw Raw input to parse.
     * @param options Global parser options.
     * @param baseOffset Starting offset of the input. Node locations are calculated relative to this offset.
     * @returns Metadata comment AST or null (if the raw rule cannot be parsed as a metadata comment)
     */
    static parse(raw, options = parser_options/* defaultParserOptions */.n, baseOffset = 0) {
        // Fast check to avoid unnecessary work
        if (raw.indexOf(constants/* COLON */.oH) === -1) {
            return null;
        }
        let offset = 0;
        // Skip leading spaces before the comment marker
        offset = string/* StringUtils */.$x.skipWS(raw, offset);
        // Check if the rule starts with a comment marker (first non-space sequence)
        if (raw[offset] !== nodes/* CommentMarker */.yg.Regular && raw[offset] !== nodes/* CommentMarker */.yg.Hashmark) {
            return null;
        }
        // Consume the comment marker
        const marker = ValueParser.parse(raw[offset], options, baseOffset + offset);
        offset += 1;
        // Skip spaces
        offset = string/* StringUtils */.$x.skipWS(raw, offset);
        // Save header start position
        const headerStart = offset;
        // Check if the comment text starts with a known header
        const text = raw.slice(offset);
        for (const knownHeader of KNOWN_METADATA_HEADERS) {
            // Check if the comment text starts with the header (case-insensitive)
            if (text.toLocaleLowerCase().startsWith(knownHeader.toLocaleLowerCase())) {
                // Skip the header
                offset += knownHeader.length;
                // Save header
                const header = ValueParser.parse(raw.slice(headerStart, offset), options, baseOffset + headerStart);
                // Skip spaces after the header
                offset = string/* StringUtils */.$x.skipWS(raw, offset);
                // Check if the rule contains a separator after the header
                if (raw[offset] !== constants/* COLON */.oH) {
                    return null;
                }
                // Skip the separator
                offset += 1;
                // Skip spaces after the separator
                offset = string/* StringUtils */.$x.skipWS(raw, offset);
                // Save the value start position
                const valueStart = offset;
                // Check if the rule contains a value
                if (offset >= raw.length) {
                    return null;
                }
                const valueEnd = string/* StringUtils */.$x.skipWSBack(raw, raw.length - 1) + 1;
                // Save the value
                const value = ValueParser.parse(raw.slice(valueStart, valueEnd), options, baseOffset + valueStart);
                const result = {
                    type: nodes/* CommentRuleType */.gV.MetadataCommentRule,
                    category: nodes/* RuleCategory */.$O.Comment,
                    syntax: adblockers/* AdblockSyntax */.Y.Common,
                    marker,
                    header,
                    value,
                };
                if (options.includeRaws) {
                    result.raws = {
                        text: raw,
                    };
                }
                if (options.isLocIncluded) {
                    result.start = baseOffset;
                    result.end = baseOffset + raw.length;
                }
                return result;
            }
        }
        return null;
    }
}



// EXTERNAL MODULE: ./node_modules/.pnpm/@adguard+agtree@3.1.3/node_modules/@adguard/agtree/dist/parser/misc/logical-expression-parser.js
var logical_expression_parser = __webpack_require__(11951);
;// ./node_modules/.pnpm/@adguard+agtree@3.1.3/node_modules/@adguard/agtree/dist/parser/comment/preprocessor-parser.js
/*
 * AGTree v3.1.3 (build date: Tue, 29 Apr 2025 12:25:03 GMT)
 * (c) 2025 Adguard Software Ltd.
 * Released under the MIT license
 * https://github.com/AdguardTeam/tsurlfilter/tree/master/packages/agtree#readme
 */











/**
 * Pre-processor directives
 *
 * @see {@link https://kb.adguard.com/en/general/how-to-create-your-own-ad-filters#pre-processor-directives}
 * @see {@link https://github.com/gorhill/uBlock/wiki/Static-filter-syntax#pre-parsing-directives}
 */
/**
 * `PreProcessorParser` is responsible for parsing preprocessor rules.
 * Pre-processor comments are special comments that are used to control the behavior of the filter list processor.
 * Please note that this parser only handles general syntax for now, and does not validate the parameters at
 * the parsing stage.
 *
 * @example
 * If your rule is
 * ```adblock
 * !#if (adguard)
 * ```
 * then the directive's name is `if` and its value is `(adguard)`, but the parameter list
 * is not parsed / validated further.
 * @see {@link https://kb.adguard.com/en/general/how-to-create-your-own-ad-filters#pre-processor-directives}
 * @see {@link https://github.com/gorhill/uBlock/wiki/Static-filter-syntax#pre-parsing-directives}
 */
class PreProcessorCommentParser extends base_parser/* BaseParser */.V {
    /**
     * Determines whether the rule is a pre-processor rule.
     *
     * @param raw Raw rule
     * @returns `true` if the rule is a pre-processor rule, `false` otherwise
     */
    static isPreProcessorRule(raw) {
        const trimmed = raw.trim();
        // Avoid this case: !##... (commonly used in AdGuard filters)
        return trimmed.startsWith(constants/* PREPROCESSOR_MARKER */.PD) && trimmed[constants/* PREPROCESSOR_MARKER_LEN */.nx] !== constants/* HASHMARK */.C;
    }
    /**
     * Parses a raw rule as a pre-processor comment.
     *
     * @param raw Raw input to parse.
     * @param options Global parser options.
     * @param baseOffset Starting offset of the input. Node locations are calculated relative to this offset.
     * @returns
     * Pre-processor comment AST or null (if the raw rule cannot be parsed as a pre-processor comment)
     */
    static parse(raw, options = parser_options/* defaultParserOptions */.n, baseOffset = 0) {
        // Ignore non-pre-processor rules
        if (!PreProcessorCommentParser.isPreProcessorRule(raw)) {
            return null;
        }
        let offset = 0;
        // Ignore whitespace characters before the rule (if any)
        offset = string/* StringUtils */.$x.skipWS(raw, offset);
        // Ignore the pre-processor marker
        offset += constants/* PREPROCESSOR_MARKER_LEN */.nx;
        // Ignore whitespace characters after the pre-processor marker (if any)
        // Note: this is incorrect according to the spec, but we do it for tolerance
        offset = string/* StringUtils */.$x.skipWS(raw, offset);
        // Directive name should start at this offset, so we save this offset now
        const nameStart = offset;
        // Consume directive name, so parse the sequence until the first
        // whitespace / opening parenthesis / end of string
        while (offset < raw.length) {
            const ch = raw[offset];
            if (ch === constants/* PREPROCESSOR_SEPARATOR */.sA || ch === constants/* OPEN_PARENTHESIS */.Cx) {
                break;
            }
            offset += 1;
        }
        // Save name end offset
        const nameEnd = offset;
        // Create name node
        const name = ValueParser.parse(raw.slice(nameStart, nameEnd), options, baseOffset + nameStart);
        // Ignore whitespace characters after the directive name (if any)
        // Note: this may incorrect according to the spec, but we do it for tolerance
        offset = string/* StringUtils */.$x.skipWS(raw, offset);
        // If the directive name is "safari_cb_affinity", then we have a special case
        if (name.value === constants/* SAFARI_CB_AFFINITY */.us) {
            // Throw error if there are spaces after the directive name
            if (offset > nameEnd) {
                throw new adblock_syntax_error/* AdblockSyntaxError */.q(`Unexpected whitespace after "${constants/* SAFARI_CB_AFFINITY */.us}" directive name`, baseOffset + nameEnd, baseOffset + offset);
            }
            // safari_cb_affinity directive optionally accepts a parameter list
            // So at this point we should check if there are parameters or not
            // (cb_affinity directive followed by an opening parenthesis or if we
            // skip the whitespace we reach the end of the string)
            if (string/* StringUtils */.$x.skipWS(raw, offset) !== raw.length) {
                if (raw[offset] !== constants/* OPEN_PARENTHESIS */.Cx) {
                    throw new adblock_syntax_error/* AdblockSyntaxError */.q(`Unexpected character '${raw[offset]}' after '${constants/* SAFARI_CB_AFFINITY */.us}' directive name`, baseOffset + offset, baseOffset + offset + 1);
                }
                // If we have parameters, then we should parse them
                // Note: we don't validate the parameters at this stage
                // Ignore opening parenthesis
                offset += 1;
                // Save parameter list start offset
                const parameterListStart = offset;
                // Check for closing parenthesis
                const closingParenthesesIndex = string/* StringUtils */.$x.skipWSBack(raw);
                if (closingParenthesesIndex === -1 || raw[closingParenthesesIndex] !== constants/* CLOSE_PARENTHESIS */.s1) {
                    throw new adblock_syntax_error/* AdblockSyntaxError */.q(`Missing closing parenthesis for '${constants/* SAFARI_CB_AFFINITY */.us}' directive`, baseOffset + offset, baseOffset + raw.length);
                }
                // Save parameter list end offset
                const parameterListEnd = closingParenthesesIndex;
                // Parse parameters between the opening and closing parentheses
                const result = {
                    type: nodes/* CommentRuleType */.gV.PreProcessorCommentRule,
                    category: nodes/* RuleCategory */.$O.Comment,
                    syntax: adblockers/* AdblockSyntax */.Y.Adg,
                    name,
                    // comma separated list of parameters
                    params: ParameterListParser.parse(raw.slice(parameterListStart, parameterListEnd), options, baseOffset + parameterListStart, constants/* COMMA */.KE),
                };
                if (options.includeRaws) {
                    result.raws = {
                        text: raw,
                    };
                }
                if (options.isLocIncluded) {
                    result.start = baseOffset;
                    result.end = baseOffset + raw.length;
                }
                return result;
            }
        }
        // If we reached the end of the string, then we have a directive without parameters
        // (e.g. "!#safari_cb_affinity" or "!#endif")
        // No need to continue parsing in this case.
        if (offset === raw.length) {
            // Throw error if the directive name is "if" or "include", because these directives
            // should have parameters
            if (name.value === constants.IF || name.value === constants/* INCLUDE */.rM) {
                throw new adblock_syntax_error/* AdblockSyntaxError */.q(`Directive "${name.value}" requires parameters`, baseOffset, baseOffset + raw.length);
            }
            const result = {
                type: nodes/* CommentRuleType */.gV.PreProcessorCommentRule,
                category: nodes/* RuleCategory */.$O.Comment,
                syntax: adblockers/* AdblockSyntax */.Y.Common,
                name,
            };
            if (options.includeRaws) {
                result.raws = {
                    text: raw,
                };
            }
            if (options.isLocIncluded) {
                result.start = baseOffset;
                result.end = baseOffset + raw.length;
            }
            return result;
        }
        // Get start and end offsets of the directive parameters
        const paramsStart = offset;
        const paramsEnd = string/* StringUtils */.$x.skipWSBack(raw) + 1;
        // Prepare parameters node
        let params;
        // Parse parameters. Handle "if" and "safari_cb_affinity" directives
        // separately.
        if (name.value === constants.IF) {
            params = logical_expression_parser/* LogicalExpressionParser */.f.parse(raw.slice(paramsStart, paramsEnd), options, baseOffset + paramsStart);
        }
        else {
            params = ValueParser.parse(raw.slice(paramsStart, paramsEnd), options, baseOffset + paramsStart);
        }
        const result = {
            type: nodes/* CommentRuleType */.gV.PreProcessorCommentRule,
            category: nodes/* RuleCategory */.$O.Comment,
            syntax: adblockers/* AdblockSyntax */.Y.Common,
            name,
            params,
        };
        if (options.includeRaws) {
            result.raws = {
                text: raw,
            };
        }
        if (options.isLocIncluded) {
            result.start = baseOffset;
            result.end = baseOffset + raw.length;
        }
        return result;
    }
}



;// ./node_modules/.pnpm/@adguard+agtree@3.1.3/node_modules/@adguard/agtree/dist/parser/comment/simple-comment-parser.js
/*
 * AGTree v3.1.3 (build date: Tue, 29 Apr 2025 12:25:03 GMT)
 * (c) 2025 Adguard Software Ltd.
 * Released under the MIT license
 * https://github.com/AdguardTeam/tsurlfilter/tree/master/packages/agtree#readme
 */








/**
 * `SimpleCommentParser` is responsible for parsing simple comments.
 * Some comments have a special meaning in adblock syntax, like agent comments or hints,
 * but this parser is only responsible for parsing regular comments,
 * whose only purpose is to provide some human-readable information.
 *
 * @example
 * ```adblock
 * ! This is a simple comment
 * # This is a simple comment, but in host-like syntax
 * ```
 */
class SimpleCommentParser extends base_parser/* BaseParser */.V {
    /**
     * Checks if the raw rule is a simple comment.
     *
     * @param raw Raw input to check.
     * @returns `true` if the input is a simple comment, `false` otherwise.
     * @note This method does not check for adblock agent comments.
     */
    static isSimpleComment(raw) {
        const trimmed = raw.trim();
        // Exclamation mark based comments
        if (trimmed.startsWith(nodes/* CommentMarker */.yg.Regular)) {
            return true;
        }
        // Hashmark based comments
        // Note: in this case, we must be sure that we do not mistakenly parse a cosmetic rule as a #-like comment,
        // since most cosmetic rule separators also start with #
        if (trimmed.startsWith(nodes/* CommentMarker */.yg.Hashmark)) {
            const result = cosmetic_rule_separator/* CosmeticRuleSeparatorUtils */.m.find(trimmed);
            // If we cannot find a separator, it means that the rule is definitely a comment
            if (result === null) {
                return true;
            }
            // Otherwise, we must check if the separator is followed by a valid selector
            const { end } = result;
            // No valid selector
            if (!trimmed[end + 1]
                || string/* StringUtils */.$x.isWhitespace(trimmed[end + 1])
                || (trimmed[end + 1] === nodes/* CommentMarker */.yg.Hashmark && trimmed[end + 2] === nodes/* CommentMarker */.yg.Hashmark)) {
                return true;
            }
        }
        return false;
    }
    /**
     * Parses a raw rule as a simple comment.
     *
     * @param raw Raw input to parse.
     * @param options Global parser options.
     * @param baseOffset Starting offset of the input. Node locations are calculated relative to this offset.
     * @returns Comment rule node or null (if the raw rule cannot be parsed as a simple comment).
     */
    static parse(raw, options = parser_options/* defaultParserOptions */.n, baseOffset = 0) {
        // Ignore non-comment rules
        if (!this.isSimpleComment(raw)) {
            return null;
        }
        // If we are here, it means that the rule is a regular comment
        let offset = 0;
        // Skip leading whitespace (if any)
        offset = string/* StringUtils */.$x.skipWS(raw, offset);
        // Get comment marker
        const marker = ValueParser.parse(raw[offset], options, baseOffset + offset);
        // Skip marker
        offset += 1;
        // Get comment text
        const text = ValueParser.parse(raw.slice(offset), options, baseOffset + offset);
        // Regular comment rule
        const result = {
            category: nodes/* RuleCategory */.$O.Comment,
            type: nodes/* CommentRuleType */.gV.CommentRule,
            // TODO: Change syntax when hashmark is used
            syntax: adblockers/* AdblockSyntax */.Y.Common,
            marker,
            text,
        };
        if (options.includeRaws) {
            result.raws = {
                text: raw,
            };
        }
        if (options.isLocIncluded) {
            result.start = baseOffset;
            result.end = baseOffset + raw.length;
        }
        return result;
    }
}



;// ./node_modules/.pnpm/@adguard+agtree@3.1.3/node_modules/@adguard/agtree/dist/parser/comment/comment-parser.js
/*
 * AGTree v3.1.3 (build date: Tue, 29 Apr 2025 12:25:03 GMT)
 * (c) 2025 Adguard Software Ltd.
 * Released under the MIT license
 * https://github.com/AdguardTeam/tsurlfilter/tree/master/packages/agtree#readme
 */









/* eslint-disable no-param-reassign */
/**
 * `CommentParser` is responsible for parsing any comment-like adblock rules.
 *
 * @example
 * Example rules:
 *  - Adblock agent rules:
 *      - ```adblock
 *        [AdGuard]
 *        ```
 *      - ```adblock
 *        [Adblock Plus 2.0]
 *        ```
 *      - etc.
 *  - AdGuard hint rules:
 *      - ```adblock
 *        !+ NOT_OPTIMIZED
 *        ```
 *      - ```adblock
 *        !+ NOT_OPTIMIZED PLATFORM(windows)
 *        ```
 *      - etc.
 *  - Pre-processor rules:
 *      - ```adblock
 *        !#if (adguard)
 *        ```
 *      - ```adblock
 *        !#endif
 *        ```
 *      - etc.
 *  - Metadata rules:
 *      - ```adblock
 *        ! Title: My List
 *        ```
 *      - ```adblock
 *        ! Version: 2.0.150
 *        ```
 *      - etc.
 *  - AGLint inline config rules:
 *      - ```adblock
 *        ! aglint-enable some-rule
 *        ```
 *      - ```adblock
 *        ! aglint-disable some-rule
 *        ```
 *      - etc.
 *  - Simple comments:
 *      - Regular version:
 *        ```adblock
 *        ! This is just a comment
 *        ```
 *      - uBlock Origin / "hostlist" version:
 *        ```adblock
 *        # This is just a comment
 *        ```
 *      - etc.
 */
class CommentParser extends base_parser/* BaseParser */.V {
    /**
     * Checks whether a rule is a comment.
     *
     * @param raw Raw rule
     * @returns `true` if the rule is a comment, `false` otherwise
     */
    static isCommentRule(raw) {
        const trimmed = raw.trim();
        return SimpleCommentParser.isSimpleComment(trimmed) || AgentCommentParser.isAgentRule(trimmed);
    }
    /**
     * Parses a raw rule as comment.
     *
     * @param raw Raw input to parse.
     * @param options Global parser options.
     * @param baseOffset Starting offset of the input. Node locations are calculated relative to this offset.
     * @returns Comment AST or null (if the raw rule cannot be parsed as comment)
     */
    static parse(raw, options = parser_options/* defaultParserOptions */.n, baseOffset = 0) {
        // Ignore non-comment rules
        if (!CommentParser.isCommentRule(raw)) {
            return null;
        }
        // Note: we parse non-functional comments at the end,
        // if the input does not match any of the previous, more specific comment patterns
        return AgentCommentParser.parse(raw, options, baseOffset)
            || HintCommentParser.parse(raw, options, baseOffset)
            || PreProcessorCommentParser.parse(raw, options, baseOffset)
            || MetadataCommentParser.parse(raw, options, baseOffset)
            || ConfigCommentParser.parse(raw, options, baseOffset)
            || SimpleCommentParser.parse(raw, options, baseOffset);
    }
}



// EXTERNAL MODULE: ./node_modules/.pnpm/sprintf-js@1.1.3/node_modules/sprintf-js/src/sprintf.js
var sprintf = __webpack_require__(63607);
// EXTERNAL MODULE: ./node_modules/.pnpm/@adguard+css-tokenizer@1.2.0/node_modules/@adguard/css-tokenizer/dist/csstokenizer.mjs
var csstokenizer = __webpack_require__(25651);
// EXTERNAL MODULE: ./node_modules/.pnpm/@adguard+agtree@3.1.3/node_modules/@adguard/agtree/dist/parser/misc/domain-list-parser.js + 1 modules
var domain_list_parser = __webpack_require__(2607);
;// ./node_modules/.pnpm/@adguard+agtree@3.1.3/node_modules/@adguard/agtree/dist/parser/misc/modifier-parser.js
/*
 * AGTree v3.1.3 (build date: Tue, 29 Apr 2025 12:25:03 GMT)
 * (c) 2025 Adguard Software Ltd.
 * Released under the MIT license
 * https://github.com/AdguardTeam/tsurlfilter/tree/master/packages/agtree#readme
 */







/**
 * `ModifierParser` is responsible for parsing modifiers.
 *
 * @example
 * `match-case`, `~third-party`, `domain=example.com|~example.org`
 */
class ModifierParser extends base_parser/* BaseParser */.V {
    /**
     * Parses a modifier.
     *
     * @param raw Raw input to parse.
     * @param options Global parser options.
     * @param baseOffset Starting offset of the input. Node locations are calculated relative to this offset.
     *
     * @returns Parsed modifier
     * @throws An error if modifier name or value is empty.
     */
    static parse(raw, options = parser_options/* defaultParserOptions */.n, baseOffset = 0) {
        let offset = 0;
        // Skip leading whitespace
        offset = string/* StringUtils */.$x.skipWS(raw, offset);
        // Save the offset of the first character of the modifier (whole modifier)
        const modifierStart = offset;
        // Check if the modifier is an exception
        let exception = false;
        if (raw[offset] === constants/* NEGATION_MARKER */.bP) {
            offset += constants/* NEGATION_MARKER */.bP.length;
            exception = true;
        }
        // Skip whitespace after the exception marker (if any)
        offset = string/* StringUtils */.$x.skipWS(raw, offset);
        // Save the offset of the first character of the modifier name
        const modifierNameStart = offset;
        // Find assignment operator
        const assignmentIndex = string/* StringUtils */.$x.findNextUnescapedCharacter(raw, constants/* MODIFIER_ASSIGN_OPERATOR */.li);
        // Find the end of the modifier
        const modifierEnd = Math.max(string/* StringUtils */.$x.skipWSBack(raw) + 1, modifierNameStart);
        // Modifier name can't be empty
        if (modifierNameStart === modifierEnd) {
            throw new adblock_syntax_error/* AdblockSyntaxError */.q('Modifier name cannot be empty', baseOffset, baseOffset + raw.length);
        }
        let modifier;
        let value;
        // If there is no assignment operator, the whole modifier is the name
        // without a value
        if (assignmentIndex === -1) {
            modifier = ValueParser.parse(raw.slice(modifierNameStart, modifierEnd), options, baseOffset + modifierNameStart);
        }
        else {
            // If there is an assignment operator, first we need to find the
            // end of the modifier name, then we can parse the value
            const modifierNameEnd = string/* StringUtils */.$x.skipWSBack(raw, assignmentIndex - 1) + 1;
            modifier = ValueParser.parse(raw.slice(modifierNameStart, modifierNameEnd), options, baseOffset + modifierNameStart);
            // Value can't be empty
            if (assignmentIndex + 1 === modifierEnd) {
                throw new adblock_syntax_error/* AdblockSyntaxError */.q('Modifier value cannot be empty', baseOffset, baseOffset + raw.length);
            }
            // Skip whitespace after the assignment operator
            const valueStart = string/* StringUtils */.$x.skipWS(raw, assignmentIndex + constants/* MODIFIER_ASSIGN_OPERATOR */.li.length);
            value = ValueParser.parse(raw.slice(valueStart, modifierEnd), options, baseOffset + valueStart);
        }
        const result = {
            type: 'Modifier',
            name: modifier,
            value,
            exception,
        };
        if (options.isLocIncluded) {
            result.start = baseOffset + modifierStart;
            result.end = baseOffset + modifierEnd;
        }
        return result;
    }
}



;// ./node_modules/.pnpm/@adguard+agtree@3.1.3/node_modules/@adguard/agtree/dist/parser/misc/modifier-list.js
/*
 * AGTree v3.1.3 (build date: Tue, 29 Apr 2025 12:25:03 GMT)
 * (c) 2025 Adguard Software Ltd.
 * Released under the MIT license
 * https://github.com/AdguardTeam/tsurlfilter/tree/master/packages/agtree#readme
 */






/* eslint-disable no-param-reassign */
/**
 * `ModifierListParser` is responsible for parsing modifier lists. Please note that the name is not
 * uniform, "modifiers" are also known as "options".
 *
 * @see {@link https://kb.adguard.com/en/general/how-to-create-your-own-ad-filters#basic-rules-modifiers}
 * @see {@link https://kb.adguard.com/en/general/how-to-create-your-own-ad-filters#non-basic-rules-modifiers}
 * @see {@link https://help.eyeo.com/adblockplus/how-to-write-filters#options}
 */
class ModifierListParser extends base_parser/* BaseParser */.V {
    /**
     * Parses the cosmetic rule modifiers, eg. `third-party,domain=example.com|~example.org`.
     *
     * _Note:_ you should remove `$` separator before passing the raw modifiers to this function,
     *  or it will be parsed in the first modifier.
     *
     * @param raw Raw input to parse.
     * @param options Global parser options.
     * @param baseOffset Starting offset of the input. Node locations are calculated relative to this offset.
     * @returns Parsed modifiers interface
     */
    static parse(raw, options = parser_options/* defaultParserOptions */.n, baseOffset = 0) {
        const result = {
            type: 'ModifierList',
            children: [],
        };
        if (options.isLocIncluded) {
            result.start = baseOffset;
            result.end = baseOffset + raw.length;
        }
        let offset = string/* StringUtils */.$x.skipWS(raw);
        let separatorIndex = -1;
        // Split modifiers by unescaped commas
        while (offset < raw.length) {
            // Skip whitespace before the modifier
            offset = string/* StringUtils */.$x.skipWS(raw, offset);
            const modifierStart = offset;
            // Find the index of the first unescaped comma
            separatorIndex = string/* StringUtils */.$x.findNextUnescapedCharacter(raw, constants/* MODIFIERS_SEPARATOR */.b9, offset);
            const modifierEnd = separatorIndex === -1
                ? raw.length
                : string/* StringUtils */.$x.skipWSBack(raw, separatorIndex - 1) + 1;
            // Parse the modifier
            const modifier = ModifierParser.parse(raw.slice(modifierStart, modifierEnd), options, baseOffset + modifierStart);
            result.children.push(modifier);
            // Increment the offset to the next modifier (or the end of the string)
            offset = separatorIndex === -1 ? raw.length : separatorIndex + 1;
        }
        // Check if there are any modifiers after the last separator
        if (separatorIndex !== -1) {
            const modifierStart = string/* StringUtils */.$x.skipWS(raw, separatorIndex + 1);
            result.children.push(ModifierParser.parse(raw.slice(modifierStart, raw.length), options, baseOffset + modifierStart));
        }
        return result;
    }
}



// EXTERNAL MODULE: ./node_modules/.pnpm/@adguard+agtree@3.1.3/node_modules/@adguard/agtree/dist/parser/css/balancing.js
var balancing = __webpack_require__(19613);
// EXTERNAL MODULE: ./node_modules/.pnpm/@adguard+agtree@3.1.3/node_modules/@adguard/agtree/dist/common/ubo-selector-common.js
var ubo_selector_common = __webpack_require__(5596);
;// ./node_modules/.pnpm/@adguard+agtree@3.1.3/node_modules/@adguard/agtree/dist/parser/css/ubo-selector-parser.js
/*
 * AGTree v3.1.3 (build date: Tue, 29 Apr 2025 12:25:03 GMT)
 * (c) 2025 Adguard Software Ltd.
 * Released under the MIT license
 * https://github.com/AdguardTeam/tsurlfilter/tree/master/packages/agtree#readme
 */









/**
 * @file Parser for special uBO selectors.
 */
/**
 * Possible error messages for uBO selectors. Formatted with {@link sprintf}.
 */
const ERROR_MESSAGES = {
    DUPLICATED_UBO_MODIFIER: "uBO modifier '%s' cannot be used more than once",
    EXPECTED_BUT_GOT_BEFORE: "Expected '%s' but got '%s' before '%s'",
    // eslint-disable-next-line max-len
    NEGATED_UBO_MODIFIER_CANNOT_BE_FOLLOWED_BY: "Negated uBO modifier '%s' cannot be followed by anything else than a closing parenthesis or a whitespace",
    NEGATED_UBO_MODIFIER_CANNOT_BE_PRECEDED_BY: "Negated uBO modifier '%s' cannot be preceded by '%s'",
    PSEUDO_CANNOT_BE_NESTED: "uBO modifier '%s' cannot be nested inside '%s', only '%s' is allowed as a wrapper",
    UBO_MODIFIER_CANNOT_BE_NESTED: "uBO modifier '%s' cannot be nested",
    UBO_STYLE_CANNOT_BE_FOLLOWED: 'uBO style injection cannot be followed by anything else than a whitespace',
};
/**
 * Dummy parameter for uBO modifiers in error messages.
 */
const DUMMY_PARAM = '...';
/**
 * Set of known uBO modifiers.
 *
 * @note We use `string` instead of `UboPseudoName` because we use this set for checking if a modifier is a known uBO,
 * and an unknown sequence is just a string.
 */
const KNOWN_UBO_MODIFIERS = new Set([
    ubo_selector_common/* UboPseudoName */.S.MatchesMedia,
    ubo_selector_common/* UboPseudoName */.S.MatchesPath,
    ubo_selector_common/* UboPseudoName */.S.Remove,
    ubo_selector_common/* UboPseudoName */.S.Style,
]);
/**
 * Helper function to check if the given selector has any uBO modifier. This function should be fast, because it's used
 * in the hot path of the parser.
 *
 * @param raw Raw selector string.
 * @returns `true` if the selector has any uBO modifier, `false` otherwise.
 */
const hasAnyUboModifier = (raw) => {
    // Find the first colon
    let colonIndex = raw.indexOf(constants/* COLON */.oH);
    while (colonIndex !== -1) {
        // Find next opening parenthesis
        const openingParenthesisIndex = raw.indexOf(constants/* OPEN_PARENTHESIS */.Cx, colonIndex + 1);
        // If there is no opening parenthesis, then the selector doesn't contain any uBO modifier
        if (openingParenthesisIndex === -1) {
            return false;
        }
        // Check if the modifier is a known uBO modifier
        if (KNOWN_UBO_MODIFIERS.has(raw.slice(colonIndex + 1, openingParenthesisIndex))) {
            return true;
        }
        // Find next colon
        colonIndex = raw.indexOf(constants/* COLON */.oH, openingParenthesisIndex + 1);
    }
    return false;
};
/**
 * A simple helper function to format a pseudo name for error messages.
 *
 * @param name Pseudo name.
 * @param wrapper Wrapper pseudo name (eg. `not`) (optional, defaults to `undefined`).
 * @returns Formatted pseudo name.
 * @example
 * ```ts
 * formatPseudoName('matches-path', 'not'); // => ':not(:matches-path(...))'
 * formatPseudoName('matches-media'); // => ':matches-media(...)'
 * ```
 */
const formatPseudoName = (name, wrapper) => {
    const result = [];
    if (wrapper) {
        result.push(constants/* COLON */.oH, wrapper, constants/* OPEN_PARENTHESIS */.Cx);
    }
    result.push(constants/* COLON */.oH, name, constants/* OPEN_PARENTHESIS */.Cx, DUMMY_PARAM, constants/* CLOSE_PARENTHESIS */.s1);
    if (wrapper) {
        result.push(constants/* CLOSE_PARENTHESIS */.s1);
    }
    return result.join(constants/* EMPTY */.wg);
};
/**
 * Parser for uBO selectors.
 */
class UboSelectorParser extends base_parser/* BaseParser */.V {
    /**
     * Parses a uBO selector list, eg. `div:matches-path(/path)`.
     *
     * @param raw Raw input to parse.
     * @param options Global parser options.
     * @param baseOffset Starting offset of the input. Node locations are calculated relative to this offset.
     *
     * @returns Parsed uBO selector {@link UboSelectorParser}.
     * @throws An {@link AdblockSyntaxError} if the selector list is syntactically invalid.
     */
    static parse(raw, options = parser_options/* defaultParserOptions */.n, baseOffset = 0) {
        // Prepare helper variables
        const modifiers = {
            type: 'ModifierList',
            children: [],
        };
        if (options.isLocIncluded) {
            modifiers.start = baseOffset;
            modifiers.end = baseOffset + raw.length;
        }
        // Do not perform any parsing if the selector doesn't contain any uBO modifier
        // Parsing is a relatively expensive operation, but this check is cheap, so we can avoid unnecessary work
        // TODO: Move this check to the cosmetic parser (adjustable syntaxes - if uBO syntax is disabled, then we don't
        // need to check for uBO modifiers)
        if (!hasAnyUboModifier(raw)) {
            const selector = {
                type: 'Value',
                value: raw,
            };
            if (options.isLocIncluded) {
                selector.start = baseOffset;
                selector.end = baseOffset + raw.length;
            }
            const result = {
                type: 'UboSelector',
                selector,
                modifiers,
            };
            if (options.isLocIncluded) {
                result.start = baseOffset;
                result.end = baseOffset + raw.length;
            }
            return result;
        }
        // Simple way to check if a modifier is already processed to avoid duplicate modifiers
        const processedModifiers = new Set();
        // We need to keep track of the tokens for handling negations properly
        const tokens = [];
        // This array is used to mark the character slots in the selector string that are occupied by uBO modifiers
        const uboIndexes = new Array(raw.length);
        const uboModifierStack = [];
        let i = 0;
        // Helper function to stack a uBO modifier
        const stackModifier = (modifier) => {
            if (processedModifiers.has(modifier.name)) {
                throw new adblock_syntax_error/* AdblockSyntaxError */.q((0,sprintf.sprintf)(ERROR_MESSAGES.DUPLICATED_UBO_MODIFIER, formatPseudoName(modifier.name)), baseOffset + modifier.modifierStart, baseOffset + raw.length);
            }
            uboModifierStack.push(modifier);
        };
        // Tokenize the selector, calculate the balance
        (0,balancing/* tokenizeFnBalanced */.g)(raw, (type, start, end, _, balance) => {
            // Special case: style injection (`:style(...)` and `:remove()`) can only be used at the end of the
            // selector, like
            //  - `div:style(...)`,
            //  - `div:matches-media(...):style(...)`,
            //  - `div:remove()`,
            // etc.
            //
            // But not like
            //  - `:style(...) div`,
            //  - `:matches-media(...):style(...) div`,
            //  - `:remove() div`,
            // etc.
            //
            // The one exception is whitespace, which is allowed after style injection, like
            //  - `div:style(...) `,
            //  - `div:matches-media(...):style(...) `,
            //  - `div:remove() `,
            // etc.
            if ((processedModifiers.has(ubo_selector_common/* UboPseudoName */.S.Style)
                || processedModifiers.has(ubo_selector_common/* UboPseudoName */.S.Remove))
                && type !== csstokenizer/* TokenType */.ks.Whitespace) {
                throw new adblock_syntax_error/* AdblockSyntaxError */.q(ERROR_MESSAGES.UBO_STYLE_CANNOT_BE_FOLLOWED, baseOffset + start, baseOffset + raw.length);
            }
            // Check for pseudo classes (colon followed by a function)
            if (tokens[i - 1]?.type === csstokenizer/* TokenType */.ks.Colon && type === csstokenizer/* TokenType */.ks.Function) {
                // Since closing parenthesis is always included in the function token, but we only need the function
                // name, we need to cut off the last character, this is why we use `end - 1` here
                const fn = raw.slice(start, end - 1);
                // Check if the pseudo class is a known uBO modifier
                if (KNOWN_UBO_MODIFIERS.has(fn)) {
                    // Generally, uBO modifiers cannot be nested, like
                    //  - `:any(:matches-media(...))`,
                    //  - `:matches-media(:matches-media(...))`,
                    //  - `:not(style(...))`,
                    //  etc.
                    if (balance > 1) {
                        // However, we have one exception: `:matches-path()` can be nested inside `:not()`s, like:
                        //  - `:not(:matches-path(...))`,
                        //  - `:not(:not(:matches-path(...)))`,
                        //  etc.
                        //
                        // But it can't be nested inside any other pseudo class, like:
                        //  - `:anything(:matches-path(...))`,
                        //  etc.
                        //
                        // Moreover, :not() can't contain any other data, like
                        //  - `:not(div:matches-path(...))`,
                        //  - `:not(:matches-path(...):matches-path(...))`,
                        //  - `:not(:matches-path(...) div)`,
                        // etc.
                        if (fn === ubo_selector_common/* UboPseudoName */.S.MatchesPath) {
                            if (uboModifierStack.length > 0) {
                                throw new adblock_syntax_error/* AdblockSyntaxError */.q((0,sprintf.sprintf)(ERROR_MESSAGES.PSEUDO_CANNOT_BE_NESTED, formatPseudoName(ubo_selector_common/* UboPseudoName */.S.MatchesPath), formatPseudoName(uboModifierStack[uboModifierStack.length - 1].name), formatPseudoName(constants/* CSS_NOT_PSEUDO */.vr)), baseOffset + start - 1, baseOffset + raw.length);
                            }
                            let isException = false;
                            let modifierBalance = balance;
                            let modifierStart = start;
                            for (let j = i - 1; j >= 0; j -= 1) {
                                // If we have reached the root level, then we should check if the `not` function is
                                // preceded by a colon (which means that it's a pseudo class)
                                if (tokens[j].balance === 0) {
                                    modifierStart = tokens[j].start;
                                    modifierBalance = tokens[j].balance;
                                    break;
                                }
                                else if (tokens[j].type === csstokenizer/* TokenType */.ks.Colon
                                    || tokens[j].type === csstokenizer/* TokenType */.ks.Whitespace) {
                                    continue;
                                }
                                else if (tokens[j].type === csstokenizer/* TokenType */.ks.Function) {
                                    const wrapperFnName = raw.slice(tokens[j].start, tokens[j].end - 1);
                                    if (wrapperFnName !== constants/* CSS_NOT_PSEUDO */.vr) {
                                        throw new adblock_syntax_error/* AdblockSyntaxError */.q((0,sprintf.sprintf)(ERROR_MESSAGES.PSEUDO_CANNOT_BE_NESTED, formatPseudoName(ubo_selector_common/* UboPseudoName */.S.MatchesPath), formatPseudoName(wrapperFnName), formatPseudoName(constants/* CSS_NOT_PSEUDO */.vr)), baseOffset + tokens[j].start - 1, baseOffset + raw.length);
                                    }
                                    if (tokens[j - 1]?.type !== csstokenizer/* TokenType */.ks.Colon) {
                                        const got = tokens[j - 1]?.type
                                            ? (0,csstokenizer/* getFormattedTokenName */.bZ)(tokens[j - 1]?.type)
                                            : 'nothing';
                                        throw new adblock_syntax_error/* AdblockSyntaxError */.q((0,sprintf.sprintf)(ERROR_MESSAGES.EXPECTED_BUT_GOT_BEFORE, (0,csstokenizer/* getFormattedTokenName */.bZ)(csstokenizer/* TokenType */.ks.Colon), got, formatPseudoName(ubo_selector_common/* UboPseudoName */.S.MatchesPath, constants/* CSS_NOT_PSEUDO */.vr)), 
                                        // eslint-disable-next-line no-unsafe-optional-chaining
                                        baseOffset + tokens[j - 1]?.start || 0, baseOffset + raw.length);
                                    }
                                    isException = !isException;
                                    continue;
                                }
                                else {
                                    throw new adblock_syntax_error/* AdblockSyntaxError */.q((0,sprintf.sprintf)(ERROR_MESSAGES.NEGATED_UBO_MODIFIER_CANNOT_BE_PRECEDED_BY, formatPseudoName(ubo_selector_common/* UboPseudoName */.S.MatchesPath), (0,csstokenizer/* getFormattedTokenName */.bZ)(tokens[j].type)), baseOffset + tokens[j].start, baseOffset + raw.length);
                                }
                            }
                            stackModifier({
                                name: fn,
                                modifierStart,
                                modifierBalance,
                                nameStart: start,
                                nameEnd: end - 1, // ignore opening parenthesis
                                valueStart: end,
                                valueBalance: balance,
                                isException,
                            });
                        }
                        else {
                            throw new adblock_syntax_error/* AdblockSyntaxError */.q((0,sprintf.sprintf)(ERROR_MESSAGES.UBO_MODIFIER_CANNOT_BE_NESTED, formatPseudoName(fn)), baseOffset + start - 1, baseOffset + raw.length);
                        }
                    }
                    else {
                        stackModifier({
                            name: fn,
                            modifierStart: start - 1, // Include the colon
                            modifierBalance: balance,
                            nameStart: start,
                            nameEnd: end - 1, // ignore opening parenthesis
                            valueStart: end,
                            valueBalance: balance,
                            isException: false,
                        });
                    }
                }
            }
            else {
                // Get the last stacked modifier
                const lastStackedModifier = uboModifierStack[uboModifierStack.length - 1];
                // Do not allow any other token after `:matches-path(...)` inside `:not(...)`
                if (lastStackedModifier?.name === ubo_selector_common/* UboPseudoName */.S.MatchesPath && lastStackedModifier?.isException) {
                    if (!(type === csstokenizer/* TokenType */.ks.CloseParenthesis || type === csstokenizer/* TokenType */.ks.Whitespace)
                        && balance < lastStackedModifier.valueBalance) {
                        throw new adblock_syntax_error/* AdblockSyntaxError */.q((0,sprintf.sprintf)(ERROR_MESSAGES.NEGATED_UBO_MODIFIER_CANNOT_BE_FOLLOWED_BY, formatPseudoName(ubo_selector_common/* UboPseudoName */.S.MatchesPath), (0,csstokenizer/* getFormattedTokenName */.bZ)(type)), baseOffset + start, baseOffset + raw.length);
                    }
                }
                // If we have reached a closing parenthesis, then we should check if it closes the last stacked modifier
                // and if so, pop it from the stack
                if (type === csstokenizer/* TokenType */.ks.CloseParenthesis && lastStackedModifier) {
                    if (balance === Math.max(0, lastStackedModifier.valueBalance - 1)) {
                        lastStackedModifier.valueEnd = start;
                    }
                    if (balance === Math.max(0, lastStackedModifier.modifierBalance - 1)) {
                        const modifierName = {
                            type: 'Value',
                            value: lastStackedModifier.name,
                        };
                        if (options.isLocIncluded) {
                            // TODO: Refactor
                            modifierName.start = baseOffset + lastStackedModifier.nameStart;
                            modifierName.end = baseOffset + lastStackedModifier.nameEnd;
                        }
                        const value = {
                            type: 'Value',
                            value: raw.slice(lastStackedModifier.valueStart, lastStackedModifier.valueEnd),
                        };
                        if (options.isLocIncluded) {
                            value.start = baseOffset + lastStackedModifier.valueStart;
                            // It's safe to use `!` here, because we determined the value end index in the
                            // previous `if` statement
                            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                            value.end = baseOffset + lastStackedModifier.valueEnd;
                        }
                        const modifier = {
                            type: 'Modifier',
                            name: modifierName,
                            value,
                            exception: lastStackedModifier.isException,
                        };
                        if (options.isLocIncluded) {
                            modifier.start = baseOffset + lastStackedModifier.modifierStart;
                            modifier.end = baseOffset + end;
                        }
                        modifiers.children.push(modifier);
                        processedModifiers.add(lastStackedModifier.name);
                        uboModifierStack.pop();
                        // Mark the character slots in the selector string that are occupied by uBO modifiers
                        uboIndexes.fill(true, lastStackedModifier.modifierStart, end);
                    }
                }
            }
            // Save the token to the history and increase the index
            tokens.push({
                type,
                start,
                end,
                balance,
            });
            i += 1;
        });
        const selector = {
            type: 'Value',
            value: raw
                .split(constants/* EMPTY */.wg)
                .map((char, p) => (uboIndexes[p] ? constants/* EMPTY */.wg : char))
                .join(constants/* EMPTY */.wg)
                .trim(),
        };
        if (options.isLocIncluded) {
            selector.start = baseOffset;
            selector.end = baseOffset + raw.length;
        }
        const result = {
            type: 'UboSelector',
            selector,
            modifiers,
        };
        if (options.isLocIncluded) {
            result.start = baseOffset;
            result.end = baseOffset + raw.length;
        }
        return result;
    }
}



// EXTERNAL MODULE: ./node_modules/.pnpm/@adguard+agtree@3.1.3/node_modules/@adguard/agtree/dist/parser/css/adg-css-injection-parser.js
var adg_css_injection_parser = __webpack_require__(95452);
// EXTERNAL MODULE: ./node_modules/.pnpm/@adguard+agtree@3.1.3/node_modules/@adguard/agtree/dist/common/abp-snippet-injection-body-common.js
var abp_snippet_injection_body_common = __webpack_require__(10434);
;// ./node_modules/.pnpm/@adguard+agtree@3.1.3/node_modules/@adguard/agtree/dist/parser/cosmetic/body/abp-snippet-injection-body-parser.js
/*
 * AGTree v3.1.3 (build date: Tue, 29 Apr 2025 12:25:03 GMT)
 * (c) 2025 Adguard Software Ltd.
 * Released under the MIT license
 * https://github.com/AdguardTeam/tsurlfilter/tree/master/packages/agtree#readme
 */








/**
 * @file uBlock scriptlet injection body parser
 */
/**
 * `AbpSnippetInjectionBodyParser` is responsible for parsing the body of an Adblock Plus-style snippet rule.
 *
 * Please note that the parser will parse any scriptlet rule if it is syntactically correct.
 * For example, it will parse this:
 * ```adblock
 * example.com#$#snippet0 arg0
 * ```
 *
 * but it didn't check if the scriptlet `snippet0` actually supported by any adblocker.
 *
 * @see {@link https://help.eyeo.com/adblockplus/snippet-filters-tutorial}
 */
class AbpSnippetInjectionBodyParser extends base_parser/* BaseParser */.V {
    /**
     * Parses the body of an Adblock Plus-style snippet rule.
     *
     * @param raw Raw input to parse.
     * @param options Global parser options.
     * @param baseOffset Starting offset of the input. Node locations are calculated relative to this offset.
     * @returns Node of the parsed scriptlet call body
     * @throws If the body is syntactically incorrect
     * @example
     * ```
     * #$#snippet0 arg0
     * ```
     */
    static parse(raw, options = parser_options/* defaultParserOptions */.n, baseOffset = 0) {
        const result = {
            type: 'ScriptletInjectionRuleBody',
            children: [],
        };
        if (options.isLocIncluded) {
            result.start = baseOffset;
            result.end = baseOffset + raw.length;
        }
        let offset = 0;
        // Skip leading spaces
        offset = string/* StringUtils */.$x.skipWS(raw, offset);
        while (offset < raw.length) {
            offset = string/* StringUtils */.$x.skipWS(raw, offset);
            const scriptletCallStart = offset;
            // Find the next semicolon or the end of the string
            let semicolonIndex = string/* StringUtils */.$x.findUnescapedNonStringNonRegexChar(raw, constants/* SEMICOLON */.I8, offset);
            if (semicolonIndex === -1) {
                semicolonIndex = raw.length;
            }
            const scriptletCallEnd = Math.max(string/* StringUtils */.$x.skipWSBack(raw, semicolonIndex - 1) + 1, scriptletCallStart);
            const params = ParameterListParser.parse(raw.slice(scriptletCallStart, scriptletCallEnd), options, baseOffset + scriptletCallStart, constants/* SPACE */.t6);
            // Parse the scriptlet call
            result.children.push(params);
            // Skip the semicolon
            offset = semicolonIndex + 1;
        }
        if (result.children.length === 0) {
            throw new adblock_syntax_error/* AdblockSyntaxError */.q(abp_snippet_injection_body_common/* AbpSnippetInjectionBodyCommon */.H.ERROR_MESSAGES.EMPTY_SCRIPTLET_CALL, baseOffset, baseOffset + raw.length);
        }
        return result;
    }
}



// EXTERNAL MODULE: ./node_modules/.pnpm/@adguard+agtree@3.1.3/node_modules/@adguard/agtree/dist/utils/quotes.js
var quotes = __webpack_require__(31529);
;// ./node_modules/.pnpm/@adguard+agtree@3.1.3/node_modules/@adguard/agtree/dist/parser/misc/ubo-parameter-list-parser.js
/*
 * AGTree v3.1.3 (build date: Tue, 29 Apr 2025 12:25:03 GMT)
 * (c) 2025 Adguard Software Ltd.
 * Released under the MIT license
 * https://github.com/AdguardTeam/tsurlfilter/tree/master/packages/agtree#readme
 */








/**
 * Parser for uBO-specific parameter lists.
 */
class UboParameterListParser extends ParameterListParser {
    /**
     * Parses an "uBO-specific parameter list".
     *
     * @param raw Raw input to parse.
     * @param options Global parser options.
     * @param baseOffset Starting offset of the input. Node locations are calculated relative to this offset.
     * @param separator Separator character (default: comma).
     * @param requireQuotes Whether to require quotes around the parameter values (default: false).
     * @param supportedQuotes Set of accepted quotes (default: {@link QUOTE_SET}).
     * @returns Parameter list node.
     *
     * @note Based on {@link https://github.com/gorhill/uBlock/blob/f9ab4b75041815e6e5690d80851189ae3dc660d0/src/js/static-filtering-parser.js#L607-L699} to provide consistency.
     */
    static parse(raw, options = parser_options/* defaultParserOptions */.n, baseOffset = 0, separator = constants/* COMMA */.KE, requireQuotes = false, supportedQuotes = quotes/* QUOTE_SET */.iO) {
        // Prepare the parameter list node
        const params = {
            type: 'ParameterList',
            children: [],
        };
        const { length } = raw;
        if (options.isLocIncluded) {
            params.start = baseOffset;
            params.end = baseOffset + length;
        }
        let offset = 0;
        // TODO: Eliminate the need for extraNull
        let extraNull = false;
        while (offset < length) {
            offset = string/* StringUtils */.$x.skipWS(raw, offset);
            const paramStart = offset;
            let paramEnd = offset;
            if (supportedQuotes.has(raw[offset])) {
                // Find the closing quote
                const possibleClosingQuoteIndex = string/* StringUtils */.$x.findNextUnescapedCharacter(raw, raw[offset], offset + 1);
                if (possibleClosingQuoteIndex !== -1) {
                    // Next non-whitespace character after the closing quote should be the separator
                    const nextSeparatorIndex = string/* StringUtils */.$x.skipWS(raw, possibleClosingQuoteIndex + 1);
                    if (nextSeparatorIndex === length) {
                        // If the separator is not found, the param end is the end of the string
                        paramEnd = string/* StringUtils */.$x.skipWSBack(raw, length - 1) + 1;
                        offset = length;
                    }
                    else if (raw[nextSeparatorIndex] === separator) {
                        // If the quote is followed by a separator, we can use it as a closing quote
                        paramEnd = possibleClosingQuoteIndex + 1;
                        offset = nextSeparatorIndex + 1;
                    }
                    else {
                        if (requireQuotes) {
                            throw new adblock_syntax_error/* AdblockSyntaxError */.q(`Expected separator, got: '${raw[nextSeparatorIndex]}'`, baseOffset + nextSeparatorIndex, baseOffset + length);
                        }
                        /**
                         * At that point found `possibleClosingQuoteIndex` is wrong
                         * | is `offset`
                         * ~ is `possibleClosingQuoteIndex`
                         * ^ is `nextSeparatorIndex`
                         *
                         * Example 1: "abc, ').cba='1'"
                         *                  |      ~^
                         * Example 2: "abc, ').cba, '1'"
                         *                  |       ~^
                         * Example 3: "abc, ').cba='1', cba"
                         *                  |      ~^
                         *
                         * Search for separator before `possibleClosingQuoteIndex`
                         */
                        const separatorIndexBeforeQuote = string/* StringUtils */.$x.findNextUnescapedCharacterBackwards(raw, separator, possibleClosingQuoteIndex, constants/* ESCAPE_CHARACTER */.Kx, offset + 1);
                        if (separatorIndexBeforeQuote !== -1) {
                            // Found separator before (Example 2)
                            paramEnd = string/* StringUtils */.$x.skipWSBack(raw, separatorIndexBeforeQuote - 1) + 1;
                            offset = separatorIndexBeforeQuote + 1;
                        }
                        else {
                            // Didn't found separator before, search after
                            const separatorIndexAfterQuote = string/* StringUtils */.$x.findNextUnescapedCharacter(raw, separator, possibleClosingQuoteIndex);
                            if (separatorIndexAfterQuote !== -1) {
                                // We found separator after (Example 3)
                                paramEnd = string/* StringUtils */.$x.skipWSBack(raw, separatorIndexAfterQuote - 1) + 1;
                                offset = separatorIndexAfterQuote + 1;
                            }
                            else {
                                // If the separator is not found, the param end is the end of the string (Example 1)
                                paramEnd = string/* StringUtils */.$x.skipWSBack(raw, length - 1) + 1;
                                offset = length;
                            }
                        }
                    }
                }
                else {
                    if (requireQuotes) {
                        throw new adblock_syntax_error/* AdblockSyntaxError */.q('Expected closing quote, got end of string', baseOffset + offset, baseOffset + length);
                    }
                    // If the closing quote is not found, the param end is the end of the string
                    paramEnd = string/* StringUtils */.$x.skipWSBack(raw, length - 1) + 1;
                    offset = length;
                }
            }
            else {
                if (requireQuotes) {
                    throw new adblock_syntax_error/* AdblockSyntaxError */.q(`Expected quote, got: '${raw[offset]}'`, baseOffset + offset, baseOffset + length);
                }
                const nextSeparator = string/* StringUtils */.$x.findNextUnescapedCharacter(raw, separator, offset);
                if (nextSeparator === -1) {
                    // If the separator is not found, the param end is the end of the string
                    paramEnd = string/* StringUtils */.$x.skipWSBack(raw, length - 1) + 1;
                    offset = length;
                }
                else {
                    // Param end should be the last non-whitespace character before the separator
                    paramEnd = string/* StringUtils */.$x.skipWSBack(raw, nextSeparator - 1) + 1;
                    offset = nextSeparator + 1;
                    if (string/* StringUtils */.$x.skipWS(raw, length - 1) === nextSeparator) {
                        extraNull = true;
                    }
                }
            }
            if (paramStart < paramEnd) {
                params.children.push(ValueParser.parse(raw.slice(paramStart, paramEnd), options, baseOffset + paramStart));
            }
            else {
                params.children.push(null);
            }
        }
        if (extraNull) {
            params.children.push(null);
        }
        return params;
    }
}



;// ./node_modules/.pnpm/@adguard+agtree@3.1.3/node_modules/@adguard/agtree/dist/parser/cosmetic/body/ubo-scriptlet-injection-body-parser.js
/*
 * AGTree v3.1.3 (build date: Tue, 29 Apr 2025 12:25:03 GMT)
 * (c) 2025 Adguard Software Ltd.
 * Released under the MIT license
 * https://github.com/AdguardTeam/tsurlfilter/tree/master/packages/agtree#readme
 */







/**
 * @file uBlock scriptlet injection body parser
 */
/**
 * `UboScriptletInjectionBodyParser` is responsible for parsing the body of a uBlock-style scriptlet rule.
 *
 * Please note that the parser will parse any scriptlet rule if it is syntactically correct.
 * For example, it will parse this:
 * ```adblock
 * example.com##+js(scriptlet0, arg0)
 * ```
 *
 * but it didn't check if the scriptlet `scriptlet0` actually supported by any adblocker.
 *
 * @see {@link https://github.com/gorhill/uBlock/wiki/Static-filter-syntax#scriptlet-injection}
 */
class UboScriptletInjectionBodyParser extends base_parser/* BaseParser */.V {
    /**
     * Error messages used by the parser.
     */
    static ERROR_MESSAGES = {
        NO_SCRIPTLET_MASK: `Invalid uBO scriptlet call, no scriptlet call mask '${constants/* UBO_SCRIPTLET_MASK */.Rq}' found`,
        NO_OPENING_PARENTHESIS: `Invalid uBO scriptlet call, no opening parentheses '${constants/* OPEN_PARENTHESIS */.Cx}' found`,
        NO_CLOSING_PARENTHESIS: `Invalid uBO scriptlet call, no closing parentheses '${constants/* CLOSE_PARENTHESIS */.s1}' found`,
        NO_SCRIPTLET_NAME: 'Invalid uBO scriptlet call, no scriptlet name specified',
        WHITESPACE_AFTER_MASK: 'Invalid uBO scriptlet call, whitespace is not allowed after the scriptlet call mask',
    };
    /**
     * Parses the body of a uBlock-style scriptlet rule.
     *
     * @param raw Raw input to parse.
     * @param options Global parser options.
     * @param baseOffset Starting offset of the input. Node locations are calculated relative to this offset.
     * @returns Node of the parsed scriptlet call body
     * @throws If the body is syntactically incorrect
     * @example
     * ```
     * ##+js(scriptlet0, arg0)
     * ```
     */
    static parse(raw, options = parser_options/* defaultParserOptions */.n, baseOffset = 0) {
        let offset = 0;
        // Skip leading spaces
        offset = string/* StringUtils */.$x.skipWS(raw, offset);
        let scriptletMaskLength = 0;
        if (raw.startsWith(constants/* UBO_SCRIPTLET_MASK */.Rq, offset)) {
            scriptletMaskLength = constants/* UBO_SCRIPTLET_MASK */.Rq.length;
        }
        else if (raw.startsWith(constants/* UBO_SCRIPTLET_MASK_LEGACY */.Vs, offset)) {
            scriptletMaskLength = constants/* UBO_SCRIPTLET_MASK_LEGACY */.Vs.length;
        }
        // Scriptlet call should start with "+js"
        if (!scriptletMaskLength) {
            throw new adblock_syntax_error/* AdblockSyntaxError */.q(this.ERROR_MESSAGES.NO_SCRIPTLET_MASK, baseOffset + offset, baseOffset + raw.length);
        }
        offset += scriptletMaskLength;
        // Whitespace is not allowed after the mask
        if (raw[offset] === constants/* SPACE */.t6) {
            throw new adblock_syntax_error/* AdblockSyntaxError */.q(this.ERROR_MESSAGES.WHITESPACE_AFTER_MASK, baseOffset + offset, baseOffset + raw.length);
        }
        // Parameter list should be wrapped in parentheses
        if (raw[offset] !== constants/* OPEN_PARENTHESIS */.Cx) {
            throw new adblock_syntax_error/* AdblockSyntaxError */.q(this.ERROR_MESSAGES.NO_OPENING_PARENTHESIS, baseOffset + offset, baseOffset + raw.length);
        }
        // Save the offset of the opening parentheses
        const openingParenthesesIndex = offset;
        // Skip whitespace from the end
        const closingParenthesesIndex = string/* StringUtils */.$x.skipWSBack(raw, raw.length - 1);
        // Closing parentheses should be present
        if (raw[closingParenthesesIndex] !== constants/* CLOSE_PARENTHESIS */.s1
            || raw[closingParenthesesIndex - 1] === constants/* ESCAPE_CHARACTER */.Kx) {
            throw new adblock_syntax_error/* AdblockSyntaxError */.q(this.ERROR_MESSAGES.NO_CLOSING_PARENTHESIS, baseOffset + offset, baseOffset + raw.length);
        }
        const result = {
            type: 'ScriptletInjectionRuleBody',
            children: [],
        };
        if (options.isLocIncluded) {
            result.start = baseOffset;
            result.end = baseOffset + raw.length;
        }
        // Special case: empty scriptlet call, like +js(), +js( ), etc.
        if (string/* StringUtils */.$x.skipWS(raw, openingParenthesesIndex + 1) === closingParenthesesIndex) {
            return result;
        }
        // Parse parameter list
        const params = UboParameterListParser.parse(raw.slice(openingParenthesesIndex + 1, closingParenthesesIndex), options, baseOffset + openingParenthesesIndex + 1, constants/* COMMA */.KE);
        // Do not allow parameters without scriptlet: +js(, arg0, arg1)
        if (params.children.length > 0 && params.children[0] === null) {
            throw new adblock_syntax_error/* AdblockSyntaxError */.q(this.ERROR_MESSAGES.NO_SCRIPTLET_NAME, baseOffset + offset, baseOffset + raw.length);
        }
        result.children.push(params);
        return result;
    }
}



;// ./node_modules/.pnpm/@adguard+agtree@3.1.3/node_modules/@adguard/agtree/dist/parser/cosmetic/body/adg-scriptlet-injection-body-parser.js
/*
 * AGTree v3.1.3 (build date: Tue, 29 Apr 2025 12:25:03 GMT)
 * (c) 2025 Adguard Software Ltd.
 * Released under the MIT license
 * https://github.com/AdguardTeam/tsurlfilter/tree/master/packages/agtree#readme
 */









/**
 * @file AdGuard scriptlet injection body parser
 */
/**
 * `AdgScriptletInjectionBodyParser` is responsible for parsing the body of an AdGuard-style scriptlet rule.
 *
 * Please note that the parser will parse any scriptlet rule if it is syntactically correct.
 * For example, it will parse this:
 * ```adblock
 * example.com#%#//scriptlet('scriptlet0', 'arg0')
 * ```
 *
 * but it didn't check if the scriptlet `scriptlet0` actually supported by any adblocker.
 *
 * @see {@link https://kb.adguard.com/en/general/how-to-create-your-own-ad-filters#scriptlets}
 */
class AdgScriptletInjectionBodyParser extends base_parser/* BaseParser */.V {
    /**
     * Error messages used by the parser.
     */
    static ERROR_MESSAGES = {
        NO_SCRIPTLET_MASK: `Invalid ADG scriptlet call, no scriptlet call mask '${constants/* ADG_SCRIPTLET_MASK */.x$}' found`,
        NO_OPENING_PARENTHESIS: `Invalid ADG scriptlet call, no opening parentheses '${constants/* OPEN_PARENTHESIS */.Cx}' found`,
        NO_CLOSING_PARENTHESIS: `Invalid ADG scriptlet call, no closing parentheses '${constants/* CLOSE_PARENTHESIS */.s1}' found`,
        WHITESPACE_AFTER_MASK: 'Invalid ADG scriptlet call, whitespace is not allowed after the scriptlet call mask',
        NO_INCONSISTENT_QUOTES: 'Invalid ADG scriptlet call, inconsistent quotes',
        NO_UNCLOSED_PARAMETER: 'Invalid ADG scriptlet call, unclosed parameter',
        EXPECTED_QUOTE: "Invalid ADG scriptlet call, expected quote, got '%s'",
        EXPECTED_COMMA: "Invalid ADG scriptlet call, expected comma, got '%s'",
    };
    /**
     * Parses the body of an AdGuard-style scriptlet rule.
     *
     * @param raw Raw input to parse.
     * @param options Global parser options.
     * @param baseOffset Starting offset of the input. Node locations are calculated relative to this offset.
     * @returns Node of the parsed scriptlet call body
     * @throws If the body is syntactically incorrect
     * @example
     * ```
     * //scriptlet('scriptlet0', 'arg0')
     * ```
     */
    static parse(raw, options = parser_options/* defaultParserOptions */.n, baseOffset = 0) {
        let offset = 0;
        // Skip leading spaces
        offset = string/* StringUtils */.$x.skipWS(raw, offset);
        // Scriptlet call should start with "//scriptlet"
        if (!raw.startsWith(constants/* ADG_SCRIPTLET_MASK */.x$, offset)) {
            throw new adblock_syntax_error/* AdblockSyntaxError */.q(this.ERROR_MESSAGES.NO_SCRIPTLET_MASK, baseOffset + offset, baseOffset + raw.length);
        }
        offset += constants/* ADG_SCRIPTLET_MASK */.x$.length;
        // Whitespace is not allowed after the mask
        if (raw[offset] === constants/* SPACE */.t6) {
            throw new adblock_syntax_error/* AdblockSyntaxError */.q(this.ERROR_MESSAGES.WHITESPACE_AFTER_MASK, baseOffset + offset, baseOffset + raw.length);
        }
        // Parameter list should be wrapped in parentheses
        if (raw[offset] !== constants/* OPEN_PARENTHESIS */.Cx) {
            throw new adblock_syntax_error/* AdblockSyntaxError */.q(this.ERROR_MESSAGES.NO_OPENING_PARENTHESIS, baseOffset + offset, baseOffset + raw.length);
        }
        // Save the offset of the opening parentheses
        const openingParenthesesIndex = offset;
        // Skip whitespace from the end
        const closingParenthesesIndex = string/* StringUtils */.$x.skipWSBack(raw, raw.length - 1);
        // Closing parentheses should be present
        if (raw[closingParenthesesIndex] !== constants/* CLOSE_PARENTHESIS */.s1
            || raw[closingParenthesesIndex - 1] === constants/* ESCAPE_CHARACTER */.Kx) {
            throw new adblock_syntax_error/* AdblockSyntaxError */.q(this.ERROR_MESSAGES.NO_CLOSING_PARENTHESIS, baseOffset + offset, baseOffset + raw.length);
        }
        // Skip space, if any
        offset = string/* StringUtils */.$x.skipWS(raw, offset + 1);
        const result = {
            type: 'ScriptletInjectionRuleBody',
            children: [],
        };
        if (options.isLocIncluded) {
            result.start = baseOffset;
            result.end = baseOffset + raw.length;
        }
        // Special case: empty scriptlet call, like `//scriptlet()`, `//scriptlet( )` etc.
        if (string/* StringUtils */.$x.skipWS(raw, openingParenthesesIndex + 1) === closingParenthesesIndex) {
            return result;
        }
        let detectedQuote = null;
        const parameterList = {
            type: 'ParameterList',
            children: [],
        };
        if (options.isLocIncluded) {
            parameterList.start = baseOffset + openingParenthesesIndex + 1;
            parameterList.end = baseOffset + closingParenthesesIndex;
        }
        while (offset < closingParenthesesIndex) {
            // Skip whitespace
            offset = string/* StringUtils */.$x.skipWS(raw, offset);
            // Expect comma if not first parameter
            if (parameterList.children.length > 0) {
                if (raw[offset] !== constants/* COMMA */.KE) {
                    throw new adblock_syntax_error/* AdblockSyntaxError */.q((0,sprintf.sprintf)(AdgScriptletInjectionBodyParser.ERROR_MESSAGES.EXPECTED_COMMA, raw[offset]), baseOffset + offset, baseOffset + raw.length);
                }
                // Eat the comma
                offset += 1;
                // Skip whitespace
                offset = string/* StringUtils */.$x.skipWS(raw, offset);
            }
            // Next character should be a quote
            if (raw[offset] === constants/* SINGLE_QUOTE */.ur || raw[offset] === constants/* DOUBLE_QUOTE */.fi) {
                if ((0,type_guards/* isNull */.kZ)(detectedQuote)) {
                    detectedQuote = raw[offset];
                }
                else if (detectedQuote !== raw[offset]) {
                    throw new adblock_syntax_error/* AdblockSyntaxError */.q(AdgScriptletInjectionBodyParser.ERROR_MESSAGES.NO_INCONSISTENT_QUOTES, baseOffset + offset, baseOffset + raw.length);
                }
                // Find next unescaped same quote
                const closingQuoteIndex = string/* StringUtils */.$x.findNextUnescapedCharacter(raw, detectedQuote, offset + 1);
                if (closingQuoteIndex === -1) {
                    throw new adblock_syntax_error/* AdblockSyntaxError */.q(AdgScriptletInjectionBodyParser.ERROR_MESSAGES.NO_UNCLOSED_PARAMETER, baseOffset + offset, baseOffset + raw.length);
                }
                // Save the parameter
                const parameter = ValueParser.parse(raw.slice(offset, closingQuoteIndex + 1), options, baseOffset + offset);
                parameterList.children.push(parameter);
                // Move after the closing quote
                offset = string/* StringUtils */.$x.skipWS(raw, closingQuoteIndex + 1);
            }
            else {
                throw new adblock_syntax_error/* AdblockSyntaxError */.q((0,sprintf.sprintf)(AdgScriptletInjectionBodyParser.ERROR_MESSAGES.EXPECTED_QUOTE, raw[offset]), baseOffset + offset, baseOffset + raw.length);
            }
        }
        result.children.push(parameterList);
        return result;
    }
}



;// ./node_modules/.pnpm/@adguard+agtree@3.1.3/node_modules/@adguard/agtree/dist/parser/cosmetic/cosmetic-rule-parser.js
/*
 * AGTree v3.1.3 (build date: Tue, 29 Apr 2025 12:25:03 GMT)
 * (c) 2025 Adguard Software Ltd.
 * Released under the MIT license
 * https://github.com/AdguardTeam/tsurlfilter/tree/master/packages/agtree#readme
 */




















/**
 * Possible error messages for uBO selectors. Formatted with {@link sprintf}.
 */
const cosmetic_rule_parser_ERROR_MESSAGES = {
    EMPTY_RULE_BODY: 'Empty rule body',
    INVALID_BODY_FOR_SEPARATOR: "Body '%s' is not valid for the '%s' cosmetic rule separator",
    MISSING_ADGUARD_MODIFIER_LIST_END: "Missing '%s' at the end of the AdGuard modifier list in pattern '%s'",
    MISSING_ADGUARD_MODIFIER_LIST_MARKER: "Missing '%s' at the beginning of the AdGuard modifier list in pattern '%s'",
    SYNTAXES_CANNOT_BE_MIXED: "'%s' syntax cannot be mixed with '%s' syntax",
    SYNTAX_DISABLED: "Parsing '%s' syntax is disabled, but the rule uses it",
};
const ADG_CSS_INJECTION_PATTERN = /^(?:.+){(?:.+)}$/;
/**
 * `CosmeticRuleParser` is responsible for parsing cosmetic rules.
 *
 * Where possible, it automatically detects the difference between supported syntaxes:
 *  - AdGuard
 *  - uBlock Origin
 *  - Adblock Plus
 *
 * If the syntax is common / cannot be determined, the parser gives `Common` syntax.
 *
 * Please note that syntactically correct rules are parsed even if they are not actually
 * compatible with the given adblocker. This is a completely natural behavior, meaningful
 * checking of compatibility is not done at the parser level.
 */
// TODO: Make raw body parsing optional
// TODO: Split into smaller sections
class CosmeticRuleParser extends base_parser/* BaseParser */.V {
    /**
     * Determines whether a rule is a cosmetic rule. The rule is considered cosmetic if it
     * contains a cosmetic rule separator.
     *
     * @param raw Raw rule
     * @returns `true` if the rule is a cosmetic rule, `false` otherwise
     */
    static isCosmeticRule(raw) {
        const trimmed = raw.trim();
        if (CommentParser.isCommentRule(trimmed)) {
            return false;
        }
        return cosmetic_rule_separator/* CosmeticRuleSeparatorUtils */.m.find(trimmed) !== null;
    }
    /**
     * Parses a cosmetic rule. The structure of the cosmetic rules:
     *  - pattern (AdGuard pattern can have modifiers, other syntaxes don't)
     *  - separator
     *  - body
     *
     * @param raw Raw input to parse.
     * @param options Global parser options.
     * @param baseOffset Starting offset of the input. Node locations are calculated relative to this offset.
     * @returns
     * Parsed cosmetic rule AST or null if it failed to parse based on the known cosmetic rules
     * @throws If the input matches the cosmetic rule pattern but syntactically invalid
     */
    // TODO: Split to smaller functions
    static parse(raw, options = parser_options/* defaultParserOptions */.n, baseOffset = 0) {
        // Find cosmetic rule separator - each cosmetic rule must have it, otherwise it is not a cosmetic rule
        const separatorResult = cosmetic_rule_separator/* CosmeticRuleSeparatorUtils */.m.find(raw);
        if (!separatorResult) {
            return null;
        }
        let syntax = adblockers/* AdblockSyntax */.Y.Common;
        let modifiers;
        const patternStart = string/* StringUtils */.$x.skipWS(raw);
        const patternEnd = string/* StringUtils */.$x.skipWSBack(raw, separatorResult.start - 1) + 1;
        const bodyStart = string/* StringUtils */.$x.skipWS(raw, separatorResult.end);
        const bodyEnd = string/* StringUtils */.$x.skipWSBack(raw) + 1;
        // Note we use '<=' instead of '===' because we have bidirectional trim
        if (bodyEnd <= bodyStart) {
            throw new adblock_syntax_error/* AdblockSyntaxError */.q(cosmetic_rule_parser_ERROR_MESSAGES.EMPTY_RULE_BODY, baseOffset, baseOffset + raw.length);
        }
        // Step 1. Parse the pattern: it can be a domain list or a domain list with modifiers (AdGuard)
        const rawPattern = raw.slice(patternStart, patternEnd);
        let patternOffset = patternStart;
        if (rawPattern[patternOffset] === constants/* OPEN_SQUARE_BRACKET */.cU) {
            // Save offset to the beginning of the modifier list for later
            const modifierListStart = patternOffset;
            // Consume opening square bracket
            patternOffset += 1;
            // Skip whitespace after opening square bracket
            patternOffset = string/* StringUtils */.$x.skipWS(rawPattern, patternOffset);
            // Open square bracket should be followed by a modifier separator: [$
            if (rawPattern[patternOffset] !== constants/* DOLLAR_SIGN */.nj) {
                throw new adblock_syntax_error/* AdblockSyntaxError */.q((0,sprintf.sprintf)(cosmetic_rule_parser_ERROR_MESSAGES.MISSING_ADGUARD_MODIFIER_LIST_MARKER, constants/* DOLLAR_SIGN */.nj, rawPattern), baseOffset + patternOffset, baseOffset + rawPattern.length);
            }
            // Consume modifier separator
            patternOffset += 1;
            // Skip whitespace after modifier separator
            patternOffset = string/* StringUtils */.$x.skipWS(rawPattern, patternOffset);
            // Modifier list ends with the last unescaped square bracket
            // We search for the last unescaped square bracket, because some modifiers can contain square brackets,
            // e.g. [$domain=/example[0-9]\.(com|org)/]##.ad
            const modifierListEnd = string/* StringUtils */.$x.findLastUnescapedCharacter(rawPattern, constants/* CLOSE_SQUARE_BRACKET */.A1);
            if (modifierListEnd === -1) {
                throw new adblock_syntax_error/* AdblockSyntaxError */.q((0,sprintf.sprintf)(cosmetic_rule_parser_ERROR_MESSAGES.MISSING_ADGUARD_MODIFIER_LIST_END, constants/* CLOSE_SQUARE_BRACKET */.A1, rawPattern), baseOffset + patternOffset, baseOffset + rawPattern.length);
            }
            // Parse modifier list
            modifiers = ModifierListParser.parse(raw.slice(patternOffset, modifierListEnd), options, baseOffset + patternOffset);
            // Expand modifier list location to include the opening and closing square brackets
            if (options.isLocIncluded) {
                modifiers.start = baseOffset + modifierListStart;
                modifiers.end = baseOffset + modifierListEnd + 1;
            }
            // Consume modifier list
            patternOffset = modifierListEnd + 1;
            // Change the syntax to ADG
            syntax = adblockers/* AdblockSyntax */.Y.Adg;
        }
        // Skip whitespace after modifier list
        patternOffset = string/* StringUtils */.$x.skipWS(rawPattern, patternOffset);
        // Parse domains
        const domains = domain_list_parser/* DomainListParser */.y.parse(rawPattern.slice(patternOffset), options, baseOffset + patternOffset);
        // Step 2. Parse the separator
        const separator = {
            type: 'Value',
            value: separatorResult.separator,
        };
        if (options.isLocIncluded) {
            separator.start = baseOffset + separatorResult.start;
            separator.end = baseOffset + separatorResult.end;
        }
        const exception = cosmetic_rule_separator/* CosmeticRuleSeparatorUtils */.m.isException(separatorResult.separator);
        // Step 3. Parse the rule body
        let rawBody = raw.slice(bodyStart, bodyEnd);
        /**
         * Ensures that the rule syntax is common or the expected one. This function is used to prevent mixing
         * different syntaxes in the same rule.
         *
         * @example
         * The following rule mixes AdGuard and uBO syntaxes, because it uses AdGuard modifier list and uBO
         * CSS injection:
         * ```adblock
         * [$path=/something]example.com##.foo:style(color: red)
         * ```
         * In this case, parser sets syntax to AdGuard, because it detects the AdGuard modifier list, but
         * when parsing the rule body, it detects uBO CSS injection, which is not compatible with AdGuard.
         *
         * @param expectedSyntax Expected syntax
         * @throws If the rule syntax is not common or the expected one
         */
        const expectCommonOrSpecificSyntax = (expectedSyntax) => {
            if (syntax !== adblockers/* AdblockSyntax */.Y.Common && syntax !== expectedSyntax) {
                throw new adblock_syntax_error/* AdblockSyntaxError */.q((0,sprintf.sprintf)(cosmetic_rule_parser_ERROR_MESSAGES.SYNTAXES_CANNOT_BE_MIXED, expectedSyntax, syntax), baseOffset + patternStart, baseOffset + bodyEnd);
            }
        };
        let uboSelector;
        // Parse UBO rule modifiers
        if (options.parseUboSpecificRules) {
            uboSelector = UboSelectorParser.parse(rawBody, options, baseOffset + bodyStart);
            rawBody = uboSelector.selector.value;
            // Do not allow ADG modifiers and UBO modifiers in the same rule
            if (uboSelector.modifiers && uboSelector.modifiers.children.length > 0) {
                // If modifiers are present, that means that the ADG modifier list was parsed
                expectCommonOrSpecificSyntax(adblockers/* AdblockSyntax */.Y.Ubo);
                // Change the syntax to uBO
                syntax = adblockers/* AdblockSyntax */.Y.Ubo;
                // Store the rule modifiers
                // Please note that not each special uBO modifier is a rule modifier, some of them are
                // used for CSS injection, for example `:style()` and `:remove()`
                for (const modifier of uboSelector.modifiers.children) {
                    // TODO: Add support for matches-media and element hiding rules
                    // TODO: Improve this condition if new uBO modifiers are added
                    if (modifier.name.value === ubo_selector_common/* UboPseudoName */.S.MatchesPath) {
                        // Prepare the modifier list if it does not exist yet
                        if (!modifiers) {
                            modifiers = {
                                type: 'ModifierList',
                                children: [],
                            };
                            if (options.isLocIncluded) {
                                modifiers.start = baseOffset + bodyStart;
                                modifiers.end = baseOffset + bodyEnd;
                            }
                        }
                        modifiers.children.push(modifier);
                    }
                }
            }
        }
        const raws = {
            text: raw,
        };
        const baseRule = {
            category: nodes/* RuleCategory */.$O.Cosmetic,
            exception,
            modifiers,
            domains,
            separator,
        };
        if (options.includeRaws) {
            baseRule.raws = raws;
        }
        if (options.isLocIncluded) {
            baseRule.start = baseOffset;
            baseRule.end = baseOffset + raw.length;
        }
        const parseUboCssInjection = () => {
            if (!uboSelector || !uboSelector.modifiers || uboSelector.modifiers.children?.length < 1) {
                return null;
            }
            expectCommonOrSpecificSyntax(adblockers/* AdblockSyntax */.Y.Ubo);
            const selectorList = uboSelector.selector;
            let declarationList;
            let mediaQueryList;
            let remove = false;
            for (const modifier of uboSelector.modifiers.children) {
                switch (modifier.name.value) {
                    case ubo_selector_common/* UboPseudoName */.S.Style:
                        declarationList = modifier.value;
                        break;
                    case ubo_selector_common/* UboPseudoName */.S.Remove:
                        declarationList = {
                            type: 'Value',
                            value: '',
                        };
                        remove = true;
                        break;
                    case ubo_selector_common/* UboPseudoName */.S.MatchesMedia:
                        mediaQueryList = modifier.value;
                        break;
                }
            }
            // If neither `:style()` nor `:remove()` is present
            if (!declarationList) {
                return null;
            }
            const body = {
                type: 'CssInjectionRuleBody',
                selectorList,
                declarationList,
                mediaQueryList,
                remove,
            };
            if (options.isLocIncluded) {
                body.start = baseOffset + bodyStart;
                body.end = baseOffset + bodyEnd;
            }
            return {
                syntax: adblockers/* AdblockSyntax */.Y.Ubo,
                type: nodes/* CosmeticRuleType */.k9.CssInjectionRule,
                body,
            };
        };
        const parseElementHiding = () => {
            const selectorList = {
                type: 'Value',
                value: rawBody,
            };
            if (options.isLocIncluded) {
                selectorList.start = baseOffset + bodyStart;
                selectorList.end = baseOffset + bodyEnd;
            }
            const body = {
                type: 'ElementHidingRuleBody',
                selectorList,
            };
            if (options.isLocIncluded) {
                body.start = baseOffset + bodyStart;
                body.end = baseOffset + bodyEnd;
            }
            return {
                syntax,
                type: nodes/* CosmeticRuleType */.k9.ElementHidingRule,
                body,
            };
        };
        const parseAdgCssInjection = () => {
            // TODO: Improve this detection. Need to cover the following cases:
            // #$#body { color: red;
            // #$#@media (min-width: 100px) { body { color: red; }
            // ADG CSS injection
            if (!ADG_CSS_INJECTION_PATTERN.test(rawBody)) {
                return null;
            }
            expectCommonOrSpecificSyntax(adblockers/* AdblockSyntax */.Y.Adg);
            return {
                syntax: adblockers/* AdblockSyntax */.Y.Adg,
                type: nodes/* CosmeticRuleType */.k9.CssInjectionRule,
                body: adg_css_injection_parser/* AdgCssInjectionParser */.Ye.parse(rawBody, options, baseOffset + bodyStart),
            };
        };
        /**
         * Parses Adb CSS injection rules
         * eg: example.com##.foo { display: none; }
         *
         * @returns parsed rule
         */
        const parseAbpCssInjection = () => {
            if (!options.parseAbpSpecificRules) {
                return null;
            }
            // check if the rule contains both CSS block open and close characters
            // if none of them is present we can stop parsing
            if (rawBody.indexOf(constants/* CSS_BLOCK_OPEN */.zW) === -1 && rawBody.indexOf(constants/* CSS_BLOCK_CLOSE */.pi) === -1) {
                return null;
            }
            if (!(0,csstokenizer/* hasToken */.y0)(rawBody, new Set([csstokenizer/* TokenType */.ks.OpenCurlyBracket, csstokenizer/* TokenType */.ks.CloseCurlyBracket]))) {
                return null;
            }
            // try to parse the raw body as an AdGuard CSS injection rule
            const body = adg_css_injection_parser/* AdgCssInjectionParser */.Ye.parse(rawBody, options, baseOffset + bodyStart);
            // if the parsed rule type is a 'CssInjectionRuleBody', return the parsed rule
            return {
                syntax: adblockers/* AdblockSyntax */.Y.Abp,
                type: nodes/* CosmeticRuleType */.k9.CssInjectionRule,
                body,
            };
        };
        const parseAbpSnippetInjection = () => {
            if (!options.parseAbpSpecificRules) {
                throw new adblock_syntax_error/* AdblockSyntaxError */.q((0,sprintf.sprintf)(cosmetic_rule_parser_ERROR_MESSAGES.SYNTAX_DISABLED, adblockers/* AdblockSyntax */.Y.Abp), baseOffset + bodyStart, baseOffset + bodyEnd);
            }
            expectCommonOrSpecificSyntax(adblockers/* AdblockSyntax */.Y.Abp);
            const body = AbpSnippetInjectionBodyParser.parse(rawBody, options, baseOffset + bodyStart);
            if (options.isLocIncluded) {
                body.start = baseOffset + bodyStart;
                body.end = baseOffset + bodyEnd;
            }
            return {
                syntax: adblockers/* AdblockSyntax */.Y.Abp,
                type: nodes/* CosmeticRuleType */.k9.ScriptletInjectionRule,
                body,
            };
        };
        const parseUboScriptletInjection = () => {
            if (!rawBody.startsWith(constants/* UBO_SCRIPTLET_MASK */.Rq) && !rawBody.startsWith(constants/* UBO_SCRIPTLET_MASK_LEGACY */.Vs)) {
                return null;
            }
            if (!options.parseUboSpecificRules) {
                throw new adblock_syntax_error/* AdblockSyntaxError */.q((0,sprintf.sprintf)(cosmetic_rule_parser_ERROR_MESSAGES.SYNTAX_DISABLED, adblockers/* AdblockSyntax */.Y.Ubo), baseOffset + bodyStart, baseOffset + bodyEnd);
            }
            expectCommonOrSpecificSyntax(adblockers/* AdblockSyntax */.Y.Ubo);
            const body = UboScriptletInjectionBodyParser.parse(rawBody, options, baseOffset + bodyStart);
            if (options.isLocIncluded) {
                body.start = baseOffset + bodyStart;
                body.end = baseOffset + bodyEnd;
            }
            return {
                syntax: adblockers/* AdblockSyntax */.Y.Ubo,
                type: nodes/* CosmeticRuleType */.k9.ScriptletInjectionRule,
                body,
            };
        };
        const parseAdgScriptletInjection = () => {
            // ADG scriptlet injection
            if (!rawBody.startsWith(constants/* ADG_SCRIPTLET_MASK */.x$)) {
                return null;
            }
            expectCommonOrSpecificSyntax(adblockers/* AdblockSyntax */.Y.Adg);
            const body = AdgScriptletInjectionBodyParser.parse(rawBody, options, baseOffset + bodyStart);
            if (options.isLocIncluded) {
                body.start = baseOffset + bodyStart;
                body.end = baseOffset + bodyEnd;
            }
            return {
                syntax: adblockers/* AdblockSyntax */.Y.Adg,
                type: nodes/* CosmeticRuleType */.k9.ScriptletInjectionRule,
                body,
            };
        };
        const parseAdgJsInjection = () => {
            expectCommonOrSpecificSyntax(adblockers/* AdblockSyntax */.Y.Adg);
            const body = {
                type: 'Value',
                value: rawBody,
            };
            if (options.isLocIncluded) {
                body.start = baseOffset + bodyStart;
                body.end = baseOffset + bodyEnd;
            }
            return {
                syntax: adblockers/* AdblockSyntax */.Y.Adg,
                type: nodes/* CosmeticRuleType */.k9.JsInjectionRule,
                body,
            };
        };
        const parseUboHtmlFiltering = () => {
            if (!rawBody.startsWith(constants/* UBO_HTML_MASK */._h)) {
                return null;
            }
            if (!options.parseUboSpecificRules) {
                throw new adblock_syntax_error/* AdblockSyntaxError */.q((0,sprintf.sprintf)(cosmetic_rule_parser_ERROR_MESSAGES.SYNTAX_DISABLED, adblockers/* AdblockSyntax */.Y.Ubo), baseOffset + bodyStart, baseOffset + bodyEnd);
            }
            expectCommonOrSpecificSyntax(adblockers/* AdblockSyntax */.Y.Ubo);
            const body = {
                type: 'Value',
                value: rawBody,
            };
            if (options.isLocIncluded) {
                body.start = baseOffset + bodyStart;
                body.end = baseOffset + bodyEnd;
            }
            return {
                syntax: adblockers/* AdblockSyntax */.Y.Ubo,
                type: nodes/* CosmeticRuleType */.k9.HtmlFilteringRule,
                body,
            };
        };
        const parseAdgHtmlFiltering = () => {
            expectCommonOrSpecificSyntax(adblockers/* AdblockSyntax */.Y.Adg);
            const body = {
                type: 'Value',
                value: rawBody,
            };
            if (options.isLocIncluded) {
                body.start = baseOffset + bodyStart;
                body.end = baseOffset + bodyEnd;
            }
            return {
                syntax: adblockers/* AdblockSyntax */.Y.Adg,
                type: nodes/* CosmeticRuleType */.k9.HtmlFilteringRule,
                body,
            };
        };
        // Create a fast lookup table for cosmetic rule separators and their parsing functions.
        // One separator can have multiple parsing functions. If the first function returns null,
        // the next function is called, and so on.
        // If all functions return null, an error should be thrown.
        const separatorMap = {
            '##': [
                parseUboHtmlFiltering,
                parseUboScriptletInjection,
                parseUboCssInjection,
                parseAbpCssInjection,
                parseElementHiding,
            ],
            '#@#': [
                parseUboHtmlFiltering,
                parseUboScriptletInjection,
                parseUboCssInjection,
                parseAbpCssInjection,
                parseElementHiding,
            ],
            '#?#': [parseUboCssInjection, parseAbpCssInjection, parseElementHiding],
            '#@?#': [parseUboCssInjection, parseAbpCssInjection, parseElementHiding],
            '#$#': [parseAdgCssInjection, parseAbpSnippetInjection],
            '#@$#': [parseAdgCssInjection, parseAbpSnippetInjection],
            '#$?#': [parseAdgCssInjection],
            '#@$?#': [parseAdgCssInjection],
            '#%#': [parseAdgScriptletInjection, parseAdgJsInjection],
            '#@%#': [parseAdgScriptletInjection, parseAdgJsInjection],
            $$: [parseAdgHtmlFiltering],
            '$@$': [parseAdgHtmlFiltering],
        };
        const parseFunctions = separatorMap[separatorResult.separator];
        let restProps;
        for (const parseFunction of parseFunctions) {
            restProps = parseFunction();
            if (restProps) {
                break;
            }
        }
        // If none of the parsing functions returned a result, it means that the rule is unknown / invalid.
        if (!restProps) {
            throw new adblock_syntax_error/* AdblockSyntaxError */.q((0,sprintf.sprintf)(cosmetic_rule_parser_ERROR_MESSAGES.INVALID_BODY_FOR_SEPARATOR, rawBody, separatorResult.separator), baseOffset + bodyStart, baseOffset + bodyEnd);
        }
        // Combine the base rule with the rest of the properties.
        return {
            ...baseRule,
            ...restProps,
        };
    }
}



;// ./node_modules/.pnpm/@adguard+agtree@3.1.3/node_modules/@adguard/agtree/dist/parser/network/network-rule-parser.js
/*
 * AGTree v3.1.3 (build date: Tue, 29 Apr 2025 12:25:03 GMT)
 * (c) 2025 Adguard Software Ltd.
 * Released under the MIT license
 * https://github.com/AdguardTeam/tsurlfilter/tree/master/packages/agtree#readme
 */










/**
 * `NetworkRuleParser` is responsible for parsing network rules.
 *
 * Please note that this will parse all syntactically correct network rules.
 * Modifier compatibility is not checked at the parser level.
 *
 * @see {@link https://kb.adguard.com/en/general/how-to-create-your-own-ad-filters#basic-rules}
 * @see {@link https://help.eyeo.com/adblockplus/how-to-write-filters#basic}
 */
class NetworkRuleParser extends base_parser/* BaseParser */.V {
    /**
     * Parses a network rule (also known as basic rule).
     *
     * @param raw Raw input to parse.
     * @param options Global parser options.
     * @param baseOffset Starting offset of the input. Node locations are calculated relative to this offset.
     * @returns Network rule AST
     *
     * @throws If the rule is syntactically incorrect.
     */
    static parse(raw, options = parser_options/* defaultParserOptions */.n, baseOffset = 0) {
        let offset = 0;
        // Skip leading whitespace
        offset = string/* StringUtils */.$x.skipWS(raw, offset);
        // Handle exception rules
        let exception = false;
        // Rule starts with exception marker, eg @@||example.com,
        // where @@ is the exception marker
        if (raw.startsWith(constants/* NETWORK_RULE_EXCEPTION_MARKER */.rF, offset)) {
            offset += constants/* NETWORK_RULE_EXCEPTION_MARKER_LEN */.Lb;
            exception = true;
        }
        // Save the start of the pattern
        const patternStart = offset;
        // Find corresponding (last) separator ($) character (if any)
        const separatorIndex = NetworkRuleParser.findNetworkRuleSeparatorIndex(raw);
        // Save the end of the pattern
        const patternEnd = separatorIndex === -1
            ? string/* StringUtils */.$x.skipWSBack(raw) + 1
            : string/* StringUtils */.$x.skipWSBack(raw, separatorIndex - 1) + 1;
        // Parse pattern
        const pattern = ValueParser.parse(raw.slice(patternStart, patternEnd), options, baseOffset + patternStart);
        // Parse modifiers (if any)
        let modifiers;
        // Get a last non-whitespace index
        const lastNonWsIndex = string/* StringUtils */.$x.skipWSBack(raw);
        // Find start and end index of the modifiers
        const modifiersStart = separatorIndex + 1;
        const modifiersEnd = string/* StringUtils */.$x.skipWSBack(raw) + 1;
        if (separatorIndex !== -1) {
            // Check for empty modifiers
            if (separatorIndex === lastNonWsIndex) {
                throw new adblock_syntax_error/* AdblockSyntaxError */.q('Empty modifiers are not allowed', baseOffset + separatorIndex, baseOffset + raw.length);
            }
            modifiers = ModifierListParser.parse(raw.slice(modifiersStart, modifiersEnd), options, baseOffset + modifiersStart);
        }
        // Throw error if there is no pattern and no modifiers
        if (pattern.value.length === 0 && (modifiers === undefined || modifiers.children.length === 0)) {
            throw new adblock_syntax_error/* AdblockSyntaxError */.q('Network rule must have a pattern or modifiers', baseOffset, baseOffset + raw.length);
        }
        const result = {
            type: nodes/* NetworkRuleType */.vY.NetworkRule,
            category: nodes/* RuleCategory */.$O.Network,
            syntax: adblockers/* AdblockSyntax */.Y.Common,
            exception,
            pattern,
            modifiers,
        };
        if (options.includeRaws) {
            result.raws = {
                text: raw,
            };
        }
        if (options.isLocIncluded) {
            result.start = baseOffset;
            result.end = baseOffset + raw.length;
        }
        return result;
    }
    /**
     * Finds the index of the separator character in a network rule.
     *
     * @param rule Network rule to check
     * @returns The index of the separator character, or -1 if there is no separator
     */
    static findNetworkRuleSeparatorIndex(rule) {
        // As we are looking for the last separator, we start from the end of the string
        for (let i = rule.length - 1; i >= 0; i -= 1) {
            // If we find a potential separator, we should check
            // - if it's not escaped
            // - if it's not followed by a regex marker, for example: `example.org^$removeparam=/regex$/`
            // eslint-disable-next-line max-len
            if (rule[i] === constants/* NETWORK_RULE_SEPARATOR */.Xj && rule[i + 1] !== constants/* REGEX_MARKER */.Vb && rule[i - 1] !== constants/* ESCAPE_CHARACTER */.Kx) {
                return i;
            }
        }
        return -1;
    }
}



// EXTERNAL MODULE: ./node_modules/.pnpm/tldts@5.7.112/node_modules/tldts/dist/es6/index.js + 12 modules
var es6 = __webpack_require__(13548);
// EXTERNAL MODULE: ./node_modules/.pnpm/is-ip@3.1.0/node_modules/is-ip/index.js
var is_ip = __webpack_require__(85183);
;// ./node_modules/.pnpm/@adguard+agtree@3.1.3/node_modules/@adguard/agtree/dist/parser/network/host-rule-parser.js
/*
 * AGTree v3.1.3 (build date: Tue, 29 Apr 2025 12:25:03 GMT)
 * (c) 2025 Adguard Software Ltd.
 * Released under the MIT license
 * https://github.com/AdguardTeam/tsurlfilter/tree/master/packages/agtree#readme
 */









/* eslint-disable no-param-reassign */
/**
 * `HostRuleParser` is responsible for parsing hosts-like rules.
 *
 * HostRule is a structure for simple host-level rules (i.e. /etc/hosts syntax).
 * It also supports "just domain" syntax. In this case, the IP will be set to 0.0.0.0.
 *
 * Rules syntax looks like this:
 * ```text
 * IP_address canonical_hostname [aliases...]
 * ```
 *
 * @example
 * `192.168.1.13 bar.mydomain.org bar` -- ipv4
 * `ff02::1 ip6-allnodes` -- ipv6
 * `::1 localhost ip6-localhost ip6-loopback` -- ipv6 aliases
 * `example.org` -- "just domain" syntax
 * @see {@link http://man7.org/linux/man-pages/man5/hosts.5.html}
 */
class HostRuleParser extends base_parser/* BaseParser */.V {
    static NULL_IP = '0.0.0.0';
    static COMMENT_MARKER = '#';
    /**
     * Parses an etc/hosts-like rule.
     *
     * @param raw Raw input to parse.
     * @param options Global parser options.
     * @param baseOffset Starting offset of the input. Node locations are calculated relative to this offset.
     * @returns Host rule node.
     *
     * @throws If the input contains invalid data.
     */
    static parse(raw, options = parser_options/* defaultParserOptions */.n, baseOffset = 0) {
        let offset = string/* StringUtils */.$x.skipWS(raw, 0);
        const parts = [];
        let lastPartStartIndex = offset;
        let comment = null;
        const rawLength = raw.length;
        const parsePartIfNeeded = (startIndex, endIndex) => {
            if (startIndex < endIndex) {
                parts.push(ValueParser.parse(raw.slice(startIndex, endIndex), options, baseOffset + startIndex));
            }
        };
        while (offset < rawLength) {
            if (string/* StringUtils */.$x.isWhitespace(raw[offset])) {
                parsePartIfNeeded(lastPartStartIndex, offset);
                offset = string/* StringUtils */.$x.skipWS(raw, offset);
                lastPartStartIndex = offset;
            }
            else if (raw[offset] === HostRuleParser.COMMENT_MARKER) {
                const commentStart = offset;
                offset = string/* StringUtils */.$x.skipWS(raw, offset + 1);
                comment = ValueParser.parse(raw.slice(offset), options, baseOffset + commentStart);
                offset = rawLength;
                lastPartStartIndex = offset;
            }
            else {
                offset += 1;
            }
        }
        parsePartIfNeeded(lastPartStartIndex, offset);
        const partsLength = parts.length;
        if (partsLength < 1) {
            throw new Error('Host rule must have at least one domain name or an IP address and a domain name');
        }
        const result = {
            category: nodes/* RuleCategory */.$O.Network,
            type: nodes/* NetworkRuleType */.vY.HostRule,
            syntax: adblockers/* AdblockSyntax */.Y.Common,
        };
        if (partsLength === 1) {
            // "Just domain" syntax, e.g. `example.org`
            // In this case, domain should be valid and IP will be set to 0.0.0.0 by default
            if ((0,es6/* getDomain */.FB)(parts[0].value) !== parts[0].value) {
                throw new Error(`Not a valid domain: ${parts[0].value}`);
            }
            result.ip = {
                type: 'Value',
                value: HostRuleParser.NULL_IP,
            };
            result.hostnames = {
                type: 'HostnameList',
                children: parts,
            };
        }
        else if (partsLength > 1) {
            // IP + domain list syntax
            const [ip, ...hostnames] = parts;
            if (!is_ip(ip.value)) {
                throw new Error(`Invalid IP address: ${ip.value}`);
            }
            for (const { value } of hostnames) {
                if ((0,es6/* getHostname */.EW)(value) !== value) {
                    throw new Error(`Not a valid hostname: ${value}`);
                }
            }
            result.ip = ip;
            result.hostnames = {
                type: 'HostnameList',
                children: hostnames,
            };
        }
        if (comment) {
            result.comment = comment;
        }
        if (options.includeRaws) {
            result.raws = {
                text: raw,
            };
        }
        return result;
    }
}



;// ./node_modules/.pnpm/@adguard+agtree@3.1.3/node_modules/@adguard/agtree/dist/parser/rule-parser.js
/*
 * AGTree v3.1.3 (build date: Tue, 29 Apr 2025 12:25:03 GMT)
 * (c) 2025 Adguard Software Ltd.
 * Released under the MIT license
 * https://github.com/AdguardTeam/tsurlfilter/tree/master/packages/agtree#readme
 */










/* eslint-disable no-param-reassign */
/**
 * `RuleParser` is responsible for parsing the rules.
 *
 * It automatically determines the category and syntax of the rule, so you can pass any kind of rule to it.
 */
class RuleParser extends base_parser/* BaseParser */.V {
    /**
     * Helper method to parse host rules if the `parseHostRules` option is enabled, otherwise it will
     * parse network rules.
     *
     * @param raw Raw input to parse.
     * @param options Global parser options.
     * @param baseOffset Starting offset of the input. Node locations are calculated relative to this offset.
     * @returns Host rule or network rule node.
     */
    static parseHostOrNetworkRule(raw, options, baseOffset) {
        if (options.parseHostRules) {
            try {
                return HostRuleParser.parse(raw, options, baseOffset);
            }
            catch (error) {
                // Ignore the error, and fall back to network rule parser
            }
        }
        return NetworkRuleParser.parse(raw, options, baseOffset);
    }
    /**
     * Parse an adblock rule. You can pass any kind of rule to this method, since it will automatically determine
     * the category and syntax. If the rule is syntactically invalid, then an error will be thrown. If the
     * syntax / compatibility cannot be determined clearly, then the value of the `syntax` property will be
     * `Common`.
     *
     * For example, let's have this network rule:
     * ```adblock
     * ||example.org^$important
     * ```
     * The `syntax` property will be `Common`, since the rule is syntactically correct in every adblockers, but we
     * cannot determine at parsing level whether `important` is an existing option or not, nor if it exists, then
     * which adblocker supports it. This is why the `syntax` property is simply `Common` at this point.
     * The concrete COMPATIBILITY of the rule will be determined later, in a different, higher-level layer, called
     * "Compatibility table".
     *
     * But we can determinate the concrete syntax of this rule:
     * ```adblock
     * example.org#%#//scriptlet("scriptlet0", "arg0")
     * ```
     * since it is clearly an AdGuard-specific rule and no other adblockers uses this syntax natively. However, we also
     * cannot determine the COMPATIBILITY of this rule, as it is not clear at this point whether the `scriptlet0`
     * scriptlet is supported by AdGuard or not. This is also the task of the "Compatibility table". Here, we simply
     * mark the rule with the `AdGuard` syntax in this case.
     *
     * @param raw Raw input to parse.
     * @param options Global parser options.
     * @param baseOffset Starting offset of the input. Node locations are calculated relative to this offset.
     * @returns Adblock rule node
     * @throws If the input matches a pattern but syntactically invalid
     * @example
     * Take a look at the following example:
     * ```js
     * // Parse a network rule
     * const ast1 = RuleParser.parse("||example.org^$important");
     *
     * // Parse another network rule
     * const ast2 = RuleParser.parse("/ads.js^$important,third-party,domain=example.org|~example.com");
     *
     * // Parse a cosmetic rule
     * const ast2 = RuleParser.parse("example.org##.banner");
     *
     * // Parse another cosmetic rule
     * const ast3 = RuleParser.parse("example.org#?#.banner:-abp-has(.ad)");
     *
     * // Parse a comment rule
     * const ast4 = RuleParser.parse("! Comment");
     *
     * // Parse an empty rule
     * const ast5 = RuleParser.parse("");
     *
     * // Parse a comment rule (with metadata)
     * const ast6 = RuleParser.parse("! Title: Example");
     *
     * // Parse a pre-processor rule
     * const ast7 = RuleParser.parse("!#if (adguard)");
     * ```
     */
    static parse(raw, options = parser_options/* defaultParserOptions */.n, baseOffset = 0) {
        try {
            // Empty lines / rules (handle it just for convenience)
            if (raw.trim().length === 0) {
                const result = {
                    type: 'EmptyRule',
                    category: nodes/* RuleCategory */.$O.Empty,
                    syntax: adblockers/* AdblockSyntax */.Y.Common,
                };
                if (options.includeRaws) {
                    result.raws = {
                        text: raw,
                    };
                }
                if (options.isLocIncluded) {
                    result.start = baseOffset;
                    result.end = baseOffset + raw.length;
                }
                return result;
            }
            // Try to parse the rule with all sub-parsers. If a rule doesn't match
            // the pattern of a parser, then it will return `null`. For example, a
            // network rule will not match the pattern of a comment rule, since it
            // doesn't start with comment marker. But if the rule matches the
            // pattern of a parser, then it will return the AST of the rule, or
            // throw an error if the rule is syntactically invalid.
            if (options.ignoreComments) {
                if (CommentParser.isCommentRule(raw)) {
                    const result = {
                        type: 'EmptyRule',
                        category: nodes/* RuleCategory */.$O.Empty,
                        syntax: adblockers/* AdblockSyntax */.Y.Common,
                    };
                    if (options.includeRaws) {
                        result.raws = {
                            text: raw,
                        };
                    }
                    if (options.isLocIncluded) {
                        result.start = baseOffset;
                        result.end = baseOffset + raw.length;
                    }
                    return result;
                }
                return CosmeticRuleParser.parse(raw, options, baseOffset)
                    || RuleParser.parseHostOrNetworkRule(raw, options, baseOffset);
            }
            return CommentParser.parse(raw, options, baseOffset)
                || CosmeticRuleParser.parse(raw, options, baseOffset)
                || RuleParser.parseHostOrNetworkRule(raw, options, baseOffset);
        }
        catch (error) {
            // If tolerant mode is disabled or the error is not known, then simply
            // re-throw the error
            if (!options.tolerant || !(error instanceof Error)) {
                throw error;
            }
            const errorNode = {
                type: 'InvalidRuleError',
                name: error.name,
                message: error.message,
            };
            // If the error is an AdblockSyntaxError, then we can add the
            // location of the error to the result
            if (error instanceof adblock_syntax_error/* AdblockSyntaxError */.q) {
                errorNode.start = error.start;
                errorNode.end = error.end;
            }
            // Otherwise, return an invalid rule (tolerant mode)
            const result = {
                type: 'InvalidRule',
                category: nodes/* RuleCategory */.$O.Invalid,
                syntax: adblockers/* AdblockSyntax */.Y.Common,
                raw,
                error: errorNode,
            };
            if (options.includeRaws) {
                result.raws = {
                    text: raw,
                };
            }
            if (options.isLocIncluded) {
                result.start = baseOffset;
                result.end = baseOffset + raw.length;
            }
            return result;
        }
    }
}




/***/ }),

/***/ 45577:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   S: () => (/* binding */ BaseSerializer)
/* harmony export */ });
/* harmony import */ var _errors_not_implemented_error_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(74173);
/*
 * AGTree v3.1.3 (build date: Tue, 29 Apr 2025 12:25:03 GMT)
 * (c) 2025 Adguard Software Ltd.
 * Released under the MIT license
 * https://github.com/AdguardTeam/tsurlfilter/tree/master/packages/agtree#readme
 */


/**
 * @file Base serializer class.
 */
/**
 * Base class for serializers. Each serializer should extend this class.
 */
class BaseSerializer {
    /**
     * Serializes the AST node to a byte buffer.
     *
     * @param node AST node to serialize.
     * @param buffer Output byte buffer to write to.
     * @param args Additional, parser-specific arguments, if needed.
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    static serialize(node, buffer, ...args) {
        throw new _errors_not_implemented_error_js__WEBPACK_IMPORTED_MODULE_0__/* .NotImplementedError */ .E();
    }
}




/***/ }),

/***/ 63113:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Z: () => (/* binding */ NodeType),
/* harmony export */   y: () => (/* binding */ LogicalExpressionSerializer)
/* harmony export */ });
/* harmony import */ var _utils_constants_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(27895);
/* harmony import */ var _utils_type_guards_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(8123);
/* harmony import */ var _base_serializer_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(45577);
/* harmony import */ var _marshalling_utils_misc_logical_expression_common_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(93828);
/* harmony import */ var _marshalling_utils_misc_binary_type_common_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(82938);
/*
 * AGTree v3.1.3 (build date: Tue, 29 Apr 2025 12:25:03 GMT)
 * (c) 2025 Adguard Software Ltd.
 * Released under the MIT license
 * https://github.com/AdguardTeam/tsurlfilter/tree/master/packages/agtree#readme
 */






/**
 * Possible node types in the logical expression.
 */
const NodeType = {
    Variable: 'Variable',
    Operator: 'Operator',
    Parenthesis: 'Parenthesis',
};
/**
 * `LogicalExpressionSerializer` is responsible for serializing logical expressions.
 *
 * @example
 * From the following rule:
 * ```adblock
 * !#if (adguard_ext_android_cb || adguard_ext_safari)
 * ```
 * this parser will parse the expression `(adguard_ext_android_cb || adguard_ext_safari)`.
 */
// TODO: Refactor this class
class LogicalExpressionSerializer extends _base_serializer_js__WEBPACK_IMPORTED_MODULE_0__/* .BaseSerializer */ .S {
    /**
     * Serializes a variable node to binary format.
     *
     * @param node Node to serialize.
     * @param buffer ByteBuffer for writing binary data.
     */
    // TODO: create a common serialize / deserialize interface for such nodes (Variable, Value, Parameter, etc.)
    static serializeVariableNode(node, buffer) {
        buffer.writeUint8(_marshalling_utils_misc_binary_type_common_js__WEBPACK_IMPORTED_MODULE_1__/* .BinaryTypeMarshallingMap */ .u.ExpressionVariableNode);
        const frequentName = _marshalling_utils_misc_logical_expression_common_js__WEBPACK_IMPORTED_MODULE_2__/* .KNOWN_VARIABLES_SERIALIZATION_MAP */ .Y5.get(node.name);
        if (!(0,_utils_type_guards_js__WEBPACK_IMPORTED_MODULE_3__/* .isUndefined */ .b0)(frequentName)) {
            buffer.writeUint8(_marshalling_utils_misc_logical_expression_common_js__WEBPACK_IMPORTED_MODULE_2__/* .VariableNodeBinaryPropMarshallingMap */ .Tf.FrequentName);
            buffer.writeUint8(frequentName);
        }
        else {
            buffer.writeUint8(_marshalling_utils_misc_logical_expression_common_js__WEBPACK_IMPORTED_MODULE_2__/* .VariableNodeBinaryPropMarshallingMap */ .Tf.Name);
            buffer.writeString(node.name);
        }
        if (!(0,_utils_type_guards_js__WEBPACK_IMPORTED_MODULE_3__/* .isUndefined */ .b0)(node.start)) {
            buffer.writeUint8(_marshalling_utils_misc_logical_expression_common_js__WEBPACK_IMPORTED_MODULE_2__/* .VariableNodeBinaryPropMarshallingMap */ .Tf.Start);
            buffer.writeUint32(node.start);
        }
        if (!(0,_utils_type_guards_js__WEBPACK_IMPORTED_MODULE_3__/* .isUndefined */ .b0)(node.end)) {
            buffer.writeUint8(_marshalling_utils_misc_logical_expression_common_js__WEBPACK_IMPORTED_MODULE_2__/* .VariableNodeBinaryPropMarshallingMap */ .Tf.End);
            buffer.writeUint32(node.end);
        }
        buffer.writeUint8(_utils_constants_js__WEBPACK_IMPORTED_MODULE_4__/* .NULL */ .Cq);
    }
    /**
     * Serializes a parenthesis node to binary format.
     *
     * @param node Node to serialize.
     * @param buffer ByteBuffer for writing binary data.
     */
    static serializeParenthesisNode(node, buffer) {
        buffer.writeUint8(_marshalling_utils_misc_binary_type_common_js__WEBPACK_IMPORTED_MODULE_1__/* .BinaryTypeMarshallingMap */ .u.ExpressionParenthesisNode);
        buffer.writeUint8(_marshalling_utils_misc_logical_expression_common_js__WEBPACK_IMPORTED_MODULE_2__/* .ParenthesisNodeBinaryPropMarshallingMap */ .z0.Expression);
        LogicalExpressionSerializer.serialize(node.expression, buffer);
        if (!(0,_utils_type_guards_js__WEBPACK_IMPORTED_MODULE_3__/* .isUndefined */ .b0)(node.start)) {
            buffer.writeUint8(_marshalling_utils_misc_logical_expression_common_js__WEBPACK_IMPORTED_MODULE_2__/* .ParenthesisNodeBinaryPropMarshallingMap */ .z0.Start);
            buffer.writeUint32(node.start);
        }
        if (!(0,_utils_type_guards_js__WEBPACK_IMPORTED_MODULE_3__/* .isUndefined */ .b0)(node.end)) {
            buffer.writeUint8(_marshalling_utils_misc_logical_expression_common_js__WEBPACK_IMPORTED_MODULE_2__/* .ParenthesisNodeBinaryPropMarshallingMap */ .z0.End);
            buffer.writeUint32(node.end);
        }
        buffer.writeUint8(_utils_constants_js__WEBPACK_IMPORTED_MODULE_4__/* .NULL */ .Cq);
    }
    /**
     * Serializes an operator node to binary format.
     *
     * @param node Node to serialize.
     * @param buffer ByteBuffer for writing binary data.
     */
    static serializeOperatorNode(node, buffer) {
        buffer.writeUint8(_marshalling_utils_misc_binary_type_common_js__WEBPACK_IMPORTED_MODULE_1__/* .BinaryTypeMarshallingMap */ .u.ExpressionOperatorNode);
        buffer.writeUint8(_marshalling_utils_misc_logical_expression_common_js__WEBPACK_IMPORTED_MODULE_2__/* .OperatorNodeBinaryPropMarshallingMap */ .hc.Operator);
        const operatorBinary = _marshalling_utils_misc_logical_expression_common_js__WEBPACK_IMPORTED_MODULE_2__/* .LOGICAL_EXPRESSION_OPERATOR_SERIALISATION_MAP */ .td.get(node.operator);
        if ((0,_utils_type_guards_js__WEBPACK_IMPORTED_MODULE_3__/* .isUndefined */ .b0)(operatorBinary)) {
            throw new Error(`Unknown operator: ${node.operator}`);
        }
        buffer.writeUint8(operatorBinary);
        buffer.writeUint8(_marshalling_utils_misc_logical_expression_common_js__WEBPACK_IMPORTED_MODULE_2__/* .OperatorNodeBinaryPropMarshallingMap */ .hc.Left);
        LogicalExpressionSerializer.serialize(node.left, buffer);
        if (node.right) {
            buffer.writeUint8(_marshalling_utils_misc_logical_expression_common_js__WEBPACK_IMPORTED_MODULE_2__/* .OperatorNodeBinaryPropMarshallingMap */ .hc.Right);
            LogicalExpressionSerializer.serialize(node.right, buffer);
        }
        if (!(0,_utils_type_guards_js__WEBPACK_IMPORTED_MODULE_3__/* .isUndefined */ .b0)(node.start)) {
            buffer.writeUint8(_marshalling_utils_misc_logical_expression_common_js__WEBPACK_IMPORTED_MODULE_2__/* .OperatorNodeBinaryPropMarshallingMap */ .hc.Start);
            buffer.writeUint32(node.start);
        }
        if (!(0,_utils_type_guards_js__WEBPACK_IMPORTED_MODULE_3__/* .isUndefined */ .b0)(node.end)) {
            buffer.writeUint8(_marshalling_utils_misc_logical_expression_common_js__WEBPACK_IMPORTED_MODULE_2__/* .OperatorNodeBinaryPropMarshallingMap */ .hc.End);
            buffer.writeUint32(node.end);
        }
        buffer.writeUint8(_utils_constants_js__WEBPACK_IMPORTED_MODULE_4__/* .NULL */ .Cq);
    }
    /**
     * Serializes a logical expression node to binary format.
     *
     * @param node Node to serialize.
     * @param buffer ByteBuffer for writing binary data.
     */
    static serialize(node, buffer) {
        switch (node.type) {
            case NodeType.Variable:
                LogicalExpressionSerializer.serializeVariableNode(node, buffer);
                break;
            case NodeType.Operator:
                LogicalExpressionSerializer.serializeOperatorNode(node, buffer);
                break;
            case NodeType.Parenthesis:
                LogicalExpressionSerializer.serializeParenthesisNode(node, buffer);
                break;
            default:
                // eslint-disable-next-line @typescript-eslint/no-explicit-any
                throw new Error(`Unexpected node type: ${node.type}`);
        }
        buffer.writeUint8(_utils_constants_js__WEBPACK_IMPORTED_MODULE_4__/* .NULL */ .Cq);
    }
}




/***/ }),

/***/ 73734:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Y: () => (/* binding */ AdblockSyntax)
/* harmony export */ });
/*
 * AGTree v3.1.3 (build date: Tue, 29 Apr 2025 12:25:03 GMT)
 * (c) 2025 Adguard Software Ltd.
 * Released under the MIT license
 * https://github.com/AdguardTeam/tsurlfilter/tree/master/packages/agtree#readme
 */
/**
 * @file Possible adblock syntaxes are listed here.
 */
/**
 * Possible adblock syntaxes (supported by this library)
 */
const AdblockSyntax = {
    /**
     * Common syntax, which is supported by more than one adblocker (or by all adblockers).
     *
     * We typically use this syntax when we cannot determine the concrete syntax of the rule,
     * because the syntax is used by more than one adblocker natively.
     *
     * @example
     * - `||example.org^$important` is a common syntax, since it is used by all adblockers natively, and
     * we cannot determine at parsing level whether `important` is a valid option or not, and if it is valid,
     * then which adblocker supports it.
     */
    Common: 'Common',
    /**
     * Adblock Plus syntax.
     *
     * @example
     * - `example.org#$#abort-on-property-read alert` is an Adblock Plus syntax, since it is not used by any other
     * adblockers directly (probably supported by some on-the-fly conversion, but this is not the native syntax).
     * @see {@link https://adblockplus.org/}
     */
    Abp: 'AdblockPlus',
    /**
     * uBlock Origin syntax.
     *
     * @example
     * - `example.com##+js(set, atob, noopFunc)` is an uBlock Origin syntax, since it is not used by any other
     * adblockers directly (probably supported by some on-the-fly conversion, but this is not the native syntax).
     * @see {@link https://github.com/gorhill/uBlock}
     */
    Ubo: 'UblockOrigin',
    /**
     * AdGuard syntax.
     *
     * @example
     * - `example.org#%#//scriptlet("abort-on-property-read", "alert")` is an AdGuard syntax, since it is not used
     * by any other adblockers directly (probably supported by some on-the-fly conversion, but this is not the native
     * syntax).
     * @see {@link https://adguard.com/}
     */
    Adg: 'AdGuard',
};




/***/ }),

/***/ 75096:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   T: () => (/* binding */ BINARY_SCHEMA_VERSION)
/* harmony export */ });
/*
 * AGTree v3.1.3 (build date: Tue, 29 Apr 2025 12:25:03 GMT)
 * (c) 2025 Adguard Software Ltd.
 * Released under the MIT license
 * https://github.com/AdguardTeam/tsurlfilter/tree/master/packages/agtree#readme
 */
/**
 * @file Binary schema version.
 */
/**
 * Binary schema version.
 * This version number is used to ensure that the binary format is compatible with the current library version.
 * We increment this number if the serialized format changes in a way that is not backwards-compatible.
 */
const BINARY_SCHEMA_VERSION = 1;




/***/ }),

/***/ 50253:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   $: () => (/* binding */ ByteBuffer)
/* harmony export */ });
/*
 * AGTree v3.1.3 (build date: Tue, 29 Apr 2025 12:25:03 GMT)
 * (c) 2025 Adguard Software Ltd.
 * Released under the MIT license
 * https://github.com/AdguardTeam/tsurlfilter/tree/master/packages/agtree#readme
 */
/* eslint-disable no-bitwise */
/**
 * @file Core ByteBuffer implementation for handling binary data in chunks.
 */
/**
 * Core ByteBuffer implementation for handling binary data in chunks.
 * This class allows for efficient byte storage and manipulation by organizing data into chunks
 * and providing methods to read and write bytes.
 */
class ByteBuffer {
    /**
     * The size of each chunk in bytes (32 KB).
     */
    // ! IMPORTANT: If you ever change this value, make sure to update optimized bitwise operations in the code.
    static CHUNK_SIZE = 32768; // 32 * 1024
    /**
     * An array of Uint8Array chunks that make up the buffer.
     */
    chunks;
    /**
     * The total number of chunks in the buffer.
     */
    chunksLength;
    /**
     * Constructs a new ByteBuffer instance.
     *
     * @param chunks Optional array of chunks to initialize the ByteBuffer with.
     * @param cloneChunks Flag indicating if the chunks should be cloned. For performance reasons,
     * its default value is `false`. If the original chunks are guaranteed not to change,
     * leave this flag as `false` to avoid unnecessary copying.
     */
    constructor(chunks, cloneChunks = false) {
        const chunksToUse = chunks ?? [];
        this.chunks = cloneChunks ? chunksToUse.map((chunk) => new Uint8Array(chunk)) : chunksToUse;
        this.chunksLength = chunks?.length ?? 0;
    }
    /**
     * Ensures that the buffer has enough capacity to accommodate a given position.
     * This method adjusts the `chunks` array size to ensure it can hold the specified position.
     *
     * @param position The position to ensure capacity for.
     */
    ensureCapacity(position) {
        // same as Math.floor(position / chunk size), just optimized for the 32 KB chunk size
        const requiredChunkIndex = position >>> 0x000F;
        for (let i = this.chunksLength; i <= requiredChunkIndex; i += 1) {
            this.chunks.push(new Uint8Array(ByteBuffer.CHUNK_SIZE));
            this.chunksLength += 1;
        }
    }
    /**
     * Writes a byte to the buffer at the specified position.
     * If the position is outside of the buffer's current size, the buffer is resized to accommodate it.
     *
     * @param position The position at which to write the byte.
     * @param value The byte value to write (0-255).
     */
    writeByte(position, value) {
        // same as Math.floor(position / chunk size), just optimized for the 32 KB chunk size
        const chunkIndex = position >>> 0x000F;
        // same as position % chunk size, just optimized for the 32 KB chunk size
        const chunkOffset = position & 0x7FFF;
        if (chunkIndex >= this.chunksLength) {
            this.ensureCapacity(position);
        }
        this.chunks[chunkIndex][chunkOffset] = value;
    }
    /**
     * Reads a byte from the specified position in the buffer.
     * Returns `undefined` if the position is outside of the buffer's current size.
     *
     * @param position The position from which to read the byte.
     * @returns The read byte value, or `undefined` if the position is out of bounds.
     */
    readByte(position) {
        const chunkIndex = position >>> 0x000F;
        const chunkOffset = position & 0x7FFF;
        if (chunkIndex >= this.chunksLength) {
            return undefined;
        }
        return this.chunks[chunkIndex][chunkOffset];
    }
}




/***/ }),

/***/ 27895:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A1: () => (/* binding */ CLOSE_SQUARE_BRACKET),
/* harmony export */   AT: () => (/* binding */ SMALL_LETTER_Z),
/* harmony export */   Ae: () => (/* binding */ CSS_MEDIA_MARKER),
/* harmony export */   BH: () => (/* binding */ AGLINT_COMMAND_PREFIX),
/* harmony export */   BR: () => (/* binding */ HINT_MARKER_LEN),
/* harmony export */   C: () => (/* binding */ HASHMARK),
/* harmony export */   CR: () => (/* binding */ CR),
/* harmony export */   Cq: () => (/* binding */ NULL),
/* harmony export */   Cx: () => (/* binding */ OPEN_PARENTHESIS),
/* harmony export */   Ec: () => (/* binding */ EXCLAMATION_MARK),
/* harmony export */   Ez: () => (/* binding */ AGLINT_CONFIG_COMMENT_MARKER),
/* harmony export */   FF: () => (/* binding */ FF),
/* harmony export */   H3: () => (/* binding */ SMALL_LETTER_A),
/* harmony export */   I6: () => (/* binding */ UBO_MATCHES_PATH_OPERATOR),
/* harmony export */   I8: () => (/* binding */ SEMICOLON),
/* harmony export */   IF: () => (/* binding */ IF),
/* harmony export */   II: () => (/* binding */ UINT8_MAX),
/* harmony export */   JD: () => (/* binding */ ADG_PATH_MODIFIER),
/* harmony export */   KE: () => (/* binding */ COMMA),
/* harmony export */   KT: () => (/* binding */ CRLF),
/* harmony export */   Kx: () => (/* binding */ ESCAPE_CHARACTER),
/* harmony export */   L5: () => (/* binding */ PIPE),
/* harmony export */   LF: () => (/* binding */ LF),
/* harmony export */   Lb: () => (/* binding */ NETWORK_RULE_EXCEPTION_MARKER_LEN),
/* harmony export */   Ln: () => (/* binding */ ASTERISK),
/* harmony export */   NW: () => (/* binding */ ADG_DOMAINS_MODIFIER),
/* harmony export */   Nb: () => (/* binding */ QUESTION_MARK),
/* harmony export */   PD: () => (/* binding */ PREPROCESSOR_MARKER),
/* harmony export */   Pe: () => (/* binding */ ADG_APP_MODIFIER),
/* harmony export */   Rq: () => (/* binding */ UBO_SCRIPTLET_MASK),
/* harmony export */   UT: () => (/* binding */ EQUALS),
/* harmony export */   Vb: () => (/* binding */ REGEX_MARKER),
/* harmony export */   Vs: () => (/* binding */ UBO_SCRIPTLET_MASK_LEGACY),
/* harmony export */   Vw: () => (/* binding */ ADG_URL_MODIFIER),
/* harmony export */   Xj: () => (/* binding */ NETWORK_RULE_SEPARATOR),
/* harmony export */   _h: () => (/* binding */ UBO_HTML_MASK),
/* harmony export */   b9: () => (/* binding */ MODIFIERS_SEPARATOR),
/* harmony export */   bP: () => (/* binding */ NEGATION_MARKER),
/* harmony export */   bs: () => (/* binding */ WILDCARD),
/* harmony export */   cP: () => (/* binding */ CARET),
/* harmony export */   cU: () => (/* binding */ OPEN_SQUARE_BRACKET),
/* harmony export */   e0: () => (/* binding */ AMPERSAND),
/* harmony export */   fB: () => (/* binding */ UNDERSCORE),
/* harmony export */   fW: () => (/* binding */ PIPE_MODIFIER_SEPARATOR),
/* harmony export */   fi: () => (/* binding */ DOUBLE_QUOTE),
/* harmony export */   g9: () => (/* binding */ NUMBER_9),
/* harmony export */   hk: () => (/* binding */ CAPITAL_LETTER_Z),
/* harmony export */   j6: () => (/* binding */ HINT_MARKER),
/* harmony export */   li: () => (/* binding */ MODIFIER_ASSIGN_OPERATOR),
/* harmony export */   nC: () => (/* binding */ NUMBER_0),
/* harmony export */   nj: () => (/* binding */ DOLLAR_SIGN),
/* harmony export */   nx: () => (/* binding */ PREPROCESSOR_MARKER_LEN),
/* harmony export */   o: () => (/* binding */ SLASH),
/* harmony export */   oH: () => (/* binding */ COLON),
/* harmony export */   oo: () => (/* binding */ COMMA_DOMAIN_LIST_SEPARATOR),
/* harmony export */   ot: () => (/* binding */ CAPITAL_LETTER_A),
/* harmony export */   pi: () => (/* binding */ CSS_BLOCK_CLOSE),
/* harmony export */   rF: () => (/* binding */ NETWORK_RULE_EXCEPTION_MARKER),
/* harmony export */   rM: () => (/* binding */ INCLUDE),
/* harmony export */   r_: () => (/* binding */ BACKSLASH),
/* harmony export */   s1: () => (/* binding */ CLOSE_PARENTHESIS),
/* harmony export */   sA: () => (/* binding */ PREPROCESSOR_SEPARATOR),
/* harmony export */   sV: () => (/* binding */ OPEN_CURLY_BRACKET),
/* harmony export */   t6: () => (/* binding */ SPACE),
/* harmony export */   ur: () => (/* binding */ SINGLE_QUOTE),
/* harmony export */   us: () => (/* binding */ SAFARI_CB_AFFINITY),
/* harmony export */   uu: () => (/* binding */ PLUS),
/* harmony export */   vr: () => (/* binding */ CSS_NOT_PSEUDO),
/* harmony export */   w1: () => (/* binding */ BACKTICK_QUOTE),
/* harmony export */   wH: () => (/* binding */ AT_SIGN),
/* harmony export */   wU: () => (/* binding */ CLOSE_CURLY_BRACKET),
/* harmony export */   wg: () => (/* binding */ EMPTY),
/* harmony export */   wn: () => (/* binding */ TAB),
/* harmony export */   x$: () => (/* binding */ ADG_SCRIPTLET_MASK),
/* harmony export */   y0: () => (/* binding */ DOT),
/* harmony export */   zW: () => (/* binding */ CSS_BLOCK_OPEN),
/* harmony export */   zg: () => (/* binding */ UINT16_MAX)
/* harmony export */ });
/* unused harmony exports CAPITAL_LETTERS, CAPITAL_LETTER_B, CAPITAL_LETTER_C, CAPITAL_LETTER_D, CAPITAL_LETTER_E, CAPITAL_LETTER_F, CAPITAL_LETTER_G, CAPITAL_LETTER_H, CAPITAL_LETTER_I, CAPITAL_LETTER_J, CAPITAL_LETTER_K, CAPITAL_LETTER_L, CAPITAL_LETTER_M, CAPITAL_LETTER_N, CAPITAL_LETTER_O, CAPITAL_LETTER_P, CAPITAL_LETTER_Q, CAPITAL_LETTER_R, CAPITAL_LETTER_S, CAPITAL_LETTER_T, CAPITAL_LETTER_U, CAPITAL_LETTER_V, CAPITAL_LETTER_W, CAPITAL_LETTER_X, CAPITAL_LETTER_Y, NEWLINE, NUMBERS, NUMBER_1, NUMBER_2, NUMBER_3, NUMBER_4, NUMBER_5, NUMBER_6, NUMBER_7, NUMBER_8, SMALL_LETTERS, SMALL_LETTER_B, SMALL_LETTER_C, SMALL_LETTER_D, SMALL_LETTER_E, SMALL_LETTER_F, SMALL_LETTER_G, SMALL_LETTER_H, SMALL_LETTER_I, SMALL_LETTER_J, SMALL_LETTER_K, SMALL_LETTER_L, SMALL_LETTER_M, SMALL_LETTER_N, SMALL_LETTER_O, SMALL_LETTER_P, SMALL_LETTER_Q, SMALL_LETTER_R, SMALL_LETTER_S, SMALL_LETTER_T, SMALL_LETTER_U, SMALL_LETTER_V, SMALL_LETTER_W, SMALL_LETTER_X, SMALL_LETTER_Y */
/*
 * AGTree v3.1.3 (build date: Tue, 29 Apr 2025 12:25:03 GMT)
 * (c) 2025 Adguard Software Ltd.
 * Released under the MIT license
 * https://github.com/AdguardTeam/tsurlfilter/tree/master/packages/agtree#readme
 */
/**
 * @file Constant values used by all parts of the library
 */
// TODO: remove unused constants
// General
/**
 * Empty string.
 */
const EMPTY = '';
const SPACE = ' ';
const TAB = '\t';
const COLON = ':';
const COMMA = ',';
const DOT = '.';
const SEMICOLON = ';';
const AMPERSAND = '&';
const ASTERISK = '*';
const AT_SIGN = '@';
const CARET = '^';
const DOLLAR_SIGN = '$';
const EQUALS = '=';
const EXCLAMATION_MARK = '!';
const HASHMARK = '#';
const PIPE = '|';
const PLUS = '+';
const QUESTION_MARK = '?';
const SLASH = '/';
const UNDERSCORE = '_';
// Escape characters
const BACKSLASH = '\\';
const ESCAPE_CHARACTER = BACKSLASH;
// Newlines
const CR = '\r';
const FF = '\f';
const LF = '\n';
const CRLF = CR + LF;
const NEWLINE = (/* unused pure expression or super */ null && (LF));
// Quotes
const BACKTICK_QUOTE = '`';
const DOUBLE_QUOTE = '"';
const SINGLE_QUOTE = '\'';
// Brackets
const OPEN_PARENTHESIS = '(';
const CLOSE_PARENTHESIS = ')';
const OPEN_SQUARE_BRACKET = '[';
const CLOSE_SQUARE_BRACKET = ']';
const OPEN_CURLY_BRACKET = '{';
const CLOSE_CURLY_BRACKET = '}';
// Letters
const SMALL_LETTER_A = 'a';
const SMALL_LETTER_B = 'b';
const SMALL_LETTER_C = 'c';
const SMALL_LETTER_D = 'd';
const SMALL_LETTER_E = 'e';
const SMALL_LETTER_F = 'f';
const SMALL_LETTER_G = 'g';
const SMALL_LETTER_H = 'h';
const SMALL_LETTER_I = 'i';
const SMALL_LETTER_J = 'j';
const SMALL_LETTER_K = 'k';
const SMALL_LETTER_L = 'l';
const SMALL_LETTER_M = 'm';
const SMALL_LETTER_N = 'n';
const SMALL_LETTER_O = 'o';
const SMALL_LETTER_P = 'p';
const SMALL_LETTER_Q = 'q';
const SMALL_LETTER_R = 'r';
const SMALL_LETTER_S = 's';
const SMALL_LETTER_T = 't';
const SMALL_LETTER_U = 'u';
const SMALL_LETTER_V = 'v';
const SMALL_LETTER_W = 'w';
const SMALL_LETTER_X = 'x';
const SMALL_LETTER_Y = 'y';
const SMALL_LETTER_Z = 'z';
/**
 * Set of all small letters.
 */
const SMALL_LETTERS = new Set([
    SMALL_LETTER_A,
    SMALL_LETTER_B,
    SMALL_LETTER_C,
    SMALL_LETTER_D,
    SMALL_LETTER_E,
    SMALL_LETTER_F,
    SMALL_LETTER_G,
    SMALL_LETTER_H,
    SMALL_LETTER_I,
    SMALL_LETTER_J,
    SMALL_LETTER_K,
    SMALL_LETTER_L,
    SMALL_LETTER_M,
    SMALL_LETTER_N,
    SMALL_LETTER_O,
    SMALL_LETTER_P,
    SMALL_LETTER_Q,
    SMALL_LETTER_R,
    SMALL_LETTER_S,
    SMALL_LETTER_T,
    SMALL_LETTER_U,
    SMALL_LETTER_V,
    SMALL_LETTER_W,
    SMALL_LETTER_X,
    SMALL_LETTER_Y,
    SMALL_LETTER_Z,
]);
// Capital letters
const CAPITAL_LETTER_A = 'A';
const CAPITAL_LETTER_B = 'B';
const CAPITAL_LETTER_C = 'C';
const CAPITAL_LETTER_D = 'D';
const CAPITAL_LETTER_E = 'E';
const CAPITAL_LETTER_F = 'F';
const CAPITAL_LETTER_G = 'G';
const CAPITAL_LETTER_H = 'H';
const CAPITAL_LETTER_I = 'I';
const CAPITAL_LETTER_J = 'J';
const CAPITAL_LETTER_K = 'K';
const CAPITAL_LETTER_L = 'L';
const CAPITAL_LETTER_M = 'M';
const CAPITAL_LETTER_N = 'N';
const CAPITAL_LETTER_O = 'O';
const CAPITAL_LETTER_P = 'P';
const CAPITAL_LETTER_Q = 'Q';
const CAPITAL_LETTER_R = 'R';
const CAPITAL_LETTER_S = 'S';
const CAPITAL_LETTER_T = 'T';
const CAPITAL_LETTER_U = 'U';
const CAPITAL_LETTER_V = 'V';
const CAPITAL_LETTER_W = 'W';
const CAPITAL_LETTER_X = 'X';
const CAPITAL_LETTER_Y = 'Y';
const CAPITAL_LETTER_Z = 'Z';
/**
 * Set of all capital letters.
 */
const CAPITAL_LETTERS = new Set([
    CAPITAL_LETTER_A,
    CAPITAL_LETTER_B,
    CAPITAL_LETTER_C,
    CAPITAL_LETTER_D,
    CAPITAL_LETTER_E,
    CAPITAL_LETTER_F,
    CAPITAL_LETTER_G,
    CAPITAL_LETTER_H,
    CAPITAL_LETTER_I,
    CAPITAL_LETTER_J,
    CAPITAL_LETTER_K,
    CAPITAL_LETTER_L,
    CAPITAL_LETTER_M,
    CAPITAL_LETTER_N,
    CAPITAL_LETTER_O,
    CAPITAL_LETTER_P,
    CAPITAL_LETTER_Q,
    CAPITAL_LETTER_R,
    CAPITAL_LETTER_S,
    CAPITAL_LETTER_T,
    CAPITAL_LETTER_U,
    CAPITAL_LETTER_V,
    CAPITAL_LETTER_W,
    CAPITAL_LETTER_X,
    CAPITAL_LETTER_Y,
    CAPITAL_LETTER_Z,
]);
// Numbers as strings
const NUMBER_0 = '0';
const NUMBER_1 = '1';
const NUMBER_2 = '2';
const NUMBER_3 = '3';
const NUMBER_4 = '4';
const NUMBER_5 = '5';
const NUMBER_6 = '6';
const NUMBER_7 = '7';
const NUMBER_8 = '8';
const NUMBER_9 = '9';
/**
 * Set of all numbers as strings.
 */
const NUMBERS = new Set([
    NUMBER_0,
    NUMBER_1,
    NUMBER_2,
    NUMBER_3,
    NUMBER_4,
    NUMBER_5,
    NUMBER_6,
    NUMBER_7,
    NUMBER_8,
    NUMBER_9,
]);
const REGEX_MARKER = '/';
const ADG_SCRIPTLET_MASK = '//scriptlet';
const UBO_SCRIPTLET_MASK = '+js';
const UBO_SCRIPTLET_MASK_LEGACY = 'script:inject';
const UBO_HTML_MASK = '^';
const UBO_MATCHES_PATH_OPERATOR = 'matches-path';
const ADG_PATH_MODIFIER = 'path';
const ADG_DOMAINS_MODIFIER = 'domain';
const ADG_APP_MODIFIER = 'app';
const ADG_URL_MODIFIER = 'url';
// Modifiers are separated by ",". For example: "script,domain=example.com"
const MODIFIERS_SEPARATOR = ',';
const MODIFIER_ASSIGN_OPERATOR = '=';
const NEGATION_MARKER = '~';
/**
 * The wildcard symbol — `*`.
 */
const WILDCARD = ASTERISK;
/**
 * Classic domain separator.
 *
 * @example
 * ```adblock
 * ! Domains are separated by ",":
 * example.com,~example.org##.ads
 * ```
 */
const COMMA_DOMAIN_LIST_SEPARATOR = ',';
/**
 * Modifier separator for $app, $denyallow, $domain, $method.
 *
 * @example
 * ```adblock
 * ! Domains are separated by "|":
 * ads.js^$script,domains=example.com|~example.org
 * ```
 */
const PIPE_MODIFIER_SEPARATOR = '|';
const CSS_MEDIA_MARKER = '@media';
const CSS_NOT_PSEUDO = 'not';
const CSS_BLOCK_OPEN = '{';
const CSS_BLOCK_CLOSE = '}';
const HINT_MARKER = '!+';
const HINT_MARKER_LEN = HINT_MARKER.length;
const NETWORK_RULE_EXCEPTION_MARKER = '@@';
const NETWORK_RULE_EXCEPTION_MARKER_LEN = NETWORK_RULE_EXCEPTION_MARKER.length;
const NETWORK_RULE_SEPARATOR = '$';
const AGLINT_COMMAND_PREFIX = 'aglint';
const AGLINT_CONFIG_COMMENT_MARKER = '--';
const PREPROCESSOR_MARKER = '!#';
const PREPROCESSOR_MARKER_LEN = PREPROCESSOR_MARKER.length;
const PREPROCESSOR_SEPARATOR = ' ';
const SAFARI_CB_AFFINITY = 'safari_cb_affinity';
const IF = 'if';
const INCLUDE = 'include';
const NULL = 0;
const UINT8_MAX = 255;
const UINT16_MAX = 65535;




/***/ }),

/***/ 80576:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   m: () => (/* binding */ CosmeticRuleSeparatorUtils)
/* harmony export */ });
/* harmony import */ var _nodes_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(91354);
/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(27895);
/*
 * AGTree v3.1.3 (build date: Tue, 29 Apr 2025 12:25:03 GMT)
 * (c) 2025 Adguard Software Ltd.
 * Released under the MIT license
 * https://github.com/AdguardTeam/tsurlfilter/tree/master/packages/agtree#readme
 */



/**
 * @file Cosmetic rule separator finder and categorizer
 */
/**
 * Utility class for cosmetic rule separators.
 */
class CosmeticRuleSeparatorUtils {
    /**
     * Checks whether the specified separator is an exception.
     *
     * @param separator Separator to check
     * @returns `true` if the separator is an exception, `false` otherwise
     */
    static isException(separator) {
        // Simply check the second character
        return separator[1] === _constants_js__WEBPACK_IMPORTED_MODULE_0__/* .AT_SIGN */ .wH;
    }
    /**
     * Checks whether the specified separator is marks an Extended CSS cosmetic rule.
     *
     * @param separator Separator to check
     * @returns `true` if the separator is marks an Extended CSS cosmetic rule, `false` otherwise
     */
    static isExtendedCssMarker(separator) {
        return (separator === _nodes_index_js__WEBPACK_IMPORTED_MODULE_1__/* .CosmeticRuleSeparator */ .p5.ExtendedElementHiding
            || separator === _nodes_index_js__WEBPACK_IMPORTED_MODULE_1__/* .CosmeticRuleSeparator */ .p5.ExtendedElementHidingException
            || separator === _nodes_index_js__WEBPACK_IMPORTED_MODULE_1__/* .CosmeticRuleSeparator */ .p5.AdgExtendedCssInjection
            || separator === _nodes_index_js__WEBPACK_IMPORTED_MODULE_1__/* .CosmeticRuleSeparator */ .p5.AdgExtendedCssInjectionException);
    }
    /**
     * Looks for the cosmetic rule separator in the rule. This is a simplified version that
     * masks the recursive function.
     *
     * @param rule Raw rule
     * @returns Separator result or null if no separator was found
     */
    static find(rule) {
        /**
         * Helper function to create results of the `find` method.
         *
         * @param start Start position
         * @param separator Separator type
         * @returns Cosmetic rule separator node
         */
        // eslint-disable-next-line max-len
        function createResult(start, separator) {
            return {
                separator,
                start,
                end: start + separator.length,
            };
        }
        for (let i = 0; i < rule.length; i += 1) {
            if (rule[i] === '#') {
                if (rule[i + 1] === '#' && rule[i - 1] !== _constants_js__WEBPACK_IMPORTED_MODULE_0__/* .SPACE */ .t6) {
                    // ##
                    return createResult(i, _nodes_index_js__WEBPACK_IMPORTED_MODULE_1__/* .CosmeticRuleSeparator */ .p5.ElementHiding);
                }
                if (rule[i + 1] === '?' && rule[i + 2] === '#') {
                    // #?#
                    return createResult(i, _nodes_index_js__WEBPACK_IMPORTED_MODULE_1__/* .CosmeticRuleSeparator */ .p5.ExtendedElementHiding);
                }
                if (rule[i + 1] === '%' && rule[i + 2] === '#') {
                    // #%#
                    return createResult(i, _nodes_index_js__WEBPACK_IMPORTED_MODULE_1__/* .CosmeticRuleSeparator */ .p5.AdgJsInjection);
                }
                if (rule[i + 1] === '$') {
                    if (rule[i + 2] === '#') {
                        // #$#
                        return createResult(i, _nodes_index_js__WEBPACK_IMPORTED_MODULE_1__/* .CosmeticRuleSeparator */ .p5.AdgCssInjection);
                    }
                    if (rule[i + 2] === '?' && rule[i + 3] === '#') {
                        // #$?#
                        return createResult(i, _nodes_index_js__WEBPACK_IMPORTED_MODULE_1__/* .CosmeticRuleSeparator */ .p5.AdgExtendedCssInjection);
                    }
                }
                // Exceptions
                if (rule[i + 1] === '@') {
                    if (rule[i + 2] === '#' && rule[i - 1] !== _constants_js__WEBPACK_IMPORTED_MODULE_0__/* .SPACE */ .t6) {
                        // #@#
                        return createResult(i, _nodes_index_js__WEBPACK_IMPORTED_MODULE_1__/* .CosmeticRuleSeparator */ .p5.ElementHidingException);
                    }
                    if (rule[i + 2] === '?' && rule[i + 3] === '#') {
                        // #@?#
                        return createResult(i, _nodes_index_js__WEBPACK_IMPORTED_MODULE_1__/* .CosmeticRuleSeparator */ .p5.ExtendedElementHidingException);
                    }
                    if (rule[i + 2] === '%' && rule[i + 3] === '#') {
                        // #@%#
                        return createResult(i, _nodes_index_js__WEBPACK_IMPORTED_MODULE_1__/* .CosmeticRuleSeparator */ .p5.AdgJsInjectionException);
                    }
                    if (rule[i + 2] === '$') {
                        if (rule[i + 3] === '#') {
                            // #@$#
                            return createResult(i, _nodes_index_js__WEBPACK_IMPORTED_MODULE_1__/* .CosmeticRuleSeparator */ .p5.AdgCssInjectionException);
                        }
                        if (rule[i + 3] === '?' && rule[i + 4] === '#') {
                            // #@$?#
                            return createResult(i, _nodes_index_js__WEBPACK_IMPORTED_MODULE_1__/* .CosmeticRuleSeparator */ .p5.AdgExtendedCssInjectionException);
                        }
                    }
                }
            }
            if (rule[i] === '$') {
                if (rule[i + 1] === '$') {
                    // $$
                    return createResult(i, _nodes_index_js__WEBPACK_IMPORTED_MODULE_1__/* .CosmeticRuleSeparator */ .p5.AdgHtmlFiltering);
                }
                if (rule[i + 1] === '@' && rule[i + 2] === '$') {
                    // $@$
                    return createResult(i, _nodes_index_js__WEBPACK_IMPORTED_MODULE_1__/* .CosmeticRuleSeparator */ .p5.AdgHtmlFilteringException);
                }
            }
        }
        return null;
    }
}




/***/ }),

/***/ 40680:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Aw: () => (/* binding */ DomainUtils)
/* harmony export */ });
/* unused harmony exports WILDCARD_SUBDOMAIN, WILDCARD_TLD */
/* harmony import */ var tldts__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(13548);
/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(27895);
/*
 * AGTree v3.1.3 (build date: Tue, 29 Apr 2025 12:25:03 GMT)
 * (c) 2025 Adguard Software Ltd.
 * Released under the MIT license
 * https://github.com/AdguardTeam/tsurlfilter/tree/master/packages/agtree#readme
 */



/**
 * @file Utility functions for domain and hostname validation.
 */
/**
 * Marker for a wildcard top-level domain — `.*`.
 *
 * @example
 * `example.*` — matches with any TLD, e.g. `example.org`, `example.com`, etc.
 */
const WILDCARD_TLD = _constants_js__WEBPACK_IMPORTED_MODULE_1__/* .DOT */ .y0 + _constants_js__WEBPACK_IMPORTED_MODULE_1__/* .WILDCARD */ .bs;
/**
 * Marker for a wildcard subdomain — `*.`.
 *
 * @example
 * `*.example.org` — matches with any subdomain, e.g. `foo.example.org` or `bar.example.org`
 */
const WILDCARD_SUBDOMAIN = _constants_js__WEBPACK_IMPORTED_MODULE_1__/* .WILDCARD */ .bs + _constants_js__WEBPACK_IMPORTED_MODULE_1__/* .DOT */ .y0;
/**
 * Utility functions for domain and hostname validation.
 */
class DomainUtils {
    /**
     * Check if the input is a valid domain or hostname.
     *
     * @param domain Domain to check
     * @returns `true` if the domain is valid, `false` otherwise
     */
    static isValidDomainOrHostname(domain) {
        let domainToCheck = domain;
        // Wildcard-only domain, typically a generic rule
        if (domainToCheck === _constants_js__WEBPACK_IMPORTED_MODULE_1__/* .WILDCARD */ .bs) {
            return true;
        }
        // https://adguard.com/kb/general/ad-filtering/create-own-filters/#wildcard-for-tld
        if (domainToCheck.endsWith(WILDCARD_TLD)) {
            // Remove the wildcard TLD
            domainToCheck = domainToCheck.substring(0, domainToCheck.length - WILDCARD_TLD.length);
        }
        if (domainToCheck.startsWith(WILDCARD_SUBDOMAIN)) {
            // Remove the wildcard subdomain
            domainToCheck = domainToCheck.substring(WILDCARD_SUBDOMAIN.length);
        }
        // Parse the domain with tldts
        const tldtsResult = (0,tldts__WEBPACK_IMPORTED_MODULE_0__/* .parse */ .qg)(domainToCheck);
        // Check if the domain is valid
        return domainToCheck === tldtsResult.domain || domainToCheck === tldtsResult.hostname;
    }
}




/***/ }),

/***/ 72313:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  N: () => (/* binding */ InputByteBuffer)
});

// EXTERNAL MODULE: ./node_modules/.pnpm/@adguard+agtree@3.1.3/node_modules/@adguard/agtree/dist/utils/byte-buffer.js
var byte_buffer = __webpack_require__(50253);
// EXTERNAL MODULE: ./node_modules/.pnpm/@adguard+agtree@3.1.3/node_modules/@adguard/agtree/dist/utils/type-guards.js
var type_guards = __webpack_require__(8123);
// EXTERNAL MODULE: ./node_modules/.pnpm/@adguard+agtree@3.1.3/node_modules/@adguard/agtree/dist/utils/is-chromium.js
var is_chromium = __webpack_require__(36765);
// EXTERNAL MODULE: ./node_modules/.pnpm/@adguard+agtree@3.1.3/node_modules/@adguard/agtree/dist/utils/constants.js
var constants = __webpack_require__(27895);
;// ./node_modules/.pnpm/@adguard+agtree@3.1.3/node_modules/@adguard/agtree/dist/utils/text-decoder-polyfill.js
/*
 * AGTree v3.1.3 (build date: Tue, 29 Apr 2025 12:25:03 GMT)
 * (c) 2025 Adguard Software Ltd.
 * Released under the MIT license
 * https://github.com/AdguardTeam/tsurlfilter/tree/master/packages/agtree#readme
 */


/* eslint-disable no-plusplus */
/* eslint-disable no-bitwise */
/**
 * @file Optimized utility for decoding strings from byte sequences.
 */
const REPLACEMENT_CHAR = String.fromCodePoint(0xFFFD);
/**
 * Decodes a byte sequence into an UTF-8 string according to the WHATWG spec.
 * Optimized for performance.
 *
 * @param buffer Buffer to read the bytes from.
 * @param start Start offset in the buffer.
 * @param end End offset in the buffer.
 * @returns Decoded string.
 * @see {@link https://encoding.spec.whatwg.org/#utf-8-decoder}
 */
const decodeTextPolyfill = (buffer, start = 0, end = -1) => {
    let codePoint = 0;
    let bytesSeen = 0;
    let bytesNeeded = 0;
    let lowerBoundary = 0x0080;
    let upperBoundary = 0x00BF;
    let i = start;
    const { length } = buffer;
    const realEnd = end === -1 ? length : Math.min(end, length);
    const result = new Array(realEnd - start);
    let resIdx = 0;
    for (; i < realEnd; i += 1) {
        const byte = buffer[i];
        if (bytesNeeded === 0) {
            if (byte <= 0x007F) {
                codePoint = byte & 0x00FF;
            }
            else if (byte >= 0x00C2 && byte <= 0x00DF) {
                bytesNeeded = 1;
                codePoint = byte & 0x001F;
            }
            else if (byte >= 0x00E0 && byte <= 0x00EF) {
                bytesNeeded = 2;
                codePoint = byte & 0x000F;
                if (byte === 0x00E0) {
                    // Adjust lower boundary for exclusion of overlong sequences
                    lowerBoundary = 0x00A0;
                }
                else if (byte === 0x00ED) {
                    // Adjust upper boundary to exclude surrogates
                    upperBoundary = 0x009F;
                }
            }
            else if (byte >= 0x00F0 && byte <= 0x00F4) {
                bytesNeeded = 3;
                codePoint = byte & 0x0007;
                if (byte === 0x00F0) {
                    // Adjust lower boundary for exclusion of overlong sequences
                    lowerBoundary = 0x0090;
                }
                else if (byte === 0x00F4) {
                    // Adjust upper boundary to limit to valid Unicode range
                    upperBoundary = 0x008F;
                }
            }
            else {
                // For bytes that are not valid initial bytes of UTF-8 sequences, add replacement character
                result[resIdx++] = REPLACEMENT_CHAR;
                continue;
            }
        }
        else {
            // For subsequent bytes in a multibyte sequence, check if the byte is in the expected range
            if (!(byte >= lowerBoundary && byte <= upperBoundary)) {
                // Reset the state for illegal sequences and add replacement character
                bytesNeeded = 0;
                bytesSeen = 0;
                lowerBoundary = 0x0080;
                upperBoundary = 0x00BF;
                result[resIdx++] = REPLACEMENT_CHAR;
                // Decrement `i` to re-evaluate this byte as the start of a new sequence
                i -= 1;
                continue;
            }
            codePoint = (codePoint << 6) | (byte & 0x003F);
            // Reset boundaries for next bytes
            lowerBoundary = 0x0080;
            upperBoundary = 0x00BF;
            bytesSeen += 1;
        }
        if (bytesSeen === bytesNeeded) {
            // Complete the code point assembly and add it to the result
            result[resIdx++] = String.fromCodePoint(codePoint);
            // Reset for the next character
            bytesNeeded = 0;
            bytesSeen = 0;
            codePoint = 0;
        }
    }
    return result.join(constants/* EMPTY */.wg);
};



// EXTERNAL MODULE: ./node_modules/.pnpm/@adguard+agtree@3.1.3/node_modules/@adguard/agtree/dist/utils/binary-schema-version.js
var binary_schema_version = __webpack_require__(75096);
;// ./node_modules/.pnpm/@adguard+agtree@3.1.3/node_modules/@adguard/agtree/dist/errors/binary-schema-mismatch-error.js
/*
 * AGTree v3.1.3 (build date: Tue, 29 Apr 2025 12:25:03 GMT)
 * (c) 2025 Adguard Software Ltd.
 * Released under the MIT license
 * https://github.com/AdguardTeam/tsurlfilter/tree/master/packages/agtree#readme
 */
/**
 * @file Customized error for binary schema mismatch.
 */
const ERROR_NAME = 'BinarySchemaMismatchError';
/**
 * Customized error for binary schema mismatch.
 */
class BinarySchemaMismatchError extends Error {
    /**
     * Expected schema version.
     */
    expectedVersion;
    /**
     * Actual schema version.
     */
    actualVersion;
    /**
     * Constructs a new `BinarySchemaMismatchError` instance.
     *
     * @param expectedVersion Expected schema version.
     * @param actualVersion Actual schema version.
     */
    constructor(expectedVersion, actualVersion) {
        super(`Expected schema version ${expectedVersion}, but got ${actualVersion}`);
        this.name = ERROR_NAME;
        this.expectedVersion = expectedVersion;
        this.actualVersion = actualVersion;
    }
}



;// ./node_modules/.pnpm/@adguard+agtree@3.1.3/node_modules/@adguard/agtree/dist/utils/input-byte-buffer.js
/*
 * AGTree v3.1.3 (build date: Tue, 29 Apr 2025 12:25:03 GMT)
 * (c) 2025 Adguard Software Ltd.
 * Released under the MIT license
 * https://github.com/AdguardTeam/tsurlfilter/tree/master/packages/agtree#readme
 */







/* eslint-disable max-len */
/* eslint-disable no-plusplus */
/* eslint-disable no-bitwise */
/**
 * @file Input byte buffer for reading binary data.
 */
/**
 * Input byte buffer for reading binary data.
 *
 * @note Internally, this class uses a {@link ByteBuffer} instance, just providing a convenient API for reading data.
 */
class InputByteBuffer extends byte_buffer/* ByteBuffer */.$ {
    /**
     * Current offset in the buffer for reading.
     */
    offset;
    /**
     * Shared native decoder for decoding strings.
     */
    sharedNativeDecoder;
    /**
     * Flag indicating if the current environment is Chromium.
     * This is used for performance optimizations, because Chromium's TextEncoder/TextDecoder has a relatively
     * large marshalling overhead for small strings.
     */
    isChromium;
    /**
     * Constructs a new `InputByteBuffer` instance.
     *
     * @param chunks Array of chunks to initialize the ByteBuffer with.
     * @param cloneChunks Flag indicating if the chunks should be cloned. For performance reasons,
     * its default value is `false`. If the original chunks are guaranteed not to change,
     * leave this flag as `false` to avoid unnecessary copying.
     * @param initialOffset Initial offset in the buffer for reading.
     *
     * @throws If the specified chunks array is empty.
     * @throws If the binary schema version in the buffer is not equal to the expected version.
     * @throws If the initial offset is out of bounds.
     */
    constructor(chunks, cloneChunks = false, initialOffset = 0) {
        super(chunks, cloneChunks);
        // TODO: Consider accepting an empty array of chunks
        // Check binary schema version
        if (chunks.length === 0) {
            throw new Error('No data in the buffer');
        }
        const actualVersion = this.readSchemaVersion();
        if (actualVersion !== binary_schema_version/* BINARY_SCHEMA_VERSION */.T) {
            throw new BinarySchemaMismatchError(binary_schema_version/* BINARY_SCHEMA_VERSION */.T, actualVersion);
        }
        // Throw an error if the initial offset is out of bounds
        if (initialOffset < 0 || initialOffset > this.chunks.length * byte_buffer/* ByteBuffer */.$.CHUNK_SIZE) {
            throw new Error(`Invalid offset: ${initialOffset}`);
        }
        // Schema version is always stored at the beginning of the buffer - skip it, because it is already processed
        this.offset = Math.max(4, initialOffset);
        this.sharedNativeDecoder = new TextDecoder();
        this.isChromium = (0,is_chromium/* isChromium */.F)();
    }
    /**
     * Creates a new InputByteBuffer instance from a Storage instance by reading chunks from the storage.
     *
     * @param storage Storage instance.
     * @param key Key to read from the storage.
     * @returns New InputByteBuffer instance.
     * @note For performance reasons, chunks are passed by reference and not copied.
     */
    static async createFromStorage(storage, key) {
        const chunks = await storage.get(key);
        if (!(0,type_guards/* isArrayOfUint8Arrays */.r_)(chunks)) {
            throw new Error('The data from storage is not an array of Uint8Arrays');
        }
        return new InputByteBuffer(chunks);
    }
    /**
     * Reads a 8-bit unsigned integer from the buffer.
     *
     * @returns 8-bit unsigned integer from the buffer.
     */
    readUint8() {
        const result = this.readByte(this.offset++) ?? 0;
        return result;
    }
    /**
     * Reads a 16-bit unsigned integer from the buffer.
     *
     * @returns 16-bit unsigned integer from the buffer.
     */
    readUint16() {
        const result = (((this.readByte(this.offset++) ?? 0) << 8)
            | ((this.readByte(this.offset++) ?? 0))) >>> 0;
        return result;
    }
    /**
     * Reads a 32-bit unsigned integer from the buffer at the specified index.
     *
     * @param index Index to read the 32-bit unsigned integer from.
     *
     * @returns 32-bit unsigned integer from the buffer.
     */
    readUint32FromIndex(index) {
        const result = (((this.readByte(index) ?? 0) << 24)
            | ((this.readByte(index + 1) ?? 0) << 16)
            | ((this.readByte(index + 2) ?? 0) << 8)
            | ((this.readByte(index + 3) ?? 0))) >>> 0;
        return result;
    }
    /**
     * Reads a 32-bit unsigned integer from the buffer.
     *
     * @returns 32-bit unsigned integer from the buffer.
     */
    readUint32() {
        const result = this.readUint32FromIndex(this.offset);
        this.offset += 4;
        return result;
    }
    /**
     * Reads schema version from the buffer.
     *
     * @returns 32-bit unsigned integer from the buffer.
     * @note Schema version is always stored at the beginning of the buffer.
     */
    readSchemaVersion() {
        return this.readUint32FromIndex(0);
    }
    /**
     * Reads a 32-bit signed integer from the buffer.
     *
     * @returns 32-bit signed integer from the buffer.
     */
    readInt32() {
        const result = this.readUint32();
        return result > 0x7fffffff ? result - 0x100000000 : result;
    }
    /**
     * Reads an optimized unsigned integer from the buffer.
     * 'Optimized' means that the integer is stored in a variable number of bytes, depending on its value,
     * so that smaller numbers occupy less space.
     *
     * @returns Decoded unsigned integer from the buffer.
     */
    readOptimizedUint() {
        let result = 0;
        let shift = 0;
        while (shift <= 28) {
            const byteValue = this.readByte(this.offset++) ?? 0;
            result |= (byteValue & 0x7F) << shift;
            shift += 7;
            if ((byteValue & 0x80) === 0) {
                break;
            }
        }
        return result;
    }
    /**
     * Reads a string from the buffer.
     *
     * @returns Decoded string from the buffer.
     */
    readString() {
        const length = this.readOptimizedUint();
        let chunkIndex = this.offset >>> 0x000F;
        const chunkOffset = this.offset & 0x7FFF; // offset is only relevant for the first chunk
        const endOffset = chunkOffset + length;
        // In most cases, the string is stored in the current chunk
        if (endOffset < byte_buffer/* ByteBuffer */.$.CHUNK_SIZE) {
            this.offset += length;
            if (this.isChromium) {
                return decodeTextPolyfill(this.chunks[chunkIndex], chunkOffset, endOffset);
            }
            return this.sharedNativeDecoder.decode(this.chunks[chunkIndex].subarray(chunkOffset, endOffset));
        }
        const result = [];
        result.push(this.sharedNativeDecoder.decode(this.chunks[chunkIndex++].subarray(chunkOffset), { stream: true }));
        let remaining = length - (byte_buffer/* ByteBuffer */.$.CHUNK_SIZE - chunkOffset);
        while (remaining) {
            const chunk = this.chunks[chunkIndex];
            if (!chunk) {
                break;
            }
            const toRead = Math.min(remaining, byte_buffer/* ByteBuffer */.$.CHUNK_SIZE);
            result.push(this.sharedNativeDecoder.decode(chunk.subarray(0, toRead), { stream: true }));
            remaining -= toRead;
            chunkIndex += 1;
        }
        // Finish decoding, if something is left
        result.push(this.sharedNativeDecoder.decode());
        this.offset += length;
        return result.join('');
    }
    /**
     * Reads a 8-bit unsigned integer from the buffer without advancing the offset.
     *
     * @returns 8-bit unsigned integer from the buffer.
     */
    peekUint8() {
        return this.readByte(this.offset) ?? 0;
    }
    /**
     * Helper method for asserting the next 8-bit unsigned integer in the buffer.
     *
     * @param value Expected value.
     * @throws If the next value in the buffer is not equal to the expected value.
     */
    assertUint8(value) {
        const result = this.readUint8();
        if (result !== value) {
            throw new Error(`Expected ${value}, but got ${result}`);
        }
    }
    /**
     * Creates a new `InputByteBuffer` instance with the given initial offset.
     *
     * @param initialOffset Initial offset for the new buffer.
     * @param cloneChunks Flag indicating if the chunks should be cloned. For performance reasons,
     * its default value is `false`. If the original chunks are guaranteed not to change,
     * leave this flag as `false` to avoid unnecessary copying.
     *
     * @returns New `InputByteBuffer` instance with the given initial offset.
     *
     * @note This method is useful if you want to read some data from a specific index.
     */
    createCopyWithOffset(initialOffset, cloneChunks = false) {
        return new InputByteBuffer(this.chunks, cloneChunks, initialOffset);
    }
    /**
     * Gets the current offset in the buffer for reading.
     *
     * @returns Current offset in the buffer for reading.
     */
    get currentOffset() {
        return this.offset;
    }
    /**
     * Gets the capacity of the buffer.
     *
     * @returns Capacity of the buffer.
     */
    get capacity() {
        return this.chunks.length * byte_buffer/* ByteBuffer */.$.CHUNK_SIZE;
    }
    /**
     * Gets the chunks of the buffer.
     *
     * @returns Chunks of the buffer.
     */
    getChunks() {
        return this.chunks;
    }
}




/***/ }),

/***/ 36765:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   F: () => (/* binding */ isChromium)
/* harmony export */ });
/*
 * AGTree v3.1.3 (build date: Tue, 29 Apr 2025 12:25:03 GMT)
 * (c) 2025 Adguard Software Ltd.
 * Released under the MIT license
 * https://github.com/AdguardTeam/tsurlfilter/tree/master/packages/agtree#readme
 */
/**
 * A simple function to check if the current browser is Chromium-based.
 *
 * @returns `true` if the current browser is Chromium-based, `false` otherwise.
 * @see {@link https://stackoverflow.com/a/62797156}
 */
const isChromium = () => {
    return typeof window !== 'undefined'
        && (Object.prototype.hasOwnProperty.call(window, 'chrome')
            || (typeof window.navigator !== 'undefined'
                && /chrome/i.test(window.navigator.userAgent)));
};




/***/ }),

/***/ 31529:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Qj: () => (/* binding */ QuoteUtils),
/* harmony export */   XA: () => (/* binding */ QuoteType),
/* harmony export */   iO: () => (/* binding */ QUOTE_SET)
/* harmony export */ });
/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(27895);
/*
 * AGTree v3.1.3 (build date: Tue, 29 Apr 2025 12:25:03 GMT)
 * (c) 2025 Adguard Software Ltd.
 * Released under the MIT license
 * https://github.com/AdguardTeam/tsurlfilter/tree/master/packages/agtree#readme
 */


/**
 * @file Utility functions for working with quotes
 */
/**
 * Set of all possible quote characters supported by the library
 */
const QUOTE_SET = new Set([
    _constants_js__WEBPACK_IMPORTED_MODULE_0__/* .SINGLE_QUOTE */ .ur,
    _constants_js__WEBPACK_IMPORTED_MODULE_0__/* .DOUBLE_QUOTE */ .fi,
    _constants_js__WEBPACK_IMPORTED_MODULE_0__/* .BACKTICK_QUOTE */ .w1,
]);
/**
 * Possible quote types for scriptlet parameters
 */
const QuoteType = {
    /**
     * No quotes at all
     */
    None: 'none',
    /**
     * Single quotes (`'`)
     */
    Single: 'single',
    /**
     * Double quotes (`"`)
     */
    Double: 'double',
    /**
     * Backtick quotes (`` ` ``)
     */
    Backtick: 'backtick',
};
/**
 * Utility functions for working with quotes
 */
class QuoteUtils {
    /**
     * Escape all unescaped occurrences of the character
     *
     * @param string String to escape
     * @param char Character to escape
     * @returns Escaped string
     */
    static escapeUnescapedOccurrences(string, char) {
        let result = _constants_js__WEBPACK_IMPORTED_MODULE_0__/* .EMPTY */ .wg;
        for (let i = 0; i < string.length; i += 1) {
            if (string[i] === char && (i === 0 || string[i - 1] !== _constants_js__WEBPACK_IMPORTED_MODULE_0__/* .ESCAPE_CHARACTER */ .Kx)) {
                result += _constants_js__WEBPACK_IMPORTED_MODULE_0__/* .ESCAPE_CHARACTER */ .Kx;
            }
            result += string[i];
        }
        return result;
    }
    /**
     * Unescape all single escaped occurrences of the character
     *
     * @param string String to unescape
     * @param char Character to unescape
     * @returns Unescaped string
     */
    static unescapeSingleEscapedOccurrences(string, char) {
        let result = _constants_js__WEBPACK_IMPORTED_MODULE_0__/* .EMPTY */ .wg;
        for (let i = 0; i < string.length; i += 1) {
            if (string[i] === char
                && string[i - 1] === _constants_js__WEBPACK_IMPORTED_MODULE_0__/* .ESCAPE_CHARACTER */ .Kx
                && (i === 1 || string[i - 2] !== _constants_js__WEBPACK_IMPORTED_MODULE_0__/* .ESCAPE_CHARACTER */ .Kx)) {
                result = result.slice(0, -1);
            }
            result += string[i];
        }
        return result;
    }
    /**
     * Get quote type of the string
     *
     * @param string String to check
     * @returns Quote type of the string
     */
    static getStringQuoteType(string) {
        // Don't check 1-character strings to avoid false positives
        if (string.length > 1) {
            if (string.startsWith(_constants_js__WEBPACK_IMPORTED_MODULE_0__/* .SINGLE_QUOTE */ .ur) && string.endsWith(_constants_js__WEBPACK_IMPORTED_MODULE_0__/* .SINGLE_QUOTE */ .ur)) {
                return QuoteType.Single;
            }
            if (string.startsWith(_constants_js__WEBPACK_IMPORTED_MODULE_0__/* .DOUBLE_QUOTE */ .fi) && string.endsWith(_constants_js__WEBPACK_IMPORTED_MODULE_0__/* .DOUBLE_QUOTE */ .fi)) {
                return QuoteType.Double;
            }
            if (string.startsWith(_constants_js__WEBPACK_IMPORTED_MODULE_0__/* .BACKTICK_QUOTE */ .w1) && string.endsWith(_constants_js__WEBPACK_IMPORTED_MODULE_0__/* .BACKTICK_QUOTE */ .w1)) {
                return QuoteType.Backtick;
            }
        }
        return QuoteType.None;
    }
    /**
     * Set quote type of the string
     *
     * @param string String to set quote type of
     * @param quoteType Quote type to set
     * @returns String with the specified quote type
     */
    static setStringQuoteType(string, quoteType) {
        const actualQuoteType = QuoteUtils.getStringQuoteType(string);
        switch (quoteType) {
            case QuoteType.None:
                if (actualQuoteType === QuoteType.Single) {
                    return QuoteUtils.escapeUnescapedOccurrences(string.slice(1, -1), _constants_js__WEBPACK_IMPORTED_MODULE_0__/* .SINGLE_QUOTE */ .ur);
                }
                if (actualQuoteType === QuoteType.Double) {
                    return QuoteUtils.escapeUnescapedOccurrences(string.slice(1, -1), _constants_js__WEBPACK_IMPORTED_MODULE_0__/* .DOUBLE_QUOTE */ .fi);
                }
                if (actualQuoteType === QuoteType.Backtick) {
                    return QuoteUtils.escapeUnescapedOccurrences(string.slice(1, -1), _constants_js__WEBPACK_IMPORTED_MODULE_0__/* .BACKTICK_QUOTE */ .w1);
                }
                return string;
            case QuoteType.Single:
                if (actualQuoteType === QuoteType.None) {
                    return _constants_js__WEBPACK_IMPORTED_MODULE_0__/* .SINGLE_QUOTE */ .ur + QuoteUtils.escapeUnescapedOccurrences(string, _constants_js__WEBPACK_IMPORTED_MODULE_0__/* .SINGLE_QUOTE */ .ur) + _constants_js__WEBPACK_IMPORTED_MODULE_0__/* .SINGLE_QUOTE */ .ur;
                }
                if (actualQuoteType === QuoteType.Double) {
                    return _constants_js__WEBPACK_IMPORTED_MODULE_0__/* .SINGLE_QUOTE */ .ur
                        + QuoteUtils.escapeUnescapedOccurrences(QuoteUtils.unescapeSingleEscapedOccurrences(string.slice(1, -1), _constants_js__WEBPACK_IMPORTED_MODULE_0__/* .DOUBLE_QUOTE */ .fi), _constants_js__WEBPACK_IMPORTED_MODULE_0__/* .SINGLE_QUOTE */ .ur) + _constants_js__WEBPACK_IMPORTED_MODULE_0__/* .SINGLE_QUOTE */ .ur;
                }
                if (actualQuoteType === QuoteType.Backtick) {
                    return _constants_js__WEBPACK_IMPORTED_MODULE_0__/* .SINGLE_QUOTE */ .ur
                        + QuoteUtils.escapeUnescapedOccurrences(QuoteUtils.unescapeSingleEscapedOccurrences(string.slice(1, -1), _constants_js__WEBPACK_IMPORTED_MODULE_0__/* .BACKTICK_QUOTE */ .w1), _constants_js__WEBPACK_IMPORTED_MODULE_0__/* .SINGLE_QUOTE */ .ur) + _constants_js__WEBPACK_IMPORTED_MODULE_0__/* .SINGLE_QUOTE */ .ur;
                }
                return string;
            case QuoteType.Double:
                if (actualQuoteType === QuoteType.None) {
                    return _constants_js__WEBPACK_IMPORTED_MODULE_0__/* .DOUBLE_QUOTE */ .fi + QuoteUtils.escapeUnescapedOccurrences(string, _constants_js__WEBPACK_IMPORTED_MODULE_0__/* .DOUBLE_QUOTE */ .fi) + _constants_js__WEBPACK_IMPORTED_MODULE_0__/* .DOUBLE_QUOTE */ .fi;
                }
                if (actualQuoteType !== QuoteType.Double) {
                    // eslint-disable-next-line max-len
                    return _constants_js__WEBPACK_IMPORTED_MODULE_0__/* .DOUBLE_QUOTE */ .fi
                        + QuoteUtils.escapeUnescapedOccurrences(QuoteUtils.unescapeSingleEscapedOccurrences(string.slice(1, -1), _constants_js__WEBPACK_IMPORTED_MODULE_0__/* .SINGLE_QUOTE */ .ur), _constants_js__WEBPACK_IMPORTED_MODULE_0__/* .DOUBLE_QUOTE */ .fi) + _constants_js__WEBPACK_IMPORTED_MODULE_0__/* .DOUBLE_QUOTE */ .fi;
                }
                return string;
            case QuoteType.Backtick:
                if (actualQuoteType === QuoteType.None) {
                    // eslint-disable-next-line max-len
                    return _constants_js__WEBPACK_IMPORTED_MODULE_0__/* .BACKTICK_QUOTE */ .w1 + QuoteUtils.escapeUnescapedOccurrences(string, _constants_js__WEBPACK_IMPORTED_MODULE_0__/* .BACKTICK_QUOTE */ .w1) + _constants_js__WEBPACK_IMPORTED_MODULE_0__/* .BACKTICK_QUOTE */ .w1;
                }
                if (actualQuoteType !== QuoteType.Backtick) {
                    // eslint-disable-next-line max-len
                    return _constants_js__WEBPACK_IMPORTED_MODULE_0__/* .BACKTICK_QUOTE */ .w1
                        + QuoteUtils.escapeUnescapedOccurrences(QuoteUtils.unescapeSingleEscapedOccurrences(string.slice(1, -1), _constants_js__WEBPACK_IMPORTED_MODULE_0__/* .SINGLE_QUOTE */ .ur), _constants_js__WEBPACK_IMPORTED_MODULE_0__/* .BACKTICK_QUOTE */ .w1) + _constants_js__WEBPACK_IMPORTED_MODULE_0__/* .BACKTICK_QUOTE */ .w1;
                }
                return string;
            default:
                return string;
        }
    }
    /**
     * Removes bounding quotes from a string, if any
     *
     * @param string Input string
     * @returns String without quotes
     */
    static removeQuotes(string) {
        if (
        // We should check for string length to avoid false positives
        string.length > 1
            && (string[0] === _constants_js__WEBPACK_IMPORTED_MODULE_0__/* .SINGLE_QUOTE */ .ur || string[0] === _constants_js__WEBPACK_IMPORTED_MODULE_0__/* .DOUBLE_QUOTE */ .fi || string[0] === _constants_js__WEBPACK_IMPORTED_MODULE_0__/* .BACKTICK_QUOTE */ .w1)
            && string[0] === string[string.length - 1]) {
            return string.slice(1, -1);
        }
        return string;
    }
    /**
     * Removes bounding quotes from a string, if any, and unescapes the escaped quotes,
     * like transforming `'abc\'def'` to `abc'def`.
     *
     * @param string Input string
     * @returns String without quotes
     */
    static removeQuotesAndUnescape(string) {
        if (
        // We should check for string length to avoid false positives
        string.length > 1
            && (string[0] === _constants_js__WEBPACK_IMPORTED_MODULE_0__/* .SINGLE_QUOTE */ .ur || string[0] === _constants_js__WEBPACK_IMPORTED_MODULE_0__/* .DOUBLE_QUOTE */ .fi || string[0] === _constants_js__WEBPACK_IMPORTED_MODULE_0__/* .BACKTICK_QUOTE */ .w1)
            && string[0] === string[string.length - 1]) {
            return QuoteUtils.unescapeSingleEscapedOccurrences(string.slice(1, -1), string[0]);
        }
        return string;
    }
    /**
     * Wraps given `strings` with `quote` (defaults to single quote `'`)
     * and joins them with `separator` (defaults to comma+space `, `).
     *
     * @param strings Strings to quote and join.
     * @param quoteType Quote to use.
     * @param separator Separator to use.
     *
     * @returns String with joined items.
     *
     * @example
     * ['abc', 'def']: strings[]  ->  "'abc', 'def'": string
     */
    static quoteAndJoinStrings(strings, quoteType = QuoteType.Single, separator = `${_constants_js__WEBPACK_IMPORTED_MODULE_0__/* .COMMA */ .KE}${_constants_js__WEBPACK_IMPORTED_MODULE_0__/* .SPACE */ .t6}`) {
        return strings
            .map((s) => QuoteUtils.setStringQuoteType(s, quoteType))
            .join(separator);
    }
}




/***/ }),

/***/ 38949:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   $x: () => (/* binding */ StringUtils),
/* harmony export */   E0: () => (/* binding */ DOUBLE_QUOTE_MARKER)
/* harmony export */ });
/* unused harmony export SINGLE_QUOTE_MARKER */
/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(27895);
/*
 * AGTree v3.1.3 (build date: Tue, 29 Apr 2025 12:25:03 GMT)
 * (c) 2025 Adguard Software Ltd.
 * Released under the MIT license
 * https://github.com/AdguardTeam/tsurlfilter/tree/master/packages/agtree#readme
 */


/**
 * @file Utility functions for string manipulation.
 */
const SINGLE_QUOTE_MARKER = "'";
const DOUBLE_QUOTE_MARKER = '"';
/**
 * Utility functions for string manipulation.
 */
class StringUtils {
    /**
     * Finds the first occurrence of a character that:
     * - isn't preceded by an escape character
     *
     * @param pattern - Source pattern
     * @param searchedCharacter - Searched character
     * @param start - Start index
     * @param escapeCharacter - Escape character, \ by default
     * @param end - End index (excluded)
     * @returns Index or -1 if the character not found
     */
    static findNextUnescapedCharacter(pattern, searchedCharacter, start = 0, escapeCharacter = _constants_js__WEBPACK_IMPORTED_MODULE_0__/* .ESCAPE_CHARACTER */ .Kx, end = pattern.length) {
        for (let i = start; i < end; i += 1) {
            // The searched character cannot be preceded by an escape
            if (pattern[i] === searchedCharacter && pattern[i - 1] !== escapeCharacter) {
                return i;
            }
        }
        return -1;
    }
    /**
     * Finds the first occurrence in backward direction of a character that isn't preceded by an escape character.
     *
     * @param pattern - Source pattern
     * @param searchedCharacter - Searched character
     * @param start - Start index
     * @param escapeCharacter - Escape character, \ by default
     * @param end - End index (Included)
     * @returns Index or -1 if the character not found
     */
    static findNextUnescapedCharacterBackwards(pattern, searchedCharacter, start = pattern.length - 1, escapeCharacter = _constants_js__WEBPACK_IMPORTED_MODULE_0__/* .ESCAPE_CHARACTER */ .Kx, end = 0) {
        for (let i = start; i >= end; i -= 1) {
            // The searched character cannot be preceded by an escape
            if (pattern[i] === searchedCharacter && pattern[i - 1] !== escapeCharacter) {
                return i;
            }
        }
        return -1;
    }
    /**
     * Finds the last occurrence of a character that:
     * - isn't preceded by an escape character
     *
     * @param pattern - Source pattern
     * @param searchedCharacter - Searched character
     * @param escapeCharacter - Escape character, \ by default
     * @returns Index or -1 if the character not found
     */
    static findLastUnescapedCharacter(pattern, searchedCharacter, escapeCharacter = _constants_js__WEBPACK_IMPORTED_MODULE_0__/* .ESCAPE_CHARACTER */ .Kx) {
        for (let i = pattern.length - 1; i >= 0; i -= 1) {
            // The searched character cannot be preceded by an escape
            if (pattern[i] === searchedCharacter && pattern[i - 1] !== escapeCharacter) {
                return i;
            }
        }
        return -1;
    }
    /**
     * Finds the next occurrence of a character that:
     * - isn't preceded by an escape character
     * - isn't followed by the specified character
     *
     * @param pattern - Source pattern
     * @param start - Start index
     * @param searchedCharacter - Searched character
     * @param notFollowedBy - Searched character not followed by this character
     * @param escapeCharacter - Escape character, \ by default
     * @returns Index or -1 if the character not found
     */
    static findNextUnescapedCharacterThatNotFollowedBy(pattern, start, searchedCharacter, notFollowedBy, escapeCharacter = _constants_js__WEBPACK_IMPORTED_MODULE_0__/* .ESCAPE_CHARACTER */ .Kx) {
        for (let i = start; i < pattern.length; i += 1) {
            // The searched character cannot be preceded by an escape
            if (pattern[i] === searchedCharacter
                && pattern[i + 1] !== notFollowedBy
                && pattern[i - 1] !== escapeCharacter) {
                return i;
            }
        }
        return -1;
    }
    /**
     * Finds the last occurrence of a character that:
     * - isn't preceded by an escape character
     * - isn't followed by the specified character
     *
     * @param pattern - Source pattern
     * @param searchedCharacter - Searched character
     * @param notFollowedBy - Searched character not followed by this character
     * @param escapeCharacter - Escape character, \ by default
     * @returns Index or -1 if the character not found
     */
    static findLastUnescapedCharacterThatNotFollowedBy(pattern, searchedCharacter, notFollowedBy, escapeCharacter = _constants_js__WEBPACK_IMPORTED_MODULE_0__/* .ESCAPE_CHARACTER */ .Kx) {
        for (let i = pattern.length - 1; i >= 0; i -= 1) {
            // The searched character cannot be preceded by an escape
            if (pattern[i] === searchedCharacter
                && pattern[i + 1] !== notFollowedBy
                && pattern[i - 1] !== escapeCharacter) {
                return i;
            }
        }
        return -1;
    }
    /**
     * Finds the next occurrence of a character that:
     * - isn't part of any string literal ('literal' or "literal")
     * - isn't part of any RegExp expression (/regexp/)
     *
     * @param pattern - Source pattern
     * @param searchedCharacter - Searched character
     * @param start - Start index
     * @returns Index or -1 if the character not found
     */
    static findUnescapedNonStringNonRegexChar(pattern, searchedCharacter, start = 0) {
        let open = null;
        for (let i = start; i < pattern.length; i += 1) {
            if ((pattern[i] === SINGLE_QUOTE_MARKER
                || pattern[i] === DOUBLE_QUOTE_MARKER
                || pattern[i] === _constants_js__WEBPACK_IMPORTED_MODULE_0__/* .REGEX_MARKER */ .Vb)
                && pattern[i - 1] !== _constants_js__WEBPACK_IMPORTED_MODULE_0__/* .ESCAPE_CHARACTER */ .Kx) {
                if (open === pattern[i]) {
                    open = null;
                }
                else if (open === null) {
                    open = pattern[i];
                }
            }
            else if (open === null && pattern[i] === searchedCharacter && pattern[i - 1] !== _constants_js__WEBPACK_IMPORTED_MODULE_0__/* .ESCAPE_CHARACTER */ .Kx) {
                return i;
            }
        }
        return -1;
    }
    /**
     * Finds the next occurrence of a character that:
     * - isn't part of any string literal ('literal' or "literal")
     * - isn't preceded by an escape character
     *
     * @param pattern - Source pattern
     * @param searchedCharacter - Searched character
     * @param start - Start index
     * @param escapeCharacter - Escape character, \ by default
     * @returns Index or -1 if the character not found
     */
    static findNextUnquotedUnescapedCharacter(pattern, searchedCharacter, start = 0, escapeCharacter = _constants_js__WEBPACK_IMPORTED_MODULE_0__/* .ESCAPE_CHARACTER */ .Kx) {
        let openQuote = null;
        for (let i = start; i < pattern.length; i += 1) {
            // Unescaped ' or "
            if ((pattern[i] === SINGLE_QUOTE_MARKER || pattern[i] === DOUBLE_QUOTE_MARKER)
                && pattern[i - 1] !== escapeCharacter) {
                if (!openQuote)
                    openQuote = pattern[i];
                else if (openQuote === pattern[i])
                    openQuote = null;
            }
            else if (pattern[i] === searchedCharacter && pattern[i - 1] !== escapeCharacter) {
                // Unescaped character
                if (!openQuote) {
                    return i;
                }
            }
        }
        return -1;
    }
    /**
     * Finds the next occurrence of a character that:
     * - isn't "bracketed"
     * - isn't preceded by an escape character
     *
     * @param pattern - Source pattern
     * @param searchedCharacter - Searched character
     * @param start - Start index
     * @param escapeCharacter - Escape character, \ by default
     * @param openBracket - Open bracket, ( by default
     * @param closeBracket - Close bracket, ( by default
     * @throws If the opening and closing brackets are the same
     * @returns Index or -1 if the character not found
     */
    static findNextNotBracketedUnescapedCharacter(pattern, searchedCharacter, start = 0, escapeCharacter = _constants_js__WEBPACK_IMPORTED_MODULE_0__/* .ESCAPE_CHARACTER */ .Kx, openBracket = '(', closeBracket = ')') {
        if (openBracket === closeBracket) {
            throw new Error('Open and close bracket cannot be the same');
        }
        let depth = 0;
        for (let i = start; i < pattern.length; i += 1) {
            if (pattern[i] === openBracket) {
                depth += 1;
            }
            else if (pattern[i] === closeBracket) {
                depth -= 1;
            }
            else if (depth < 1 && pattern[i] === searchedCharacter && pattern[i - 1] !== escapeCharacter) {
                return i;
            }
        }
        return -1;
    }
    /**
     * Splits the source pattern along characters that:
     * - isn't part of any string literal ('literal' or "literal")
     * - isn't preceded by an escape character
     *
     * @param pattern - Source pattern
     * @param delimeterCharacter - Delimeter character
     * @returns Splitted string
     */
    static splitStringByUnquotedUnescapedCharacter(pattern, delimeterCharacter) {
        const parts = [];
        let delimeterIndex = -1;
        do {
            const prevDelimeterIndex = delimeterIndex;
            delimeterIndex = StringUtils.findNextUnquotedUnescapedCharacter(pattern, delimeterCharacter, delimeterIndex + 1);
            if (delimeterIndex !== -1) {
                parts.push(pattern.substring(prevDelimeterIndex + 1, delimeterIndex));
            }
            else {
                parts.push(pattern.substring(prevDelimeterIndex + 1, pattern.length));
            }
        } while (delimeterIndex !== -1);
        return parts;
    }
    /**
     * Splits the source pattern along characters that:
     * - isn't part of any string literal ('literal' or "literal")
     * - isn't part of any RegExp expression (/regexp/)
     * - isn't preceded by an escape character
     *
     * @param pattern - Source pattern
     * @param delimeterCharacter - Delimeter character
     * @returns Splitted string
     */
    static splitStringByUnescapedNonStringNonRegexChar(pattern, delimeterCharacter) {
        const parts = [];
        let delimeterIndex = -1;
        do {
            const prevDelimeterIndex = delimeterIndex;
            delimeterIndex = StringUtils.findUnescapedNonStringNonRegexChar(pattern, delimeterCharacter, delimeterIndex + 1);
            if (delimeterIndex !== -1) {
                parts.push(pattern.substring(prevDelimeterIndex + 1, delimeterIndex));
            }
            else {
                parts.push(pattern.substring(prevDelimeterIndex + 1, pattern.length));
            }
        } while (delimeterIndex !== -1);
        return parts;
    }
    /**
     * Splits the source pattern along characters that:
     * - isn't preceded by an escape character
     *
     * @param pattern - Source pattern
     * @param delimeterCharacter - Delimeter character
     * @returns Splitted string
     */
    static splitStringByUnescapedCharacter(pattern, delimeterCharacter) {
        const parts = [];
        let delimeterIndex = -1;
        do {
            const prevDelimeterIndex = delimeterIndex;
            delimeterIndex = StringUtils.findNextUnescapedCharacter(pattern, delimeterCharacter, delimeterIndex + 1);
            if (delimeterIndex !== -1) {
                parts.push(pattern.substring(prevDelimeterIndex + 1, delimeterIndex));
            }
            else {
                parts.push(pattern.substring(prevDelimeterIndex + 1, pattern.length));
            }
        } while (delimeterIndex !== -1);
        return parts;
    }
    /**
     * Determines whether the given character is a space or tab character.
     *
     * @param char - The character to check.
     * @returns true if the given character is a space or tab character, false otherwise.
     */
    static isWhitespace(char) {
        return char === _constants_js__WEBPACK_IMPORTED_MODULE_0__/* .SPACE */ .t6 || char === _constants_js__WEBPACK_IMPORTED_MODULE_0__/* .TAB */ .wn;
    }
    /**
     * Checks if the given character is a digit.
     *
     * @param char The character to check.
     * @returns `true` if the given character is a digit, `false` otherwise.
     */
    static isDigit(char) {
        return char >= _constants_js__WEBPACK_IMPORTED_MODULE_0__/* .NUMBER_0 */ .nC && char <= _constants_js__WEBPACK_IMPORTED_MODULE_0__/* .NUMBER_9 */ .g9;
    }
    /**
     * Checks if the given character is a small letter.
     *
     * @param char The character to check.
     * @returns `true` if the given character is a small letter, `false` otherwise.
     */
    static isSmallLetter(char) {
        return char >= _constants_js__WEBPACK_IMPORTED_MODULE_0__/* .SMALL_LETTER_A */ .H3 && char <= _constants_js__WEBPACK_IMPORTED_MODULE_0__/* .SMALL_LETTER_Z */ .AT;
    }
    /**
     * Checks if the given character is a capital letter.
     *
     * @param char The character to check.
     * @returns `true` if the given character is a capital letter, `false` otherwise.
     */
    static isCapitalLetter(char) {
        return char >= _constants_js__WEBPACK_IMPORTED_MODULE_0__/* .CAPITAL_LETTER_A */ .ot && char <= _constants_js__WEBPACK_IMPORTED_MODULE_0__/* .CAPITAL_LETTER_Z */ .hk;
    }
    /**
     * Checks if the given character is a letter (small or capital).
     *
     * @param char The character to check.
     * @returns `true` if the given character is a letter, `false` otherwise.
     */
    static isLetter(char) {
        return StringUtils.isSmallLetter(char) || StringUtils.isCapitalLetter(char);
    }
    /**
     * Checks if the given character is a letter or a digit.
     *
     * @param char Character to check
     * @returns `true` if the given character is a letter or a digit, `false` otherwise.
     */
    static isAlphaNumeric(char) {
        return StringUtils.isLetter(char) || StringUtils.isDigit(char);
    }
    /**
     * Searches for the first non-whitespace character in the source pattern.
     *
     * @param pattern - Source pattern
     * @param start - Start index
     * @returns Index or -1 if the character not found
     */
    static findFirstNonWhitespaceCharacter(pattern, start = 0) {
        for (let i = start; i < pattern.length; i += 1) {
            if (!StringUtils.isWhitespace(pattern[i])) {
                return i;
            }
        }
        return -1;
    }
    /**
     * Searches for the last non-whitespace character in the source pattern.
     *
     * @param pattern - Source pattern
     * @returns Index or -1 if the character not found
     */
    static findLastNonWhitespaceCharacter(pattern) {
        for (let i = pattern.length - 1; i >= 0; i -= 1) {
            if (!StringUtils.isWhitespace(pattern[i])) {
                return i;
            }
        }
        return -1;
    }
    /**
     * Finds the next whitespace character in the pattern.
     *
     * @param pattern Pattern to search in
     * @param start Start index
     * @returns Index of the next whitespace character or the length of the pattern if not found
     */
    static findNextWhitespaceCharacter(pattern, start = 0) {
        for (let i = start; i < pattern.length; i += 1) {
            if (StringUtils.isWhitespace(pattern[i])) {
                return i;
            }
        }
        return pattern.length;
    }
    /**
     * Escapes a specified character in the string.
     *
     * @param pattern - Input string
     * @param character - Character to escape
     * @param escapeCharacter - Escape character (optional)
     * @returns Escaped string
     */
    static escapeCharacter(pattern, character, escapeCharacter = _constants_js__WEBPACK_IMPORTED_MODULE_0__/* .ESCAPE_CHARACTER */ .Kx) {
        let result = _constants_js__WEBPACK_IMPORTED_MODULE_0__/* .EMPTY */ .wg;
        for (let i = 0; i < pattern.length; i += 1) {
            if (pattern[i] === character && pattern[i - 1] !== escapeCharacter) {
                result += escapeCharacter;
            }
            result += pattern[i];
        }
        return result;
    }
    /**
     * Searches for the next non-whitespace character in the source pattern.
     *
     * @param pattern Pattern to search
     * @param start Start index
     * @returns Index of the next non-whitespace character or the length of the pattern
     */
    static skipWS(pattern, start = 0) {
        let i = start;
        while (i < pattern.length && StringUtils.isWhitespace(pattern[i])) {
            i += 1;
        }
        return Math.min(i, pattern.length);
    }
    /**
     * Searches for the previous non-whitespace character in the source pattern.
     *
     * @param pattern Pattern to search
     * @param start Start index
     * @returns Index of the previous non-whitespace character or -1
     */
    static skipWSBack(pattern, start = pattern.length - 1) {
        let i = start;
        while (i >= 0 && StringUtils.isWhitespace(pattern[i])) {
            i -= 1;
        }
        return Math.max(i, -1);
    }
    /**
     * Checks if the given character is a new line character.
     *
     * @param char Character to check
     * @returns `true` if the given character is a new line character, `false` otherwise.
     */
    static isEOL(char) {
        return char === _constants_js__WEBPACK_IMPORTED_MODULE_0__.CR || char === _constants_js__WEBPACK_IMPORTED_MODULE_0__.LF || char === _constants_js__WEBPACK_IMPORTED_MODULE_0__.FF;
    }
    /**
     * Splits a string along newline characters.
     *
     * @param input - Input string
     * @returns Splitted string
     */
    static splitStringByNewLines(input) {
        return input.split(/\r?\n/);
    }
    /**
     * Splits a string by new lines and stores the new line type for each line
     *
     * @param input The input string to be split
     * @returns An array of tuples, where each tuple contains a line of the input string and its
     * corresponding new line type ("lf", "crlf", or "cr")
     */
    static splitStringByNewLinesEx(input) {
        // Array to store the tuples of line and new line type
        const result = [];
        let currentLine = _constants_js__WEBPACK_IMPORTED_MODULE_0__/* .EMPTY */ .wg;
        let newLineType = null;
        // Iterate over each character in the input string
        for (let i = 0; i < input.length; i += 1) {
            const char = input[i];
            if (char === _constants_js__WEBPACK_IMPORTED_MODULE_0__.CR) {
                if (input[i + 1] === _constants_js__WEBPACK_IMPORTED_MODULE_0__.LF) {
                    newLineType = 'crlf';
                    i += 1;
                }
                else {
                    newLineType = 'cr';
                }
                result.push([currentLine, newLineType]);
                currentLine = _constants_js__WEBPACK_IMPORTED_MODULE_0__/* .EMPTY */ .wg;
                newLineType = null;
            }
            else if (char === _constants_js__WEBPACK_IMPORTED_MODULE_0__.LF) {
                newLineType = 'lf';
                result.push([currentLine, newLineType]);
                currentLine = _constants_js__WEBPACK_IMPORTED_MODULE_0__/* .EMPTY */ .wg;
                newLineType = null;
            }
            else {
                currentLine += char;
            }
        }
        if (result.length === 0 || currentLine !== _constants_js__WEBPACK_IMPORTED_MODULE_0__/* .EMPTY */ .wg) {
            result.push([currentLine, newLineType]);
        }
        return result;
    }
    /**
     * Merges an array of tuples (line, newLineType) into a single string
     *
     * @param input The array of tuples to be merged
     * @returns A single string containing the lines and new line characters from the input array
     */
    static mergeStringByNewLines(input) {
        let result = _constants_js__WEBPACK_IMPORTED_MODULE_0__/* .EMPTY */ .wg;
        // Iterate over each tuple in the input array
        for (let i = 0; i < input.length; i += 1) {
            const [line, newLineType] = input[i];
            // Add the line to the result string
            result += line;
            // Add the appropriate new line character based on the newLineType
            if (newLineType !== null) {
                if (newLineType === 'crlf') {
                    result += _constants_js__WEBPACK_IMPORTED_MODULE_0__/* .CRLF */ .KT;
                }
                else if (newLineType === 'cr') {
                    result += _constants_js__WEBPACK_IMPORTED_MODULE_0__.CR;
                }
                else {
                    result += _constants_js__WEBPACK_IMPORTED_MODULE_0__.LF;
                }
            }
        }
        return result;
    }
    /**
     * Helper method to parse a raw string as a number
     *
     * @param raw Raw string to parse
     * @returns Parsed number
     * @throws If the raw string can't be parsed as a number
     */
    static parseNumber(raw) {
        const result = parseInt(raw, 10);
        if (Number.isNaN(result)) {
            throw new Error('Expected a number');
        }
        return result;
    }
    /**
     * Checks if the given value is a string.
     *
     * @param value Value to check
     * @returns `true` if the value is a string, `false` otherwise
     */
    static isString(value) {
        return typeof value === 'string';
    }
    /**
     * Escapes the given characters in the input string.
     *
     * @param input Input string
     * @param characters Characters to escape (by default, no characters are escaped)
     * @returns Escaped string
     */
    static escapeCharacters(input, characters = new Set()) {
        let result = _constants_js__WEBPACK_IMPORTED_MODULE_0__/* .EMPTY */ .wg;
        for (let i = 0; i < input.length; i += 1) {
            if (characters.has(input[i])) {
                result += _constants_js__WEBPACK_IMPORTED_MODULE_0__/* .ESCAPE_CHARACTER */ .Kx;
            }
            result += input[i];
        }
        return result;
    }
}




/***/ }),

/***/ 8123:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Kg: () => (/* binding */ isString),
/* harmony export */   b0: () => (/* binding */ isUndefined),
/* harmony export */   kZ: () => (/* binding */ isNull),
/* harmony export */   r_: () => (/* binding */ isArrayOfUint8Arrays)
/* harmony export */ });
/*
 * AGTree v3.1.3 (build date: Tue, 29 Apr 2025 12:25:03 GMT)
 * (c) 2025 Adguard Software Ltd.
 * Released under the MIT license
 * https://github.com/AdguardTeam/tsurlfilter/tree/master/packages/agtree#readme
 */
/**
 * Checks whether the given value is undefined.
 *
 * @param value Value to check.
 *
 * @returns `true` if the value is 'undefined', `false` otherwise.
 */
const isUndefined = (value) => {
    return typeof value === 'undefined';
};
/**
 * Checks whether the given value is null.
 *
 * @param value Value to check.
 *
 * @returns `true` if the value is 'null', `false` otherwise.
 */
const isNull = (value) => {
    return value === null;
};
/**
 * Checks whether the given value is a string.
 *
 * @param value Value to check.
 * @returns `true` if the value is a string, `false` otherwise.
 */
const isString = (value) => {
    return typeof value === 'string';
};
/**
 * Checks whether the given value is an array of Uint8Arrays.
 *
 * @param value Value to check.
 *
 * @returns True if the value type is an array of Uint8Arrays.
 */
const isArrayOfUint8Arrays = (value) => {
    return Array.isArray(value) && value.every((chunk) => chunk instanceof Uint8Array);
};




/***/ }),

/***/ 3030:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   e: () => (/* binding */ scriptlets)
/* harmony export */ });
function AmazonApstag(source, args) {
    var flag = "done";
    var uniqueIdentifier = source.uniqueId + source.name + "_" + (Array.isArray(args) ? args.join("_") : "");
    if (source.uniqueId) {
        if (Window.prototype.toString[uniqueIdentifier] === flag) {
            return;
        }
    }
    function AmazonApstag(source) {
        var apstagWrapper = {
            fetchBids(a, b) {
                if (typeof b === "function") {
                    b([]);
                }
            },
            init: noopFunc,
            setDisplayBids: noopFunc,
            targetingKeys: noopFunc
        };
        window.apstag = apstagWrapper;
        hit(source);
    }
    function hit(source) {
        var ADGUARD_PREFIX = "[AdGuard]";
        if (!source.verbose) {
            return;
        }
        try {
            var trace = console.trace.bind(console);
            var label = `${ADGUARD_PREFIX} `;
            if (source.engine === "corelibs") {
                label += source.ruleText;
            } else {
                if (source.domainName) {
                    label += `${source.domainName}`;
                }
                if (source.args) {
                    label += `#%#//scriptlet('${source.name}', '${source.args.join("', '")}')`;
                } else {
                    label += `#%#//scriptlet('${source.name}')`;
                }
            }
            if (trace) {
                trace(label);
            }
        } catch (e) {}
        if (typeof window.__debug === "function") {
            window.__debug(source);
        }
    }
    function noopFunc() {}
    var updatedArgs = args ? [].concat(source).concat(args) : [ source ];
    try {
        AmazonApstag.apply(this, updatedArgs);
        if (source.uniqueId) {
            Object.defineProperty(Window.prototype.toString, uniqueIdentifier, {
                value: flag,
                enumerable: false,
                writable: false,
                configurable: false
            });
        }
    } catch (e) {
        console.log(e);
    }
}

function DidomiLoader(source, args) {
    var flag = "done";
    var uniqueIdentifier = source.uniqueId + source.name + "_" + (Array.isArray(args) ? args.join("_") : "");
    if (source.uniqueId) {
        if (Window.prototype.toString[uniqueIdentifier] === flag) {
            return;
        }
    }
    function DidomiLoader(source) {
        function UserConsentStatusForVendorSubscribe() {}
        UserConsentStatusForVendorSubscribe.prototype.filter = function() {
            return new UserConsentStatusForVendorSubscribe;
        };
        UserConsentStatusForVendorSubscribe.prototype.subscribe = noopFunc;
        function UserConsentStatusForVendor() {}
        UserConsentStatusForVendor.prototype.first = function() {
            return new UserConsentStatusForVendorSubscribe;
        };
        UserConsentStatusForVendor.prototype.filter = function() {
            return new UserConsentStatusForVendorSubscribe;
        };
        UserConsentStatusForVendor.prototype.subscribe = noopFunc;
        var DidomiWrapper = {
            isConsentRequired: falseFunc,
            getUserConsentStatusForPurpose: trueFunc,
            getUserConsentStatus: trueFunc,
            getUserStatus: noopFunc,
            getRequiredPurposes: noopArray,
            getUserConsentStatusForVendor: trueFunc,
            Purposes: {
                Cookies: "cookies"
            },
            notice: {
                configure: noopFunc,
                hide: noopFunc,
                isVisible: falseFunc,
                show: noopFunc,
                showDataProcessing: trueFunc
            },
            isUserConsentStatusPartial: falseFunc,
            on() {
                return {
                    actions: {},
                    emitter: {},
                    services: {},
                    store: {}
                };
            },
            shouldConsentBeCollected: falseFunc,
            getUserConsentStatusForAll: noopFunc,
            getObservableOnUserConsentStatusForVendor() {
                return new UserConsentStatusForVendor;
            }
        };
        window.Didomi = DidomiWrapper;
        var didomiStateWrapper = {
            didomiExperimentId: "",
            didomiExperimentUserGroup: "",
            didomiGDPRApplies: 1,
            didomiIABConsent: "",
            didomiPurposesConsent: "",
            didomiPurposesConsentDenied: "",
            didomiPurposesConsentUnknown: "",
            didomiVendorsConsent: "",
            didomiVendorsConsentDenied: "",
            didomiVendorsConsentUnknown: "",
            didomiVendorsRawConsent: "",
            didomiVendorsRawConsentDenied: "",
            didomiVendorsRawConsentUnknown: ""
        };
        window.didomiState = didomiStateWrapper;
        var tcData = {
            eventStatus: "tcloaded",
            gdprApplies: false,
            listenerId: noopFunc,
            vendor: {
                consents: []
            },
            purpose: {
                consents: []
            }
        };
        var __tcfapiWrapper = function __tcfapiWrapper(command, version, callback) {
            if (typeof callback !== "function" || command === "removeEventListener") {
                return;
            }
            callback(tcData, true);
        };
        window.__tcfapi = __tcfapiWrapper;
        var didomiEventListenersWrapper = {
            stub: true,
            push: noopFunc
        };
        window.didomiEventListeners = didomiEventListenersWrapper;
        var didomiOnReadyWrapper = {
            stub: true,
            push(arg) {
                if (typeof arg !== "function") {
                    return;
                }
                if (document.readyState !== "complete") {
                    window.addEventListener("load", (function() {
                        setTimeout(arg(window.Didomi));
                    }));
                } else {
                    setTimeout(arg(window.Didomi));
                }
            }
        };
        window.didomiOnReady = window.didomiOnReady || didomiOnReadyWrapper;
        if (Array.isArray(window.didomiOnReady)) {
            window.didomiOnReady.forEach((function(arg) {
                if (typeof arg === "function") {
                    try {
                        setTimeout(arg(window.Didomi));
                    } catch (e) {}
                }
            }));
        }
        hit(source);
    }
    function hit(source) {
        var ADGUARD_PREFIX = "[AdGuard]";
        if (!source.verbose) {
            return;
        }
        try {
            var trace = console.trace.bind(console);
            var label = `${ADGUARD_PREFIX} `;
            if (source.engine === "corelibs") {
                label += source.ruleText;
            } else {
                if (source.domainName) {
                    label += `${source.domainName}`;
                }
                if (source.args) {
                    label += `#%#//scriptlet('${source.name}', '${source.args.join("', '")}')`;
                } else {
                    label += `#%#//scriptlet('${source.name}')`;
                }
            }
            if (trace) {
                trace(label);
            }
        } catch (e) {}
        if (typeof window.__debug === "function") {
            window.__debug(source);
        }
    }
    function noopFunc() {}
    function noopArray() {
        return [];
    }
    function trueFunc() {
        return true;
    }
    function falseFunc() {
        return false;
    }
    var updatedArgs = args ? [].concat(source).concat(args) : [ source ];
    try {
        DidomiLoader.apply(this, updatedArgs);
        if (source.uniqueId) {
            Object.defineProperty(Window.prototype.toString, uniqueIdentifier, {
                value: flag,
                enumerable: false,
                writable: false,
                configurable: false
            });
        }
    } catch (e) {
        console.log(e);
    }
}

function Fingerprintjs2(source, args) {
    var flag = "done";
    var uniqueIdentifier = source.uniqueId + source.name + "_" + (Array.isArray(args) ? args.join("_") : "");
    if (source.uniqueId) {
        if (Window.prototype.toString[uniqueIdentifier] === flag) {
            return;
        }
    }
    function Fingerprintjs2(source) {
        var browserId = "";
        for (var i = 0; i < 8; i += 1) {
            browserId += (Math.random() * 65536 + 4096).toString(16).slice(-4);
        }
        var Fingerprint2 = function Fingerprint2() {};
        Fingerprint2.get = function(options, callback) {
            if (!callback) {
                callback = options;
            }
            setTimeout((function() {
                if (callback) {
                    callback(browserId, []);
                }
            }), 1);
        };
        Fingerprint2.prototype = {
            get: Fingerprint2.get
        };
        window.Fingerprint2 = Fingerprint2;
        hit(source);
    }
    function hit(source) {
        var ADGUARD_PREFIX = "[AdGuard]";
        if (!source.verbose) {
            return;
        }
        try {
            var trace = console.trace.bind(console);
            var label = `${ADGUARD_PREFIX} `;
            if (source.engine === "corelibs") {
                label += source.ruleText;
            } else {
                if (source.domainName) {
                    label += `${source.domainName}`;
                }
                if (source.args) {
                    label += `#%#//scriptlet('${source.name}', '${source.args.join("', '")}')`;
                } else {
                    label += `#%#//scriptlet('${source.name}')`;
                }
            }
            if (trace) {
                trace(label);
            }
        } catch (e) {}
        if (typeof window.__debug === "function") {
            window.__debug(source);
        }
    }
    var updatedArgs = args ? [].concat(source).concat(args) : [ source ];
    try {
        Fingerprintjs2.apply(this, updatedArgs);
        if (source.uniqueId) {
            Object.defineProperty(Window.prototype.toString, uniqueIdentifier, {
                value: flag,
                enumerable: false,
                writable: false,
                configurable: false
            });
        }
    } catch (e) {
        console.log(e);
    }
}

function Fingerprintjs3(source, args) {
    var flag = "done";
    var uniqueIdentifier = source.uniqueId + source.name + "_" + (Array.isArray(args) ? args.join("_") : "");
    if (source.uniqueId) {
        if (Window.prototype.toString[uniqueIdentifier] === flag) {
            return;
        }
    }
    function Fingerprintjs3(source) {
        var visitorId = function() {
            var id = "";
            for (var i = 0; i < 8; i += 1) {
                id += (Math.random() * 65536 + 4096).toString(16).slice(-4);
            }
            return id;
        }();
        var FingerprintJS = function FingerprintJS() {};
        FingerprintJS.prototype = {
            load() {
                return Promise.resolve(new FingerprintJS);
            },
            get() {
                return Promise.resolve({
                    visitorId: visitorId
                });
            },
            hashComponents: noopStr
        };
        window.FingerprintJS = new FingerprintJS;
        hit(source);
    }
    function hit(source) {
        var ADGUARD_PREFIX = "[AdGuard]";
        if (!source.verbose) {
            return;
        }
        try {
            var trace = console.trace.bind(console);
            var label = `${ADGUARD_PREFIX} `;
            if (source.engine === "corelibs") {
                label += source.ruleText;
            } else {
                if (source.domainName) {
                    label += `${source.domainName}`;
                }
                if (source.args) {
                    label += `#%#//scriptlet('${source.name}', '${source.args.join("', '")}')`;
                } else {
                    label += `#%#//scriptlet('${source.name}')`;
                }
            }
            if (trace) {
                trace(label);
            }
        } catch (e) {}
        if (typeof window.__debug === "function") {
            window.__debug(source);
        }
    }
    function noopStr() {
        return "";
    }
    var updatedArgs = args ? [].concat(source).concat(args) : [ source ];
    try {
        Fingerprintjs3.apply(this, updatedArgs);
        if (source.uniqueId) {
            Object.defineProperty(Window.prototype.toString, uniqueIdentifier, {
                value: flag,
                enumerable: false,
                writable: false,
                configurable: false
            });
        }
    } catch (e) {
        console.log(e);
    }
}

function Gemius(source, args) {
    var flag = "done";
    var uniqueIdentifier = source.uniqueId + source.name + "_" + (Array.isArray(args) ? args.join("_") : "");
    if (source.uniqueId) {
        if (Window.prototype.toString[uniqueIdentifier] === flag) {
            return;
        }
    }
    function Gemius(source) {
        var GemiusPlayer = function GemiusPlayer() {};
        GemiusPlayer.prototype = {
            setVideoObject: noopFunc,
            newProgram: noopFunc,
            programEvent: noopFunc,
            newAd: noopFunc,
            adEvent: noopFunc
        };
        window.GemiusPlayer = GemiusPlayer;
        hit(source);
    }
    function hit(source) {
        var ADGUARD_PREFIX = "[AdGuard]";
        if (!source.verbose) {
            return;
        }
        try {
            var trace = console.trace.bind(console);
            var label = `${ADGUARD_PREFIX} `;
            if (source.engine === "corelibs") {
                label += source.ruleText;
            } else {
                if (source.domainName) {
                    label += `${source.domainName}`;
                }
                if (source.args) {
                    label += `#%#//scriptlet('${source.name}', '${source.args.join("', '")}')`;
                } else {
                    label += `#%#//scriptlet('${source.name}')`;
                }
            }
            if (trace) {
                trace(label);
            }
        } catch (e) {}
        if (typeof window.__debug === "function") {
            window.__debug(source);
        }
    }
    function noopFunc() {}
    var updatedArgs = args ? [].concat(source).concat(args) : [ source ];
    try {
        Gemius.apply(this, updatedArgs);
        if (source.uniqueId) {
            Object.defineProperty(Window.prototype.toString, uniqueIdentifier, {
                value: flag,
                enumerable: false,
                writable: false,
                configurable: false
            });
        }
    } catch (e) {
        console.log(e);
    }
}

function GoogleAnalytics(source, args) {
    var flag = "done";
    var uniqueIdentifier = source.uniqueId + source.name + "_" + (Array.isArray(args) ? args.join("_") : "");
    if (source.uniqueId) {
        if (Window.prototype.toString[uniqueIdentifier] === flag) {
            return;
        }
    }
    function GoogleAnalytics(source) {
        var _window$googleAnalyti;
        var Tracker = function Tracker() {};
        var proto = Tracker.prototype;
        proto.get = noopFunc;
        proto.set = noopFunc;
        proto.send = noopFunc;
        var googleAnalyticsName = window.GoogleAnalyticsObject || "ga";
        var queue = (_window$googleAnalyti = window[googleAnalyticsName]) === null || _window$googleAnalyti === void 0 ? void 0 : _window$googleAnalyti.q;
        function ga(a) {
            var len = arguments.length;
            if (len === 0) {
                return;
            }
            var lastArg = arguments[len - 1];
            var replacer;
            if (lastArg instanceof Object && lastArg !== null && typeof lastArg.hitCallback === "function") {
                replacer = lastArg.hitCallback;
            } else if (typeof lastArg === "function") {
                replacer = function replacer() {
                    lastArg(ga.create());
                };
            }
            try {
                setTimeout(replacer, 1);
            } catch (ex) {}
        }
        ga.create = function() {
            return new Tracker;
        };
        ga.getByName = function() {
            return new Tracker;
        };
        ga.getAll = function() {
            return [ new Tracker ];
        };
        ga.remove = noopFunc;
        ga.loaded = true;
        window[googleAnalyticsName] = ga;
        if (Array.isArray(queue)) {
            var push = function push(arg) {
                ga(...arg);
            };
            queue.push = push;
            queue.forEach(push);
        }
        var {dataLayer: dataLayer, google_optimize: google_optimize} = window;
        if (dataLayer instanceof Object === false) {
            return;
        }
        if (dataLayer.hide instanceof Object && typeof dataLayer.hide.end === "function") {
            dataLayer.hide.end();
        }
        var handleCallback = function handleCallback(dataObj, funcName) {
            if (dataObj && typeof dataObj[funcName] === "function") {
                setTimeout(dataObj[funcName]);
            }
        };
        if (typeof dataLayer.push === "function") {
            dataLayer.push = function(data) {
                if (data instanceof Object) {
                    handleCallback(data, "eventCallback");
                    for (var key in data) {
                        handleCallback(data[key], "event_callback");
                    }
                    if (!data.hasOwnProperty("eventCallback") && !data.hasOwnProperty("eventCallback")) {
                        [].push.call(window.dataLayer, data);
                    }
                }
                if (Array.isArray(data)) {
                    data.forEach((function(arg) {
                        handleCallback(arg, "callback");
                    }));
                }
                return noopFunc;
            };
        }
        if (google_optimize instanceof Object && typeof google_optimize.get === "function") {
            var googleOptimizeWrapper = {
                get: noopFunc
            };
            window.google_optimize = googleOptimizeWrapper;
        }
        hit(source);
    }
    function hit(source) {
        var ADGUARD_PREFIX = "[AdGuard]";
        if (!source.verbose) {
            return;
        }
        try {
            var trace = console.trace.bind(console);
            var label = `${ADGUARD_PREFIX} `;
            if (source.engine === "corelibs") {
                label += source.ruleText;
            } else {
                if (source.domainName) {
                    label += `${source.domainName}`;
                }
                if (source.args) {
                    label += `#%#//scriptlet('${source.name}', '${source.args.join("', '")}')`;
                } else {
                    label += `#%#//scriptlet('${source.name}')`;
                }
            }
            if (trace) {
                trace(label);
            }
        } catch (e) {}
        if (typeof window.__debug === "function") {
            window.__debug(source);
        }
    }
    function noopFunc() {}
    var updatedArgs = args ? [].concat(source).concat(args) : [ source ];
    try {
        GoogleAnalytics.apply(this, updatedArgs);
        if (source.uniqueId) {
            Object.defineProperty(Window.prototype.toString, uniqueIdentifier, {
                value: flag,
                enumerable: false,
                writable: false,
                configurable: false
            });
        }
    } catch (e) {
        console.log(e);
    }
}

function GoogleAnalyticsGa(source, args) {
    var flag = "done";
    var uniqueIdentifier = source.uniqueId + source.name + "_" + (Array.isArray(args) ? args.join("_") : "");
    if (source.uniqueId) {
        if (Window.prototype.toString[uniqueIdentifier] === flag) {
            return;
        }
    }
    function GoogleAnalyticsGa(source) {
        function Gaq() {}
        Gaq.prototype.Na = noopFunc;
        Gaq.prototype.O = noopFunc;
        Gaq.prototype.Sa = noopFunc;
        Gaq.prototype.Ta = noopFunc;
        Gaq.prototype.Va = noopFunc;
        Gaq.prototype._createAsyncTracker = noopFunc;
        Gaq.prototype._getAsyncTracker = noopFunc;
        Gaq.prototype._getPlugin = noopFunc;
        Gaq.prototype.push = function(data) {
            if (typeof data === "function") {
                data();
                return;
            }
            if (Array.isArray(data) === false) {
                return;
            }
            if (typeof data[0] === "string" && /(^|\.)_link$/.test(data[0]) && typeof data[1] === "string") {
                window.location.assign(data[1]);
            }
            if (data[0] === "_set" && data[1] === "hitCallback" && typeof data[2] === "function") {
                data[2]();
            }
        };
        var gaq = new Gaq;
        var asyncTrackers = window._gaq || [];
        if (Array.isArray(asyncTrackers)) {
            while (asyncTrackers[0]) {
                gaq.push(asyncTrackers.shift());
            }
        }
        window._gaq = gaq.qf = gaq;
        function Gat() {}
        var api = [ "_addIgnoredOrganic", "_addIgnoredRef", "_addItem", "_addOrganic", "_addTrans", "_clearIgnoredOrganic", "_clearIgnoredRef", "_clearOrganic", "_cookiePathCopy", "_deleteCustomVar", "_getName", "_setAccount", "_getAccount", "_getClientInfo", "_getDetectFlash", "_getDetectTitle", "_getLinkerUrl", "_getLocalGifPath", "_getServiceMode", "_getVersion", "_getVisitorCustomVar", "_initData", "_link", "_linkByPost", "_setAllowAnchor", "_setAllowHash", "_setAllowLinker", "_setCampContentKey", "_setCampMediumKey", "_setCampNameKey", "_setCampNOKey", "_setCampSourceKey", "_setCampTermKey", "_setCampaignCookieTimeout", "_setCampaignTrack", "_setClientInfo", "_setCookiePath", "_setCookiePersistence", "_setCookieTimeout", "_setCustomVar", "_setDetectFlash", "_setDetectTitle", "_setDomainName", "_setLocalGifPath", "_setLocalRemoteServerMode", "_setLocalServerMode", "_setReferrerOverride", "_setRemoteServerMode", "_setSampleRate", "_setSessionTimeout", "_setSiteSpeedSampleRate", "_setSessionCookieTimeout", "_setVar", "_setVisitorCookieTimeout", "_trackEvent", "_trackPageLoadTime", "_trackPageview", "_trackSocial", "_trackTiming", "_trackTrans", "_visitCode" ];
        var tracker = api.reduce((function(res, funcName) {
            res[funcName] = noopFunc;
            return res;
        }), {});
        tracker._getLinkerUrl = function(a) {
            return a;
        };
        tracker._link = function(url) {
            if (typeof url !== "string") {
                return;
            }
            try {
                window.location.assign(url);
            } catch (e) {
                logMessage(source, e);
            }
        };
        Gat.prototype._anonymizeIP = noopFunc;
        Gat.prototype._createTracker = noopFunc;
        Gat.prototype._forceSSL = noopFunc;
        Gat.prototype._getPlugin = noopFunc;
        Gat.prototype._getTracker = function() {
            return tracker;
        };
        Gat.prototype._getTrackerByName = function() {
            return tracker;
        };
        Gat.prototype._getTrackers = noopFunc;
        Gat.prototype.aa = noopFunc;
        Gat.prototype.ab = noopFunc;
        Gat.prototype.hb = noopFunc;
        Gat.prototype.la = noopFunc;
        Gat.prototype.oa = noopFunc;
        Gat.prototype.pa = noopFunc;
        Gat.prototype.u = noopFunc;
        var gat = new Gat;
        window._gat = gat;
        hit(source);
    }
    function hit(source) {
        var ADGUARD_PREFIX = "[AdGuard]";
        if (!source.verbose) {
            return;
        }
        try {
            var trace = console.trace.bind(console);
            var label = `${ADGUARD_PREFIX} `;
            if (source.engine === "corelibs") {
                label += source.ruleText;
            } else {
                if (source.domainName) {
                    label += `${source.domainName}`;
                }
                if (source.args) {
                    label += `#%#//scriptlet('${source.name}', '${source.args.join("', '")}')`;
                } else {
                    label += `#%#//scriptlet('${source.name}')`;
                }
            }
            if (trace) {
                trace(label);
            }
        } catch (e) {}
        if (typeof window.__debug === "function") {
            window.__debug(source);
        }
    }
    function noopFunc() {}
    function logMessage(source, message) {
        var forced = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
        var convertMessageToString = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
        var {name: name, verbose: verbose} = source;
        if (!forced && !verbose) {
            return;
        }
        var nativeConsole = console.log;
        if (!convertMessageToString) {
            nativeConsole(`${name}:`, message);
            return;
        }
        nativeConsole(`${name}: ${message}`);
    }
    var updatedArgs = args ? [].concat(source).concat(args) : [ source ];
    try {
        GoogleAnalyticsGa.apply(this, updatedArgs);
        if (source.uniqueId) {
            Object.defineProperty(Window.prototype.toString, uniqueIdentifier, {
                value: flag,
                enumerable: false,
                writable: false,
                configurable: false
            });
        }
    } catch (e) {
        console.log(e);
    }
}

function GoogleIma3(source, args) {
    var flag = "done";
    var uniqueIdentifier = source.uniqueId + source.name + "_" + (Array.isArray(args) ? args.join("_") : "");
    if (source.uniqueId) {
        if (Window.prototype.toString[uniqueIdentifier] === flag) {
            return;
        }
    }
    function GoogleIma3(source) {
        var _window$google$ima;
        var VERSION = "3.453.0";
        var ima = {};
        var AdDisplayContainer = function AdDisplayContainer(containerElement) {
            var divElement = document.createElement("div");
            divElement.style.setProperty("display", "none", "important");
            divElement.style.setProperty("visibility", "collapse", "important");
            if (containerElement) {
                containerElement.appendChild(divElement);
            }
        };
        AdDisplayContainer.prototype.destroy = noopFunc;
        AdDisplayContainer.prototype.initialize = noopFunc;
        var ImaSdkSettings = function ImaSdkSettings() {};
        ImaSdkSettings.CompanionBackfillMode = {
            ALWAYS: "always",
            ON_MASTER_AD: "on_master_ad"
        };
        ImaSdkSettings.VpaidMode = {
            DISABLED: 0,
            ENABLED: 1,
            INSECURE: 2
        };
        ImaSdkSettings.prototype = {
            c: true,
            f: {},
            i: false,
            l: "",
            p: "",
            r: 0,
            t: "",
            v: "",
            getCompanionBackfill: noopFunc,
            getDisableCustomPlaybackForIOS10Plus() {
                return this.i;
            },
            getDisabledFlashAds: function getDisabledFlashAds() {
                return true;
            },
            getFeatureFlags() {
                return this.f;
            },
            getLocale() {
                return this.l;
            },
            getNumRedirects() {
                return this.r;
            },
            getPlayerType() {
                return this.t;
            },
            getPlayerVersion() {
                return this.v;
            },
            getPpid() {
                return this.p;
            },
            getVpaidMode() {
                return this.C;
            },
            isCookiesEnabled() {
                return this.c;
            },
            isVpaidAdapter() {
                return this.M;
            },
            setCompanionBackfill: noopFunc,
            setAutoPlayAdBreaks(a) {
                this.K = a;
            },
            setCookiesEnabled(c) {
                this.c = !!c;
            },
            setDisableCustomPlaybackForIOS10Plus(i) {
                this.i = !!i;
            },
            setDisableFlashAds: noopFunc,
            setFeatureFlags(f) {
                this.f = !!f;
            },
            setIsVpaidAdapter(a) {
                this.M = a;
            },
            setLocale(l) {
                this.l = !!l;
            },
            setNumRedirects(r) {
                this.r = !!r;
            },
            setPageCorrelator(a) {
                this.R = a;
            },
            setPlayerType(t) {
                this.t = !!t;
            },
            setPlayerVersion(v) {
                this.v = !!v;
            },
            setPpid(p) {
                this.p = !!p;
            },
            setVpaidMode(a) {
                this.C = a;
            },
            setSessionId: noopFunc,
            setStreamCorrelator: noopFunc,
            setVpaidAllowed: noopFunc,
            CompanionBackfillMode: {
                ALWAYS: "always",
                ON_MASTER_AD: "on_master_ad"
            },
            VpaidMode: {
                DISABLED: 0,
                ENABLED: 1,
                INSECURE: 2
            }
        };
        var EventHandler = function EventHandler() {
            this.listeners = new Map;
            this._dispatch = function(e) {
                var listeners = this.listeners.get(e.type);
                listeners = listeners ? listeners.values() : [];
                for (var _i = 0, _Array$from = Array.from(listeners); _i < _Array$from.length; _i++) {
                    var listener = _Array$from[_i];
                    try {
                        listener(e);
                    } catch (r) {
                        logMessage(source, r);
                    }
                }
            };
            this.addEventListener = function(types, callback, options, context) {
                if (!Array.isArray(types)) {
                    types = [ types ];
                }
                for (var i = 0; i < types.length; i += 1) {
                    var type = types[i];
                    if (!this.listeners.has(type)) {
                        this.listeners.set(type, new Map);
                    }
                    this.listeners.get(type).set(callback, callback.bind(context || this));
                }
            };
            this.removeEventListener = function(types, callback) {
                if (!Array.isArray(types)) {
                    types = [ types ];
                }
                for (var i = 0; i < types.length; i += 1) {
                    var _this$listeners$get;
                    var type = types[i];
                    (_this$listeners$get = this.listeners.get(type)) === null || _this$listeners$get === void 0 || _this$listeners$get.delete(callback);
                }
            };
        };
        var AdsManager = new EventHandler;
        AdsManager.volume = 1;
        AdsManager.collapse = noopFunc;
        AdsManager.configureAdsManager = noopFunc;
        AdsManager.destroy = noopFunc;
        AdsManager.discardAdBreak = noopFunc;
        AdsManager.expand = noopFunc;
        AdsManager.focus = noopFunc;
        AdsManager.getAdSkippableState = function() {
            return false;
        };
        AdsManager.getCuePoints = function() {
            return [ 0 ];
        };
        AdsManager.getCurrentAd = function() {
            return currentAd;
        };
        AdsManager.getCurrentAdCuePoints = function() {
            return [];
        };
        AdsManager.getRemainingTime = function() {
            return 0;
        };
        AdsManager.getVolume = function() {
            return this.volume;
        };
        AdsManager.init = noopFunc;
        AdsManager.isCustomClickTrackingUsed = function() {
            return false;
        };
        AdsManager.isCustomPlaybackUsed = function() {
            return false;
        };
        AdsManager.pause = noopFunc;
        AdsManager.requestNextAdBreak = noopFunc;
        AdsManager.resize = noopFunc;
        AdsManager.resume = noopFunc;
        AdsManager.setVolume = function(v) {
            this.volume = v;
        };
        AdsManager.skip = noopFunc;
        AdsManager.start = function() {
            for (var _i2 = 0, _arr = [ AdEvent.Type.ALL_ADS_COMPLETED, AdEvent.Type.CONTENT_RESUME_REQUESTED ]; _i2 < _arr.length; _i2++) {
                var type = _arr[_i2];
                try {
                    this._dispatch(new ima.AdEvent(type));
                } catch (e) {
                    logMessage(source, e);
                }
            }
        };
        AdsManager.stop = noopFunc;
        AdsManager.updateAdsRenderingSettings = noopFunc;
        var manager = Object.create(AdsManager);
        var AdsManagerLoadedEvent = function AdsManagerLoadedEvent(type, adsRequest, userRequestContext) {
            this.type = type;
            this.adsRequest = adsRequest;
            this.userRequestContext = userRequestContext;
        };
        AdsManagerLoadedEvent.prototype = {
            getAdsManager: function getAdsManager() {
                return manager;
            },
            getUserRequestContext() {
                if (this.userRequestContext) {
                    return this.userRequestContext;
                }
                return {};
            }
        };
        AdsManagerLoadedEvent.Type = {
            ADS_MANAGER_LOADED: "adsManagerLoaded"
        };
        var AdsLoader = EventHandler;
        AdsLoader.prototype.settings = new ImaSdkSettings;
        AdsLoader.prototype.contentComplete = noopFunc;
        AdsLoader.prototype.destroy = noopFunc;
        AdsLoader.prototype.getSettings = function() {
            return this.settings;
        };
        AdsLoader.prototype.getVersion = function() {
            return VERSION;
        };
        AdsLoader.prototype.requestAds = function(adsRequest, userRequestContext) {
            var _this = this;
            requestAnimationFrame((function() {
                var {ADS_MANAGER_LOADED: ADS_MANAGER_LOADED} = AdsManagerLoadedEvent.Type;
                var event = new ima.AdsManagerLoadedEvent(ADS_MANAGER_LOADED, adsRequest, userRequestContext);
                _this._dispatch(event);
            }));
            var e = new ima.AdError("adPlayError", 1205, 1205, "The browser prevented playback initiated without user interaction.", adsRequest, userRequestContext);
            requestAnimationFrame((function() {
                _this._dispatch(new ima.AdErrorEvent(e));
            }));
        };
        var AdsRenderingSettings = noopFunc;
        var AdsRequest = function AdsRequest() {};
        AdsRequest.prototype = {
            setAdWillAutoPlay: noopFunc,
            setAdWillPlayMuted: noopFunc,
            setContinuousPlayback: noopFunc
        };
        var AdPodInfo = function AdPodInfo() {};
        AdPodInfo.prototype = {
            getAdPosition: function getAdPosition() {
                return 1;
            },
            getIsBumper: function getIsBumper() {
                return false;
            },
            getMaxDuration: function getMaxDuration() {
                return -1;
            },
            getPodIndex: function getPodIndex() {
                return 1;
            },
            getTimeOffset: function getTimeOffset() {
                return 0;
            },
            getTotalAds: function getTotalAds() {
                return 1;
            }
        };
        var UniversalAdIdInfo = function UniversalAdIdInfo() {};
        UniversalAdIdInfo.prototype.getAdIdRegistry = function() {
            return "";
        };
        UniversalAdIdInfo.prototype.getAdIsValue = function() {
            return "";
        };
        var Ad = function Ad() {};
        Ad.prototype = {
            pi: new AdPodInfo,
            getAdId: function getAdId() {
                return "";
            },
            getAdPodInfo() {
                return this.pi;
            },
            getAdSystem: function getAdSystem() {
                return "";
            },
            getAdvertiserName: function getAdvertiserName() {
                return "";
            },
            getApiFramework: function getApiFramework() {
                return null;
            },
            getCompanionAds: function getCompanionAds() {
                return [];
            },
            getContentType: function getContentType() {
                return "";
            },
            getCreativeAdId: function getCreativeAdId() {
                return "";
            },
            getDealId: function getDealId() {
                return "";
            },
            getDescription: function getDescription() {
                return "";
            },
            getDuration: function getDuration() {
                return 8.5;
            },
            getHeight: function getHeight() {
                return 0;
            },
            getMediaUrl: function getMediaUrl() {
                return null;
            },
            getMinSuggestedDuration: function getMinSuggestedDuration() {
                return -2;
            },
            getSkipTimeOffset: function getSkipTimeOffset() {
                return -1;
            },
            getSurveyUrl: function getSurveyUrl() {
                return null;
            },
            getTitle: function getTitle() {
                return "";
            },
            getTraffickingParametersString: function getTraffickingParametersString() {
                return "";
            },
            getUiElements: function getUiElements() {
                return [ "" ];
            },
            getUniversalAdIdRegistry: function getUniversalAdIdRegistry() {
                return "unknown";
            },
            getUniversalAdIds: function getUniversalAdIds() {
                return [ new UniversalAdIdInfo ];
            },
            getUniversalAdIdValue: function getUniversalAdIdValue() {
                return "unknown";
            },
            getVastMediaBitrate: function getVastMediaBitrate() {
                return 0;
            },
            getVastMediaHeight: function getVastMediaHeight() {
                return 0;
            },
            getVastMediaWidth: function getVastMediaWidth() {
                return 0;
            },
            getWidth: function getWidth() {
                return 0;
            },
            getWrapperAdIds: function getWrapperAdIds() {
                return [ "" ];
            },
            getWrapperAdSystems: function getWrapperAdSystems() {
                return [ "" ];
            },
            getWrapperCreativeIds: function getWrapperCreativeIds() {
                return [ "" ];
            },
            isLinear: function isLinear() {
                return true;
            },
            isSkippable() {
                return true;
            }
        };
        var CompanionAd = function CompanionAd() {};
        CompanionAd.prototype = {
            getAdSlotId: function getAdSlotId() {
                return "";
            },
            getContent: function getContent() {
                return "";
            },
            getContentType: function getContentType() {
                return "";
            },
            getHeight: function getHeight() {
                return 1;
            },
            getWidth: function getWidth() {
                return 1;
            }
        };
        var AdError = function AdError(type, code, vast, message, adsRequest, userRequestContext) {
            this.errorCode = code;
            this.message = message;
            this.type = type;
            this.adsRequest = adsRequest;
            this.userRequestContext = userRequestContext;
            this.getErrorCode = function() {
                return this.errorCode;
            };
            this.getInnerError = function() {
                return null;
            };
            this.getMessage = function() {
                return this.message;
            };
            this.getType = function() {
                return this.type;
            };
            this.getVastErrorCode = function() {
                return this.vastErrorCode;
            };
            this.toString = function() {
                return `AdError ${this.errorCode}: ${this.message}`;
            };
        };
        AdError.ErrorCode = {};
        AdError.Type = {};
        var isEngadget = function isEngadget() {
            try {
                for (var _i3 = 0, _Object$values = Object.values(window.vidible._getContexts()); _i3 < _Object$values.length; _i3++) {
                    var _ctx$getPlayer;
                    var ctx = _Object$values[_i3];
                    if ((_ctx$getPlayer = ctx.getPlayer()) !== null && _ctx$getPlayer !== void 0 && (_ctx$getPlayer = _ctx$getPlayer.div) !== null && _ctx$getPlayer !== void 0 && _ctx$getPlayer.innerHTML.includes("www.engadget.com")) {
                        return true;
                    }
                }
            } catch (e) {}
            return false;
        };
        var currentAd = isEngadget() ? undefined : new Ad;
        var AdEvent = function AdEvent(type) {
            this.type = type;
        };
        AdEvent.prototype = {
            getAd: function getAd() {
                return currentAd;
            },
            getAdData: function getAdData() {}
        };
        AdEvent.Type = {
            AD_BREAK_READY: "adBreakReady",
            AD_BUFFERING: "adBuffering",
            AD_CAN_PLAY: "adCanPlay",
            AD_METADATA: "adMetadata",
            AD_PROGRESS: "adProgress",
            ALL_ADS_COMPLETED: "allAdsCompleted",
            CLICK: "click",
            COMPLETE: "complete",
            CONTENT_PAUSE_REQUESTED: "contentPauseRequested",
            CONTENT_RESUME_REQUESTED: "contentResumeRequested",
            DURATION_CHANGE: "durationChange",
            EXPANDED_CHANGED: "expandedChanged",
            FIRST_QUARTILE: "firstQuartile",
            IMPRESSION: "impression",
            INTERACTION: "interaction",
            LINEAR_CHANGE: "linearChange",
            LINEAR_CHANGED: "linearChanged",
            LOADED: "loaded",
            LOG: "log",
            MIDPOINT: "midpoint",
            PAUSED: "pause",
            RESUMED: "resume",
            SKIPPABLE_STATE_CHANGED: "skippableStateChanged",
            SKIPPED: "skip",
            STARTED: "start",
            THIRD_QUARTILE: "thirdQuartile",
            USER_CLOSE: "userClose",
            VIDEO_CLICKED: "videoClicked",
            VIDEO_ICON_CLICKED: "videoIconClicked",
            VIEWABLE_IMPRESSION: "viewable_impression",
            VOLUME_CHANGED: "volumeChange",
            VOLUME_MUTED: "mute"
        };
        var AdErrorEvent = function AdErrorEvent(error) {
            this.error = error;
            this.type = "adError";
            this.getError = function() {
                return this.error;
            };
            this.getUserRequestContext = function() {
                var _this$error;
                if ((_this$error = this.error) !== null && _this$error !== void 0 && _this$error.userRequestContext) {
                    return this.error.userRequestContext;
                }
                return {};
            };
        };
        AdErrorEvent.Type = {
            AD_ERROR: "adError"
        };
        var CustomContentLoadedEvent = function CustomContentLoadedEvent() {};
        CustomContentLoadedEvent.Type = {
            CUSTOM_CONTENT_LOADED: "deprecated-event"
        };
        var CompanionAdSelectionSettings = function CompanionAdSelectionSettings() {};
        CompanionAdSelectionSettings.CreativeType = {
            ALL: "All",
            FLASH: "Flash",
            IMAGE: "Image"
        };
        CompanionAdSelectionSettings.ResourceType = {
            ALL: "All",
            HTML: "Html",
            IFRAME: "IFrame",
            STATIC: "Static"
        };
        CompanionAdSelectionSettings.SizeCriteria = {
            IGNORE: "IgnoreSize",
            SELECT_EXACT_MATCH: "SelectExactMatch",
            SELECT_NEAR_MATCH: "SelectNearMatch"
        };
        var AdCuePoints = function AdCuePoints() {};
        AdCuePoints.prototype = {
            getCuePoints: function getCuePoints() {
                return [];
            },
            getAdIdRegistry: function getAdIdRegistry() {
                return "";
            },
            getAdIdValue: function getAdIdValue() {
                return "";
            }
        };
        var AdProgressData = noopFunc;
        Object.assign(ima, {
            AdCuePoints: AdCuePoints,
            AdDisplayContainer: AdDisplayContainer,
            AdError: AdError,
            AdErrorEvent: AdErrorEvent,
            AdEvent: AdEvent,
            AdPodInfo: AdPodInfo,
            AdProgressData: AdProgressData,
            AdsLoader: AdsLoader,
            AdsManager: manager,
            AdsManagerLoadedEvent: AdsManagerLoadedEvent,
            AdsRenderingSettings: AdsRenderingSettings,
            AdsRequest: AdsRequest,
            CompanionAd: CompanionAd,
            CompanionAdSelectionSettings: CompanionAdSelectionSettings,
            CustomContentLoadedEvent: CustomContentLoadedEvent,
            gptProxyInstance: {},
            ImaSdkSettings: ImaSdkSettings,
            OmidAccessMode: {
                DOMAIN: "domain",
                FULL: "full",
                LIMITED: "limited"
            },
            OmidVerificationVendor: {
                1: "OTHER",
                2: "MOAT",
                3: "DOUBLEVERIFY",
                4: "INTEGRAL_AD_SCIENCE",
                5: "PIXELATE",
                6: "NIELSEN",
                7: "COMSCORE",
                8: "MEETRICS",
                9: "GOOGLE",
                OTHER: 1,
                MOAT: 2,
                DOUBLEVERIFY: 3,
                INTEGRAL_AD_SCIENCE: 4,
                PIXELATE: 5,
                NIELSEN: 6,
                COMSCORE: 7,
                MEETRICS: 8,
                GOOGLE: 9
            },
            settings: new ImaSdkSettings,
            UiElements: {
                AD_ATTRIBUTION: "adAttribution",
                COUNTDOWN: "countdown"
            },
            UniversalAdIdInfo: UniversalAdIdInfo,
            VERSION: VERSION,
            ViewMode: {
                FULLSCREEN: "fullscreen",
                NORMAL: "normal"
            }
        });
        if (!window.google) {
            window.google = {};
        }
        if ((_window$google$ima = window.google.ima) !== null && _window$google$ima !== void 0 && _window$google$ima.dai) {
            ima.dai = window.google.ima.dai;
        }
        window.google.ima = ima;
        hit(source);
    }
    function hit(source) {
        var ADGUARD_PREFIX = "[AdGuard]";
        if (!source.verbose) {
            return;
        }
        try {
            var trace = console.trace.bind(console);
            var label = `${ADGUARD_PREFIX} `;
            if (source.engine === "corelibs") {
                label += source.ruleText;
            } else {
                if (source.domainName) {
                    label += `${source.domainName}`;
                }
                if (source.args) {
                    label += `#%#//scriptlet('${source.name}', '${source.args.join("', '")}')`;
                } else {
                    label += `#%#//scriptlet('${source.name}')`;
                }
            }
            if (trace) {
                trace(label);
            }
        } catch (e) {}
        if (typeof window.__debug === "function") {
            window.__debug(source);
        }
    }
    function noopFunc() {}
    function logMessage(source, message) {
        var forced = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
        var convertMessageToString = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
        var {name: name, verbose: verbose} = source;
        if (!forced && !verbose) {
            return;
        }
        var nativeConsole = console.log;
        if (!convertMessageToString) {
            nativeConsole(`${name}:`, message);
            return;
        }
        nativeConsole(`${name}: ${message}`);
    }
    var updatedArgs = args ? [].concat(source).concat(args) : [ source ];
    try {
        GoogleIma3.apply(this, updatedArgs);
        if (source.uniqueId) {
            Object.defineProperty(Window.prototype.toString, uniqueIdentifier, {
                value: flag,
                enumerable: false,
                writable: false,
                configurable: false
            });
        }
    } catch (e) {
        console.log(e);
    }
}

function GoogleSyndicationAdsByGoogle(source, args) {
    var flag = "done";
    var uniqueIdentifier = source.uniqueId + source.name + "_" + (Array.isArray(args) ? args.join("_") : "");
    if (source.uniqueId) {
        if (Window.prototype.toString[uniqueIdentifier] === flag) {
            return;
        }
    }
    function GoogleSyndicationAdsByGoogle(source) {
        window.adsbygoogle = {
            loaded: true,
            push(arg) {
                if (typeof this.length === "undefined") {
                    this.length = 0;
                    this.length += 1;
                }
                if (arg !== null && arg instanceof Object && arg.constructor.name === "Object") {
                    for (var _i = 0, _Object$keys = Object.keys(arg); _i < _Object$keys.length; _i++) {
                        var key = _Object$keys[_i];
                        if (typeof arg[key] === "function") {
                            try {
                                arg[key].call(this, {});
                            } catch (_unused) {}
                        }
                    }
                }
            }
        };
        var adElems = document.querySelectorAll(".adsbygoogle");
        var css = "height:1px!important;max-height:1px!important;max-width:1px!important;width:1px!important;";
        var statusAttrName = "data-adsbygoogle-status";
        var ASWIFT_IFRAME_MARKER = "aswift_";
        var GOOGLE_ADS_IFRAME_MARKER = "google_ads_iframe_";
        var executed = false;
        for (var i = 0; i < adElems.length; i += 1) {
            var adElemChildNodes = adElems[i].childNodes;
            var childNodesQuantity = adElemChildNodes.length;
            var areIframesDefined = false;
            if (childNodesQuantity > 0) {
                areIframesDefined = childNodesQuantity === 2 && adElemChildNodes[0].nodeName.toLowerCase() === "iframe" && adElemChildNodes[0].id.includes(ASWIFT_IFRAME_MARKER) && adElemChildNodes[1].nodeName.toLowerCase() === "iframe" && adElemChildNodes[1].id.includes(GOOGLE_ADS_IFRAME_MARKER);
            }
            if (!areIframesDefined) {
                adElems[i].setAttribute(statusAttrName, "done");
                var aswiftIframe = document.createElement("iframe");
                aswiftIframe.id = `${ASWIFT_IFRAME_MARKER}${i}`;
                aswiftIframe.style = css;
                adElems[i].appendChild(aswiftIframe);
                var innerAswiftIframe = document.createElement("iframe");
                aswiftIframe.contentWindow.document.body.appendChild(innerAswiftIframe);
                var googleadsIframe = document.createElement("iframe");
                googleadsIframe.id = `${GOOGLE_ADS_IFRAME_MARKER}${i}`;
                googleadsIframe.style = css;
                adElems[i].appendChild(googleadsIframe);
                var innerGoogleadsIframe = document.createElement("iframe");
                googleadsIframe.contentWindow.document.body.appendChild(innerGoogleadsIframe);
                executed = true;
            }
        }
        if (executed) {
            hit(source);
        }
    }
    function hit(source) {
        var ADGUARD_PREFIX = "[AdGuard]";
        if (!source.verbose) {
            return;
        }
        try {
            var trace = console.trace.bind(console);
            var label = `${ADGUARD_PREFIX} `;
            if (source.engine === "corelibs") {
                label += source.ruleText;
            } else {
                if (source.domainName) {
                    label += `${source.domainName}`;
                }
                if (source.args) {
                    label += `#%#//scriptlet('${source.name}', '${source.args.join("', '")}')`;
                } else {
                    label += `#%#//scriptlet('${source.name}')`;
                }
            }
            if (trace) {
                trace(label);
            }
        } catch (e) {}
        if (typeof window.__debug === "function") {
            window.__debug(source);
        }
    }
    var updatedArgs = args ? [].concat(source).concat(args) : [ source ];
    try {
        GoogleSyndicationAdsByGoogle.apply(this, updatedArgs);
        if (source.uniqueId) {
            Object.defineProperty(Window.prototype.toString, uniqueIdentifier, {
                value: flag,
                enumerable: false,
                writable: false,
                configurable: false
            });
        }
    } catch (e) {
        console.log(e);
    }
}

function GoogleTagServicesGpt(source, args) {
    var flag = "done";
    var uniqueIdentifier = source.uniqueId + source.name + "_" + (Array.isArray(args) ? args.join("_") : "");
    if (source.uniqueId) {
        if (Window.prototype.toString[uniqueIdentifier] === flag) {
            return;
        }
    }
    function GoogleTagServicesGpt(source) {
        var slots = new Map;
        var slotsById = new Map;
        var slotsPerPath = new Map;
        var slotCreatives = new Map;
        var eventCallbacks = new Map;
        var gTargeting = new Map;
        var addEventListener = function addEventListener(name, listener) {
            if (!eventCallbacks.has(name)) {
                eventCallbacks.set(name, new Set);
            }
            eventCallbacks.get(name).add(listener);
            return this;
        };
        var removeEventListener = function removeEventListener(name, listener) {
            if (eventCallbacks.has(name)) {
                return eventCallbacks.get(name).delete(listener);
            }
            return false;
        };
        var fireSlotEvent = function fireSlotEvent(name, slot) {
            return new Promise((function(resolve) {
                requestAnimationFrame((function() {
                    var size = [ 0, 0 ];
                    var callbacksSet = eventCallbacks.get(name) || [];
                    var callbackArray = Array.from(callbacksSet);
                    for (var i = 0; i < callbackArray.length; i += 1) {
                        callbackArray[i]({
                            isEmpty: true,
                            size: size,
                            slot: slot
                        });
                    }
                    resolve();
                }));
            }));
        };
        var emptySlotElement = function emptySlotElement(slot) {
            var node = document.getElementById(slot.getSlotElementId());
            while (node !== null && node !== void 0 && node.lastChild) {
                node.lastChild.remove();
            }
        };
        var recreateIframeForSlot = function recreateIframeForSlot(slot) {
            var _document$getElementB;
            var eid = `google_ads_iframe_${slot.getId()}`;
            (_document$getElementB = document.getElementById(eid)) === null || _document$getElementB === void 0 || _document$getElementB.remove();
            var node = document.getElementById(slot.getSlotElementId());
            if (node) {
                var f = document.createElement("iframe");
                f.id = eid;
                f.srcdoc = "<body></body>";
                f.style = "position:absolute; width:0; height:0; left:0; right:0; z-index:-1; border:0";
                f.setAttribute("width", 0);
                f.setAttribute("height", 0);
                f.setAttribute("data-load-complete", true);
                f.setAttribute("data-google-container-id", true);
                f.setAttribute("sandbox", "");
                node.appendChild(f);
            }
        };
        var displaySlot = function displaySlot(slot) {
            if (!slot) {
                return;
            }
            var id = slot.getSlotElementId();
            if (!document.getElementById(id)) {
                return;
            }
            var parent = document.getElementById(id);
            if (parent) {
                parent.appendChild(document.createElement("div"));
            }
            emptySlotElement(slot);
            recreateIframeForSlot(slot);
            fireSlotEvent("slotRenderEnded", slot);
            fireSlotEvent("slotRequested", slot);
            fireSlotEvent("slotResponseReceived", slot);
            fireSlotEvent("slotOnload", slot);
            fireSlotEvent("impressionViewable", slot);
        };
        var companionAdsService = {
            addEventListener: addEventListener,
            removeEventListener: removeEventListener,
            enableSyncLoading: noopFunc,
            setRefreshUnfilledSlots: noopFunc,
            getSlots: noopArray
        };
        var contentService = {
            addEventListener: addEventListener,
            removeEventListener: removeEventListener,
            setContent: noopFunc
        };
        function PassbackSlot() {}
        PassbackSlot.prototype.display = noopFunc;
        PassbackSlot.prototype.get = noopNull;
        PassbackSlot.prototype.set = noopThis;
        PassbackSlot.prototype.setClickUrl = noopThis;
        PassbackSlot.prototype.setTagForChildDirectedTreatment = noopThis;
        PassbackSlot.prototype.setTargeting = noopThis;
        PassbackSlot.prototype.updateTargetingFromMap = noopThis;
        function SizeMappingBuilder() {}
        SizeMappingBuilder.prototype.addSize = noopThis;
        SizeMappingBuilder.prototype.build = noopNull;
        var getTargetingValue = function getTargetingValue(v) {
            if (typeof v === "string") {
                return [ v ];
            }
            try {
                return Array.prototype.flat.call(v);
            } catch (_unused) {}
            return [];
        };
        var updateTargeting = function updateTargeting(targeting, map) {
            if (typeof map === "object") {
                for (var key in map) {
                    if (Object.prototype.hasOwnProperty.call(map, key)) {
                        targeting.set(key, getTargetingValue(map[key]));
                    }
                }
            }
        };
        var defineSlot = function defineSlot(adUnitPath, creatives, optDiv) {
            if (slotsById.has(optDiv)) {
                var _document$getElementB2;
                (_document$getElementB2 = document.getElementById(optDiv)) === null || _document$getElementB2 === void 0 || _document$getElementB2.remove();
                return slotsById.get(optDiv);
            }
            var attributes = new Map;
            var targeting = new Map;
            var exclusions = new Set;
            var response = {
                advertiserId: undefined,
                campaignId: undefined,
                creativeId: undefined,
                creativeTemplateId: undefined,
                lineItemId: undefined
            };
            var sizes = [ {
                getHeight: function getHeight() {
                    return 2;
                },
                getWidth: function getWidth() {
                    return 2;
                }
            } ];
            var num = (slotsPerPath.get(adUnitPath) || 0) + 1;
            slotsPerPath.set(adUnitPath, num);
            var id = `${adUnitPath}_${num}`;
            var clickUrl = "";
            var collapseEmptyDiv = null;
            var services = new Set;
            var slot = {
                addService(e) {
                    services.add(e);
                    return slot;
                },
                clearCategoryExclusions: noopThis,
                clearTargeting(k) {
                    if (k === undefined) {
                        targeting.clear();
                    } else {
                        targeting.delete(k);
                    }
                },
                defineSizeMapping(mapping) {
                    slotCreatives.set(optDiv, mapping);
                    return this;
                },
                get: function get(k) {
                    return attributes.get(k);
                },
                getAdUnitPath: function getAdUnitPath() {
                    return adUnitPath;
                },
                getAttributeKeys: function getAttributeKeys() {
                    return Array.from(attributes.keys());
                },
                getCategoryExclusions: function getCategoryExclusions() {
                    return Array.from(exclusions);
                },
                getClickUrl: function getClickUrl() {
                    return clickUrl;
                },
                getCollapseEmptyDiv: function getCollapseEmptyDiv() {
                    return collapseEmptyDiv;
                },
                getContentUrl: function getContentUrl() {
                    return "";
                },
                getDivStartsCollapsed: function getDivStartsCollapsed() {
                    return null;
                },
                getDomId: function getDomId() {
                    return optDiv;
                },
                getEscapedQemQueryId: function getEscapedQemQueryId() {
                    return "";
                },
                getFirstLook: function getFirstLook() {
                    return 0;
                },
                getId: function getId() {
                    return id;
                },
                getHtml: function getHtml() {
                    return "";
                },
                getName: function getName() {
                    return id;
                },
                getOutOfPage: function getOutOfPage() {
                    return false;
                },
                getResponseInformation: function getResponseInformation() {
                    return response;
                },
                getServices: function getServices() {
                    return Array.from(services);
                },
                getSizes: function getSizes() {
                    return sizes;
                },
                getSlotElementId: function getSlotElementId() {
                    return optDiv;
                },
                getSlotId: function getSlotId() {
                    return slot;
                },
                getTargeting: function getTargeting(k) {
                    return targeting.get(k) || gTargeting.get(k) || [];
                },
                getTargetingKeys: function getTargetingKeys() {
                    return Array.from(new Set(Array.of(...gTargeting.keys(), ...targeting.keys())));
                },
                getTargetingMap: function getTargetingMap() {
                    return Object.assign(Object.fromEntries(gTargeting.entries()), Object.fromEntries(targeting.entries()));
                },
                set(k, v) {
                    attributes.set(k, v);
                    return slot;
                },
                setCategoryExclusion(e) {
                    exclusions.add(e);
                    return slot;
                },
                setClickUrl(u) {
                    clickUrl = u;
                    return slot;
                },
                setCollapseEmptyDiv(v) {
                    collapseEmptyDiv = !!v;
                    return slot;
                },
                setSafeFrameConfig: noopThis,
                setTagForChildDirectedTreatment: noopThis,
                setTargeting(k, v) {
                    targeting.set(k, getTargetingValue(v));
                    return slot;
                },
                toString: function toString() {
                    return id;
                },
                updateTargetingFromMap(map) {
                    updateTargeting(targeting, map);
                    return slot;
                }
            };
            slots.set(adUnitPath, slot);
            slotsById.set(optDiv, slot);
            slotCreatives.set(optDiv, creatives);
            return slot;
        };
        var pubAdsService = {
            addEventListener: addEventListener,
            removeEventListener: removeEventListener,
            clear: noopFunc,
            clearCategoryExclusions: noopThis,
            clearTagForChildDirectedTreatment: noopThis,
            clearTargeting(k) {
                if (k === undefined) {
                    gTargeting.clear();
                } else {
                    gTargeting.delete(k);
                }
            },
            collapseEmptyDivs: noopFunc,
            defineOutOfPagePassback() {
                return new PassbackSlot;
            },
            definePassback() {
                return new PassbackSlot;
            },
            disableInitialLoad: noopFunc,
            display: noopFunc,
            enableAsyncRendering: noopFunc,
            enableLazyLoad: noopFunc,
            enableSingleRequest: noopFunc,
            enableSyncRendering: noopFunc,
            enableVideoAds: noopFunc,
            get: noopNull,
            getAttributeKeys: noopArray,
            getTargeting: noopArray,
            getTargetingKeys: noopArray,
            getSlots: noopArray,
            isInitialLoadDisabled: trueFunc,
            refresh: noopFunc,
            set: noopThis,
            setCategoryExclusion: noopThis,
            setCentering: noopFunc,
            setCookieOptions: noopThis,
            setForceSafeFrame: noopThis,
            setLocation: noopThis,
            setPrivacySettings: noopThis,
            setPublisherProvidedId: noopThis,
            setRequestNonPersonalizedAds: noopThis,
            setSafeFrameConfig: noopThis,
            setTagForChildDirectedTreatment: noopThis,
            setTargeting: noopThis,
            setVideoContent: noopThis,
            updateCorrelator: noopFunc
        };
        var {googletag: googletag = {}} = window;
        var {cmd: cmd = []} = googletag;
        googletag.apiReady = true;
        googletag.cmd = [];
        googletag.cmd.push = function(a) {
            try {
                a();
            } catch (ex) {}
            return 1;
        };
        googletag.companionAds = function() {
            return companionAdsService;
        };
        googletag.content = function() {
            return contentService;
        };
        googletag.defineOutOfPageSlot = defineSlot;
        googletag.defineSlot = defineSlot;
        googletag.destroySlots = function() {
            slots.clear();
            slotsById.clear();
        };
        googletag.disablePublisherConsole = noopFunc;
        googletag.display = function(arg) {
            var id;
            if (arg !== null && arg !== void 0 && arg.getSlotElementId) {
                id = arg.getSlotElementId();
            } else if (arg !== null && arg !== void 0 && arg.nodeType) {
                id = arg.id;
            } else {
                id = String(arg);
            }
            displaySlot(slotsById.get(id));
        };
        googletag.enableServices = noopFunc;
        googletag.getVersion = noopStr;
        googletag.pubads = function() {
            return pubAdsService;
        };
        googletag.pubadsReady = true;
        googletag.setAdIframeTitle = noopFunc;
        googletag.sizeMapping = function() {
            return new SizeMappingBuilder;
        };
        window.googletag = googletag;
        while (cmd.length !== 0) {
            googletag.cmd.push(cmd.shift());
        }
        hit(source);
    }
    function hit(source) {
        var ADGUARD_PREFIX = "[AdGuard]";
        if (!source.verbose) {
            return;
        }
        try {
            var trace = console.trace.bind(console);
            var label = `${ADGUARD_PREFIX} `;
            if (source.engine === "corelibs") {
                label += source.ruleText;
            } else {
                if (source.domainName) {
                    label += `${source.domainName}`;
                }
                if (source.args) {
                    label += `#%#//scriptlet('${source.name}', '${source.args.join("', '")}')`;
                } else {
                    label += `#%#//scriptlet('${source.name}')`;
                }
            }
            if (trace) {
                trace(label);
            }
        } catch (e) {}
        if (typeof window.__debug === "function") {
            window.__debug(source);
        }
    }
    function noopFunc() {}
    function noopThis() {
        return this;
    }
    function noopNull() {
        return null;
    }
    function noopArray() {
        return [];
    }
    function noopStr() {
        return "";
    }
    function trueFunc() {
        return true;
    }
    var updatedArgs = args ? [].concat(source).concat(args) : [ source ];
    try {
        GoogleTagServicesGpt.apply(this, updatedArgs);
        if (source.uniqueId) {
            Object.defineProperty(Window.prototype.toString, uniqueIdentifier, {
                value: flag,
                enumerable: false,
                writable: false,
                configurable: false
            });
        }
    } catch (e) {
        console.log(e);
    }
}

function Matomo(source, args) {
    var flag = "done";
    var uniqueIdentifier = source.uniqueId + source.name + "_" + (Array.isArray(args) ? args.join("_") : "");
    if (source.uniqueId) {
        if (Window.prototype.toString[uniqueIdentifier] === flag) {
            return;
        }
    }
    function Matomo(source) {
        var Tracker = function Tracker() {};
        Tracker.prototype.setDoNotTrack = noopFunc;
        Tracker.prototype.setDomains = noopFunc;
        Tracker.prototype.setCustomDimension = noopFunc;
        Tracker.prototype.trackPageView = noopFunc;
        var AsyncTracker = function AsyncTracker() {};
        AsyncTracker.prototype.addListener = noopFunc;
        var matomoWrapper = {
            getTracker: Tracker,
            getAsyncTracker: AsyncTracker
        };
        window.Piwik = matomoWrapper;
        hit(source);
    }
    function hit(source) {
        var ADGUARD_PREFIX = "[AdGuard]";
        if (!source.verbose) {
            return;
        }
        try {
            var trace = console.trace.bind(console);
            var label = `${ADGUARD_PREFIX} `;
            if (source.engine === "corelibs") {
                label += source.ruleText;
            } else {
                if (source.domainName) {
                    label += `${source.domainName}`;
                }
                if (source.args) {
                    label += `#%#//scriptlet('${source.name}', '${source.args.join("', '")}')`;
                } else {
                    label += `#%#//scriptlet('${source.name}')`;
                }
            }
            if (trace) {
                trace(label);
            }
        } catch (e) {}
        if (typeof window.__debug === "function") {
            window.__debug(source);
        }
    }
    function noopFunc() {}
    var updatedArgs = args ? [].concat(source).concat(args) : [ source ];
    try {
        Matomo.apply(this, updatedArgs);
        if (source.uniqueId) {
            Object.defineProperty(Window.prototype.toString, uniqueIdentifier, {
                value: flag,
                enumerable: false,
                writable: false,
                configurable: false
            });
        }
    } catch (e) {
        console.log(e);
    }
}

function NaverWcslog(source, args) {
    var flag = "done";
    var uniqueIdentifier = source.uniqueId + source.name + "_" + (Array.isArray(args) ? args.join("_") : "");
    if (source.uniqueId) {
        if (Window.prototype.toString[uniqueIdentifier] === flag) {
            return;
        }
    }
    function NaverWcslog(source) {
        window.wcs_add = {};
        window.wcs_do = noopFunc;
        window.wcs = {
            inflow: noopFunc
        };
        hit(source);
    }
    function hit(source) {
        var ADGUARD_PREFIX = "[AdGuard]";
        if (!source.verbose) {
            return;
        }
        try {
            var trace = console.trace.bind(console);
            var label = `${ADGUARD_PREFIX} `;
            if (source.engine === "corelibs") {
                label += source.ruleText;
            } else {
                if (source.domainName) {
                    label += `${source.domainName}`;
                }
                if (source.args) {
                    label += `#%#//scriptlet('${source.name}', '${source.args.join("', '")}')`;
                } else {
                    label += `#%#//scriptlet('${source.name}')`;
                }
            }
            if (trace) {
                trace(label);
            }
        } catch (e) {}
        if (typeof window.__debug === "function") {
            window.__debug(source);
        }
    }
    function noopFunc() {}
    var updatedArgs = args ? [].concat(source).concat(args) : [ source ];
    try {
        NaverWcslog.apply(this, updatedArgs);
        if (source.uniqueId) {
            Object.defineProperty(Window.prototype.toString, uniqueIdentifier, {
                value: flag,
                enumerable: false,
                writable: false,
                configurable: false
            });
        }
    } catch (e) {
        console.log(e);
    }
}

function Pardot(source, args) {
    var flag = "done";
    var uniqueIdentifier = source.uniqueId + source.name + "_" + (Array.isArray(args) ? args.join("_") : "");
    if (source.uniqueId) {
        if (Window.prototype.toString[uniqueIdentifier] === flag) {
            return;
        }
    }
    function Pardot(source) {
        window.piVersion = "1.0.2";
        window.piScriptNum = 0;
        window.piScriptObj = [];
        window.checkNamespace = noopFunc;
        window.getPardotUrl = noopStr;
        window.piGetParameter = noopNull;
        window.piSetCookie = noopFunc;
        window.piGetCookie = noopStr;
        function piTracker() {
            window.pi = {
                tracker: {
                    visitor_id: "",
                    visitor_id_sign: "",
                    pi_opt_in: "",
                    campaign_id: ""
                }
            };
            window.piScriptNum += 1;
        }
        window.piResponse = noopFunc;
        window.piTracker = piTracker;
        piTracker();
        hit(source);
    }
    function hit(source) {
        var ADGUARD_PREFIX = "[AdGuard]";
        if (!source.verbose) {
            return;
        }
        try {
            var trace = console.trace.bind(console);
            var label = `${ADGUARD_PREFIX} `;
            if (source.engine === "corelibs") {
                label += source.ruleText;
            } else {
                if (source.domainName) {
                    label += `${source.domainName}`;
                }
                if (source.args) {
                    label += `#%#//scriptlet('${source.name}', '${source.args.join("', '")}')`;
                } else {
                    label += `#%#//scriptlet('${source.name}')`;
                }
            }
            if (trace) {
                trace(label);
            }
        } catch (e) {}
        if (typeof window.__debug === "function") {
            window.__debug(source);
        }
    }
    function noopFunc() {}
    function noopStr() {
        return "";
    }
    function noopNull() {
        return null;
    }
    var updatedArgs = args ? [].concat(source).concat(args) : [ source ];
    try {
        Pardot.apply(this, updatedArgs);
        if (source.uniqueId) {
            Object.defineProperty(Window.prototype.toString, uniqueIdentifier, {
                value: flag,
                enumerable: false,
                writable: false,
                configurable: false
            });
        }
    } catch (e) {
        console.log(e);
    }
}

function Prebid(source, args) {
    var flag = "done";
    var uniqueIdentifier = source.uniqueId + source.name + "_" + (Array.isArray(args) ? args.join("_") : "");
    if (source.uniqueId) {
        if (Window.prototype.toString[uniqueIdentifier] === flag) {
            return;
        }
    }
    function Prebid(source) {
        var pushFunction = function pushFunction(arg) {
            if (typeof arg === "function") {
                try {
                    arg.call();
                } catch (ex) {}
            }
        };
        var pbjsWrapper = {
            addAdUnits() {},
            adServers: {
                dfp: {
                    buildVideoUrl: noopStr
                }
            },
            adUnits: [],
            aliasBidder() {},
            cmd: [],
            enableAnalytics() {},
            getHighestCpmBids: noopArray,
            libLoaded: true,
            que: [],
            requestBids(arg) {
                if (arg instanceof Object && arg.bidsBackHandler) {
                    try {
                        arg.bidsBackHandler.call();
                    } catch (ex) {}
                }
            },
            removeAdUnit() {},
            setBidderConfig() {},
            setConfig() {},
            setTargetingForGPTAsync() {}
        };
        pbjsWrapper.cmd.push = pushFunction;
        pbjsWrapper.que.push = pushFunction;
        window.pbjs = pbjsWrapper;
        hit(source);
    }
    function hit(source) {
        var ADGUARD_PREFIX = "[AdGuard]";
        if (!source.verbose) {
            return;
        }
        try {
            var trace = console.trace.bind(console);
            var label = `${ADGUARD_PREFIX} `;
            if (source.engine === "corelibs") {
                label += source.ruleText;
            } else {
                if (source.domainName) {
                    label += `${source.domainName}`;
                }
                if (source.args) {
                    label += `#%#//scriptlet('${source.name}', '${source.args.join("', '")}')`;
                } else {
                    label += `#%#//scriptlet('${source.name}')`;
                }
            }
            if (trace) {
                trace(label);
            }
        } catch (e) {}
        if (typeof window.__debug === "function") {
            window.__debug(source);
        }
    }
    function noopStr() {
        return "";
    }
    function noopArray() {
        return [];
    }
    var updatedArgs = args ? [].concat(source).concat(args) : [ source ];
    try {
        Prebid.apply(this, updatedArgs);
        if (source.uniqueId) {
            Object.defineProperty(Window.prototype.toString, uniqueIdentifier, {
                value: flag,
                enumerable: false,
                writable: false,
                configurable: false
            });
        }
    } catch (e) {
        console.log(e);
    }
}

function ScoreCardResearchBeacon(source, args) {
    var flag = "done";
    var uniqueIdentifier = source.uniqueId + source.name + "_" + (Array.isArray(args) ? args.join("_") : "");
    if (source.uniqueId) {
        if (Window.prototype.toString[uniqueIdentifier] === flag) {
            return;
        }
    }
    function ScoreCardResearchBeacon(source) {
        window.COMSCORE = {
            purge() {
                window._comscore = [];
            },
            beacon() {}
        };
        hit(source);
    }
    function hit(source) {
        var ADGUARD_PREFIX = "[AdGuard]";
        if (!source.verbose) {
            return;
        }
        try {
            var trace = console.trace.bind(console);
            var label = `${ADGUARD_PREFIX} `;
            if (source.engine === "corelibs") {
                label += source.ruleText;
            } else {
                if (source.domainName) {
                    label += `${source.domainName}`;
                }
                if (source.args) {
                    label += `#%#//scriptlet('${source.name}', '${source.args.join("', '")}')`;
                } else {
                    label += `#%#//scriptlet('${source.name}')`;
                }
            }
            if (trace) {
                trace(label);
            }
        } catch (e) {}
        if (typeof window.__debug === "function") {
            window.__debug(source);
        }
    }
    var updatedArgs = args ? [].concat(source).concat(args) : [ source ];
    try {
        ScoreCardResearchBeacon.apply(this, updatedArgs);
        if (source.uniqueId) {
            Object.defineProperty(Window.prototype.toString, uniqueIdentifier, {
                value: flag,
                enumerable: false,
                writable: false,
                configurable: false
            });
        }
    } catch (e) {
        console.log(e);
    }
}

function abortCurrentInlineScript(source, args) {
    var flag = "done";
    var uniqueIdentifier = source.uniqueId + source.name + "_" + (Array.isArray(args) ? args.join("_") : "");
    if (source.uniqueId) {
        if (Window.prototype.toString[uniqueIdentifier] === flag) {
            return;
        }
    }
    function abortCurrentInlineScript(source, property, search) {
        var searchRegexp = toRegExp(search);
        var rid = randomId();
        var SRC_DATA_MARKER = "data:text/javascript;base64,";
        var getCurrentScript = function getCurrentScript() {
            if ("currentScript" in document) {
                return document.currentScript;
            }
            var scripts = document.getElementsByTagName("script");
            return scripts[scripts.length - 1];
        };
        var ourScript = getCurrentScript();
        var abort = function abort() {
            var _scriptEl$src;
            var scriptEl = getCurrentScript();
            if (!scriptEl) {
                return;
            }
            var content = scriptEl.textContent;
            try {
                var textContentGetter = Object.getOwnPropertyDescriptor(Node.prototype, "textContent").get;
                content = textContentGetter.call(scriptEl);
            } catch (e) {}
            if (content.length === 0 && typeof scriptEl.src !== "undefined" && (_scriptEl$src = scriptEl.src) !== null && _scriptEl$src !== void 0 && _scriptEl$src.startsWith(SRC_DATA_MARKER)) {
                var encodedContent = scriptEl.src.slice(SRC_DATA_MARKER.length);
                content = window.atob(encodedContent);
            }
            if (scriptEl instanceof HTMLScriptElement && content.length > 0 && scriptEl !== ourScript && searchRegexp.test(content)) {
                hit(source);
                throw new ReferenceError(rid);
            }
        };
        var _setChainPropAccess = function setChainPropAccess(owner, property) {
            var chainInfo = getPropertyInChain(owner, property);
            var {base: base} = chainInfo;
            var {prop: prop, chain: chain} = chainInfo;
            if (base instanceof Object === false && base === null) {
                var props = property.split(".");
                var propIndex = props.indexOf(prop);
                var baseName = props[propIndex - 1];
                var message = `The scriptlet had been executed before the ${baseName} was loaded.`;
                logMessage(source, message);
                return;
            }
            if (chain) {
                var setter = function setter(a) {
                    base = a;
                    if (a instanceof Object) {
                        _setChainPropAccess(a, chain);
                    }
                };
                Object.defineProperty(owner, prop, {
                    get: function get() {
                        return base;
                    },
                    set: setter
                });
                return;
            }
            var currentValue = base[prop];
            var origDescriptor = Object.getOwnPropertyDescriptor(base, prop);
            if (origDescriptor instanceof Object === false || origDescriptor.get instanceof Function === false) {
                currentValue = base[prop];
                origDescriptor = undefined;
            }
            var descriptorWrapper = Object.assign(getDescriptorAddon(), {
                currentValue: currentValue,
                get() {
                    if (!this.isAbortingSuspended) {
                        this.isolateCallback(abort);
                    }
                    if (origDescriptor instanceof Object) {
                        return origDescriptor.get.call(base);
                    }
                    return this.currentValue;
                },
                set(newValue) {
                    if (!this.isAbortingSuspended) {
                        this.isolateCallback(abort);
                    }
                    if (origDescriptor instanceof Object) {
                        origDescriptor.set.call(base, newValue);
                    } else {
                        this.currentValue = newValue;
                    }
                }
            });
            setPropertyAccess(base, prop, {
                get() {
                    return descriptorWrapper.get.call(descriptorWrapper);
                },
                set(newValue) {
                    descriptorWrapper.set.call(descriptorWrapper, newValue);
                }
            });
        };
        _setChainPropAccess(window, property);
        window.onerror = createOnErrorHandler(rid).bind();
    }
    function randomId() {
        return Math.random().toString(36).slice(2, 9);
    }
    function setPropertyAccess(object, property, descriptor) {
        var currentDescriptor = Object.getOwnPropertyDescriptor(object, property);
        if (currentDescriptor && !currentDescriptor.configurable) {
            return false;
        }
        Object.defineProperty(object, property, descriptor);
        return true;
    }
    function getPropertyInChain(base, chain) {
        var pos = chain.indexOf(".");
        if (pos === -1) {
            return {
                base: base,
                prop: chain
            };
        }
        var prop = chain.slice(0, pos);
        if (base === null) {
            return {
                base: base,
                prop: prop,
                chain: chain
            };
        }
        var nextBase = base[prop];
        chain = chain.slice(pos + 1);
        if ((base instanceof Object || typeof base === "object") && isEmptyObject(base)) {
            return {
                base: base,
                prop: prop,
                chain: chain
            };
        }
        if (nextBase === null) {
            return {
                base: base,
                prop: prop,
                chain: chain
            };
        }
        if (nextBase !== undefined) {
            return getPropertyInChain(nextBase, chain);
        }
        Object.defineProperty(base, prop, {
            configurable: true
        });
        return {
            base: base,
            prop: prop,
            chain: chain
        };
    }
    function toRegExp(rawInput) {
        var input = rawInput || "";
        var DEFAULT_VALUE = ".?";
        var FORWARD_SLASH = "/";
        if (input === "") {
            return new RegExp(DEFAULT_VALUE);
        }
        var delimiterIndex = input.lastIndexOf(FORWARD_SLASH);
        var flagsPart = input.substring(delimiterIndex + 1);
        var regExpPart = input.substring(0, delimiterIndex + 1);
        var isValidRegExpFlag = function isValidRegExpFlag(flag) {
            if (!flag) {
                return false;
            }
            try {
                new RegExp("", flag);
                return true;
            } catch (ex) {
                return false;
            }
        };
        var getRegExpFlags = function getRegExpFlags(regExpStr, flagsStr) {
            if (regExpStr.startsWith(FORWARD_SLASH) && regExpStr.endsWith(FORWARD_SLASH) && !regExpStr.endsWith("\\/") && isValidRegExpFlag(flagsStr)) {
                return flagsStr;
            }
            return "";
        };
        var flags = getRegExpFlags(regExpPart, flagsPart);
        if (input.startsWith(FORWARD_SLASH) && input.endsWith(FORWARD_SLASH) || flags) {
            var regExpInput = flags ? regExpPart : input;
            return new RegExp(regExpInput.slice(1, -1), flags);
        }
        var escaped = input.replace(/\\'/g, "'").replace(/\\"/g, '"').replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
        return new RegExp(escaped);
    }
    function createOnErrorHandler(rid) {
        var nativeOnError = window.onerror;
        return function onError(error) {
            if (typeof error === "string" && error.includes(rid)) {
                return true;
            }
            if (nativeOnError instanceof Function) {
                for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
                    args[_key - 1] = arguments[_key];
                }
                return nativeOnError.apply(window, [ error, ...args ]);
            }
            return false;
        };
    }
    function hit(source) {
        var ADGUARD_PREFIX = "[AdGuard]";
        if (!source.verbose) {
            return;
        }
        try {
            var trace = console.trace.bind(console);
            var label = `${ADGUARD_PREFIX} `;
            if (source.engine === "corelibs") {
                label += source.ruleText;
            } else {
                if (source.domainName) {
                    label += `${source.domainName}`;
                }
                if (source.args) {
                    label += `#%#//scriptlet('${source.name}', '${source.args.join("', '")}')`;
                } else {
                    label += `#%#//scriptlet('${source.name}')`;
                }
            }
            if (trace) {
                trace(label);
            }
        } catch (e) {}
        if (typeof window.__debug === "function") {
            window.__debug(source);
        }
    }
    function logMessage(source, message) {
        var forced = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
        var convertMessageToString = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
        var {name: name, verbose: verbose} = source;
        if (!forced && !verbose) {
            return;
        }
        var nativeConsole = console.log;
        if (!convertMessageToString) {
            nativeConsole(`${name}:`, message);
            return;
        }
        nativeConsole(`${name}: ${message}`);
    }
    function isEmptyObject(obj) {
        return Object.keys(obj).length === 0 && !obj.prototype;
    }
    function getDescriptorAddon() {
        return {
            isAbortingSuspended: false,
            isolateCallback(cb) {
                this.isAbortingSuspended = true;
                try {
                    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
                        args[_key - 1] = arguments[_key];
                    }
                    var result = cb(...args);
                    this.isAbortingSuspended = false;
                    return result;
                } catch (_unused) {
                    var rid = randomId();
                    this.isAbortingSuspended = false;
                    throw new ReferenceError(rid);
                }
            }
        };
    }
    var updatedArgs = args ? [].concat(source).concat(args) : [ source ];
    try {
        abortCurrentInlineScript.apply(this, updatedArgs);
        if (source.uniqueId) {
            Object.defineProperty(Window.prototype.toString, uniqueIdentifier, {
                value: flag,
                enumerable: false,
                writable: false,
                configurable: false
            });
        }
    } catch (e) {
        console.log(e);
    }
}

function abortOnPropertyRead(source, args) {
    var flag = "done";
    var uniqueIdentifier = source.uniqueId + source.name + "_" + (Array.isArray(args) ? args.join("_") : "");
    if (source.uniqueId) {
        if (Window.prototype.toString[uniqueIdentifier] === flag) {
            return;
        }
    }
    function abortOnPropertyRead(source, property) {
        if (!property) {
            return;
        }
        var rid = randomId();
        var abort = function abort() {
            hit(source);
            throw new ReferenceError(rid);
        };
        var _setChainPropAccess = function setChainPropAccess(owner, property) {
            var chainInfo = getPropertyInChain(owner, property);
            var {base: base} = chainInfo;
            var {prop: prop, chain: chain} = chainInfo;
            if (chain) {
                var setter = function setter(a) {
                    base = a;
                    if (a instanceof Object) {
                        _setChainPropAccess(a, chain);
                    }
                };
                Object.defineProperty(owner, prop, {
                    get: function get() {
                        return base;
                    },
                    set: setter
                });
                return;
            }
            setPropertyAccess(base, prop, {
                get: abort,
                set: function set() {}
            });
        };
        _setChainPropAccess(window, property);
        window.onerror = createOnErrorHandler(rid).bind();
    }
    function randomId() {
        return Math.random().toString(36).slice(2, 9);
    }
    function setPropertyAccess(object, property, descriptor) {
        var currentDescriptor = Object.getOwnPropertyDescriptor(object, property);
        if (currentDescriptor && !currentDescriptor.configurable) {
            return false;
        }
        Object.defineProperty(object, property, descriptor);
        return true;
    }
    function getPropertyInChain(base, chain) {
        var pos = chain.indexOf(".");
        if (pos === -1) {
            return {
                base: base,
                prop: chain
            };
        }
        var prop = chain.slice(0, pos);
        if (base === null) {
            return {
                base: base,
                prop: prop,
                chain: chain
            };
        }
        var nextBase = base[prop];
        chain = chain.slice(pos + 1);
        if ((base instanceof Object || typeof base === "object") && isEmptyObject(base)) {
            return {
                base: base,
                prop: prop,
                chain: chain
            };
        }
        if (nextBase === null) {
            return {
                base: base,
                prop: prop,
                chain: chain
            };
        }
        if (nextBase !== undefined) {
            return getPropertyInChain(nextBase, chain);
        }
        Object.defineProperty(base, prop, {
            configurable: true
        });
        return {
            base: base,
            prop: prop,
            chain: chain
        };
    }
    function createOnErrorHandler(rid) {
        var nativeOnError = window.onerror;
        return function onError(error) {
            if (typeof error === "string" && error.includes(rid)) {
                return true;
            }
            if (nativeOnError instanceof Function) {
                for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
                    args[_key - 1] = arguments[_key];
                }
                return nativeOnError.apply(window, [ error, ...args ]);
            }
            return false;
        };
    }
    function hit(source) {
        var ADGUARD_PREFIX = "[AdGuard]";
        if (!source.verbose) {
            return;
        }
        try {
            var trace = console.trace.bind(console);
            var label = `${ADGUARD_PREFIX} `;
            if (source.engine === "corelibs") {
                label += source.ruleText;
            } else {
                if (source.domainName) {
                    label += `${source.domainName}`;
                }
                if (source.args) {
                    label += `#%#//scriptlet('${source.name}', '${source.args.join("', '")}')`;
                } else {
                    label += `#%#//scriptlet('${source.name}')`;
                }
            }
            if (trace) {
                trace(label);
            }
        } catch (e) {}
        if (typeof window.__debug === "function") {
            window.__debug(source);
        }
    }
    function isEmptyObject(obj) {
        return Object.keys(obj).length === 0 && !obj.prototype;
    }
    var updatedArgs = args ? [].concat(source).concat(args) : [ source ];
    try {
        abortOnPropertyRead.apply(this, updatedArgs);
        if (source.uniqueId) {
            Object.defineProperty(Window.prototype.toString, uniqueIdentifier, {
                value: flag,
                enumerable: false,
                writable: false,
                configurable: false
            });
        }
    } catch (e) {
        console.log(e);
    }
}

function abortOnPropertyWrite(source, args) {
    var flag = "done";
    var uniqueIdentifier = source.uniqueId + source.name + "_" + (Array.isArray(args) ? args.join("_") : "");
    if (source.uniqueId) {
        if (Window.prototype.toString[uniqueIdentifier] === flag) {
            return;
        }
    }
    function abortOnPropertyWrite(source, property) {
        if (!property) {
            return;
        }
        var rid = randomId();
        var abort = function abort() {
            hit(source);
            throw new ReferenceError(rid);
        };
        var _setChainPropAccess = function setChainPropAccess(owner, property) {
            var chainInfo = getPropertyInChain(owner, property);
            var {base: base} = chainInfo;
            var {prop: prop, chain: chain} = chainInfo;
            if (chain) {
                var setter = function setter(a) {
                    base = a;
                    if (a instanceof Object) {
                        _setChainPropAccess(a, chain);
                    }
                };
                Object.defineProperty(owner, prop, {
                    get: function get() {
                        return base;
                    },
                    set: setter
                });
                return;
            }
            setPropertyAccess(base, prop, {
                set: abort
            });
        };
        _setChainPropAccess(window, property);
        window.onerror = createOnErrorHandler(rid).bind();
    }
    function randomId() {
        return Math.random().toString(36).slice(2, 9);
    }
    function setPropertyAccess(object, property, descriptor) {
        var currentDescriptor = Object.getOwnPropertyDescriptor(object, property);
        if (currentDescriptor && !currentDescriptor.configurable) {
            return false;
        }
        Object.defineProperty(object, property, descriptor);
        return true;
    }
    function getPropertyInChain(base, chain) {
        var pos = chain.indexOf(".");
        if (pos === -1) {
            return {
                base: base,
                prop: chain
            };
        }
        var prop = chain.slice(0, pos);
        if (base === null) {
            return {
                base: base,
                prop: prop,
                chain: chain
            };
        }
        var nextBase = base[prop];
        chain = chain.slice(pos + 1);
        if ((base instanceof Object || typeof base === "object") && isEmptyObject(base)) {
            return {
                base: base,
                prop: prop,
                chain: chain
            };
        }
        if (nextBase === null) {
            return {
                base: base,
                prop: prop,
                chain: chain
            };
        }
        if (nextBase !== undefined) {
            return getPropertyInChain(nextBase, chain);
        }
        Object.defineProperty(base, prop, {
            configurable: true
        });
        return {
            base: base,
            prop: prop,
            chain: chain
        };
    }
    function createOnErrorHandler(rid) {
        var nativeOnError = window.onerror;
        return function onError(error) {
            if (typeof error === "string" && error.includes(rid)) {
                return true;
            }
            if (nativeOnError instanceof Function) {
                for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
                    args[_key - 1] = arguments[_key];
                }
                return nativeOnError.apply(window, [ error, ...args ]);
            }
            return false;
        };
    }
    function hit(source) {
        var ADGUARD_PREFIX = "[AdGuard]";
        if (!source.verbose) {
            return;
        }
        try {
            var trace = console.trace.bind(console);
            var label = `${ADGUARD_PREFIX} `;
            if (source.engine === "corelibs") {
                label += source.ruleText;
            } else {
                if (source.domainName) {
                    label += `${source.domainName}`;
                }
                if (source.args) {
                    label += `#%#//scriptlet('${source.name}', '${source.args.join("', '")}')`;
                } else {
                    label += `#%#//scriptlet('${source.name}')`;
                }
            }
            if (trace) {
                trace(label);
            }
        } catch (e) {}
        if (typeof window.__debug === "function") {
            window.__debug(source);
        }
    }
    function isEmptyObject(obj) {
        return Object.keys(obj).length === 0 && !obj.prototype;
    }
    var updatedArgs = args ? [].concat(source).concat(args) : [ source ];
    try {
        abortOnPropertyWrite.apply(this, updatedArgs);
        if (source.uniqueId) {
            Object.defineProperty(Window.prototype.toString, uniqueIdentifier, {
                value: flag,
                enumerable: false,
                writable: false,
                configurable: false
            });
        }
    } catch (e) {
        console.log(e);
    }
}

function abortOnStackTrace(source, args) {
    var flag = "done";
    var uniqueIdentifier = source.uniqueId + source.name + "_" + (Array.isArray(args) ? args.join("_") : "");
    if (source.uniqueId) {
        if (Window.prototype.toString[uniqueIdentifier] === flag) {
            return;
        }
    }
    function abortOnStackTrace(source, property, stack) {
        if (!property || !stack) {
            return;
        }
        var rid = randomId();
        var abort = function abort() {
            hit(source);
            throw new ReferenceError(rid);
        };
        var _setChainPropAccess = function setChainPropAccess(owner, property) {
            var chainInfo = getPropertyInChain(owner, property);
            var {base: base} = chainInfo;
            var {prop: prop, chain: chain} = chainInfo;
            if (chain) {
                var setter = function setter(a) {
                    base = a;
                    if (a instanceof Object) {
                        _setChainPropAccess(a, chain);
                    }
                };
                Object.defineProperty(owner, prop, {
                    get: function get() {
                        return base;
                    },
                    set: setter
                });
                return;
            }
            if (!stack.match(/^(inlineScript|injectedScript)$/) && !isValidStrPattern(stack)) {
                logMessage(source, `Invalid parameter: ${stack}`);
                return;
            }
            var descriptorWrapper = Object.assign(getDescriptorAddon(), {
                value: base[prop],
                get() {
                    if (!this.isAbortingSuspended && this.isolateCallback(matchStackTrace, stack, (new Error).stack)) {
                        abort();
                    }
                    return this.value;
                },
                set(newValue) {
                    if (!this.isAbortingSuspended && this.isolateCallback(matchStackTrace, stack, (new Error).stack)) {
                        abort();
                    }
                    this.value = newValue;
                }
            });
            setPropertyAccess(base, prop, {
                get() {
                    return descriptorWrapper.get.call(descriptorWrapper);
                },
                set(newValue) {
                    descriptorWrapper.set.call(descriptorWrapper, newValue);
                }
            });
        };
        _setChainPropAccess(window, property);
        window.onerror = createOnErrorHandler(rid).bind();
    }
    function randomId() {
        return Math.random().toString(36).slice(2, 9);
    }
    function setPropertyAccess(object, property, descriptor) {
        var currentDescriptor = Object.getOwnPropertyDescriptor(object, property);
        if (currentDescriptor && !currentDescriptor.configurable) {
            return false;
        }
        Object.defineProperty(object, property, descriptor);
        return true;
    }
    function getPropertyInChain(base, chain) {
        var pos = chain.indexOf(".");
        if (pos === -1) {
            return {
                base: base,
                prop: chain
            };
        }
        var prop = chain.slice(0, pos);
        if (base === null) {
            return {
                base: base,
                prop: prop,
                chain: chain
            };
        }
        var nextBase = base[prop];
        chain = chain.slice(pos + 1);
        if ((base instanceof Object || typeof base === "object") && isEmptyObject(base)) {
            return {
                base: base,
                prop: prop,
                chain: chain
            };
        }
        if (nextBase === null) {
            return {
                base: base,
                prop: prop,
                chain: chain
            };
        }
        if (nextBase !== undefined) {
            return getPropertyInChain(nextBase, chain);
        }
        Object.defineProperty(base, prop, {
            configurable: true
        });
        return {
            base: base,
            prop: prop,
            chain: chain
        };
    }
    function createOnErrorHandler(rid) {
        var nativeOnError = window.onerror;
        return function onError(error) {
            if (typeof error === "string" && error.includes(rid)) {
                return true;
            }
            if (nativeOnError instanceof Function) {
                for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
                    args[_key - 1] = arguments[_key];
                }
                return nativeOnError.apply(window, [ error, ...args ]);
            }
            return false;
        };
    }
    function hit(source) {
        var ADGUARD_PREFIX = "[AdGuard]";
        if (!source.verbose) {
            return;
        }
        try {
            var trace = console.trace.bind(console);
            var label = `${ADGUARD_PREFIX} `;
            if (source.engine === "corelibs") {
                label += source.ruleText;
            } else {
                if (source.domainName) {
                    label += `${source.domainName}`;
                }
                if (source.args) {
                    label += `#%#//scriptlet('${source.name}', '${source.args.join("', '")}')`;
                } else {
                    label += `#%#//scriptlet('${source.name}')`;
                }
            }
            if (trace) {
                trace(label);
            }
        } catch (e) {}
        if (typeof window.__debug === "function") {
            window.__debug(source);
        }
    }
    function isValidStrPattern(input) {
        var FORWARD_SLASH = "/";
        var str = escapeRegExp(input);
        if (input[0] === FORWARD_SLASH && input[input.length - 1] === FORWARD_SLASH) {
            str = input.slice(1, -1);
        }
        var isValid;
        try {
            isValid = new RegExp(str);
            isValid = true;
        } catch (e) {
            isValid = false;
        }
        return isValid;
    }
    function escapeRegExp(str) {
        return str.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
    }
    function matchStackTrace(stackMatch, stackTrace) {
        if (!stackMatch || stackMatch === "") {
            return true;
        }
        var regExpValues = backupRegExpValues();
        if (shouldAbortInlineOrInjectedScript(stackMatch, stackTrace)) {
            if (regExpValues.length && regExpValues[0] !== RegExp.$1) {
                restoreRegExpValues(regExpValues);
            }
            return true;
        }
        var stackRegexp = toRegExp(stackMatch);
        var refinedStackTrace = stackTrace.split("\n").slice(2).map((function(line) {
            return line.trim();
        })).join("\n");
        if (regExpValues.length && regExpValues[0] !== RegExp.$1) {
            restoreRegExpValues(regExpValues);
        }
        return getNativeRegexpTest().call(stackRegexp, refinedStackTrace);
    }
    function getDescriptorAddon() {
        return {
            isAbortingSuspended: false,
            isolateCallback(cb) {
                this.isAbortingSuspended = true;
                try {
                    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
                        args[_key - 1] = arguments[_key];
                    }
                    var result = cb(...args);
                    this.isAbortingSuspended = false;
                    return result;
                } catch (_unused) {
                    var rid = randomId();
                    this.isAbortingSuspended = false;
                    throw new ReferenceError(rid);
                }
            }
        };
    }
    function logMessage(source, message) {
        var forced = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
        var convertMessageToString = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
        var {name: name, verbose: verbose} = source;
        if (!forced && !verbose) {
            return;
        }
        var nativeConsole = console.log;
        if (!convertMessageToString) {
            nativeConsole(`${name}:`, message);
            return;
        }
        nativeConsole(`${name}: ${message}`);
    }
    function toRegExp(rawInput) {
        var input = rawInput || "";
        var DEFAULT_VALUE = ".?";
        var FORWARD_SLASH = "/";
        if (input === "") {
            return new RegExp(DEFAULT_VALUE);
        }
        var delimiterIndex = input.lastIndexOf(FORWARD_SLASH);
        var flagsPart = input.substring(delimiterIndex + 1);
        var regExpPart = input.substring(0, delimiterIndex + 1);
        var isValidRegExpFlag = function isValidRegExpFlag(flag) {
            if (!flag) {
                return false;
            }
            try {
                new RegExp("", flag);
                return true;
            } catch (ex) {
                return false;
            }
        };
        var getRegExpFlags = function getRegExpFlags(regExpStr, flagsStr) {
            if (regExpStr.startsWith(FORWARD_SLASH) && regExpStr.endsWith(FORWARD_SLASH) && !regExpStr.endsWith("\\/") && isValidRegExpFlag(flagsStr)) {
                return flagsStr;
            }
            return "";
        };
        var flags = getRegExpFlags(regExpPart, flagsPart);
        if (input.startsWith(FORWARD_SLASH) && input.endsWith(FORWARD_SLASH) || flags) {
            var regExpInput = flags ? regExpPart : input;
            return new RegExp(regExpInput.slice(1, -1), flags);
        }
        var escaped = input.replace(/\\'/g, "'").replace(/\\"/g, '"').replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
        return new RegExp(escaped);
    }
    function isEmptyObject(obj) {
        return Object.keys(obj).length === 0 && !obj.prototype;
    }
    function getNativeRegexpTest() {
        var descriptor = Object.getOwnPropertyDescriptor(RegExp.prototype, "test");
        var nativeRegexTest = descriptor === null || descriptor === void 0 ? void 0 : descriptor.value;
        if (descriptor && typeof descriptor.value === "function") {
            return nativeRegexTest;
        }
        throw new Error("RegExp.prototype.test is not a function");
    }
    function shouldAbortInlineOrInjectedScript(stackMatch, stackTrace) {
        var INLINE_SCRIPT_STRING = "inlineScript";
        var INJECTED_SCRIPT_STRING = "injectedScript";
        var INJECTED_SCRIPT_MARKER = "<anonymous>";
        var isInlineScript = function isInlineScript(match) {
            return match.includes(INLINE_SCRIPT_STRING);
        };
        var isInjectedScript = function isInjectedScript(match) {
            return match.includes(INJECTED_SCRIPT_STRING);
        };
        if (!(isInlineScript(stackMatch) || isInjectedScript(stackMatch))) {
            return false;
        }
        var documentURL = window.location.href;
        var pos = documentURL.indexOf("#");
        if (pos !== -1) {
            documentURL = documentURL.slice(0, pos);
        }
        var stackSteps = stackTrace.split("\n").slice(2).map((function(line) {
            return line.trim();
        }));
        var stackLines = stackSteps.map((function(line) {
            var stack;
            var getStackTraceValues = /(.*?@)?(\S+)(:\d+)(:\d+)\)?$/.exec(line);
            if (getStackTraceValues) {
                var _stackURL, _stackURL2;
                var stackURL = getStackTraceValues[2];
                var stackLine = getStackTraceValues[3];
                var stackCol = getStackTraceValues[4];
                if ((_stackURL = stackURL) !== null && _stackURL !== void 0 && _stackURL.startsWith("(")) {
                    stackURL = stackURL.slice(1);
                }
                if ((_stackURL2 = stackURL) !== null && _stackURL2 !== void 0 && _stackURL2.startsWith(INJECTED_SCRIPT_MARKER)) {
                    var _stackFunction;
                    stackURL = INJECTED_SCRIPT_STRING;
                    var stackFunction = getStackTraceValues[1] !== undefined ? getStackTraceValues[1].slice(0, -1) : line.slice(0, getStackTraceValues.index).trim();
                    if ((_stackFunction = stackFunction) !== null && _stackFunction !== void 0 && _stackFunction.startsWith("at")) {
                        stackFunction = stackFunction.slice(2).trim();
                    }
                    stack = `${stackFunction} ${stackURL}${stackLine}${stackCol}`.trim();
                } else if (stackURL === documentURL) {
                    stack = `${INLINE_SCRIPT_STRING}${stackLine}${stackCol}`.trim();
                } else {
                    stack = `${stackURL}${stackLine}${stackCol}`.trim();
                }
            } else {
                stack = line;
            }
            return stack;
        }));
        if (stackLines) {
            for (var index = 0; index < stackLines.length; index += 1) {
                if (isInlineScript(stackMatch) && stackLines[index].startsWith(INLINE_SCRIPT_STRING) && stackLines[index].match(toRegExp(stackMatch))) {
                    return true;
                }
                if (isInjectedScript(stackMatch) && stackLines[index].startsWith(INJECTED_SCRIPT_STRING) && stackLines[index].match(toRegExp(stackMatch))) {
                    return true;
                }
            }
        }
        return false;
    }
    function backupRegExpValues() {
        try {
            var arrayOfRegexpValues = [];
            for (var index = 1; index < 10; index += 1) {
                var value = `$${index}`;
                if (!RegExp[value]) {
                    break;
                }
                arrayOfRegexpValues.push(RegExp[value]);
            }
            return arrayOfRegexpValues;
        } catch (error) {
            return [];
        }
    }
    function restoreRegExpValues(array) {
        if (!array.length) {
            return;
        }
        try {
            var stringPattern = "";
            if (array.length === 1) {
                stringPattern = `(${array[0]})`;
            } else {
                stringPattern = array.reduce((function(accumulator, currentValue, currentIndex) {
                    if (currentIndex === 1) {
                        return `(${accumulator}),(${currentValue})`;
                    }
                    return `${accumulator},(${currentValue})`;
                }));
            }
            var regExpGroup = new RegExp(stringPattern);
            array.toString().replace(regExpGroup, "");
        } catch (error) {
            var message = `Failed to restore RegExp values: ${error}`;
            console.log(message);
        }
    }
    var updatedArgs = args ? [].concat(source).concat(args) : [ source ];
    try {
        abortOnStackTrace.apply(this, updatedArgs);
        if (source.uniqueId) {
            Object.defineProperty(Window.prototype.toString, uniqueIdentifier, {
                value: flag,
                enumerable: false,
                writable: false,
                configurable: false
            });
        }
    } catch (e) {
        console.log(e);
    }
}

function adjustSetInterval(source, args) {
    var flag = "done";
    var uniqueIdentifier = source.uniqueId + source.name + "_" + (Array.isArray(args) ? args.join("_") : "");
    if (source.uniqueId) {
        if (Window.prototype.toString[uniqueIdentifier] === flag) {
            return;
        }
    }
    function adjustSetInterval(source, matchCallback, matchDelay, boost) {
        var nativeSetInterval = window.setInterval;
        var matchRegexp = toRegExp(matchCallback);
        var intervalWrapper = function intervalWrapper(callback, delay) {
            if (!isValidCallback(callback)) {
                var message = `Scriptlet can't be applied because of invalid callback: '${String(callback)}'`;
                logMessage(source, message);
            } else if (matchRegexp.test(callback.toString()) && isDelayMatched(matchDelay, delay)) {
                delay *= getBoostMultiplier(boost);
                hit(source);
            }
            for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
                args[_key - 2] = arguments[_key];
            }
            return nativeSetInterval.apply(window, [ callback, delay, ...args ]);
        };
        window.setInterval = intervalWrapper;
    }
    function hit(source) {
        var ADGUARD_PREFIX = "[AdGuard]";
        if (!source.verbose) {
            return;
        }
        try {
            var trace = console.trace.bind(console);
            var label = `${ADGUARD_PREFIX} `;
            if (source.engine === "corelibs") {
                label += source.ruleText;
            } else {
                if (source.domainName) {
                    label += `${source.domainName}`;
                }
                if (source.args) {
                    label += `#%#//scriptlet('${source.name}', '${source.args.join("', '")}')`;
                } else {
                    label += `#%#//scriptlet('${source.name}')`;
                }
            }
            if (trace) {
                trace(label);
            }
        } catch (e) {}
        if (typeof window.__debug === "function") {
            window.__debug(source);
        }
    }
    function isValidCallback(callback) {
        return callback instanceof Function || typeof callback === "string";
    }
    function toRegExp(rawInput) {
        var input = rawInput || "";
        var DEFAULT_VALUE = ".?";
        var FORWARD_SLASH = "/";
        if (input === "") {
            return new RegExp(DEFAULT_VALUE);
        }
        var delimiterIndex = input.lastIndexOf(FORWARD_SLASH);
        var flagsPart = input.substring(delimiterIndex + 1);
        var regExpPart = input.substring(0, delimiterIndex + 1);
        var isValidRegExpFlag = function isValidRegExpFlag(flag) {
            if (!flag) {
                return false;
            }
            try {
                new RegExp("", flag);
                return true;
            } catch (ex) {
                return false;
            }
        };
        var getRegExpFlags = function getRegExpFlags(regExpStr, flagsStr) {
            if (regExpStr.startsWith(FORWARD_SLASH) && regExpStr.endsWith(FORWARD_SLASH) && !regExpStr.endsWith("\\/") && isValidRegExpFlag(flagsStr)) {
                return flagsStr;
            }
            return "";
        };
        var flags = getRegExpFlags(regExpPart, flagsPart);
        if (input.startsWith(FORWARD_SLASH) && input.endsWith(FORWARD_SLASH) || flags) {
            var regExpInput = flags ? regExpPart : input;
            return new RegExp(regExpInput.slice(1, -1), flags);
        }
        var escaped = input.replace(/\\'/g, "'").replace(/\\"/g, '"').replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
        return new RegExp(escaped);
    }
    function getBoostMultiplier(boost) {
        var DEFAULT_MULTIPLIER = .05;
        var MIN_MULTIPLIER = .001;
        var MAX_MULTIPLIER = 50;
        var parsedBoost = parseFloat(boost);
        var boostMultiplier = nativeIsNaN(parsedBoost) || !nativeIsFinite(parsedBoost) ? DEFAULT_MULTIPLIER : parsedBoost;
        if (boostMultiplier < MIN_MULTIPLIER) {
            boostMultiplier = MIN_MULTIPLIER;
        }
        if (boostMultiplier > MAX_MULTIPLIER) {
            boostMultiplier = MAX_MULTIPLIER;
        }
        return boostMultiplier;
    }
    function isDelayMatched(inputDelay, realDelay) {
        return shouldMatchAnyDelay(inputDelay) || realDelay === getMatchDelay(inputDelay);
    }
    function logMessage(source, message) {
        var forced = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
        var convertMessageToString = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
        var {name: name, verbose: verbose} = source;
        if (!forced && !verbose) {
            return;
        }
        var nativeConsole = console.log;
        if (!convertMessageToString) {
            nativeConsole(`${name}:`, message);
            return;
        }
        nativeConsole(`${name}: ${message}`);
    }
    function nativeIsNaN(num) {
        var native = Number.isNaN || window.isNaN;
        return native(num);
    }
    function nativeIsFinite(num) {
        var native = Number.isFinite || window.isFinite;
        return native(num);
    }
    function getMatchDelay(delay) {
        var DEFAULT_DELAY = 1e3;
        var parsedDelay = parseInt(delay, 10);
        var delayMatch = nativeIsNaN(parsedDelay) ? DEFAULT_DELAY : parsedDelay;
        return delayMatch;
    }
    function shouldMatchAnyDelay(delay) {
        return delay === "*";
    }
    var updatedArgs = args ? [].concat(source).concat(args) : [ source ];
    try {
        adjustSetInterval.apply(this, updatedArgs);
        if (source.uniqueId) {
            Object.defineProperty(Window.prototype.toString, uniqueIdentifier, {
                value: flag,
                enumerable: false,
                writable: false,
                configurable: false
            });
        }
    } catch (e) {
        console.log(e);
    }
}

function adjustSetTimeout(source, args) {
    var flag = "done";
    var uniqueIdentifier = source.uniqueId + source.name + "_" + (Array.isArray(args) ? args.join("_") : "");
    if (source.uniqueId) {
        if (Window.prototype.toString[uniqueIdentifier] === flag) {
            return;
        }
    }
    function adjustSetTimeout(source, matchCallback, matchDelay, boost) {
        var nativeSetTimeout = window.setTimeout;
        var matchRegexp = toRegExp(matchCallback);
        var timeoutWrapper = function timeoutWrapper(callback, delay) {
            if (!isValidCallback(callback)) {
                var message = `Scriptlet can't be applied because of invalid callback: '${String(callback)}'`;
                logMessage(source, message);
            } else if (matchRegexp.test(callback.toString()) && isDelayMatched(matchDelay, delay)) {
                delay *= getBoostMultiplier(boost);
                hit(source);
            }
            for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
                args[_key - 2] = arguments[_key];
            }
            return nativeSetTimeout.apply(window, [ callback, delay, ...args ]);
        };
        window.setTimeout = timeoutWrapper;
    }
    function hit(source) {
        var ADGUARD_PREFIX = "[AdGuard]";
        if (!source.verbose) {
            return;
        }
        try {
            var trace = console.trace.bind(console);
            var label = `${ADGUARD_PREFIX} `;
            if (source.engine === "corelibs") {
                label += source.ruleText;
            } else {
                if (source.domainName) {
                    label += `${source.domainName}`;
                }
                if (source.args) {
                    label += `#%#//scriptlet('${source.name}', '${source.args.join("', '")}')`;
                } else {
                    label += `#%#//scriptlet('${source.name}')`;
                }
            }
            if (trace) {
                trace(label);
            }
        } catch (e) {}
        if (typeof window.__debug === "function") {
            window.__debug(source);
        }
    }
    function isValidCallback(callback) {
        return callback instanceof Function || typeof callback === "string";
    }
    function toRegExp(rawInput) {
        var input = rawInput || "";
        var DEFAULT_VALUE = ".?";
        var FORWARD_SLASH = "/";
        if (input === "") {
            return new RegExp(DEFAULT_VALUE);
        }
        var delimiterIndex = input.lastIndexOf(FORWARD_SLASH);
        var flagsPart = input.substring(delimiterIndex + 1);
        var regExpPart = input.substring(0, delimiterIndex + 1);
        var isValidRegExpFlag = function isValidRegExpFlag(flag) {
            if (!flag) {
                return false;
            }
            try {
                new RegExp("", flag);
                return true;
            } catch (ex) {
                return false;
            }
        };
        var getRegExpFlags = function getRegExpFlags(regExpStr, flagsStr) {
            if (regExpStr.startsWith(FORWARD_SLASH) && regExpStr.endsWith(FORWARD_SLASH) && !regExpStr.endsWith("\\/") && isValidRegExpFlag(flagsStr)) {
                return flagsStr;
            }
            return "";
        };
        var flags = getRegExpFlags(regExpPart, flagsPart);
        if (input.startsWith(FORWARD_SLASH) && input.endsWith(FORWARD_SLASH) || flags) {
            var regExpInput = flags ? regExpPart : input;
            return new RegExp(regExpInput.slice(1, -1), flags);
        }
        var escaped = input.replace(/\\'/g, "'").replace(/\\"/g, '"').replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
        return new RegExp(escaped);
    }
    function getBoostMultiplier(boost) {
        var DEFAULT_MULTIPLIER = .05;
        var MIN_MULTIPLIER = .001;
        var MAX_MULTIPLIER = 50;
        var parsedBoost = parseFloat(boost);
        var boostMultiplier = nativeIsNaN(parsedBoost) || !nativeIsFinite(parsedBoost) ? DEFAULT_MULTIPLIER : parsedBoost;
        if (boostMultiplier < MIN_MULTIPLIER) {
            boostMultiplier = MIN_MULTIPLIER;
        }
        if (boostMultiplier > MAX_MULTIPLIER) {
            boostMultiplier = MAX_MULTIPLIER;
        }
        return boostMultiplier;
    }
    function isDelayMatched(inputDelay, realDelay) {
        return shouldMatchAnyDelay(inputDelay) || realDelay === getMatchDelay(inputDelay);
    }
    function logMessage(source, message) {
        var forced = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
        var convertMessageToString = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
        var {name: name, verbose: verbose} = source;
        if (!forced && !verbose) {
            return;
        }
        var nativeConsole = console.log;
        if (!convertMessageToString) {
            nativeConsole(`${name}:`, message);
            return;
        }
        nativeConsole(`${name}: ${message}`);
    }
    function nativeIsNaN(num) {
        var native = Number.isNaN || window.isNaN;
        return native(num);
    }
    function nativeIsFinite(num) {
        var native = Number.isFinite || window.isFinite;
        return native(num);
    }
    function getMatchDelay(delay) {
        var DEFAULT_DELAY = 1e3;
        var parsedDelay = parseInt(delay, 10);
        var delayMatch = nativeIsNaN(parsedDelay) ? DEFAULT_DELAY : parsedDelay;
        return delayMatch;
    }
    function shouldMatchAnyDelay(delay) {
        return delay === "*";
    }
    var updatedArgs = args ? [].concat(source).concat(args) : [ source ];
    try {
        adjustSetTimeout.apply(this, updatedArgs);
        if (source.uniqueId) {
            Object.defineProperty(Window.prototype.toString, uniqueIdentifier, {
                value: flag,
                enumerable: false,
                writable: false,
                configurable: false
            });
        }
    } catch (e) {
        console.log(e);
    }
}

function callNoThrow(source, args) {
    var flag = "done";
    var uniqueIdentifier = source.uniqueId + source.name + "_" + (Array.isArray(args) ? args.join("_") : "");
    if (source.uniqueId) {
        if (Window.prototype.toString[uniqueIdentifier] === flag) {
            return;
        }
    }
    function callNoThrow(source, functionName) {
        if (!functionName) {
            return;
        }
        var {base: base, prop: prop} = getPropertyInChain(window, functionName);
        if (!base || !prop || typeof base[prop] !== "function") {
            var message = `${functionName} is not a function`;
            logMessage(source, message);
            return;
        }
        var objectWrapper = function objectWrapper() {
            var result;
            try {
                result = Reflect.apply(...arguments);
            } catch (e) {
                var _message = `Error calling ${functionName}: ${e.message}`;
                logMessage(source, _message);
            }
            hit(source);
            return result;
        };
        var objectHandler = {
            apply: objectWrapper
        };
        base[prop] = new Proxy(base[prop], objectHandler);
    }
    function hit(source) {
        var ADGUARD_PREFIX = "[AdGuard]";
        if (!source.verbose) {
            return;
        }
        try {
            var trace = console.trace.bind(console);
            var label = `${ADGUARD_PREFIX} `;
            if (source.engine === "corelibs") {
                label += source.ruleText;
            } else {
                if (source.domainName) {
                    label += `${source.domainName}`;
                }
                if (source.args) {
                    label += `#%#//scriptlet('${source.name}', '${source.args.join("', '")}')`;
                } else {
                    label += `#%#//scriptlet('${source.name}')`;
                }
            }
            if (trace) {
                trace(label);
            }
        } catch (e) {}
        if (typeof window.__debug === "function") {
            window.__debug(source);
        }
    }
    function getPropertyInChain(base, chain) {
        var pos = chain.indexOf(".");
        if (pos === -1) {
            return {
                base: base,
                prop: chain
            };
        }
        var prop = chain.slice(0, pos);
        if (base === null) {
            return {
                base: base,
                prop: prop,
                chain: chain
            };
        }
        var nextBase = base[prop];
        chain = chain.slice(pos + 1);
        if ((base instanceof Object || typeof base === "object") && isEmptyObject(base)) {
            return {
                base: base,
                prop: prop,
                chain: chain
            };
        }
        if (nextBase === null) {
            return {
                base: base,
                prop: prop,
                chain: chain
            };
        }
        if (nextBase !== undefined) {
            return getPropertyInChain(nextBase, chain);
        }
        Object.defineProperty(base, prop, {
            configurable: true
        });
        return {
            base: base,
            prop: prop,
            chain: chain
        };
    }
    function logMessage(source, message) {
        var forced = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
        var convertMessageToString = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
        var {name: name, verbose: verbose} = source;
        if (!forced && !verbose) {
            return;
        }
        var nativeConsole = console.log;
        if (!convertMessageToString) {
            nativeConsole(`${name}:`, message);
            return;
        }
        nativeConsole(`${name}: ${message}`);
    }
    function isEmptyObject(obj) {
        return Object.keys(obj).length === 0 && !obj.prototype;
    }
    var updatedArgs = args ? [].concat(source).concat(args) : [ source ];
    try {
        callNoThrow.apply(this, updatedArgs);
        if (source.uniqueId) {
            Object.defineProperty(Window.prototype.toString, uniqueIdentifier, {
                value: flag,
                enumerable: false,
                writable: false,
                configurable: false
            });
        }
    } catch (e) {
        console.log(e);
    }
}

function debugCurrentInlineScript(source, args) {
    var flag = "done";
    var uniqueIdentifier = source.uniqueId + source.name + "_" + (Array.isArray(args) ? args.join("_") : "");
    if (source.uniqueId) {
        if (Window.prototype.toString[uniqueIdentifier] === flag) {
            return;
        }
    }
    function debugCurrentInlineScript(source, property, search) {
        var searchRegexp = toRegExp(search);
        var rid = randomId();
        var getCurrentScript = function getCurrentScript() {
            if ("currentScript" in document) {
                return document.currentScript;
            }
            var scripts = document.getElementsByTagName("script");
            return scripts[scripts.length - 1];
        };
        var ourScript = getCurrentScript();
        var abort = function abort() {
            var scriptEl = getCurrentScript();
            if (!scriptEl) {
                return;
            }
            var content = scriptEl.textContent;
            try {
                var textContentGetter = Object.getOwnPropertyDescriptor(Node.prototype, "textContent").get;
                content = textContentGetter.call(scriptEl);
            } catch (e) {}
            if (scriptEl instanceof HTMLScriptElement && content.length > 0 && scriptEl !== ourScript && searchRegexp.test(content)) {
                hit(source);
                debugger;
            }
        };
        var _setChainPropAccess = function setChainPropAccess(owner, property) {
            var chainInfo = getPropertyInChain(owner, property);
            var {base: base} = chainInfo;
            var {prop: prop, chain: chain} = chainInfo;
            if (base instanceof Object === false && base === null) {
                var props = property.split(".");
                var propIndex = props.indexOf(prop);
                var baseName = props[propIndex - 1];
                var message = `The scriptlet had been executed before the ${baseName} was loaded.`;
                logMessage(message, source.verbose);
                return;
            }
            if (chain) {
                var setter = function setter(a) {
                    base = a;
                    if (a instanceof Object) {
                        _setChainPropAccess(a, chain);
                    }
                };
                Object.defineProperty(owner, prop, {
                    get: function get() {
                        return base;
                    },
                    set: setter
                });
                return;
            }
            var currentValue = base[prop];
            setPropertyAccess(base, prop, {
                set: function set(value) {
                    abort();
                    currentValue = value;
                },
                get: function get() {
                    abort();
                    return currentValue;
                }
            });
        };
        _setChainPropAccess(window, property);
        window.onerror = createOnErrorHandler(rid).bind();
    }
    function randomId() {
        return Math.random().toString(36).slice(2, 9);
    }
    function setPropertyAccess(object, property, descriptor) {
        var currentDescriptor = Object.getOwnPropertyDescriptor(object, property);
        if (currentDescriptor && !currentDescriptor.configurable) {
            return false;
        }
        Object.defineProperty(object, property, descriptor);
        return true;
    }
    function getPropertyInChain(base, chain) {
        var pos = chain.indexOf(".");
        if (pos === -1) {
            return {
                base: base,
                prop: chain
            };
        }
        var prop = chain.slice(0, pos);
        if (base === null) {
            return {
                base: base,
                prop: prop,
                chain: chain
            };
        }
        var nextBase = base[prop];
        chain = chain.slice(pos + 1);
        if ((base instanceof Object || typeof base === "object") && isEmptyObject(base)) {
            return {
                base: base,
                prop: prop,
                chain: chain
            };
        }
        if (nextBase === null) {
            return {
                base: base,
                prop: prop,
                chain: chain
            };
        }
        if (nextBase !== undefined) {
            return getPropertyInChain(nextBase, chain);
        }
        Object.defineProperty(base, prop, {
            configurable: true
        });
        return {
            base: base,
            prop: prop,
            chain: chain
        };
    }
    function toRegExp(rawInput) {
        var input = rawInput || "";
        var DEFAULT_VALUE = ".?";
        var FORWARD_SLASH = "/";
        if (input === "") {
            return new RegExp(DEFAULT_VALUE);
        }
        var delimiterIndex = input.lastIndexOf(FORWARD_SLASH);
        var flagsPart = input.substring(delimiterIndex + 1);
        var regExpPart = input.substring(0, delimiterIndex + 1);
        var isValidRegExpFlag = function isValidRegExpFlag(flag) {
            if (!flag) {
                return false;
            }
            try {
                new RegExp("", flag);
                return true;
            } catch (ex) {
                return false;
            }
        };
        var getRegExpFlags = function getRegExpFlags(regExpStr, flagsStr) {
            if (regExpStr.startsWith(FORWARD_SLASH) && regExpStr.endsWith(FORWARD_SLASH) && !regExpStr.endsWith("\\/") && isValidRegExpFlag(flagsStr)) {
                return flagsStr;
            }
            return "";
        };
        var flags = getRegExpFlags(regExpPart, flagsPart);
        if (input.startsWith(FORWARD_SLASH) && input.endsWith(FORWARD_SLASH) || flags) {
            var regExpInput = flags ? regExpPart : input;
            return new RegExp(regExpInput.slice(1, -1), flags);
        }
        var escaped = input.replace(/\\'/g, "'").replace(/\\"/g, '"').replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
        return new RegExp(escaped);
    }
    function createOnErrorHandler(rid) {
        var nativeOnError = window.onerror;
        return function onError(error) {
            if (typeof error === "string" && error.includes(rid)) {
                return true;
            }
            if (nativeOnError instanceof Function) {
                for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
                    args[_key - 1] = arguments[_key];
                }
                return nativeOnError.apply(window, [ error, ...args ]);
            }
            return false;
        };
    }
    function hit(source) {
        var ADGUARD_PREFIX = "[AdGuard]";
        if (!source.verbose) {
            return;
        }
        try {
            var trace = console.trace.bind(console);
            var label = `${ADGUARD_PREFIX} `;
            if (source.engine === "corelibs") {
                label += source.ruleText;
            } else {
                if (source.domainName) {
                    label += `${source.domainName}`;
                }
                if (source.args) {
                    label += `#%#//scriptlet('${source.name}', '${source.args.join("', '")}')`;
                } else {
                    label += `#%#//scriptlet('${source.name}')`;
                }
            }
            if (trace) {
                trace(label);
            }
        } catch (e) {}
        if (typeof window.__debug === "function") {
            window.__debug(source);
        }
    }
    function logMessage(source, message) {
        var forced = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
        var convertMessageToString = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
        var {name: name, verbose: verbose} = source;
        if (!forced && !verbose) {
            return;
        }
        var nativeConsole = console.log;
        if (!convertMessageToString) {
            nativeConsole(`${name}:`, message);
            return;
        }
        nativeConsole(`${name}: ${message}`);
    }
    function isEmptyObject(obj) {
        return Object.keys(obj).length === 0 && !obj.prototype;
    }
    var updatedArgs = args ? [].concat(source).concat(args) : [ source ];
    try {
        debugCurrentInlineScript.apply(this, updatedArgs);
        if (source.uniqueId) {
            Object.defineProperty(Window.prototype.toString, uniqueIdentifier, {
                value: flag,
                enumerable: false,
                writable: false,
                configurable: false
            });
        }
    } catch (e) {
        console.log(e);
    }
}

function debugOnPropertyRead(source, args) {
    var flag = "done";
    var uniqueIdentifier = source.uniqueId + source.name + "_" + (Array.isArray(args) ? args.join("_") : "");
    if (source.uniqueId) {
        if (Window.prototype.toString[uniqueIdentifier] === flag) {
            return;
        }
    }
    function debugOnPropertyRead(source, property) {
        if (!property) {
            return;
        }
        var rid = randomId();
        var abort = function abort() {
            hit(source);
            debugger;
        };
        var _setChainPropAccess = function setChainPropAccess(owner, property) {
            var chainInfo = getPropertyInChain(owner, property);
            var {base: base} = chainInfo;
            var {prop: prop, chain: chain} = chainInfo;
            if (chain) {
                var setter = function setter(a) {
                    base = a;
                    if (a instanceof Object) {
                        _setChainPropAccess(a, chain);
                    }
                };
                Object.defineProperty(owner, prop, {
                    get: function get() {
                        return base;
                    },
                    set: setter
                });
                return;
            }
            setPropertyAccess(base, prop, {
                get: abort,
                set: noopFunc
            });
        };
        _setChainPropAccess(window, property);
        window.onerror = createOnErrorHandler(rid).bind();
    }
    function randomId() {
        return Math.random().toString(36).slice(2, 9);
    }
    function setPropertyAccess(object, property, descriptor) {
        var currentDescriptor = Object.getOwnPropertyDescriptor(object, property);
        if (currentDescriptor && !currentDescriptor.configurable) {
            return false;
        }
        Object.defineProperty(object, property, descriptor);
        return true;
    }
    function getPropertyInChain(base, chain) {
        var pos = chain.indexOf(".");
        if (pos === -1) {
            return {
                base: base,
                prop: chain
            };
        }
        var prop = chain.slice(0, pos);
        if (base === null) {
            return {
                base: base,
                prop: prop,
                chain: chain
            };
        }
        var nextBase = base[prop];
        chain = chain.slice(pos + 1);
        if ((base instanceof Object || typeof base === "object") && isEmptyObject(base)) {
            return {
                base: base,
                prop: prop,
                chain: chain
            };
        }
        if (nextBase === null) {
            return {
                base: base,
                prop: prop,
                chain: chain
            };
        }
        if (nextBase !== undefined) {
            return getPropertyInChain(nextBase, chain);
        }
        Object.defineProperty(base, prop, {
            configurable: true
        });
        return {
            base: base,
            prop: prop,
            chain: chain
        };
    }
    function createOnErrorHandler(rid) {
        var nativeOnError = window.onerror;
        return function onError(error) {
            if (typeof error === "string" && error.includes(rid)) {
                return true;
            }
            if (nativeOnError instanceof Function) {
                for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
                    args[_key - 1] = arguments[_key];
                }
                return nativeOnError.apply(window, [ error, ...args ]);
            }
            return false;
        };
    }
    function hit(source) {
        var ADGUARD_PREFIX = "[AdGuard]";
        if (!source.verbose) {
            return;
        }
        try {
            var trace = console.trace.bind(console);
            var label = `${ADGUARD_PREFIX} `;
            if (source.engine === "corelibs") {
                label += source.ruleText;
            } else {
                if (source.domainName) {
                    label += `${source.domainName}`;
                }
                if (source.args) {
                    label += `#%#//scriptlet('${source.name}', '${source.args.join("', '")}')`;
                } else {
                    label += `#%#//scriptlet('${source.name}')`;
                }
            }
            if (trace) {
                trace(label);
            }
        } catch (e) {}
        if (typeof window.__debug === "function") {
            window.__debug(source);
        }
    }
    function noopFunc() {}
    function isEmptyObject(obj) {
        return Object.keys(obj).length === 0 && !obj.prototype;
    }
    var updatedArgs = args ? [].concat(source).concat(args) : [ source ];
    try {
        debugOnPropertyRead.apply(this, updatedArgs);
        if (source.uniqueId) {
            Object.defineProperty(Window.prototype.toString, uniqueIdentifier, {
                value: flag,
                enumerable: false,
                writable: false,
                configurable: false
            });
        }
    } catch (e) {
        console.log(e);
    }
}

function debugOnPropertyWrite(source, args) {
    var flag = "done";
    var uniqueIdentifier = source.uniqueId + source.name + "_" + (Array.isArray(args) ? args.join("_") : "");
    if (source.uniqueId) {
        if (Window.prototype.toString[uniqueIdentifier] === flag) {
            return;
        }
    }
    function debugOnPropertyWrite(source, property) {
        if (!property) {
            return;
        }
        var rid = randomId();
        var abort = function abort() {
            hit(source);
            debugger;
        };
        var _setChainPropAccess = function setChainPropAccess(owner, property) {
            var chainInfo = getPropertyInChain(owner, property);
            var {base: base} = chainInfo;
            var {prop: prop, chain: chain} = chainInfo;
            if (chain) {
                var setter = function setter(a) {
                    base = a;
                    if (a instanceof Object) {
                        _setChainPropAccess(a, chain);
                    }
                };
                Object.defineProperty(owner, prop, {
                    get: function get() {
                        return base;
                    },
                    set: setter
                });
                return;
            }
            setPropertyAccess(base, prop, {
                set: abort
            });
        };
        _setChainPropAccess(window, property);
        window.onerror = createOnErrorHandler(rid).bind();
    }
    function randomId() {
        return Math.random().toString(36).slice(2, 9);
    }
    function setPropertyAccess(object, property, descriptor) {
        var currentDescriptor = Object.getOwnPropertyDescriptor(object, property);
        if (currentDescriptor && !currentDescriptor.configurable) {
            return false;
        }
        Object.defineProperty(object, property, descriptor);
        return true;
    }
    function getPropertyInChain(base, chain) {
        var pos = chain.indexOf(".");
        if (pos === -1) {
            return {
                base: base,
                prop: chain
            };
        }
        var prop = chain.slice(0, pos);
        if (base === null) {
            return {
                base: base,
                prop: prop,
                chain: chain
            };
        }
        var nextBase = base[prop];
        chain = chain.slice(pos + 1);
        if ((base instanceof Object || typeof base === "object") && isEmptyObject(base)) {
            return {
                base: base,
                prop: prop,
                chain: chain
            };
        }
        if (nextBase === null) {
            return {
                base: base,
                prop: prop,
                chain: chain
            };
        }
        if (nextBase !== undefined) {
            return getPropertyInChain(nextBase, chain);
        }
        Object.defineProperty(base, prop, {
            configurable: true
        });
        return {
            base: base,
            prop: prop,
            chain: chain
        };
    }
    function createOnErrorHandler(rid) {
        var nativeOnError = window.onerror;
        return function onError(error) {
            if (typeof error === "string" && error.includes(rid)) {
                return true;
            }
            if (nativeOnError instanceof Function) {
                for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
                    args[_key - 1] = arguments[_key];
                }
                return nativeOnError.apply(window, [ error, ...args ]);
            }
            return false;
        };
    }
    function hit(source) {
        var ADGUARD_PREFIX = "[AdGuard]";
        if (!source.verbose) {
            return;
        }
        try {
            var trace = console.trace.bind(console);
            var label = `${ADGUARD_PREFIX} `;
            if (source.engine === "corelibs") {
                label += source.ruleText;
            } else {
                if (source.domainName) {
                    label += `${source.domainName}`;
                }
                if (source.args) {
                    label += `#%#//scriptlet('${source.name}', '${source.args.join("', '")}')`;
                } else {
                    label += `#%#//scriptlet('${source.name}')`;
                }
            }
            if (trace) {
                trace(label);
            }
        } catch (e) {}
        if (typeof window.__debug === "function") {
            window.__debug(source);
        }
    }
    function isEmptyObject(obj) {
        return Object.keys(obj).length === 0 && !obj.prototype;
    }
    var updatedArgs = args ? [].concat(source).concat(args) : [ source ];
    try {
        debugOnPropertyWrite.apply(this, updatedArgs);
        if (source.uniqueId) {
            Object.defineProperty(Window.prototype.toString, uniqueIdentifier, {
                value: flag,
                enumerable: false,
                writable: false,
                configurable: false
            });
        }
    } catch (e) {
        console.log(e);
    }
}

function dirString(source, args) {
    var flag = "done";
    var uniqueIdentifier = source.uniqueId + source.name + "_" + (Array.isArray(args) ? args.join("_") : "");
    if (source.uniqueId) {
        if (Window.prototype.toString[uniqueIdentifier] === flag) {
            return;
        }
    }
    function dirString(source, times) {
        var {dir: dir} = console;
        function dirWrapper(object) {
            if (typeof dir === "function") {
                dir.call(this, object);
            }
            hit(source);
        }
        console.dir = dirWrapper;
    }
    function hit(source) {
        var ADGUARD_PREFIX = "[AdGuard]";
        if (!source.verbose) {
            return;
        }
        try {
            var trace = console.trace.bind(console);
            var label = `${ADGUARD_PREFIX} `;
            if (source.engine === "corelibs") {
                label += source.ruleText;
            } else {
                if (source.domainName) {
                    label += `${source.domainName}`;
                }
                if (source.args) {
                    label += `#%#//scriptlet('${source.name}', '${source.args.join("', '")}')`;
                } else {
                    label += `#%#//scriptlet('${source.name}')`;
                }
            }
            if (trace) {
                trace(label);
            }
        } catch (e) {}
        if (typeof window.__debug === "function") {
            window.__debug(source);
        }
    }
    var updatedArgs = args ? [].concat(source).concat(args) : [ source ];
    try {
        dirString.apply(this, updatedArgs);
        if (source.uniqueId) {
            Object.defineProperty(Window.prototype.toString, uniqueIdentifier, {
                value: flag,
                enumerable: false,
                writable: false,
                configurable: false
            });
        }
    } catch (e) {
        console.log(e);
    }
}

function disableNewtabLinks(source, args) {
    var flag = "done";
    var uniqueIdentifier = source.uniqueId + source.name + "_" + (Array.isArray(args) ? args.join("_") : "");
    if (source.uniqueId) {
        if (Window.prototype.toString[uniqueIdentifier] === flag) {
            return;
        }
    }
    function disableNewtabLinks(source) {
        document.addEventListener("click", (function(ev) {
            var {target: target} = ev;
            while (target !== null) {
                if (target.localName === "a" && target.hasAttribute("target")) {
                    ev.stopPropagation();
                    ev.preventDefault();
                    hit(source);
                    break;
                }
                target = target.parentNode;
            }
        }));
    }
    function hit(source) {
        var ADGUARD_PREFIX = "[AdGuard]";
        if (!source.verbose) {
            return;
        }
        try {
            var trace = console.trace.bind(console);
            var label = `${ADGUARD_PREFIX} `;
            if (source.engine === "corelibs") {
                label += source.ruleText;
            } else {
                if (source.domainName) {
                    label += `${source.domainName}`;
                }
                if (source.args) {
                    label += `#%#//scriptlet('${source.name}', '${source.args.join("', '")}')`;
                } else {
                    label += `#%#//scriptlet('${source.name}')`;
                }
            }
            if (trace) {
                trace(label);
            }
        } catch (e) {}
        if (typeof window.__debug === "function") {
            window.__debug(source);
        }
    }
    var updatedArgs = args ? [].concat(source).concat(args) : [ source ];
    try {
        disableNewtabLinks.apply(this, updatedArgs);
        if (source.uniqueId) {
            Object.defineProperty(Window.prototype.toString, uniqueIdentifier, {
                value: flag,
                enumerable: false,
                writable: false,
                configurable: false
            });
        }
    } catch (e) {
        console.log(e);
    }
}

function evalDataPrune(source, args) {
    var flag = "done";
    var uniqueIdentifier = source.uniqueId + source.name + "_" + (Array.isArray(args) ? args.join("_") : "");
    if (source.uniqueId) {
        if (Window.prototype.toString[uniqueIdentifier] === flag) {
            return;
        }
    }
    function evalDataPrune(source, propsToRemove, requiredInitialProps, stack) {
        var prunePaths = getPrunePath(propsToRemove);
        var requiredPaths = getPrunePath(requiredInitialProps);
        var nativeObjects = {
            nativeStringify: window.JSON.stringify
        };
        var evalWrapper = function evalWrapper(target, thisArg, args) {
            var data = Reflect.apply(target, thisArg, args);
            if (typeof data === "object") {
                data = jsonPruner(source, data, prunePaths, requiredPaths, stack, nativeObjects);
            }
            return data;
        };
        var evalHandler = {
            apply: evalWrapper
        };
        window.eval = new Proxy(window.eval, evalHandler);
    }
    function hit(source) {
        var ADGUARD_PREFIX = "[AdGuard]";
        if (!source.verbose) {
            return;
        }
        try {
            var trace = console.trace.bind(console);
            var label = `${ADGUARD_PREFIX} `;
            if (source.engine === "corelibs") {
                label += source.ruleText;
            } else {
                if (source.domainName) {
                    label += `${source.domainName}`;
                }
                if (source.args) {
                    label += `#%#//scriptlet('${source.name}', '${source.args.join("', '")}')`;
                } else {
                    label += `#%#//scriptlet('${source.name}')`;
                }
            }
            if (trace) {
                trace(label);
            }
        } catch (e) {}
        if (typeof window.__debug === "function") {
            window.__debug(source);
        }
    }
    function matchStackTrace(stackMatch, stackTrace) {
        if (!stackMatch || stackMatch === "") {
            return true;
        }
        var regExpValues = backupRegExpValues();
        if (shouldAbortInlineOrInjectedScript(stackMatch, stackTrace)) {
            if (regExpValues.length && regExpValues[0] !== RegExp.$1) {
                restoreRegExpValues(regExpValues);
            }
            return true;
        }
        var stackRegexp = toRegExp(stackMatch);
        var refinedStackTrace = stackTrace.split("\n").slice(2).map((function(line) {
            return line.trim();
        })).join("\n");
        if (regExpValues.length && regExpValues[0] !== RegExp.$1) {
            restoreRegExpValues(regExpValues);
        }
        return getNativeRegexpTest().call(stackRegexp, refinedStackTrace);
    }
    function getWildcardPropertyInChain(base, chain) {
        var lookThrough = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
        var output = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [];
        var valueToCheck = arguments.length > 4 ? arguments[4] : undefined;
        var pos = chain.indexOf(".");
        if (pos === -1) {
            if (chain === "*" || chain === "[]") {
                for (var key in base) {
                    if (Object.prototype.hasOwnProperty.call(base, key)) {
                        if (valueToCheck !== undefined) {
                            var objectValue = base[key];
                            if (typeof objectValue === "string" && valueToCheck instanceof RegExp) {
                                if (valueToCheck.test(objectValue)) {
                                    output.push({
                                        base: base,
                                        prop: key
                                    });
                                }
                            } else if (objectValue === valueToCheck) {
                                output.push({
                                    base: base,
                                    prop: key
                                });
                            }
                        } else {
                            output.push({
                                base: base,
                                prop: key
                            });
                        }
                    }
                }
            } else if (valueToCheck !== undefined) {
                var _objectValue = base[chain];
                if (typeof _objectValue === "string" && valueToCheck instanceof RegExp) {
                    if (valueToCheck.test(_objectValue)) {
                        output.push({
                            base: base,
                            prop: chain
                        });
                    }
                } else if (base[chain] === valueToCheck) {
                    output.push({
                        base: base,
                        prop: chain
                    });
                }
            } else {
                output.push({
                    base: base,
                    prop: chain
                });
            }
            return output;
        }
        var prop = chain.slice(0, pos);
        var shouldLookThrough = prop === "[]" && Array.isArray(base) || prop === "*" && base instanceof Object || prop === "[-]" && Array.isArray(base) || prop === "{-}" && base instanceof Object;
        if (shouldLookThrough) {
            var nextProp = chain.slice(pos + 1);
            var baseKeys = Object.keys(base);
            if (prop === "{-}" || prop === "[-]") {
                var type = Array.isArray(base) ? "array" : "object";
                var shouldRemove = !!(prop === "{-}" && type === "object") || !!(prop === "[-]" && type === "array");
                if (!shouldRemove) {
                    return output;
                }
                baseKeys.forEach((function(key) {
                    var item = base[key];
                    if (isKeyInObject(item, nextProp, valueToCheck)) {
                        output.push({
                            base: base,
                            prop: key
                        });
                    }
                }));
                return output;
            }
            baseKeys.forEach((function(key) {
                var item = base[key];
                getWildcardPropertyInChain(item, nextProp, lookThrough, output, valueToCheck);
            }));
        }
        if (Array.isArray(base)) {
            base.forEach((function(key) {
                var nextBase = key;
                if (nextBase !== undefined) {
                    getWildcardPropertyInChain(nextBase, chain, lookThrough, output, valueToCheck);
                }
            }));
        }
        var nextBase = base[prop];
        chain = chain.slice(pos + 1);
        if (nextBase !== undefined) {
            getWildcardPropertyInChain(nextBase, chain, lookThrough, output, valueToCheck);
        }
        return output;
    }
    function logMessage(source, message) {
        var forced = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
        var convertMessageToString = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
        var {name: name, verbose: verbose} = source;
        if (!forced && !verbose) {
            return;
        }
        var nativeConsole = console.log;
        if (!convertMessageToString) {
            nativeConsole(`${name}:`, message);
            return;
        }
        nativeConsole(`${name}: ${message}`);
    }
    function toRegExp(rawInput) {
        var input = rawInput || "";
        var DEFAULT_VALUE = ".?";
        var FORWARD_SLASH = "/";
        if (input === "") {
            return new RegExp(DEFAULT_VALUE);
        }
        var delimiterIndex = input.lastIndexOf(FORWARD_SLASH);
        var flagsPart = input.substring(delimiterIndex + 1);
        var regExpPart = input.substring(0, delimiterIndex + 1);
        var isValidRegExpFlag = function isValidRegExpFlag(flag) {
            if (!flag) {
                return false;
            }
            try {
                new RegExp("", flag);
                return true;
            } catch (ex) {
                return false;
            }
        };
        var getRegExpFlags = function getRegExpFlags(regExpStr, flagsStr) {
            if (regExpStr.startsWith(FORWARD_SLASH) && regExpStr.endsWith(FORWARD_SLASH) && !regExpStr.endsWith("\\/") && isValidRegExpFlag(flagsStr)) {
                return flagsStr;
            }
            return "";
        };
        var flags = getRegExpFlags(regExpPart, flagsPart);
        if (input.startsWith(FORWARD_SLASH) && input.endsWith(FORWARD_SLASH) || flags) {
            var regExpInput = flags ? regExpPart : input;
            return new RegExp(regExpInput.slice(1, -1), flags);
        }
        var escaped = input.replace(/\\'/g, "'").replace(/\\"/g, '"').replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
        return new RegExp(escaped);
    }
    function isPruningNeeded(source, root, prunePaths, requiredPaths, stack, nativeObjects) {
        if (!root) {
            return false;
        }
        var {nativeStringify: nativeStringify} = nativeObjects;
        var shouldProcess;
        var prunePathsToCheck = prunePaths.map((function(obj) {
            return obj.path;
        }));
        var requiredPathsToCheck = requiredPaths.map((function(obj) {
            return obj.path;
        }));
        if (prunePathsToCheck.length === 0 && requiredPathsToCheck.length > 0) {
            var rootString = nativeStringify(root);
            var matchRegex = toRegExp(requiredPathsToCheck.join(""));
            var shouldLog = matchRegex.test(rootString);
            if (shouldLog) {
                logMessage(source, `${window.location.hostname}\n${nativeStringify(root, null, 2)}\nStack trace:\n${(new Error).stack}`, true);
                if (root && typeof root === "object") {
                    logMessage(source, root, true, false);
                }
                shouldProcess = false;
                return shouldProcess;
            }
        }
        if (stack && !matchStackTrace(stack, (new Error).stack || "")) {
            shouldProcess = false;
            return shouldProcess;
        }
        var wildcardSymbols = [ ".*.", "*.", ".*", ".[].", "[].", ".[]" ];
        var _loop = function _loop() {
            var requiredPath = requiredPathsToCheck[i];
            var lastNestedPropName = requiredPath.split(".").pop();
            var hasWildcard = wildcardSymbols.some((function(symbol) {
                return requiredPath.includes(symbol);
            }));
            var details = getWildcardPropertyInChain(root, requiredPath, hasWildcard);
            if (!details.length) {
                shouldProcess = false;
                return {
                    v: shouldProcess
                };
            }
            shouldProcess = !hasWildcard;
            for (var j = 0; j < details.length; j += 1) {
                var hasRequiredProp = typeof lastNestedPropName === "string" && details[j].base[lastNestedPropName] !== undefined;
                if (hasWildcard) {
                    shouldProcess = hasRequiredProp || shouldProcess;
                } else {
                    shouldProcess = hasRequiredProp && shouldProcess;
                }
            }
        }, _ret;
        for (var i = 0; i < requiredPathsToCheck.length; i += 1) {
            _ret = _loop();
            if (_ret) return _ret.v;
        }
        return shouldProcess;
    }
    function jsonPruner(source, root, prunePaths, requiredPaths, stack, nativeObjects) {
        var {nativeStringify: nativeStringify} = nativeObjects;
        if (prunePaths.length === 0 && requiredPaths.length === 0) {
            logMessage(source, `${window.location.hostname}\n${nativeStringify(root, null, 2)}\nStack trace:\n${(new Error).stack}`, true);
            if (root && typeof root === "object") {
                logMessage(source, root, true, false);
            }
            return root;
        }
        try {
            if (isPruningNeeded(source, root, prunePaths, requiredPaths, stack, nativeObjects) === false) {
                return root;
            }
            prunePaths.forEach((function(path) {
                var pathToCheck = path.path;
                var valueToCheck = path.value;
                var ownerObjArr = getWildcardPropertyInChain(root, pathToCheck, true, [], valueToCheck);
                for (var i = ownerObjArr.length - 1; i >= 0; i -= 1) {
                    var ownerObj = ownerObjArr[i];
                    if (ownerObj === undefined || !ownerObj.base) {
                        continue;
                    }
                    hit(source);
                    if (!Array.isArray(ownerObj.base)) {
                        delete ownerObj.base[ownerObj.prop];
                        continue;
                    }
                    try {
                        var index = Number(ownerObj.prop);
                        if (Number.isNaN(index)) {
                            continue;
                        }
                        ownerObj.base.splice(index, 1);
                    } catch (error) {
                        console.error("Error while deleting array element", error);
                    }
                }
            }));
        } catch (e) {
            logMessage(source, e);
        }
        return root;
    }
    function getPrunePath(props) {
        var VALUE_MARKER = ".[=].";
        var REGEXP_START_MARKER = "/";
        var validPropsString = typeof props === "string" && props !== undefined && props !== "";
        if (validPropsString) {
            var splitRegexp = /(?<!\.\[=\]\.\/(?:[^/]|\\.)*)\s+/;
            var parts = props.split(splitRegexp).map((function(part) {
                var splitPart = part.split(VALUE_MARKER);
                var path = splitPart[0];
                var value = splitPart[1];
                if (value !== undefined) {
                    if (value === "true") {
                        value = true;
                    } else if (value === "false") {
                        value = false;
                    } else if (value.startsWith(REGEXP_START_MARKER)) {
                        value = toRegExp(value);
                    } else if (typeof value === "string" && /^\d+$/.test(value)) {
                        value = parseFloat(value);
                    }
                    return {
                        path: path,
                        value: value
                    };
                }
                return {
                    path: path
                };
            }));
            return parts;
        }
        return [];
    }
    function getNativeRegexpTest() {
        var descriptor = Object.getOwnPropertyDescriptor(RegExp.prototype, "test");
        var nativeRegexTest = descriptor === null || descriptor === void 0 ? void 0 : descriptor.value;
        if (descriptor && typeof descriptor.value === "function") {
            return nativeRegexTest;
        }
        throw new Error("RegExp.prototype.test is not a function");
    }
    function shouldAbortInlineOrInjectedScript(stackMatch, stackTrace) {
        var INLINE_SCRIPT_STRING = "inlineScript";
        var INJECTED_SCRIPT_STRING = "injectedScript";
        var INJECTED_SCRIPT_MARKER = "<anonymous>";
        var isInlineScript = function isInlineScript(match) {
            return match.includes(INLINE_SCRIPT_STRING);
        };
        var isInjectedScript = function isInjectedScript(match) {
            return match.includes(INJECTED_SCRIPT_STRING);
        };
        if (!(isInlineScript(stackMatch) || isInjectedScript(stackMatch))) {
            return false;
        }
        var documentURL = window.location.href;
        var pos = documentURL.indexOf("#");
        if (pos !== -1) {
            documentURL = documentURL.slice(0, pos);
        }
        var stackSteps = stackTrace.split("\n").slice(2).map((function(line) {
            return line.trim();
        }));
        var stackLines = stackSteps.map((function(line) {
            var stack;
            var getStackTraceValues = /(.*?@)?(\S+)(:\d+)(:\d+)\)?$/.exec(line);
            if (getStackTraceValues) {
                var _stackURL, _stackURL2;
                var stackURL = getStackTraceValues[2];
                var stackLine = getStackTraceValues[3];
                var stackCol = getStackTraceValues[4];
                if ((_stackURL = stackURL) !== null && _stackURL !== void 0 && _stackURL.startsWith("(")) {
                    stackURL = stackURL.slice(1);
                }
                if ((_stackURL2 = stackURL) !== null && _stackURL2 !== void 0 && _stackURL2.startsWith(INJECTED_SCRIPT_MARKER)) {
                    var _stackFunction;
                    stackURL = INJECTED_SCRIPT_STRING;
                    var stackFunction = getStackTraceValues[1] !== undefined ? getStackTraceValues[1].slice(0, -1) : line.slice(0, getStackTraceValues.index).trim();
                    if ((_stackFunction = stackFunction) !== null && _stackFunction !== void 0 && _stackFunction.startsWith("at")) {
                        stackFunction = stackFunction.slice(2).trim();
                    }
                    stack = `${stackFunction} ${stackURL}${stackLine}${stackCol}`.trim();
                } else if (stackURL === documentURL) {
                    stack = `${INLINE_SCRIPT_STRING}${stackLine}${stackCol}`.trim();
                } else {
                    stack = `${stackURL}${stackLine}${stackCol}`.trim();
                }
            } else {
                stack = line;
            }
            return stack;
        }));
        if (stackLines) {
            for (var index = 0; index < stackLines.length; index += 1) {
                if (isInlineScript(stackMatch) && stackLines[index].startsWith(INLINE_SCRIPT_STRING) && stackLines[index].match(toRegExp(stackMatch))) {
                    return true;
                }
                if (isInjectedScript(stackMatch) && stackLines[index].startsWith(INJECTED_SCRIPT_STRING) && stackLines[index].match(toRegExp(stackMatch))) {
                    return true;
                }
            }
        }
        return false;
    }
    function backupRegExpValues() {
        try {
            var arrayOfRegexpValues = [];
            for (var index = 1; index < 10; index += 1) {
                var value = `$${index}`;
                if (!RegExp[value]) {
                    break;
                }
                arrayOfRegexpValues.push(RegExp[value]);
            }
            return arrayOfRegexpValues;
        } catch (error) {
            return [];
        }
    }
    function restoreRegExpValues(array) {
        if (!array.length) {
            return;
        }
        try {
            var stringPattern = "";
            if (array.length === 1) {
                stringPattern = `(${array[0]})`;
            } else {
                stringPattern = array.reduce((function(accumulator, currentValue, currentIndex) {
                    if (currentIndex === 1) {
                        return `(${accumulator}),(${currentValue})`;
                    }
                    return `${accumulator},(${currentValue})`;
                }));
            }
            var regExpGroup = new RegExp(stringPattern);
            array.toString().replace(regExpGroup, "");
        } catch (error) {
            var message = `Failed to restore RegExp values: ${error}`;
            console.log(message);
        }
    }
    function isKeyInObject(baseObj, path, valueToCheck) {
        var parts = path.split(".");
        var _check = function check(targetObject, pathSegments) {
            if (pathSegments.length === 0) {
                if (valueToCheck !== undefined) {
                    if (typeof targetObject === "string" && valueToCheck instanceof RegExp) {
                        return valueToCheck.test(targetObject);
                    }
                    return targetObject === valueToCheck;
                }
                return true;
            }
            var current = pathSegments[0];
            var rest = pathSegments.slice(1);
            if (current === "*" || current === "[]") {
                if (Array.isArray(targetObject)) {
                    return targetObject.some((function(item) {
                        return _check(item, rest);
                    }));
                }
                if (typeof targetObject === "object" && targetObject !== null) {
                    return Object.keys(targetObject).some((function(key) {
                        return _check(targetObject[key], rest);
                    }));
                }
            }
            if (Object.prototype.hasOwnProperty.call(targetObject, current)) {
                return _check(targetObject[current], rest);
            }
            return false;
        };
        return _check(baseObj, parts);
    }
    var updatedArgs = args ? [].concat(source).concat(args) : [ source ];
    try {
        evalDataPrune.apply(this, updatedArgs);
        if (source.uniqueId) {
            Object.defineProperty(Window.prototype.toString, uniqueIdentifier, {
                value: flag,
                enumerable: false,
                writable: false,
                configurable: false
            });
        }
    } catch (e) {
        console.log(e);
    }
}

function forceWindowClose(source, args) {
    var flag = "done";
    var uniqueIdentifier = source.uniqueId + source.name + "_" + (Array.isArray(args) ? args.join("_") : "");
    if (source.uniqueId) {
        if (Window.prototype.toString[uniqueIdentifier] === flag) {
            return;
        }
    }
    function forceWindowClose(source) {
        var path = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "";
        if (typeof window.close !== "function") {
            var message = "window.close() is not a function so 'close-window' scriptlet is unavailable";
            logMessage(source, message);
            return;
        }
        var closeImmediately = function closeImmediately() {
            try {
                hit(source);
                window.close();
            } catch (e) {
                logMessage(source, e);
            }
        };
        var closeByExtension = function closeByExtension() {
            var extCall = function extCall() {
                dispatchEvent(new Event("adguard:scriptlet-close-window"));
            };
            window.addEventListener("adguard:subscribed-to-close-window", extCall, {
                once: true
            });
            setTimeout((function() {
                window.removeEventListener("adguard:subscribed-to-close-window", extCall, {
                    once: true
                });
            }), 5e3);
        };
        var shouldClose = function shouldClose() {
            if (path === "") {
                return true;
            }
            var pathRegexp = toRegExp(path);
            var currentPath = `${window.location.pathname}${window.location.search}`;
            return pathRegexp.test(currentPath);
        };
        if (shouldClose()) {
            closeImmediately();
            if (navigator.userAgent.includes("Chrome")) {
                closeByExtension();
            }
        }
    }
    function hit(source) {
        var ADGUARD_PREFIX = "[AdGuard]";
        if (!source.verbose) {
            return;
        }
        try {
            var trace = console.trace.bind(console);
            var label = `${ADGUARD_PREFIX} `;
            if (source.engine === "corelibs") {
                label += source.ruleText;
            } else {
                if (source.domainName) {
                    label += `${source.domainName}`;
                }
                if (source.args) {
                    label += `#%#//scriptlet('${source.name}', '${source.args.join("', '")}')`;
                } else {
                    label += `#%#//scriptlet('${source.name}')`;
                }
            }
            if (trace) {
                trace(label);
            }
        } catch (e) {}
        if (typeof window.__debug === "function") {
            window.__debug(source);
        }
    }
    function toRegExp(rawInput) {
        var input = rawInput || "";
        var DEFAULT_VALUE = ".?";
        var FORWARD_SLASH = "/";
        if (input === "") {
            return new RegExp(DEFAULT_VALUE);
        }
        var delimiterIndex = input.lastIndexOf(FORWARD_SLASH);
        var flagsPart = input.substring(delimiterIndex + 1);
        var regExpPart = input.substring(0, delimiterIndex + 1);
        var isValidRegExpFlag = function isValidRegExpFlag(flag) {
            if (!flag) {
                return false;
            }
            try {
                new RegExp("", flag);
                return true;
            } catch (ex) {
                return false;
            }
        };
        var getRegExpFlags = function getRegExpFlags(regExpStr, flagsStr) {
            if (regExpStr.startsWith(FORWARD_SLASH) && regExpStr.endsWith(FORWARD_SLASH) && !regExpStr.endsWith("\\/") && isValidRegExpFlag(flagsStr)) {
                return flagsStr;
            }
            return "";
        };
        var flags = getRegExpFlags(regExpPart, flagsPart);
        if (input.startsWith(FORWARD_SLASH) && input.endsWith(FORWARD_SLASH) || flags) {
            var regExpInput = flags ? regExpPart : input;
            return new RegExp(regExpInput.slice(1, -1), flags);
        }
        var escaped = input.replace(/\\'/g, "'").replace(/\\"/g, '"').replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
        return new RegExp(escaped);
    }
    function logMessage(source, message) {
        var forced = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
        var convertMessageToString = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
        var {name: name, verbose: verbose} = source;
        if (!forced && !verbose) {
            return;
        }
        var nativeConsole = console.log;
        if (!convertMessageToString) {
            nativeConsole(`${name}:`, message);
            return;
        }
        nativeConsole(`${name}: ${message}`);
    }
    var updatedArgs = args ? [].concat(source).concat(args) : [ source ];
    try {
        forceWindowClose.apply(this, updatedArgs);
        if (source.uniqueId) {
            Object.defineProperty(Window.prototype.toString, uniqueIdentifier, {
                value: flag,
                enumerable: false,
                writable: false,
                configurable: false
            });
        }
    } catch (e) {
        console.log(e);
    }
}

function hideInShadowDom(source, args) {
    var flag = "done";
    var uniqueIdentifier = source.uniqueId + source.name + "_" + (Array.isArray(args) ? args.join("_") : "");
    if (source.uniqueId) {
        if (Window.prototype.toString[uniqueIdentifier] === flag) {
            return;
        }
    }
    function hideInShadowDom(source, selector, baseSelector) {
        if (!Element.prototype.attachShadow) {
            return;
        }
        var hideElement = function hideElement(targetElement) {
            var DISPLAY_NONE_CSS = "display:none!important;";
            targetElement.style.cssText = DISPLAY_NONE_CSS;
        };
        var hideHandler = function hideHandler() {
            var hostElements = !baseSelector ? findHostElements(document.documentElement) : document.querySelectorAll(baseSelector);
            var _loop = function _loop() {
                var isHidden = false;
                var {targets: targets, innerHosts: innerHosts} = pierceShadowDom(selector, hostElements);
                targets.forEach((function(targetEl) {
                    hideElement(targetEl);
                    isHidden = true;
                }));
                if (isHidden) {
                    hit(source);
                }
                hostElements = innerHosts;
            };
            while (hostElements.length !== 0) {
                _loop();
            }
        };
        hideHandler();
        observeDOMChanges(hideHandler, true);
    }
    function hit(source) {
        var ADGUARD_PREFIX = "[AdGuard]";
        if (!source.verbose) {
            return;
        }
        try {
            var trace = console.trace.bind(console);
            var label = `${ADGUARD_PREFIX} `;
            if (source.engine === "corelibs") {
                label += source.ruleText;
            } else {
                if (source.domainName) {
                    label += `${source.domainName}`;
                }
                if (source.args) {
                    label += `#%#//scriptlet('${source.name}', '${source.args.join("', '")}')`;
                } else {
                    label += `#%#//scriptlet('${source.name}')`;
                }
            }
            if (trace) {
                trace(label);
            }
        } catch (e) {}
        if (typeof window.__debug === "function") {
            window.__debug(source);
        }
    }
    function observeDOMChanges(callback) {
        var observeAttrs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
        var attrsToObserve = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];
        var THROTTLE_DELAY_MS = 20;
        var observer = new MutationObserver(throttle(callbackWrapper, THROTTLE_DELAY_MS));
        var connect = function connect() {
            if (attrsToObserve.length > 0) {
                observer.observe(document.documentElement, {
                    childList: true,
                    subtree: true,
                    attributes: observeAttrs,
                    attributeFilter: attrsToObserve
                });
            } else {
                observer.observe(document.documentElement, {
                    childList: true,
                    subtree: true,
                    attributes: observeAttrs
                });
            }
        };
        var disconnect = function disconnect() {
            observer.disconnect();
        };
        function callbackWrapper() {
            disconnect();
            callback();
            connect();
        }
        connect();
    }
    function findHostElements(rootElement) {
        var hosts = [];
        if (rootElement) {
            var domElems = rootElement.querySelectorAll("*");
            domElems.forEach((function(el) {
                if (el.shadowRoot) {
                    hosts.push(el);
                }
            }));
        }
        return hosts;
    }
    function pierceShadowDom(selector, hostElements) {
        var targets = [];
        var innerHostsAcc = [];
        hostElements.forEach((function(host) {
            var simpleElems = host.querySelectorAll(selector);
            targets = targets.concat([].slice.call(simpleElems));
            var shadowRootElem = host.shadowRoot;
            var shadowChildren = shadowRootElem.querySelectorAll(selector);
            targets = targets.concat([].slice.call(shadowChildren));
            innerHostsAcc.push(findHostElements(shadowRootElem));
        }));
        var innerHosts = flatten(innerHostsAcc);
        return {
            targets: targets,
            innerHosts: innerHosts
        };
    }
    function flatten(input) {
        var stack = [];
        input.forEach((function(el) {
            return stack.push(el);
        }));
        var res = [];
        while (stack.length) {
            var next = stack.pop();
            if (Array.isArray(next)) {
                next.forEach((function(el) {
                    return stack.push(el);
                }));
            } else {
                res.push(next);
            }
        }
        return res.reverse();
    }
    function throttle(cb, delay) {
        var wait = false;
        var savedArgs;
        var _wrapper = function wrapper() {
            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                args[_key] = arguments[_key];
            }
            if (wait) {
                savedArgs = args;
                return;
            }
            cb(...args);
            wait = true;
            setTimeout((function() {
                wait = false;
                if (savedArgs) {
                    _wrapper(...savedArgs);
                    savedArgs = null;
                }
            }), delay);
        };
        return _wrapper;
    }
    var updatedArgs = args ? [].concat(source).concat(args) : [ source ];
    try {
        hideInShadowDom.apply(this, updatedArgs);
        if (source.uniqueId) {
            Object.defineProperty(Window.prototype.toString, uniqueIdentifier, {
                value: flag,
                enumerable: false,
                writable: false,
                configurable: false
            });
        }
    } catch (e) {
        console.log(e);
    }
}

function hrefSanitizer(source, args) {
    var flag = "done";
    var uniqueIdentifier = source.uniqueId + source.name + "_" + (Array.isArray(args) ? args.join("_") : "");
    if (source.uniqueId) {
        if (Window.prototype.toString[uniqueIdentifier] === flag) {
            return;
        }
    }
    function hrefSanitizer(source, selector) {
        var attribute = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : "text";
        var transform = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : "";
        if (!selector) {
            logMessage(source, "Selector is required.");
            return;
        }
        var BASE64_DECODE_TRANSFORM_MARKER = "base64decode";
        var REMOVE_HASH_TRANSFORM_MARKER = "removeHash";
        var REMOVE_PARAM_TRANSFORM_MARKER = "removeParam";
        var MARKER_SEPARATOR = ":";
        var COMMA = ",";
        var regexpNotValidAtStart = /^[^!-~\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u0870-\u0887\u0889-\u088E\u08A0-\u08C9\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C5D\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D04-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16F1-\u16F8\u1700-\u1711\u171F-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1878\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4C\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C8A\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2183\u2184\u2C00-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005\u3006\u3031-\u3035\u303B\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u31A0-\u31BF\u31F0-\u31FF\u3400-\u4DBF\u4E00-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6E5\uA717-\uA71F\uA722-\uA788\uA78B-\uA7CD\uA7D0\uA7D1\uA7D3\uA7D5-\uA7DC\uA7F2-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB69\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC\u{10000}-\u{1000B}\u{1000D}-\u{10026}\u{10028}-\u{1003A}\u{1003C}\u{1003D}\u{1003F}-\u{1004D}\u{10050}-\u{1005D}\u{10080}-\u{100FA}\u{10280}-\u{1029C}\u{102A0}-\u{102D0}\u{10300}-\u{1031F}\u{1032D}-\u{10340}\u{10342}-\u{10349}\u{10350}-\u{10375}\u{10380}-\u{1039D}\u{103A0}-\u{103C3}\u{103C8}-\u{103CF}\u{10400}-\u{1049D}\u{104B0}-\u{104D3}\u{104D8}-\u{104FB}\u{10500}-\u{10527}\u{10530}-\u{10563}\u{10570}-\u{1057A}\u{1057C}-\u{1058A}\u{1058C}-\u{10592}\u{10594}\u{10595}\u{10597}-\u{105A1}\u{105A3}-\u{105B1}\u{105B3}-\u{105B9}\u{105BB}\u{105BC}\u{105C0}-\u{105F3}\u{10600}-\u{10736}\u{10740}-\u{10755}\u{10760}-\u{10767}\u{10780}-\u{10785}\u{10787}-\u{107B0}\u{107B2}-\u{107BA}\u{10800}-\u{10805}\u{10808}\u{1080A}-\u{10835}\u{10837}\u{10838}\u{1083C}\u{1083F}-\u{10855}\u{10860}-\u{10876}\u{10880}-\u{1089E}\u{108E0}-\u{108F2}\u{108F4}\u{108F5}\u{10900}-\u{10915}\u{10920}-\u{10939}\u{10980}-\u{109B7}\u{109BE}\u{109BF}\u{10A00}\u{10A10}-\u{10A13}\u{10A15}-\u{10A17}\u{10A19}-\u{10A35}\u{10A60}-\u{10A7C}\u{10A80}-\u{10A9C}\u{10AC0}-\u{10AC7}\u{10AC9}-\u{10AE4}\u{10B00}-\u{10B35}\u{10B40}-\u{10B55}\u{10B60}-\u{10B72}\u{10B80}-\u{10B91}\u{10C00}-\u{10C48}\u{10C80}-\u{10CB2}\u{10CC0}-\u{10CF2}\u{10D00}-\u{10D23}\u{10D4A}-\u{10D65}\u{10D6F}-\u{10D85}\u{10E80}-\u{10EA9}\u{10EB0}\u{10EB1}\u{10EC2}-\u{10EC4}\u{10F00}-\u{10F1C}\u{10F27}\u{10F30}-\u{10F45}\u{10F70}-\u{10F81}\u{10FB0}-\u{10FC4}\u{10FE0}-\u{10FF6}\u{11003}-\u{11037}\u{11071}\u{11072}\u{11075}\u{11083}-\u{110AF}\u{110D0}-\u{110E8}\u{11103}-\u{11126}\u{11144}\u{11147}\u{11150}-\u{11172}\u{11176}\u{11183}-\u{111B2}\u{111C1}-\u{111C4}\u{111DA}\u{111DC}\u{11200}-\u{11211}\u{11213}-\u{1122B}\u{1123F}\u{11240}\u{11280}-\u{11286}\u{11288}\u{1128A}-\u{1128D}\u{1128F}-\u{1129D}\u{1129F}-\u{112A8}\u{112B0}-\u{112DE}\u{11305}-\u{1130C}\u{1130F}\u{11310}\u{11313}-\u{11328}\u{1132A}-\u{11330}\u{11332}\u{11333}\u{11335}-\u{11339}\u{1133D}\u{11350}\u{1135D}-\u{11361}\u{11380}-\u{11389}\u{1138B}\u{1138E}\u{11390}-\u{113B5}\u{113B7}\u{113D1}\u{113D3}\u{11400}-\u{11434}\u{11447}-\u{1144A}\u{1145F}-\u{11461}\u{11480}-\u{114AF}\u{114C4}\u{114C5}\u{114C7}\u{11580}-\u{115AE}\u{115D8}-\u{115DB}\u{11600}-\u{1162F}\u{11644}\u{11680}-\u{116AA}\u{116B8}\u{11700}-\u{1171A}\u{11740}-\u{11746}\u{11800}-\u{1182B}\u{118A0}-\u{118DF}\u{118FF}-\u{11906}\u{11909}\u{1190C}-\u{11913}\u{11915}\u{11916}\u{11918}-\u{1192F}\u{1193F}\u{11941}\u{119A0}-\u{119A7}\u{119AA}-\u{119D0}\u{119E1}\u{119E3}\u{11A00}\u{11A0B}-\u{11A32}\u{11A3A}\u{11A50}\u{11A5C}-\u{11A89}\u{11A9D}\u{11AB0}-\u{11AF8}\u{11BC0}-\u{11BE0}\u{11C00}-\u{11C08}\u{11C0A}-\u{11C2E}\u{11C40}\u{11C72}-\u{11C8F}\u{11D00}-\u{11D06}\u{11D08}\u{11D09}\u{11D0B}-\u{11D30}\u{11D46}\u{11D60}-\u{11D65}\u{11D67}\u{11D68}\u{11D6A}-\u{11D89}\u{11D98}\u{11EE0}-\u{11EF2}\u{11F02}\u{11F04}-\u{11F10}\u{11F12}-\u{11F33}\u{11FB0}\u{12000}-\u{12399}\u{12480}-\u{12543}\u{12F90}-\u{12FF0}\u{13000}-\u{1342F}\u{13441}-\u{13446}\u{13460}-\u{143FA}\u{14400}-\u{14646}\u{16100}-\u{1611D}\u{16800}-\u{16A38}\u{16A40}-\u{16A5E}\u{16A70}-\u{16ABE}\u{16AD0}-\u{16AED}\u{16B00}-\u{16B2F}\u{16B40}-\u{16B43}\u{16B63}-\u{16B77}\u{16B7D}-\u{16B8F}\u{16D40}-\u{16D6C}\u{16E40}-\u{16E7F}\u{16F00}-\u{16F4A}\u{16F50}\u{16F93}-\u{16F9F}\u{16FE0}\u{16FE1}\u{16FE3}\u{17000}-\u{187F7}\u{18800}-\u{18CD5}\u{18CFF}-\u{18D08}\u{1AFF0}-\u{1AFF3}\u{1AFF5}-\u{1AFFB}\u{1AFFD}\u{1AFFE}\u{1B000}-\u{1B122}\u{1B132}\u{1B150}-\u{1B152}\u{1B155}\u{1B164}-\u{1B167}\u{1B170}-\u{1B2FB}\u{1BC00}-\u{1BC6A}\u{1BC70}-\u{1BC7C}\u{1BC80}-\u{1BC88}\u{1BC90}-\u{1BC99}\u{1D400}-\u{1D454}\u{1D456}-\u{1D49C}\u{1D49E}\u{1D49F}\u{1D4A2}\u{1D4A5}\u{1D4A6}\u{1D4A9}-\u{1D4AC}\u{1D4AE}-\u{1D4B9}\u{1D4BB}\u{1D4BD}-\u{1D4C3}\u{1D4C5}-\u{1D505}\u{1D507}-\u{1D50A}\u{1D50D}-\u{1D514}\u{1D516}-\u{1D51C}\u{1D51E}-\u{1D539}\u{1D53B}-\u{1D53E}\u{1D540}-\u{1D544}\u{1D546}\u{1D54A}-\u{1D550}\u{1D552}-\u{1D6A5}\u{1D6A8}-\u{1D6C0}\u{1D6C2}-\u{1D6DA}\u{1D6DC}-\u{1D6FA}\u{1D6FC}-\u{1D714}\u{1D716}-\u{1D734}\u{1D736}-\u{1D74E}\u{1D750}-\u{1D76E}\u{1D770}-\u{1D788}\u{1D78A}-\u{1D7A8}\u{1D7AA}-\u{1D7C2}\u{1D7C4}-\u{1D7CB}\u{1DF00}-\u{1DF1E}\u{1DF25}-\u{1DF2A}\u{1E030}-\u{1E06D}\u{1E100}-\u{1E12C}\u{1E137}-\u{1E13D}\u{1E14E}\u{1E290}-\u{1E2AD}\u{1E2C0}-\u{1E2EB}\u{1E4D0}-\u{1E4EB}\u{1E5D0}-\u{1E5ED}\u{1E5F0}\u{1E7E0}-\u{1E7E6}\u{1E7E8}-\u{1E7EB}\u{1E7ED}\u{1E7EE}\u{1E7F0}-\u{1E7FE}\u{1E800}-\u{1E8C4}\u{1E900}-\u{1E943}\u{1E94B}\u{1EE00}-\u{1EE03}\u{1EE05}-\u{1EE1F}\u{1EE21}\u{1EE22}\u{1EE24}\u{1EE27}\u{1EE29}-\u{1EE32}\u{1EE34}-\u{1EE37}\u{1EE39}\u{1EE3B}\u{1EE42}\u{1EE47}\u{1EE49}\u{1EE4B}\u{1EE4D}-\u{1EE4F}\u{1EE51}\u{1EE52}\u{1EE54}\u{1EE57}\u{1EE59}\u{1EE5B}\u{1EE5D}\u{1EE5F}\u{1EE61}\u{1EE62}\u{1EE64}\u{1EE67}-\u{1EE6A}\u{1EE6C}-\u{1EE72}\u{1EE74}-\u{1EE77}\u{1EE79}-\u{1EE7C}\u{1EE7E}\u{1EE80}-\u{1EE89}\u{1EE8B}-\u{1EE9B}\u{1EEA1}-\u{1EEA3}\u{1EEA5}-\u{1EEA9}\u{1EEAB}-\u{1EEBB}\u{20000}-\u{2A6DF}\u{2A700}-\u{2B739}\u{2B740}-\u{2B81D}\u{2B820}-\u{2CEA1}\u{2CEB0}-\u{2EBE0}\u{2EBF0}-\u{2EE5D}\u{2F800}-\u{2FA1D}\u{30000}-\u{3134A}\u{31350}-\u{323AF}]+/u;
        var regexpNotValidAtEnd = /[^!-~\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u0870-\u0887\u0889-\u088E\u08A0-\u08C9\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C5D\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D04-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16F1-\u16F8\u1700-\u1711\u171F-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1878\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4C\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C8A\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2183\u2184\u2C00-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005\u3006\u3031-\u3035\u303B\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u31A0-\u31BF\u31F0-\u31FF\u3400-\u4DBF\u4E00-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6E5\uA717-\uA71F\uA722-\uA788\uA78B-\uA7CD\uA7D0\uA7D1\uA7D3\uA7D5-\uA7DC\uA7F2-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB69\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC\u{10000}-\u{1000B}\u{1000D}-\u{10026}\u{10028}-\u{1003A}\u{1003C}\u{1003D}\u{1003F}-\u{1004D}\u{10050}-\u{1005D}\u{10080}-\u{100FA}\u{10280}-\u{1029C}\u{102A0}-\u{102D0}\u{10300}-\u{1031F}\u{1032D}-\u{10340}\u{10342}-\u{10349}\u{10350}-\u{10375}\u{10380}-\u{1039D}\u{103A0}-\u{103C3}\u{103C8}-\u{103CF}\u{10400}-\u{1049D}\u{104B0}-\u{104D3}\u{104D8}-\u{104FB}\u{10500}-\u{10527}\u{10530}-\u{10563}\u{10570}-\u{1057A}\u{1057C}-\u{1058A}\u{1058C}-\u{10592}\u{10594}\u{10595}\u{10597}-\u{105A1}\u{105A3}-\u{105B1}\u{105B3}-\u{105B9}\u{105BB}\u{105BC}\u{105C0}-\u{105F3}\u{10600}-\u{10736}\u{10740}-\u{10755}\u{10760}-\u{10767}\u{10780}-\u{10785}\u{10787}-\u{107B0}\u{107B2}-\u{107BA}\u{10800}-\u{10805}\u{10808}\u{1080A}-\u{10835}\u{10837}\u{10838}\u{1083C}\u{1083F}-\u{10855}\u{10860}-\u{10876}\u{10880}-\u{1089E}\u{108E0}-\u{108F2}\u{108F4}\u{108F5}\u{10900}-\u{10915}\u{10920}-\u{10939}\u{10980}-\u{109B7}\u{109BE}\u{109BF}\u{10A00}\u{10A10}-\u{10A13}\u{10A15}-\u{10A17}\u{10A19}-\u{10A35}\u{10A60}-\u{10A7C}\u{10A80}-\u{10A9C}\u{10AC0}-\u{10AC7}\u{10AC9}-\u{10AE4}\u{10B00}-\u{10B35}\u{10B40}-\u{10B55}\u{10B60}-\u{10B72}\u{10B80}-\u{10B91}\u{10C00}-\u{10C48}\u{10C80}-\u{10CB2}\u{10CC0}-\u{10CF2}\u{10D00}-\u{10D23}\u{10D4A}-\u{10D65}\u{10D6F}-\u{10D85}\u{10E80}-\u{10EA9}\u{10EB0}\u{10EB1}\u{10EC2}-\u{10EC4}\u{10F00}-\u{10F1C}\u{10F27}\u{10F30}-\u{10F45}\u{10F70}-\u{10F81}\u{10FB0}-\u{10FC4}\u{10FE0}-\u{10FF6}\u{11003}-\u{11037}\u{11071}\u{11072}\u{11075}\u{11083}-\u{110AF}\u{110D0}-\u{110E8}\u{11103}-\u{11126}\u{11144}\u{11147}\u{11150}-\u{11172}\u{11176}\u{11183}-\u{111B2}\u{111C1}-\u{111C4}\u{111DA}\u{111DC}\u{11200}-\u{11211}\u{11213}-\u{1122B}\u{1123F}\u{11240}\u{11280}-\u{11286}\u{11288}\u{1128A}-\u{1128D}\u{1128F}-\u{1129D}\u{1129F}-\u{112A8}\u{112B0}-\u{112DE}\u{11305}-\u{1130C}\u{1130F}\u{11310}\u{11313}-\u{11328}\u{1132A}-\u{11330}\u{11332}\u{11333}\u{11335}-\u{11339}\u{1133D}\u{11350}\u{1135D}-\u{11361}\u{11380}-\u{11389}\u{1138B}\u{1138E}\u{11390}-\u{113B5}\u{113B7}\u{113D1}\u{113D3}\u{11400}-\u{11434}\u{11447}-\u{1144A}\u{1145F}-\u{11461}\u{11480}-\u{114AF}\u{114C4}\u{114C5}\u{114C7}\u{11580}-\u{115AE}\u{115D8}-\u{115DB}\u{11600}-\u{1162F}\u{11644}\u{11680}-\u{116AA}\u{116B8}\u{11700}-\u{1171A}\u{11740}-\u{11746}\u{11800}-\u{1182B}\u{118A0}-\u{118DF}\u{118FF}-\u{11906}\u{11909}\u{1190C}-\u{11913}\u{11915}\u{11916}\u{11918}-\u{1192F}\u{1193F}\u{11941}\u{119A0}-\u{119A7}\u{119AA}-\u{119D0}\u{119E1}\u{119E3}\u{11A00}\u{11A0B}-\u{11A32}\u{11A3A}\u{11A50}\u{11A5C}-\u{11A89}\u{11A9D}\u{11AB0}-\u{11AF8}\u{11BC0}-\u{11BE0}\u{11C00}-\u{11C08}\u{11C0A}-\u{11C2E}\u{11C40}\u{11C72}-\u{11C8F}\u{11D00}-\u{11D06}\u{11D08}\u{11D09}\u{11D0B}-\u{11D30}\u{11D46}\u{11D60}-\u{11D65}\u{11D67}\u{11D68}\u{11D6A}-\u{11D89}\u{11D98}\u{11EE0}-\u{11EF2}\u{11F02}\u{11F04}-\u{11F10}\u{11F12}-\u{11F33}\u{11FB0}\u{12000}-\u{12399}\u{12480}-\u{12543}\u{12F90}-\u{12FF0}\u{13000}-\u{1342F}\u{13441}-\u{13446}\u{13460}-\u{143FA}\u{14400}-\u{14646}\u{16100}-\u{1611D}\u{16800}-\u{16A38}\u{16A40}-\u{16A5E}\u{16A70}-\u{16ABE}\u{16AD0}-\u{16AED}\u{16B00}-\u{16B2F}\u{16B40}-\u{16B43}\u{16B63}-\u{16B77}\u{16B7D}-\u{16B8F}\u{16D40}-\u{16D6C}\u{16E40}-\u{16E7F}\u{16F00}-\u{16F4A}\u{16F50}\u{16F93}-\u{16F9F}\u{16FE0}\u{16FE1}\u{16FE3}\u{17000}-\u{187F7}\u{18800}-\u{18CD5}\u{18CFF}-\u{18D08}\u{1AFF0}-\u{1AFF3}\u{1AFF5}-\u{1AFFB}\u{1AFFD}\u{1AFFE}\u{1B000}-\u{1B122}\u{1B132}\u{1B150}-\u{1B152}\u{1B155}\u{1B164}-\u{1B167}\u{1B170}-\u{1B2FB}\u{1BC00}-\u{1BC6A}\u{1BC70}-\u{1BC7C}\u{1BC80}-\u{1BC88}\u{1BC90}-\u{1BC99}\u{1D400}-\u{1D454}\u{1D456}-\u{1D49C}\u{1D49E}\u{1D49F}\u{1D4A2}\u{1D4A5}\u{1D4A6}\u{1D4A9}-\u{1D4AC}\u{1D4AE}-\u{1D4B9}\u{1D4BB}\u{1D4BD}-\u{1D4C3}\u{1D4C5}-\u{1D505}\u{1D507}-\u{1D50A}\u{1D50D}-\u{1D514}\u{1D516}-\u{1D51C}\u{1D51E}-\u{1D539}\u{1D53B}-\u{1D53E}\u{1D540}-\u{1D544}\u{1D546}\u{1D54A}-\u{1D550}\u{1D552}-\u{1D6A5}\u{1D6A8}-\u{1D6C0}\u{1D6C2}-\u{1D6DA}\u{1D6DC}-\u{1D6FA}\u{1D6FC}-\u{1D714}\u{1D716}-\u{1D734}\u{1D736}-\u{1D74E}\u{1D750}-\u{1D76E}\u{1D770}-\u{1D788}\u{1D78A}-\u{1D7A8}\u{1D7AA}-\u{1D7C2}\u{1D7C4}-\u{1D7CB}\u{1DF00}-\u{1DF1E}\u{1DF25}-\u{1DF2A}\u{1E030}-\u{1E06D}\u{1E100}-\u{1E12C}\u{1E137}-\u{1E13D}\u{1E14E}\u{1E290}-\u{1E2AD}\u{1E2C0}-\u{1E2EB}\u{1E4D0}-\u{1E4EB}\u{1E5D0}-\u{1E5ED}\u{1E5F0}\u{1E7E0}-\u{1E7E6}\u{1E7E8}-\u{1E7EB}\u{1E7ED}\u{1E7EE}\u{1E7F0}-\u{1E7FE}\u{1E800}-\u{1E8C4}\u{1E900}-\u{1E943}\u{1E94B}\u{1EE00}-\u{1EE03}\u{1EE05}-\u{1EE1F}\u{1EE21}\u{1EE22}\u{1EE24}\u{1EE27}\u{1EE29}-\u{1EE32}\u{1EE34}-\u{1EE37}\u{1EE39}\u{1EE3B}\u{1EE42}\u{1EE47}\u{1EE49}\u{1EE4B}\u{1EE4D}-\u{1EE4F}\u{1EE51}\u{1EE52}\u{1EE54}\u{1EE57}\u{1EE59}\u{1EE5B}\u{1EE5D}\u{1EE5F}\u{1EE61}\u{1EE62}\u{1EE64}\u{1EE67}-\u{1EE6A}\u{1EE6C}-\u{1EE72}\u{1EE74}-\u{1EE77}\u{1EE79}-\u{1EE7C}\u{1EE7E}\u{1EE80}-\u{1EE89}\u{1EE8B}-\u{1EE9B}\u{1EEA1}-\u{1EEA3}\u{1EEA5}-\u{1EEA9}\u{1EEAB}-\u{1EEBB}\u{20000}-\u{2A6DF}\u{2A700}-\u{2B739}\u{2B740}-\u{2B81D}\u{2B820}-\u{2CEA1}\u{2CEB0}-\u{2EBE0}\u{2EBF0}-\u{2EE5D}\u{2F800}-\u{2FA1D}\u{30000}-\u{3134A}\u{31350}-\u{323AF}]+$/u;
        var extractNewHref = function extractNewHref(anchor, attr) {
            if (attr === "text") {
                if (!anchor.textContent) {
                    return "";
                }
                return anchor.textContent.replace(regexpNotValidAtStart, "").replace(regexpNotValidAtEnd, "");
            }
            if (attr.startsWith("?")) {
                try {
                    var url = new URL(anchor.href, document.location.href);
                    return url.searchParams.get(attr.slice(1)) || "";
                } catch (ex) {
                    logMessage(source, `Cannot retrieve the parameter '${attr.slice(1)}' from the URL '${anchor.href}`);
                    return "";
                }
            }
            if (attr.startsWith("[") && attr.endsWith("]")) {
                return anchor.getAttribute(attr.slice(1, -1)) || "";
            }
            return "";
        };
        var isValidURL = function isValidURL(url) {
            try {
                new URL(url);
                return true;
            } catch (_unused) {
                return false;
            }
        };
        var getValidURL = function getValidURL(text) {
            if (!text) {
                return null;
            }
            try {
                var {href: href, protocol: protocol} = new URL(text, document.location.href);
                if (protocol !== "http:" && protocol !== "https:") {
                    logMessage(source, `Protocol not allowed: "${protocol}", from URL: "${href}"`);
                    return null;
                }
                return href;
            } catch (_unused2) {
                return null;
            }
        };
        var isSanitizableAnchor = function isSanitizableAnchor(element) {
            return element.nodeName.toLowerCase() === "a" && element.hasAttribute("href");
        };
        var _extractURLFromObject = function extractURLFromObject(obj) {
            for (var key in obj) {
                if (!Object.prototype.hasOwnProperty.call(obj, key)) {
                    continue;
                }
                var value = obj[key];
                if (typeof value === "string" && isValidURL(value)) {
                    return value;
                }
                if (typeof value === "object" && value !== null) {
                    var result = _extractURLFromObject(value);
                    if (result) {
                        return result;
                    }
                }
            }
            return null;
        };
        var isStringifiedObject = function isStringifiedObject(content) {
            return content.startsWith("{") && content.endsWith("}");
        };
        var decodeBase64SeveralTimes = function decodeBase64SeveralTimes(text, times) {
            var result = text;
            for (var i = 0; i < times; i += 1) {
                try {
                    result = atob(result);
                } catch (e) {
                    if (result === text) {
                        return "";
                    }
                }
            }
            if (isValidURL(result)) {
                return result;
            }
            if (isStringifiedObject(result)) {
                try {
                    var parsedResult = JSON.parse(result);
                    return _extractURLFromObject(parsedResult);
                } catch (ex) {
                    return "";
                }
            }
            logMessage(source, `Failed to decode base64 string: ${text}`);
            return "";
        };
        var SEARCH_QUERY_MARKER = "?";
        var SEARCH_PARAMS_MARKER = "&";
        var HASHBANG_MARKER = "#!";
        var ANCHOR_MARKER = "#";
        var DECODE_ATTEMPTS_NUMBER = 10;
        var decodeSearchString = function decodeSearchString(search) {
            var searchString = search.replace(SEARCH_QUERY_MARKER, "");
            var decodedParam;
            var validEncodedParam;
            if (searchString.includes(SEARCH_PARAMS_MARKER)) {
                var searchParamsArray = searchString.split(SEARCH_PARAMS_MARKER);
                searchParamsArray.forEach((function(param) {
                    decodedParam = decodeBase64SeveralTimes(param, DECODE_ATTEMPTS_NUMBER);
                    if (decodedParam && decodedParam.length > 0) {
                        validEncodedParam = decodedParam;
                    }
                }));
                return validEncodedParam;
            }
            return decodeBase64SeveralTimes(searchString, DECODE_ATTEMPTS_NUMBER);
        };
        var decodeHashString = function decodeHashString(hash) {
            var validEncodedHash = "";
            if (hash.includes(HASHBANG_MARKER)) {
                validEncodedHash = hash.replace(HASHBANG_MARKER, "");
            } else if (hash.includes(ANCHOR_MARKER)) {
                validEncodedHash = hash.replace(ANCHOR_MARKER, "");
            }
            return validEncodedHash ? decodeBase64SeveralTimes(validEncodedHash, DECODE_ATTEMPTS_NUMBER) : "";
        };
        var removeHash = function removeHash(url) {
            var urlObj = new URL(url, window.location.origin);
            if (!urlObj.hash) {
                return "";
            }
            urlObj.hash = "";
            return urlObj.toString();
        };
        var removeParam = function removeParam(url, transformValue) {
            var urlObj = new URL(url, window.location.origin);
            var paramNamesToRemoveStr = transformValue.split(MARKER_SEPARATOR)[1];
            if (!paramNamesToRemoveStr) {
                urlObj.search = "";
                return urlObj.toString();
            }
            var initSearchParamsLength = urlObj.searchParams.toString().length;
            var removeParams = paramNamesToRemoveStr.split(COMMA);
            removeParams.forEach((function(param) {
                if (urlObj.searchParams.has(param)) {
                    urlObj.searchParams.delete(param);
                }
            }));
            if (initSearchParamsLength === urlObj.searchParams.toString().length) {
                return "";
            }
            return urlObj.toString();
        };
        var decodeBase64URL = function decodeBase64URL(url) {
            var {search: search, hash: hash} = new URL(url, document.location.href);
            if (search.length > 0) {
                return decodeSearchString(search);
            }
            if (hash.length > 0) {
                return decodeHashString(hash);
            }
            logMessage(source, `Failed to execute base64 from URL: ${url}`);
            return null;
        };
        var base64Decode = function base64Decode(href) {
            if (isValidURL(href)) {
                return decodeBase64URL(href) || "";
            }
            return decodeBase64SeveralTimes(href, DECODE_ATTEMPTS_NUMBER) || "";
        };
        var sanitize = function sanitize(elementSelector) {
            var elements;
            try {
                elements = document.querySelectorAll(elementSelector);
            } catch (e) {
                logMessage(source, `Invalid selector "${elementSelector}"`);
                return;
            }
            elements.forEach((function(elem) {
                try {
                    if (!isSanitizableAnchor(elem)) {
                        logMessage(source, `${elem} is not a valid element to sanitize`);
                        return;
                    }
                    var newHref = extractNewHref(elem, attribute);
                    if (transform) {
                        switch (true) {
                          case transform === BASE64_DECODE_TRANSFORM_MARKER:
                            newHref = base64Decode(newHref);
                            break;

                          case transform === REMOVE_HASH_TRANSFORM_MARKER:
                            newHref = removeHash(newHref);
                            break;

                          case transform.startsWith(REMOVE_PARAM_TRANSFORM_MARKER):
                            {
                                newHref = removeParam(newHref, transform);
                                break;
                            }

                          default:
                            logMessage(source, `Invalid transform option: "${transform}"`);
                            return;
                        }
                    }
                    var newValidHref = getValidURL(newHref);
                    if (!newValidHref) {
                        logMessage(source, `Invalid URL: ${newHref}`);
                        return;
                    }
                    var oldHref = elem.href;
                    elem.setAttribute("href", newValidHref);
                    if (newValidHref !== oldHref) {
                        logMessage(source, `Sanitized "${oldHref}" to "${newValidHref}".`);
                    }
                } catch (ex) {
                    logMessage(source, `Failed to sanitize ${elem}.`);
                }
            }));
            hit(source);
        };
        var run = function run() {
            sanitize(selector);
            observeDOMChanges((function() {
                return sanitize(selector);
            }), true);
        };
        if (document.readyState === "loading") {
            window.addEventListener("DOMContentLoaded", run, {
                once: true
            });
        } else {
            run();
        }
    }
    function observeDOMChanges(callback) {
        var observeAttrs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
        var attrsToObserve = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];
        var THROTTLE_DELAY_MS = 20;
        var observer = new MutationObserver(throttle(callbackWrapper, THROTTLE_DELAY_MS));
        var connect = function connect() {
            if (attrsToObserve.length > 0) {
                observer.observe(document.documentElement, {
                    childList: true,
                    subtree: true,
                    attributes: observeAttrs,
                    attributeFilter: attrsToObserve
                });
            } else {
                observer.observe(document.documentElement, {
                    childList: true,
                    subtree: true,
                    attributes: observeAttrs
                });
            }
        };
        var disconnect = function disconnect() {
            observer.disconnect();
        };
        function callbackWrapper() {
            disconnect();
            callback();
            connect();
        }
        connect();
    }
    function hit(source) {
        var ADGUARD_PREFIX = "[AdGuard]";
        if (!source.verbose) {
            return;
        }
        try {
            var trace = console.trace.bind(console);
            var label = `${ADGUARD_PREFIX} `;
            if (source.engine === "corelibs") {
                label += source.ruleText;
            } else {
                if (source.domainName) {
                    label += `${source.domainName}`;
                }
                if (source.args) {
                    label += `#%#//scriptlet('${source.name}', '${source.args.join("', '")}')`;
                } else {
                    label += `#%#//scriptlet('${source.name}')`;
                }
            }
            if (trace) {
                trace(label);
            }
        } catch (e) {}
        if (typeof window.__debug === "function") {
            window.__debug(source);
        }
    }
    function logMessage(source, message) {
        var forced = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
        var convertMessageToString = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
        var {name: name, verbose: verbose} = source;
        if (!forced && !verbose) {
            return;
        }
        var nativeConsole = console.log;
        if (!convertMessageToString) {
            nativeConsole(`${name}:`, message);
            return;
        }
        nativeConsole(`${name}: ${message}`);
    }
    function throttle(cb, delay) {
        var wait = false;
        var savedArgs;
        var _wrapper = function wrapper() {
            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                args[_key] = arguments[_key];
            }
            if (wait) {
                savedArgs = args;
                return;
            }
            cb(...args);
            wait = true;
            setTimeout((function() {
                wait = false;
                if (savedArgs) {
                    _wrapper(...savedArgs);
                    savedArgs = null;
                }
            }), delay);
        };
        return _wrapper;
    }
    var updatedArgs = args ? [].concat(source).concat(args) : [ source ];
    try {
        hrefSanitizer.apply(this, updatedArgs);
        if (source.uniqueId) {
            Object.defineProperty(Window.prototype.toString, uniqueIdentifier, {
                value: flag,
                enumerable: false,
                writable: false,
                configurable: false
            });
        }
    } catch (e) {
        console.log(e);
    }
}

function injectCssInShadowDom(source, args) {
    var flag = "done";
    var uniqueIdentifier = source.uniqueId + source.name + "_" + (Array.isArray(args) ? args.join("_") : "");
    if (source.uniqueId) {
        if (Window.prototype.toString[uniqueIdentifier] === flag) {
            return;
        }
    }
    function injectCssInShadowDom(source, cssRule) {
        var hostSelector = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : "";
        if (!Element.prototype.attachShadow || typeof Proxy === "undefined" || typeof Reflect === "undefined") {
            return;
        }
        if (cssRule.match(/(url|image-set)\(.*\)/i)) {
            logMessage(source, '"url()" function is not allowed for css rules');
            return;
        }
        var callback = function callback(shadowRoot) {
            try {
                var stylesheet = new CSSStyleSheet;
                try {
                    stylesheet.insertRule(cssRule);
                } catch (e) {
                    logMessage(source, `Unable to apply the rule '${cssRule}' due to: \n'${e.message}'`);
                    return;
                }
                shadowRoot.adoptedStyleSheets = [ ...shadowRoot.adoptedStyleSheets, stylesheet ];
            } catch (_unused) {
                var styleTag = document.createElement("style");
                styleTag.innerText = cssRule;
                shadowRoot.appendChild(styleTag);
            }
            hit(source);
        };
        hijackAttachShadow(window, hostSelector, callback);
    }
    function hit(source) {
        var ADGUARD_PREFIX = "[AdGuard]";
        if (!source.verbose) {
            return;
        }
        try {
            var trace = console.trace.bind(console);
            var label = `${ADGUARD_PREFIX} `;
            if (source.engine === "corelibs") {
                label += source.ruleText;
            } else {
                if (source.domainName) {
                    label += `${source.domainName}`;
                }
                if (source.args) {
                    label += `#%#//scriptlet('${source.name}', '${source.args.join("', '")}')`;
                } else {
                    label += `#%#//scriptlet('${source.name}')`;
                }
            }
            if (trace) {
                trace(label);
            }
        } catch (e) {}
        if (typeof window.__debug === "function") {
            window.__debug(source);
        }
    }
    function logMessage(source, message) {
        var forced = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
        var convertMessageToString = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
        var {name: name, verbose: verbose} = source;
        if (!forced && !verbose) {
            return;
        }
        var nativeConsole = console.log;
        if (!convertMessageToString) {
            nativeConsole(`${name}:`, message);
            return;
        }
        nativeConsole(`${name}: ${message}`);
    }
    function hijackAttachShadow(context, hostSelector, callback) {
        var handlerWrapper = function handlerWrapper(target, thisArg, args) {
            var shadowRoot = Reflect.apply(target, thisArg, args);
            if (thisArg && thisArg.matches(hostSelector || "*")) {
                callback(shadowRoot);
            }
            return shadowRoot;
        };
        var attachShadowHandler = {
            apply: handlerWrapper
        };
        context.Element.prototype.attachShadow = new Proxy(context.Element.prototype.attachShadow, attachShadowHandler);
    }
    var updatedArgs = args ? [].concat(source).concat(args) : [ source ];
    try {
        injectCssInShadowDom.apply(this, updatedArgs);
        if (source.uniqueId) {
            Object.defineProperty(Window.prototype.toString, uniqueIdentifier, {
                value: flag,
                enumerable: false,
                writable: false,
                configurable: false
            });
        }
    } catch (e) {
        console.log(e);
    }
}

function jsonPrune(source, args) {
    var flag = "done";
    var uniqueIdentifier = source.uniqueId + source.name + "_" + (Array.isArray(args) ? args.join("_") : "");
    if (source.uniqueId) {
        if (Window.prototype.toString[uniqueIdentifier] === flag) {
            return;
        }
    }
    function jsonPrune(source, propsToRemove, requiredInitialProps) {
        var stack = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : "";
        var prunePaths = getPrunePath(propsToRemove);
        var requiredPaths = getPrunePath(requiredInitialProps);
        var nativeObjects = {
            nativeStringify: window.JSON.stringify
        };
        var nativeJSONParse = JSON.parse;
        var jsonParseWrapper = function jsonParseWrapper() {
            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                args[_key] = arguments[_key];
            }
            var root = nativeJSONParse.apply(JSON, args);
            return jsonPruner(source, root, prunePaths, requiredPaths, stack, nativeObjects);
        };
        jsonParseWrapper.toString = nativeJSONParse.toString.bind(nativeJSONParse);
        JSON.parse = jsonParseWrapper;
        var nativeResponseJson = Response.prototype.json;
        var responseJsonWrapper = function responseJsonWrapper() {
            var promise = nativeResponseJson.apply(this);
            return promise.then((function(obj) {
                return jsonPruner(source, obj, prunePaths, requiredPaths, stack, nativeObjects);
            }));
        };
        if (typeof Response === "undefined") {
            return;
        }
        Response.prototype.json = responseJsonWrapper;
    }
    function hit(source) {
        var ADGUARD_PREFIX = "[AdGuard]";
        if (!source.verbose) {
            return;
        }
        try {
            var trace = console.trace.bind(console);
            var label = `${ADGUARD_PREFIX} `;
            if (source.engine === "corelibs") {
                label += source.ruleText;
            } else {
                if (source.domainName) {
                    label += `${source.domainName}`;
                }
                if (source.args) {
                    label += `#%#//scriptlet('${source.name}', '${source.args.join("', '")}')`;
                } else {
                    label += `#%#//scriptlet('${source.name}')`;
                }
            }
            if (trace) {
                trace(label);
            }
        } catch (e) {}
        if (typeof window.__debug === "function") {
            window.__debug(source);
        }
    }
    function matchStackTrace(stackMatch, stackTrace) {
        if (!stackMatch || stackMatch === "") {
            return true;
        }
        var regExpValues = backupRegExpValues();
        if (shouldAbortInlineOrInjectedScript(stackMatch, stackTrace)) {
            if (regExpValues.length && regExpValues[0] !== RegExp.$1) {
                restoreRegExpValues(regExpValues);
            }
            return true;
        }
        var stackRegexp = toRegExp(stackMatch);
        var refinedStackTrace = stackTrace.split("\n").slice(2).map((function(line) {
            return line.trim();
        })).join("\n");
        if (regExpValues.length && regExpValues[0] !== RegExp.$1) {
            restoreRegExpValues(regExpValues);
        }
        return getNativeRegexpTest().call(stackRegexp, refinedStackTrace);
    }
    function getWildcardPropertyInChain(base, chain) {
        var lookThrough = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
        var output = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [];
        var valueToCheck = arguments.length > 4 ? arguments[4] : undefined;
        var pos = chain.indexOf(".");
        if (pos === -1) {
            if (chain === "*" || chain === "[]") {
                for (var key in base) {
                    if (Object.prototype.hasOwnProperty.call(base, key)) {
                        if (valueToCheck !== undefined) {
                            var objectValue = base[key];
                            if (typeof objectValue === "string" && valueToCheck instanceof RegExp) {
                                if (valueToCheck.test(objectValue)) {
                                    output.push({
                                        base: base,
                                        prop: key
                                    });
                                }
                            } else if (objectValue === valueToCheck) {
                                output.push({
                                    base: base,
                                    prop: key
                                });
                            }
                        } else {
                            output.push({
                                base: base,
                                prop: key
                            });
                        }
                    }
                }
            } else if (valueToCheck !== undefined) {
                var _objectValue = base[chain];
                if (typeof _objectValue === "string" && valueToCheck instanceof RegExp) {
                    if (valueToCheck.test(_objectValue)) {
                        output.push({
                            base: base,
                            prop: chain
                        });
                    }
                } else if (base[chain] === valueToCheck) {
                    output.push({
                        base: base,
                        prop: chain
                    });
                }
            } else {
                output.push({
                    base: base,
                    prop: chain
                });
            }
            return output;
        }
        var prop = chain.slice(0, pos);
        var shouldLookThrough = prop === "[]" && Array.isArray(base) || prop === "*" && base instanceof Object || prop === "[-]" && Array.isArray(base) || prop === "{-}" && base instanceof Object;
        if (shouldLookThrough) {
            var nextProp = chain.slice(pos + 1);
            var baseKeys = Object.keys(base);
            if (prop === "{-}" || prop === "[-]") {
                var type = Array.isArray(base) ? "array" : "object";
                var shouldRemove = !!(prop === "{-}" && type === "object") || !!(prop === "[-]" && type === "array");
                if (!shouldRemove) {
                    return output;
                }
                baseKeys.forEach((function(key) {
                    var item = base[key];
                    if (isKeyInObject(item, nextProp, valueToCheck)) {
                        output.push({
                            base: base,
                            prop: key
                        });
                    }
                }));
                return output;
            }
            baseKeys.forEach((function(key) {
                var item = base[key];
                getWildcardPropertyInChain(item, nextProp, lookThrough, output, valueToCheck);
            }));
        }
        if (Array.isArray(base)) {
            base.forEach((function(key) {
                var nextBase = key;
                if (nextBase !== undefined) {
                    getWildcardPropertyInChain(nextBase, chain, lookThrough, output, valueToCheck);
                }
            }));
        }
        var nextBase = base[prop];
        chain = chain.slice(pos + 1);
        if (nextBase !== undefined) {
            getWildcardPropertyInChain(nextBase, chain, lookThrough, output, valueToCheck);
        }
        return output;
    }
    function logMessage(source, message) {
        var forced = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
        var convertMessageToString = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
        var {name: name, verbose: verbose} = source;
        if (!forced && !verbose) {
            return;
        }
        var nativeConsole = console.log;
        if (!convertMessageToString) {
            nativeConsole(`${name}:`, message);
            return;
        }
        nativeConsole(`${name}: ${message}`);
    }
    function isPruningNeeded(source, root, prunePaths, requiredPaths, stack, nativeObjects) {
        if (!root) {
            return false;
        }
        var {nativeStringify: nativeStringify} = nativeObjects;
        var shouldProcess;
        var prunePathsToCheck = prunePaths.map((function(obj) {
            return obj.path;
        }));
        var requiredPathsToCheck = requiredPaths.map((function(obj) {
            return obj.path;
        }));
        if (prunePathsToCheck.length === 0 && requiredPathsToCheck.length > 0) {
            var rootString = nativeStringify(root);
            var matchRegex = toRegExp(requiredPathsToCheck.join(""));
            var shouldLog = matchRegex.test(rootString);
            if (shouldLog) {
                logMessage(source, `${window.location.hostname}\n${nativeStringify(root, null, 2)}\nStack trace:\n${(new Error).stack}`, true);
                if (root && typeof root === "object") {
                    logMessage(source, root, true, false);
                }
                shouldProcess = false;
                return shouldProcess;
            }
        }
        if (stack && !matchStackTrace(stack, (new Error).stack || "")) {
            shouldProcess = false;
            return shouldProcess;
        }
        var wildcardSymbols = [ ".*.", "*.", ".*", ".[].", "[].", ".[]" ];
        var _loop = function _loop() {
            var requiredPath = requiredPathsToCheck[i];
            var lastNestedPropName = requiredPath.split(".").pop();
            var hasWildcard = wildcardSymbols.some((function(symbol) {
                return requiredPath.includes(symbol);
            }));
            var details = getWildcardPropertyInChain(root, requiredPath, hasWildcard);
            if (!details.length) {
                shouldProcess = false;
                return {
                    v: shouldProcess
                };
            }
            shouldProcess = !hasWildcard;
            for (var j = 0; j < details.length; j += 1) {
                var hasRequiredProp = typeof lastNestedPropName === "string" && details[j].base[lastNestedPropName] !== undefined;
                if (hasWildcard) {
                    shouldProcess = hasRequiredProp || shouldProcess;
                } else {
                    shouldProcess = hasRequiredProp && shouldProcess;
                }
            }
        }, _ret;
        for (var i = 0; i < requiredPathsToCheck.length; i += 1) {
            _ret = _loop();
            if (_ret) return _ret.v;
        }
        return shouldProcess;
    }
    function jsonPruner(source, root, prunePaths, requiredPaths, stack, nativeObjects) {
        var {nativeStringify: nativeStringify} = nativeObjects;
        if (prunePaths.length === 0 && requiredPaths.length === 0) {
            logMessage(source, `${window.location.hostname}\n${nativeStringify(root, null, 2)}\nStack trace:\n${(new Error).stack}`, true);
            if (root && typeof root === "object") {
                logMessage(source, root, true, false);
            }
            return root;
        }
        try {
            if (isPruningNeeded(source, root, prunePaths, requiredPaths, stack, nativeObjects) === false) {
                return root;
            }
            prunePaths.forEach((function(path) {
                var pathToCheck = path.path;
                var valueToCheck = path.value;
                var ownerObjArr = getWildcardPropertyInChain(root, pathToCheck, true, [], valueToCheck);
                for (var i = ownerObjArr.length - 1; i >= 0; i -= 1) {
                    var ownerObj = ownerObjArr[i];
                    if (ownerObj === undefined || !ownerObj.base) {
                        continue;
                    }
                    hit(source);
                    if (!Array.isArray(ownerObj.base)) {
                        delete ownerObj.base[ownerObj.prop];
                        continue;
                    }
                    try {
                        var index = Number(ownerObj.prop);
                        if (Number.isNaN(index)) {
                            continue;
                        }
                        ownerObj.base.splice(index, 1);
                    } catch (error) {
                        console.error("Error while deleting array element", error);
                    }
                }
            }));
        } catch (e) {
            logMessage(source, e);
        }
        return root;
    }
    function getPrunePath(props) {
        var VALUE_MARKER = ".[=].";
        var REGEXP_START_MARKER = "/";
        var validPropsString = typeof props === "string" && props !== undefined && props !== "";
        if (validPropsString) {
            var splitRegexp = /(?<!\.\[=\]\.\/(?:[^/]|\\.)*)\s+/;
            var parts = props.split(splitRegexp).map((function(part) {
                var splitPart = part.split(VALUE_MARKER);
                var path = splitPart[0];
                var value = splitPart[1];
                if (value !== undefined) {
                    if (value === "true") {
                        value = true;
                    } else if (value === "false") {
                        value = false;
                    } else if (value.startsWith(REGEXP_START_MARKER)) {
                        value = toRegExp(value);
                    } else if (typeof value === "string" && /^\d+$/.test(value)) {
                        value = parseFloat(value);
                    }
                    return {
                        path: path,
                        value: value
                    };
                }
                return {
                    path: path
                };
            }));
            return parts;
        }
        return [];
    }
    function toRegExp(rawInput) {
        var input = rawInput || "";
        var DEFAULT_VALUE = ".?";
        var FORWARD_SLASH = "/";
        if (input === "") {
            return new RegExp(DEFAULT_VALUE);
        }
        var delimiterIndex = input.lastIndexOf(FORWARD_SLASH);
        var flagsPart = input.substring(delimiterIndex + 1);
        var regExpPart = input.substring(0, delimiterIndex + 1);
        var isValidRegExpFlag = function isValidRegExpFlag(flag) {
            if (!flag) {
                return false;
            }
            try {
                new RegExp("", flag);
                return true;
            } catch (ex) {
                return false;
            }
        };
        var getRegExpFlags = function getRegExpFlags(regExpStr, flagsStr) {
            if (regExpStr.startsWith(FORWARD_SLASH) && regExpStr.endsWith(FORWARD_SLASH) && !regExpStr.endsWith("\\/") && isValidRegExpFlag(flagsStr)) {
                return flagsStr;
            }
            return "";
        };
        var flags = getRegExpFlags(regExpPart, flagsPart);
        if (input.startsWith(FORWARD_SLASH) && input.endsWith(FORWARD_SLASH) || flags) {
            var regExpInput = flags ? regExpPart : input;
            return new RegExp(regExpInput.slice(1, -1), flags);
        }
        var escaped = input.replace(/\\'/g, "'").replace(/\\"/g, '"').replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
        return new RegExp(escaped);
    }
    function getNativeRegexpTest() {
        var descriptor = Object.getOwnPropertyDescriptor(RegExp.prototype, "test");
        var nativeRegexTest = descriptor === null || descriptor === void 0 ? void 0 : descriptor.value;
        if (descriptor && typeof descriptor.value === "function") {
            return nativeRegexTest;
        }
        throw new Error("RegExp.prototype.test is not a function");
    }
    function shouldAbortInlineOrInjectedScript(stackMatch, stackTrace) {
        var INLINE_SCRIPT_STRING = "inlineScript";
        var INJECTED_SCRIPT_STRING = "injectedScript";
        var INJECTED_SCRIPT_MARKER = "<anonymous>";
        var isInlineScript = function isInlineScript(match) {
            return match.includes(INLINE_SCRIPT_STRING);
        };
        var isInjectedScript = function isInjectedScript(match) {
            return match.includes(INJECTED_SCRIPT_STRING);
        };
        if (!(isInlineScript(stackMatch) || isInjectedScript(stackMatch))) {
            return false;
        }
        var documentURL = window.location.href;
        var pos = documentURL.indexOf("#");
        if (pos !== -1) {
            documentURL = documentURL.slice(0, pos);
        }
        var stackSteps = stackTrace.split("\n").slice(2).map((function(line) {
            return line.trim();
        }));
        var stackLines = stackSteps.map((function(line) {
            var stack;
            var getStackTraceValues = /(.*?@)?(\S+)(:\d+)(:\d+)\)?$/.exec(line);
            if (getStackTraceValues) {
                var _stackURL, _stackURL2;
                var stackURL = getStackTraceValues[2];
                var stackLine = getStackTraceValues[3];
                var stackCol = getStackTraceValues[4];
                if ((_stackURL = stackURL) !== null && _stackURL !== void 0 && _stackURL.startsWith("(")) {
                    stackURL = stackURL.slice(1);
                }
                if ((_stackURL2 = stackURL) !== null && _stackURL2 !== void 0 && _stackURL2.startsWith(INJECTED_SCRIPT_MARKER)) {
                    var _stackFunction;
                    stackURL = INJECTED_SCRIPT_STRING;
                    var stackFunction = getStackTraceValues[1] !== undefined ? getStackTraceValues[1].slice(0, -1) : line.slice(0, getStackTraceValues.index).trim();
                    if ((_stackFunction = stackFunction) !== null && _stackFunction !== void 0 && _stackFunction.startsWith("at")) {
                        stackFunction = stackFunction.slice(2).trim();
                    }
                    stack = `${stackFunction} ${stackURL}${stackLine}${stackCol}`.trim();
                } else if (stackURL === documentURL) {
                    stack = `${INLINE_SCRIPT_STRING}${stackLine}${stackCol}`.trim();
                } else {
                    stack = `${stackURL}${stackLine}${stackCol}`.trim();
                }
            } else {
                stack = line;
            }
            return stack;
        }));
        if (stackLines) {
            for (var index = 0; index < stackLines.length; index += 1) {
                if (isInlineScript(stackMatch) && stackLines[index].startsWith(INLINE_SCRIPT_STRING) && stackLines[index].match(toRegExp(stackMatch))) {
                    return true;
                }
                if (isInjectedScript(stackMatch) && stackLines[index].startsWith(INJECTED_SCRIPT_STRING) && stackLines[index].match(toRegExp(stackMatch))) {
                    return true;
                }
            }
        }
        return false;
    }
    function backupRegExpValues() {
        try {
            var arrayOfRegexpValues = [];
            for (var index = 1; index < 10; index += 1) {
                var value = `$${index}`;
                if (!RegExp[value]) {
                    break;
                }
                arrayOfRegexpValues.push(RegExp[value]);
            }
            return arrayOfRegexpValues;
        } catch (error) {
            return [];
        }
    }
    function restoreRegExpValues(array) {
        if (!array.length) {
            return;
        }
        try {
            var stringPattern = "";
            if (array.length === 1) {
                stringPattern = `(${array[0]})`;
            } else {
                stringPattern = array.reduce((function(accumulator, currentValue, currentIndex) {
                    if (currentIndex === 1) {
                        return `(${accumulator}),(${currentValue})`;
                    }
                    return `${accumulator},(${currentValue})`;
                }));
            }
            var regExpGroup = new RegExp(stringPattern);
            array.toString().replace(regExpGroup, "");
        } catch (error) {
            var message = `Failed to restore RegExp values: ${error}`;
            console.log(message);
        }
    }
    function isKeyInObject(baseObj, path, valueToCheck) {
        var parts = path.split(".");
        var _check = function check(targetObject, pathSegments) {
            if (pathSegments.length === 0) {
                if (valueToCheck !== undefined) {
                    if (typeof targetObject === "string" && valueToCheck instanceof RegExp) {
                        return valueToCheck.test(targetObject);
                    }
                    return targetObject === valueToCheck;
                }
                return true;
            }
            var current = pathSegments[0];
            var rest = pathSegments.slice(1);
            if (current === "*" || current === "[]") {
                if (Array.isArray(targetObject)) {
                    return targetObject.some((function(item) {
                        return _check(item, rest);
                    }));
                }
                if (typeof targetObject === "object" && targetObject !== null) {
                    return Object.keys(targetObject).some((function(key) {
                        return _check(targetObject[key], rest);
                    }));
                }
            }
            if (Object.prototype.hasOwnProperty.call(targetObject, current)) {
                return _check(targetObject[current], rest);
            }
            return false;
        };
        return _check(baseObj, parts);
    }
    var updatedArgs = args ? [].concat(source).concat(args) : [ source ];
    try {
        jsonPrune.apply(this, updatedArgs);
        if (source.uniqueId) {
            Object.defineProperty(Window.prototype.toString, uniqueIdentifier, {
                value: flag,
                enumerable: false,
                writable: false,
                configurable: false
            });
        }
    } catch (e) {
        console.log(e);
    }
}

function jsonPruneFetchResponse(source, args) {
    var flag = "done";
    var uniqueIdentifier = source.uniqueId + source.name + "_" + (Array.isArray(args) ? args.join("_") : "");
    if (source.uniqueId) {
        if (Window.prototype.toString[uniqueIdentifier] === flag) {
            return;
        }
    }
    function jsonPruneFetchResponse(source, propsToRemove, obligatoryProps) {
        var propsToMatch = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : "";
        var stack = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : "";
        if (typeof fetch === "undefined" || typeof Proxy === "undefined" || typeof Response === "undefined") {
            return;
        }
        var prunePaths = getPrunePath(propsToRemove);
        var requiredPaths = getPrunePath(obligatoryProps);
        var nativeStringify = window.JSON.stringify;
        var nativeRequestClone = window.Request.prototype.clone;
        var nativeResponseClone = window.Response.prototype.clone;
        var nativeFetch = window.fetch;
        var fetchHandlerWrapper = async function fetchHandlerWrapper(target, thisArg, args) {
            var fetchData = getFetchData(args, nativeRequestClone);
            if (!matchRequestProps(source, propsToMatch, fetchData)) {
                return Reflect.apply(target, thisArg, args);
            }
            var originalResponse;
            var clonedResponse;
            try {
                originalResponse = await nativeFetch.apply(null, args);
                clonedResponse = nativeResponseClone.call(originalResponse);
            } catch (_unused) {
                logMessage(source, `Could not make an original fetch request: ${fetchData.url}`);
                return Reflect.apply(target, thisArg, args);
            }
            var json;
            try {
                json = await originalResponse.json();
            } catch (e) {
                var message = `Response body can't be converted to json: ${objectToString(fetchData)}`;
                logMessage(source, message);
                return clonedResponse;
            }
            var modifiedJson = jsonPruner(source, json, prunePaths, requiredPaths, stack, {
                nativeStringify: nativeStringify,
                nativeRequestClone: nativeRequestClone,
                nativeResponseClone: nativeResponseClone,
                nativeFetch: nativeFetch
            });
            var forgedResponse = forgeResponse(originalResponse, nativeStringify(modifiedJson));
            hit(source);
            return forgedResponse;
        };
        var fetchHandler = {
            apply: fetchHandlerWrapper
        };
        window.fetch = new Proxy(window.fetch, fetchHandler);
    }
    function hit(source) {
        var ADGUARD_PREFIX = "[AdGuard]";
        if (!source.verbose) {
            return;
        }
        try {
            var trace = console.trace.bind(console);
            var label = `${ADGUARD_PREFIX} `;
            if (source.engine === "corelibs") {
                label += source.ruleText;
            } else {
                if (source.domainName) {
                    label += `${source.domainName}`;
                }
                if (source.args) {
                    label += `#%#//scriptlet('${source.name}', '${source.args.join("', '")}')`;
                } else {
                    label += `#%#//scriptlet('${source.name}')`;
                }
            }
            if (trace) {
                trace(label);
            }
        } catch (e) {}
        if (typeof window.__debug === "function") {
            window.__debug(source);
        }
    }
    function logMessage(source, message) {
        var forced = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
        var convertMessageToString = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
        var {name: name, verbose: verbose} = source;
        if (!forced && !verbose) {
            return;
        }
        var nativeConsole = console.log;
        if (!convertMessageToString) {
            nativeConsole(`${name}:`, message);
            return;
        }
        nativeConsole(`${name}: ${message}`);
    }
    function getFetchData(args, nativeRequestClone) {
        var fetchPropsObj = {};
        var resource = args[0];
        var fetchUrl;
        var fetchInit;
        if (resource instanceof Request) {
            var realData = nativeRequestClone.call(resource);
            var requestData = getRequestData(realData);
            fetchUrl = requestData.url;
            fetchInit = requestData;
        } else {
            fetchUrl = resource;
            fetchInit = args[1];
        }
        fetchPropsObj.url = fetchUrl;
        if (fetchInit instanceof Object) {
            var props = Object.keys(fetchInit);
            props.forEach((function(prop) {
                fetchPropsObj[prop] = fetchInit[prop];
            }));
        }
        return fetchPropsObj;
    }
    function objectToString(obj) {
        if (!obj || typeof obj !== "object") {
            return String(obj);
        }
        if (isEmptyObject(obj)) {
            return "{}";
        }
        return Object.entries(obj).map((function(pair) {
            var key = pair[0];
            var value = pair[1];
            var recordValueStr = value;
            if (value instanceof Object) {
                recordValueStr = `{ ${objectToString(value)} }`;
            }
            return `${key}:"${recordValueStr}"`;
        })).join(" ");
    }
    function matchRequestProps(source, propsToMatch, requestData) {
        if (propsToMatch === "" || propsToMatch === "*") {
            return true;
        }
        var isMatched;
        var parsedData = parseMatchProps(propsToMatch);
        if (!isValidParsedData(parsedData)) {
            logMessage(source, `Invalid parameter: ${propsToMatch}`);
            isMatched = false;
        } else {
            var matchData = getMatchPropsData(parsedData);
            var matchKeys = Object.keys(matchData);
            isMatched = matchKeys.every((function(matchKey) {
                var matchValue = matchData[matchKey];
                var dataValue = requestData[matchKey];
                return Object.prototype.hasOwnProperty.call(requestData, matchKey) && typeof dataValue === "string" && (matchValue === null || matchValue === void 0 ? void 0 : matchValue.test(dataValue));
            }));
        }
        return isMatched;
    }
    function jsonPruner(source, root, prunePaths, requiredPaths, stack, nativeObjects) {
        var {nativeStringify: nativeStringify} = nativeObjects;
        if (prunePaths.length === 0 && requiredPaths.length === 0) {
            logMessage(source, `${window.location.hostname}\n${nativeStringify(root, null, 2)}\nStack trace:\n${(new Error).stack}`, true);
            if (root && typeof root === "object") {
                logMessage(source, root, true, false);
            }
            return root;
        }
        try {
            if (isPruningNeeded(source, root, prunePaths, requiredPaths, stack, nativeObjects) === false) {
                return root;
            }
            prunePaths.forEach((function(path) {
                var pathToCheck = path.path;
                var valueToCheck = path.value;
                var ownerObjArr = getWildcardPropertyInChain(root, pathToCheck, true, [], valueToCheck);
                for (var i = ownerObjArr.length - 1; i >= 0; i -= 1) {
                    var ownerObj = ownerObjArr[i];
                    if (ownerObj === undefined || !ownerObj.base) {
                        continue;
                    }
                    hit(source);
                    if (!Array.isArray(ownerObj.base)) {
                        delete ownerObj.base[ownerObj.prop];
                        continue;
                    }
                    try {
                        var index = Number(ownerObj.prop);
                        if (Number.isNaN(index)) {
                            continue;
                        }
                        ownerObj.base.splice(index, 1);
                    } catch (error) {
                        console.error("Error while deleting array element", error);
                    }
                }
            }));
        } catch (e) {
            logMessage(source, e);
        }
        return root;
    }
    function getPrunePath(props) {
        var VALUE_MARKER = ".[=].";
        var REGEXP_START_MARKER = "/";
        var validPropsString = typeof props === "string" && props !== undefined && props !== "";
        if (validPropsString) {
            var splitRegexp = /(?<!\.\[=\]\.\/(?:[^/]|\\.)*)\s+/;
            var parts = props.split(splitRegexp).map((function(part) {
                var splitPart = part.split(VALUE_MARKER);
                var path = splitPart[0];
                var value = splitPart[1];
                if (value !== undefined) {
                    if (value === "true") {
                        value = true;
                    } else if (value === "false") {
                        value = false;
                    } else if (value.startsWith(REGEXP_START_MARKER)) {
                        value = toRegExp(value);
                    } else if (typeof value === "string" && /^\d+$/.test(value)) {
                        value = parseFloat(value);
                    }
                    return {
                        path: path,
                        value: value
                    };
                }
                return {
                    path: path
                };
            }));
            return parts;
        }
        return [];
    }
    function forgeResponse(response, textContent) {
        var {bodyUsed: bodyUsed, headers: headers, ok: ok, redirected: redirected, status: status, statusText: statusText, type: type, url: url} = response;
        var forgedResponse = new Response(textContent, {
            status: status,
            statusText: statusText,
            headers: headers
        });
        Object.defineProperties(forgedResponse, {
            url: {
                value: url
            },
            type: {
                value: type
            },
            ok: {
                value: ok
            },
            bodyUsed: {
                value: bodyUsed
            },
            redirected: {
                value: redirected
            }
        });
        return forgedResponse;
    }
    function isPruningNeeded(source, root, prunePaths, requiredPaths, stack, nativeObjects) {
        if (!root) {
            return false;
        }
        var {nativeStringify: nativeStringify} = nativeObjects;
        var shouldProcess;
        var prunePathsToCheck = prunePaths.map((function(obj) {
            return obj.path;
        }));
        var requiredPathsToCheck = requiredPaths.map((function(obj) {
            return obj.path;
        }));
        if (prunePathsToCheck.length === 0 && requiredPathsToCheck.length > 0) {
            var rootString = nativeStringify(root);
            var matchRegex = toRegExp(requiredPathsToCheck.join(""));
            var shouldLog = matchRegex.test(rootString);
            if (shouldLog) {
                logMessage(source, `${window.location.hostname}\n${nativeStringify(root, null, 2)}\nStack trace:\n${(new Error).stack}`, true);
                if (root && typeof root === "object") {
                    logMessage(source, root, true, false);
                }
                shouldProcess = false;
                return shouldProcess;
            }
        }
        if (stack && !matchStackTrace(stack, (new Error).stack || "")) {
            shouldProcess = false;
            return shouldProcess;
        }
        var wildcardSymbols = [ ".*.", "*.", ".*", ".[].", "[].", ".[]" ];
        var _loop = function _loop() {
            var requiredPath = requiredPathsToCheck[i];
            var lastNestedPropName = requiredPath.split(".").pop();
            var hasWildcard = wildcardSymbols.some((function(symbol) {
                return requiredPath.includes(symbol);
            }));
            var details = getWildcardPropertyInChain(root, requiredPath, hasWildcard);
            if (!details.length) {
                shouldProcess = false;
                return {
                    v: shouldProcess
                };
            }
            shouldProcess = !hasWildcard;
            for (var j = 0; j < details.length; j += 1) {
                var hasRequiredProp = typeof lastNestedPropName === "string" && details[j].base[lastNestedPropName] !== undefined;
                if (hasWildcard) {
                    shouldProcess = hasRequiredProp || shouldProcess;
                } else {
                    shouldProcess = hasRequiredProp && shouldProcess;
                }
            }
        }, _ret;
        for (var i = 0; i < requiredPathsToCheck.length; i += 1) {
            _ret = _loop();
            if (_ret) return _ret.v;
        }
        return shouldProcess;
    }
    function matchStackTrace(stackMatch, stackTrace) {
        if (!stackMatch || stackMatch === "") {
            return true;
        }
        var regExpValues = backupRegExpValues();
        if (shouldAbortInlineOrInjectedScript(stackMatch, stackTrace)) {
            if (regExpValues.length && regExpValues[0] !== RegExp.$1) {
                restoreRegExpValues(regExpValues);
            }
            return true;
        }
        var stackRegexp = toRegExp(stackMatch);
        var refinedStackTrace = stackTrace.split("\n").slice(2).map((function(line) {
            return line.trim();
        })).join("\n");
        if (regExpValues.length && regExpValues[0] !== RegExp.$1) {
            restoreRegExpValues(regExpValues);
        }
        return getNativeRegexpTest().call(stackRegexp, refinedStackTrace);
    }
    function toRegExp(rawInput) {
        var input = rawInput || "";
        var DEFAULT_VALUE = ".?";
        var FORWARD_SLASH = "/";
        if (input === "") {
            return new RegExp(DEFAULT_VALUE);
        }
        var delimiterIndex = input.lastIndexOf(FORWARD_SLASH);
        var flagsPart = input.substring(delimiterIndex + 1);
        var regExpPart = input.substring(0, delimiterIndex + 1);
        var isValidRegExpFlag = function isValidRegExpFlag(flag) {
            if (!flag) {
                return false;
            }
            try {
                new RegExp("", flag);
                return true;
            } catch (ex) {
                return false;
            }
        };
        var getRegExpFlags = function getRegExpFlags(regExpStr, flagsStr) {
            if (regExpStr.startsWith(FORWARD_SLASH) && regExpStr.endsWith(FORWARD_SLASH) && !regExpStr.endsWith("\\/") && isValidRegExpFlag(flagsStr)) {
                return flagsStr;
            }
            return "";
        };
        var flags = getRegExpFlags(regExpPart, flagsPart);
        if (input.startsWith(FORWARD_SLASH) && input.endsWith(FORWARD_SLASH) || flags) {
            var regExpInput = flags ? regExpPart : input;
            return new RegExp(regExpInput.slice(1, -1), flags);
        }
        var escaped = input.replace(/\\'/g, "'").replace(/\\"/g, '"').replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
        return new RegExp(escaped);
    }
    function isValidStrPattern(input) {
        var FORWARD_SLASH = "/";
        var str = escapeRegExp(input);
        if (input[0] === FORWARD_SLASH && input[input.length - 1] === FORWARD_SLASH) {
            str = input.slice(1, -1);
        }
        var isValid;
        try {
            isValid = new RegExp(str);
            isValid = true;
        } catch (e) {
            isValid = false;
        }
        return isValid;
    }
    function escapeRegExp(str) {
        return str.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
    }
    function isEmptyObject(obj) {
        return Object.keys(obj).length === 0 && !obj.prototype;
    }
    function getRequestData(request) {
        var requestInitOptions = getRequestProps();
        var entries = requestInitOptions.map((function(key) {
            var value = request[key];
            return [ key, value ];
        }));
        return Object.fromEntries(entries);
    }
    function getRequestProps() {
        return [ "url", "method", "headers", "body", "credentials", "cache", "redirect", "referrer", "referrerPolicy", "integrity", "keepalive", "signal", "mode" ];
    }
    function parseMatchProps(propsToMatchStr) {
        var PROPS_DIVIDER = " ";
        var PAIRS_MARKER = ":";
        var isRequestProp = function isRequestProp(prop) {
            return getRequestProps().includes(prop);
        };
        var propsObj = {};
        var props = propsToMatchStr.split(PROPS_DIVIDER);
        props.forEach((function(prop) {
            var dividerInd = prop.indexOf(PAIRS_MARKER);
            var key = prop.slice(0, dividerInd);
            if (isRequestProp(key)) {
                var value = prop.slice(dividerInd + 1);
                propsObj[key] = value;
            } else {
                propsObj.url = prop;
            }
        }));
        return propsObj;
    }
    function isValidParsedData(data) {
        return Object.values(data).every((function(value) {
            return isValidStrPattern(value);
        }));
    }
    function getMatchPropsData(data) {
        var matchData = {};
        var dataKeys = Object.keys(data);
        dataKeys.forEach((function(key) {
            matchData[key] = toRegExp(data[key]);
        }));
        return matchData;
    }
    function getWildcardPropertyInChain(base, chain) {
        var lookThrough = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
        var output = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [];
        var valueToCheck = arguments.length > 4 ? arguments[4] : undefined;
        var pos = chain.indexOf(".");
        if (pos === -1) {
            if (chain === "*" || chain === "[]") {
                for (var key in base) {
                    if (Object.prototype.hasOwnProperty.call(base, key)) {
                        if (valueToCheck !== undefined) {
                            var objectValue = base[key];
                            if (typeof objectValue === "string" && valueToCheck instanceof RegExp) {
                                if (valueToCheck.test(objectValue)) {
                                    output.push({
                                        base: base,
                                        prop: key
                                    });
                                }
                            } else if (objectValue === valueToCheck) {
                                output.push({
                                    base: base,
                                    prop: key
                                });
                            }
                        } else {
                            output.push({
                                base: base,
                                prop: key
                            });
                        }
                    }
                }
            } else if (valueToCheck !== undefined) {
                var _objectValue = base[chain];
                if (typeof _objectValue === "string" && valueToCheck instanceof RegExp) {
                    if (valueToCheck.test(_objectValue)) {
                        output.push({
                            base: base,
                            prop: chain
                        });
                    }
                } else if (base[chain] === valueToCheck) {
                    output.push({
                        base: base,
                        prop: chain
                    });
                }
            } else {
                output.push({
                    base: base,
                    prop: chain
                });
            }
            return output;
        }
        var prop = chain.slice(0, pos);
        var shouldLookThrough = prop === "[]" && Array.isArray(base) || prop === "*" && base instanceof Object || prop === "[-]" && Array.isArray(base) || prop === "{-}" && base instanceof Object;
        if (shouldLookThrough) {
            var nextProp = chain.slice(pos + 1);
            var baseKeys = Object.keys(base);
            if (prop === "{-}" || prop === "[-]") {
                var type = Array.isArray(base) ? "array" : "object";
                var shouldRemove = !!(prop === "{-}" && type === "object") || !!(prop === "[-]" && type === "array");
                if (!shouldRemove) {
                    return output;
                }
                baseKeys.forEach((function(key) {
                    var item = base[key];
                    if (isKeyInObject(item, nextProp, valueToCheck)) {
                        output.push({
                            base: base,
                            prop: key
                        });
                    }
                }));
                return output;
            }
            baseKeys.forEach((function(key) {
                var item = base[key];
                getWildcardPropertyInChain(item, nextProp, lookThrough, output, valueToCheck);
            }));
        }
        if (Array.isArray(base)) {
            base.forEach((function(key) {
                var nextBase = key;
                if (nextBase !== undefined) {
                    getWildcardPropertyInChain(nextBase, chain, lookThrough, output, valueToCheck);
                }
            }));
        }
        var nextBase = base[prop];
        chain = chain.slice(pos + 1);
        if (nextBase !== undefined) {
            getWildcardPropertyInChain(nextBase, chain, lookThrough, output, valueToCheck);
        }
        return output;
    }
    function shouldAbortInlineOrInjectedScript(stackMatch, stackTrace) {
        var INLINE_SCRIPT_STRING = "inlineScript";
        var INJECTED_SCRIPT_STRING = "injectedScript";
        var INJECTED_SCRIPT_MARKER = "<anonymous>";
        var isInlineScript = function isInlineScript(match) {
            return match.includes(INLINE_SCRIPT_STRING);
        };
        var isInjectedScript = function isInjectedScript(match) {
            return match.includes(INJECTED_SCRIPT_STRING);
        };
        if (!(isInlineScript(stackMatch) || isInjectedScript(stackMatch))) {
            return false;
        }
        var documentURL = window.location.href;
        var pos = documentURL.indexOf("#");
        if (pos !== -1) {
            documentURL = documentURL.slice(0, pos);
        }
        var stackSteps = stackTrace.split("\n").slice(2).map((function(line) {
            return line.trim();
        }));
        var stackLines = stackSteps.map((function(line) {
            var stack;
            var getStackTraceValues = /(.*?@)?(\S+)(:\d+)(:\d+)\)?$/.exec(line);
            if (getStackTraceValues) {
                var _stackURL, _stackURL2;
                var stackURL = getStackTraceValues[2];
                var stackLine = getStackTraceValues[3];
                var stackCol = getStackTraceValues[4];
                if ((_stackURL = stackURL) !== null && _stackURL !== void 0 && _stackURL.startsWith("(")) {
                    stackURL = stackURL.slice(1);
                }
                if ((_stackURL2 = stackURL) !== null && _stackURL2 !== void 0 && _stackURL2.startsWith(INJECTED_SCRIPT_MARKER)) {
                    var _stackFunction;
                    stackURL = INJECTED_SCRIPT_STRING;
                    var stackFunction = getStackTraceValues[1] !== undefined ? getStackTraceValues[1].slice(0, -1) : line.slice(0, getStackTraceValues.index).trim();
                    if ((_stackFunction = stackFunction) !== null && _stackFunction !== void 0 && _stackFunction.startsWith("at")) {
                        stackFunction = stackFunction.slice(2).trim();
                    }
                    stack = `${stackFunction} ${stackURL}${stackLine}${stackCol}`.trim();
                } else if (stackURL === documentURL) {
                    stack = `${INLINE_SCRIPT_STRING}${stackLine}${stackCol}`.trim();
                } else {
                    stack = `${stackURL}${stackLine}${stackCol}`.trim();
                }
            } else {
                stack = line;
            }
            return stack;
        }));
        if (stackLines) {
            for (var index = 0; index < stackLines.length; index += 1) {
                if (isInlineScript(stackMatch) && stackLines[index].startsWith(INLINE_SCRIPT_STRING) && stackLines[index].match(toRegExp(stackMatch))) {
                    return true;
                }
                if (isInjectedScript(stackMatch) && stackLines[index].startsWith(INJECTED_SCRIPT_STRING) && stackLines[index].match(toRegExp(stackMatch))) {
                    return true;
                }
            }
        }
        return false;
    }
    function getNativeRegexpTest() {
        var descriptor = Object.getOwnPropertyDescriptor(RegExp.prototype, "test");
        var nativeRegexTest = descriptor === null || descriptor === void 0 ? void 0 : descriptor.value;
        if (descriptor && typeof descriptor.value === "function") {
            return nativeRegexTest;
        }
        throw new Error("RegExp.prototype.test is not a function");
    }
    function backupRegExpValues() {
        try {
            var arrayOfRegexpValues = [];
            for (var index = 1; index < 10; index += 1) {
                var value = `$${index}`;
                if (!RegExp[value]) {
                    break;
                }
                arrayOfRegexpValues.push(RegExp[value]);
            }
            return arrayOfRegexpValues;
        } catch (error) {
            return [];
        }
    }
    function restoreRegExpValues(array) {
        if (!array.length) {
            return;
        }
        try {
            var stringPattern = "";
            if (array.length === 1) {
                stringPattern = `(${array[0]})`;
            } else {
                stringPattern = array.reduce((function(accumulator, currentValue, currentIndex) {
                    if (currentIndex === 1) {
                        return `(${accumulator}),(${currentValue})`;
                    }
                    return `${accumulator},(${currentValue})`;
                }));
            }
            var regExpGroup = new RegExp(stringPattern);
            array.toString().replace(regExpGroup, "");
        } catch (error) {
            var message = `Failed to restore RegExp values: ${error}`;
            console.log(message);
        }
    }
    function isKeyInObject(baseObj, path, valueToCheck) {
        var parts = path.split(".");
        var _check = function check(targetObject, pathSegments) {
            if (pathSegments.length === 0) {
                if (valueToCheck !== undefined) {
                    if (typeof targetObject === "string" && valueToCheck instanceof RegExp) {
                        return valueToCheck.test(targetObject);
                    }
                    return targetObject === valueToCheck;
                }
                return true;
            }
            var current = pathSegments[0];
            var rest = pathSegments.slice(1);
            if (current === "*" || current === "[]") {
                if (Array.isArray(targetObject)) {
                    return targetObject.some((function(item) {
                        return _check(item, rest);
                    }));
                }
                if (typeof targetObject === "object" && targetObject !== null) {
                    return Object.keys(targetObject).some((function(key) {
                        return _check(targetObject[key], rest);
                    }));
                }
            }
            if (Object.prototype.hasOwnProperty.call(targetObject, current)) {
                return _check(targetObject[current], rest);
            }
            return false;
        };
        return _check(baseObj, parts);
    }
    var updatedArgs = args ? [].concat(source).concat(args) : [ source ];
    try {
        jsonPruneFetchResponse.apply(this, updatedArgs);
        if (source.uniqueId) {
            Object.defineProperty(Window.prototype.toString, uniqueIdentifier, {
                value: flag,
                enumerable: false,
                writable: false,
                configurable: false
            });
        }
    } catch (e) {
        console.log(e);
    }
}

function jsonPruneXhrResponse(source, args) {
    var flag = "done";
    var uniqueIdentifier = source.uniqueId + source.name + "_" + (Array.isArray(args) ? args.join("_") : "");
    if (source.uniqueId) {
        if (Window.prototype.toString[uniqueIdentifier] === flag) {
            return;
        }
    }
    function jsonPruneXhrResponse(source, propsToRemove, obligatoryProps) {
        var propsToMatch = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : "";
        var stack = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : "";
        if (typeof Proxy === "undefined") {
            return;
        }
        var shouldLog = !propsToRemove && !obligatoryProps;
        var prunePaths = getPrunePath(propsToRemove);
        var requiredPaths = getPrunePath(obligatoryProps);
        var nativeParse = window.JSON.parse;
        var nativeStringify = window.JSON.stringify;
        var nativeOpen = window.XMLHttpRequest.prototype.open;
        var nativeSend = window.XMLHttpRequest.prototype.send;
        var setRequestHeaderWrapper = function setRequestHeaderWrapper(setRequestHeader, thisArgument, argsList) {
            thisArgument.collectedHeaders.push(argsList);
            return Reflect.apply(setRequestHeader, thisArgument, argsList);
        };
        var setRequestHeaderHandler = {
            apply: setRequestHeaderWrapper
        };
        var xhrData;
        var openWrapper = function openWrapper(target, thisArg, args) {
            xhrData = getXhrData.apply(null, args);
            if (matchRequestProps(source, propsToMatch, xhrData) || shouldLog) {
                thisArg.xhrShouldBePruned = true;
                thisArg.headersReceived = !!thisArg.headersReceived;
            }
            if (thisArg.xhrShouldBePruned && !thisArg.headersReceived) {
                thisArg.headersReceived = true;
                thisArg.collectedHeaders = [];
                thisArg.setRequestHeader = new Proxy(thisArg.setRequestHeader, setRequestHeaderHandler);
            }
            return Reflect.apply(target, thisArg, args);
        };
        var sendWrapper = function sendWrapper(target, thisArg, args) {
            var stackTrace = (new Error).stack || "";
            if (!thisArg.xhrShouldBePruned || stack && !matchStackTrace(stack, stackTrace)) {
                return Reflect.apply(target, thisArg, args);
            }
            var forgedRequest = new XMLHttpRequest;
            forgedRequest.addEventListener("readystatechange", (function() {
                if (forgedRequest.readyState !== 4) {
                    return;
                }
                var {readyState: readyState, response: response, responseText: responseText, responseURL: responseURL, responseXML: responseXML, status: status, statusText: statusText} = forgedRequest;
                var content = responseText || response;
                if (typeof content !== "string" && typeof content !== "object") {
                    return;
                }
                var modifiedContent;
                if (typeof content === "string") {
                    try {
                        var jsonContent = nativeParse(content);
                        if (shouldLog) {
                            logMessage(source, `${window.location.hostname}\n${nativeStringify(jsonContent, null, 2)}\nStack trace:\n${stackTrace}`, true);
                            logMessage(source, jsonContent, true, false);
                            modifiedContent = content;
                        } else {
                            modifiedContent = jsonPruner(source, jsonContent, prunePaths, requiredPaths, stack = "", {
                                nativeStringify: nativeStringify
                            });
                            try {
                                var {responseType: responseType} = thisArg;
                                switch (responseType) {
                                  case "":
                                  case "text":
                                    modifiedContent = nativeStringify(modifiedContent);
                                    break;

                                  case "arraybuffer":
                                    modifiedContent = (new TextEncoder).encode(nativeStringify(modifiedContent)).buffer;
                                    break;

                                  case "blob":
                                    modifiedContent = new Blob([ nativeStringify(modifiedContent) ]);
                                    break;

                                  default:
                                    break;
                                }
                            } catch (error) {
                                var message = `Response body cannot be converted to reponse type: '${content}'`;
                                logMessage(source, message);
                                modifiedContent = content;
                            }
                        }
                    } catch (error) {
                        var _message = `Response body cannot be converted to json: '${content}'`;
                        logMessage(source, _message);
                        modifiedContent = content;
                    }
                }
                Object.defineProperties(thisArg, {
                    readyState: {
                        value: readyState,
                        writable: false
                    },
                    responseURL: {
                        value: responseURL,
                        writable: false
                    },
                    responseXML: {
                        value: responseXML,
                        writable: false
                    },
                    status: {
                        value: status,
                        writable: false
                    },
                    statusText: {
                        value: statusText,
                        writable: false
                    },
                    response: {
                        value: modifiedContent,
                        writable: false
                    },
                    responseText: {
                        value: modifiedContent,
                        writable: false
                    }
                });
                setTimeout((function() {
                    var stateEvent = new Event("readystatechange");
                    thisArg.dispatchEvent(stateEvent);
                    var loadEvent = new Event("load");
                    thisArg.dispatchEvent(loadEvent);
                    var loadEndEvent = new Event("loadend");
                    thisArg.dispatchEvent(loadEndEvent);
                }), 1);
                hit(source);
            }));
            nativeOpen.apply(forgedRequest, [ xhrData.method, xhrData.url, Boolean(xhrData.async) ]);
            thisArg.collectedHeaders.forEach((function(header) {
                forgedRequest.setRequestHeader(header[0], header[1]);
            }));
            thisArg.collectedHeaders = [];
            try {
                nativeSend.call(forgedRequest, args);
            } catch (_unused) {
                return Reflect.apply(target, thisArg, args);
            }
            return undefined;
        };
        var openHandler = {
            apply: openWrapper
        };
        var sendHandler = {
            apply: sendWrapper
        };
        XMLHttpRequest.prototype.open = new Proxy(XMLHttpRequest.prototype.open, openHandler);
        XMLHttpRequest.prototype.send = new Proxy(XMLHttpRequest.prototype.send, sendHandler);
    }
    function hit(source) {
        var ADGUARD_PREFIX = "[AdGuard]";
        if (!source.verbose) {
            return;
        }
        try {
            var trace = console.trace.bind(console);
            var label = `${ADGUARD_PREFIX} `;
            if (source.engine === "corelibs") {
                label += source.ruleText;
            } else {
                if (source.domainName) {
                    label += `${source.domainName}`;
                }
                if (source.args) {
                    label += `#%#//scriptlet('${source.name}', '${source.args.join("', '")}')`;
                } else {
                    label += `#%#//scriptlet('${source.name}')`;
                }
            }
            if (trace) {
                trace(label);
            }
        } catch (e) {}
        if (typeof window.__debug === "function") {
            window.__debug(source);
        }
    }
    function logMessage(source, message) {
        var forced = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
        var convertMessageToString = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
        var {name: name, verbose: verbose} = source;
        if (!forced && !verbose) {
            return;
        }
        var nativeConsole = console.log;
        if (!convertMessageToString) {
            nativeConsole(`${name}:`, message);
            return;
        }
        nativeConsole(`${name}: ${message}`);
    }
    function toRegExp(rawInput) {
        var input = rawInput || "";
        var DEFAULT_VALUE = ".?";
        var FORWARD_SLASH = "/";
        if (input === "") {
            return new RegExp(DEFAULT_VALUE);
        }
        var delimiterIndex = input.lastIndexOf(FORWARD_SLASH);
        var flagsPart = input.substring(delimiterIndex + 1);
        var regExpPart = input.substring(0, delimiterIndex + 1);
        var isValidRegExpFlag = function isValidRegExpFlag(flag) {
            if (!flag) {
                return false;
            }
            try {
                new RegExp("", flag);
                return true;
            } catch (ex) {
                return false;
            }
        };
        var getRegExpFlags = function getRegExpFlags(regExpStr, flagsStr) {
            if (regExpStr.startsWith(FORWARD_SLASH) && regExpStr.endsWith(FORWARD_SLASH) && !regExpStr.endsWith("\\/") && isValidRegExpFlag(flagsStr)) {
                return flagsStr;
            }
            return "";
        };
        var flags = getRegExpFlags(regExpPart, flagsPart);
        if (input.startsWith(FORWARD_SLASH) && input.endsWith(FORWARD_SLASH) || flags) {
            var regExpInput = flags ? regExpPart : input;
            return new RegExp(regExpInput.slice(1, -1), flags);
        }
        var escaped = input.replace(/\\'/g, "'").replace(/\\"/g, '"').replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
        return new RegExp(escaped);
    }
    function jsonPruner(source, root, prunePaths, requiredPaths, stack, nativeObjects) {
        var {nativeStringify: nativeStringify} = nativeObjects;
        if (prunePaths.length === 0 && requiredPaths.length === 0) {
            logMessage(source, `${window.location.hostname}\n${nativeStringify(root, null, 2)}\nStack trace:\n${(new Error).stack}`, true);
            if (root && typeof root === "object") {
                logMessage(source, root, true, false);
            }
            return root;
        }
        try {
            if (isPruningNeeded(source, root, prunePaths, requiredPaths, stack, nativeObjects) === false) {
                return root;
            }
            prunePaths.forEach((function(path) {
                var pathToCheck = path.path;
                var valueToCheck = path.value;
                var ownerObjArr = getWildcardPropertyInChain(root, pathToCheck, true, [], valueToCheck);
                for (var i = ownerObjArr.length - 1; i >= 0; i -= 1) {
                    var ownerObj = ownerObjArr[i];
                    if (ownerObj === undefined || !ownerObj.base) {
                        continue;
                    }
                    hit(source);
                    if (!Array.isArray(ownerObj.base)) {
                        delete ownerObj.base[ownerObj.prop];
                        continue;
                    }
                    try {
                        var index = Number(ownerObj.prop);
                        if (Number.isNaN(index)) {
                            continue;
                        }
                        ownerObj.base.splice(index, 1);
                    } catch (error) {
                        console.error("Error while deleting array element", error);
                    }
                }
            }));
        } catch (e) {
            logMessage(source, e);
        }
        return root;
    }
    function getPrunePath(props) {
        var VALUE_MARKER = ".[=].";
        var REGEXP_START_MARKER = "/";
        var validPropsString = typeof props === "string" && props !== undefined && props !== "";
        if (validPropsString) {
            var splitRegexp = /(?<!\.\[=\]\.\/(?:[^/]|\\.)*)\s+/;
            var parts = props.split(splitRegexp).map((function(part) {
                var splitPart = part.split(VALUE_MARKER);
                var path = splitPart[0];
                var value = splitPart[1];
                if (value !== undefined) {
                    if (value === "true") {
                        value = true;
                    } else if (value === "false") {
                        value = false;
                    } else if (value.startsWith(REGEXP_START_MARKER)) {
                        value = toRegExp(value);
                    } else if (typeof value === "string" && /^\d+$/.test(value)) {
                        value = parseFloat(value);
                    }
                    return {
                        path: path,
                        value: value
                    };
                }
                return {
                    path: path
                };
            }));
            return parts;
        }
        return [];
    }
    function matchRequestProps(source, propsToMatch, requestData) {
        if (propsToMatch === "" || propsToMatch === "*") {
            return true;
        }
        var isMatched;
        var parsedData = parseMatchProps(propsToMatch);
        if (!isValidParsedData(parsedData)) {
            logMessage(source, `Invalid parameter: ${propsToMatch}`);
            isMatched = false;
        } else {
            var matchData = getMatchPropsData(parsedData);
            var matchKeys = Object.keys(matchData);
            isMatched = matchKeys.every((function(matchKey) {
                var matchValue = matchData[matchKey];
                var dataValue = requestData[matchKey];
                return Object.prototype.hasOwnProperty.call(requestData, matchKey) && typeof dataValue === "string" && (matchValue === null || matchValue === void 0 ? void 0 : matchValue.test(dataValue));
            }));
        }
        return isMatched;
    }
    function getXhrData(method, url, async, user, password) {
        return {
            method: method,
            url: url,
            async: async,
            user: user,
            password: password
        };
    }
    function isPruningNeeded(source, root, prunePaths, requiredPaths, stack, nativeObjects) {
        if (!root) {
            return false;
        }
        var {nativeStringify: nativeStringify} = nativeObjects;
        var shouldProcess;
        var prunePathsToCheck = prunePaths.map((function(obj) {
            return obj.path;
        }));
        var requiredPathsToCheck = requiredPaths.map((function(obj) {
            return obj.path;
        }));
        if (prunePathsToCheck.length === 0 && requiredPathsToCheck.length > 0) {
            var rootString = nativeStringify(root);
            var matchRegex = toRegExp(requiredPathsToCheck.join(""));
            var shouldLog = matchRegex.test(rootString);
            if (shouldLog) {
                logMessage(source, `${window.location.hostname}\n${nativeStringify(root, null, 2)}\nStack trace:\n${(new Error).stack}`, true);
                if (root && typeof root === "object") {
                    logMessage(source, root, true, false);
                }
                shouldProcess = false;
                return shouldProcess;
            }
        }
        if (stack && !matchStackTrace(stack, (new Error).stack || "")) {
            shouldProcess = false;
            return shouldProcess;
        }
        var wildcardSymbols = [ ".*.", "*.", ".*", ".[].", "[].", ".[]" ];
        var _loop = function _loop() {
            var requiredPath = requiredPathsToCheck[i];
            var lastNestedPropName = requiredPath.split(".").pop();
            var hasWildcard = wildcardSymbols.some((function(symbol) {
                return requiredPath.includes(symbol);
            }));
            var details = getWildcardPropertyInChain(root, requiredPath, hasWildcard);
            if (!details.length) {
                shouldProcess = false;
                return {
                    v: shouldProcess
                };
            }
            shouldProcess = !hasWildcard;
            for (var j = 0; j < details.length; j += 1) {
                var hasRequiredProp = typeof lastNestedPropName === "string" && details[j].base[lastNestedPropName] !== undefined;
                if (hasWildcard) {
                    shouldProcess = hasRequiredProp || shouldProcess;
                } else {
                    shouldProcess = hasRequiredProp && shouldProcess;
                }
            }
        }, _ret;
        for (var i = 0; i < requiredPathsToCheck.length; i += 1) {
            _ret = _loop();
            if (_ret) return _ret.v;
        }
        return shouldProcess;
    }
    function matchStackTrace(stackMatch, stackTrace) {
        if (!stackMatch || stackMatch === "") {
            return true;
        }
        var regExpValues = backupRegExpValues();
        if (shouldAbortInlineOrInjectedScript(stackMatch, stackTrace)) {
            if (regExpValues.length && regExpValues[0] !== RegExp.$1) {
                restoreRegExpValues(regExpValues);
            }
            return true;
        }
        var stackRegexp = toRegExp(stackMatch);
        var refinedStackTrace = stackTrace.split("\n").slice(2).map((function(line) {
            return line.trim();
        })).join("\n");
        if (regExpValues.length && regExpValues[0] !== RegExp.$1) {
            restoreRegExpValues(regExpValues);
        }
        return getNativeRegexpTest().call(stackRegexp, refinedStackTrace);
    }
    function getMatchPropsData(data) {
        var matchData = {};
        var dataKeys = Object.keys(data);
        dataKeys.forEach((function(key) {
            matchData[key] = toRegExp(data[key]);
        }));
        return matchData;
    }
    function getRequestProps() {
        return [ "url", "method", "headers", "body", "credentials", "cache", "redirect", "referrer", "referrerPolicy", "integrity", "keepalive", "signal", "mode" ];
    }
    function isValidParsedData(data) {
        return Object.values(data).every((function(value) {
            return isValidStrPattern(value);
        }));
    }
    function parseMatchProps(propsToMatchStr) {
        var PROPS_DIVIDER = " ";
        var PAIRS_MARKER = ":";
        var isRequestProp = function isRequestProp(prop) {
            return getRequestProps().includes(prop);
        };
        var propsObj = {};
        var props = propsToMatchStr.split(PROPS_DIVIDER);
        props.forEach((function(prop) {
            var dividerInd = prop.indexOf(PAIRS_MARKER);
            var key = prop.slice(0, dividerInd);
            if (isRequestProp(key)) {
                var value = prop.slice(dividerInd + 1);
                propsObj[key] = value;
            } else {
                propsObj.url = prop;
            }
        }));
        return propsObj;
    }
    function isValidStrPattern(input) {
        var FORWARD_SLASH = "/";
        var str = escapeRegExp(input);
        if (input[0] === FORWARD_SLASH && input[input.length - 1] === FORWARD_SLASH) {
            str = input.slice(1, -1);
        }
        var isValid;
        try {
            isValid = new RegExp(str);
            isValid = true;
        } catch (e) {
            isValid = false;
        }
        return isValid;
    }
    function escapeRegExp(str) {
        return str.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
    }
    function getWildcardPropertyInChain(base, chain) {
        var lookThrough = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
        var output = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [];
        var valueToCheck = arguments.length > 4 ? arguments[4] : undefined;
        var pos = chain.indexOf(".");
        if (pos === -1) {
            if (chain === "*" || chain === "[]") {
                for (var key in base) {
                    if (Object.prototype.hasOwnProperty.call(base, key)) {
                        if (valueToCheck !== undefined) {
                            var objectValue = base[key];
                            if (typeof objectValue === "string" && valueToCheck instanceof RegExp) {
                                if (valueToCheck.test(objectValue)) {
                                    output.push({
                                        base: base,
                                        prop: key
                                    });
                                }
                            } else if (objectValue === valueToCheck) {
                                output.push({
                                    base: base,
                                    prop: key
                                });
                            }
                        } else {
                            output.push({
                                base: base,
                                prop: key
                            });
                        }
                    }
                }
            } else if (valueToCheck !== undefined) {
                var _objectValue = base[chain];
                if (typeof _objectValue === "string" && valueToCheck instanceof RegExp) {
                    if (valueToCheck.test(_objectValue)) {
                        output.push({
                            base: base,
                            prop: chain
                        });
                    }
                } else if (base[chain] === valueToCheck) {
                    output.push({
                        base: base,
                        prop: chain
                    });
                }
            } else {
                output.push({
                    base: base,
                    prop: chain
                });
            }
            return output;
        }
        var prop = chain.slice(0, pos);
        var shouldLookThrough = prop === "[]" && Array.isArray(base) || prop === "*" && base instanceof Object || prop === "[-]" && Array.isArray(base) || prop === "{-}" && base instanceof Object;
        if (shouldLookThrough) {
            var nextProp = chain.slice(pos + 1);
            var baseKeys = Object.keys(base);
            if (prop === "{-}" || prop === "[-]") {
                var type = Array.isArray(base) ? "array" : "object";
                var shouldRemove = !!(prop === "{-}" && type === "object") || !!(prop === "[-]" && type === "array");
                if (!shouldRemove) {
                    return output;
                }
                baseKeys.forEach((function(key) {
                    var item = base[key];
                    if (isKeyInObject(item, nextProp, valueToCheck)) {
                        output.push({
                            base: base,
                            prop: key
                        });
                    }
                }));
                return output;
            }
            baseKeys.forEach((function(key) {
                var item = base[key];
                getWildcardPropertyInChain(item, nextProp, lookThrough, output, valueToCheck);
            }));
        }
        if (Array.isArray(base)) {
            base.forEach((function(key) {
                var nextBase = key;
                if (nextBase !== undefined) {
                    getWildcardPropertyInChain(nextBase, chain, lookThrough, output, valueToCheck);
                }
            }));
        }
        var nextBase = base[prop];
        chain = chain.slice(pos + 1);
        if (nextBase !== undefined) {
            getWildcardPropertyInChain(nextBase, chain, lookThrough, output, valueToCheck);
        }
        return output;
    }
    function shouldAbortInlineOrInjectedScript(stackMatch, stackTrace) {
        var INLINE_SCRIPT_STRING = "inlineScript";
        var INJECTED_SCRIPT_STRING = "injectedScript";
        var INJECTED_SCRIPT_MARKER = "<anonymous>";
        var isInlineScript = function isInlineScript(match) {
            return match.includes(INLINE_SCRIPT_STRING);
        };
        var isInjectedScript = function isInjectedScript(match) {
            return match.includes(INJECTED_SCRIPT_STRING);
        };
        if (!(isInlineScript(stackMatch) || isInjectedScript(stackMatch))) {
            return false;
        }
        var documentURL = window.location.href;
        var pos = documentURL.indexOf("#");
        if (pos !== -1) {
            documentURL = documentURL.slice(0, pos);
        }
        var stackSteps = stackTrace.split("\n").slice(2).map((function(line) {
            return line.trim();
        }));
        var stackLines = stackSteps.map((function(line) {
            var stack;
            var getStackTraceValues = /(.*?@)?(\S+)(:\d+)(:\d+)\)?$/.exec(line);
            if (getStackTraceValues) {
                var _stackURL, _stackURL2;
                var stackURL = getStackTraceValues[2];
                var stackLine = getStackTraceValues[3];
                var stackCol = getStackTraceValues[4];
                if ((_stackURL = stackURL) !== null && _stackURL !== void 0 && _stackURL.startsWith("(")) {
                    stackURL = stackURL.slice(1);
                }
                if ((_stackURL2 = stackURL) !== null && _stackURL2 !== void 0 && _stackURL2.startsWith(INJECTED_SCRIPT_MARKER)) {
                    var _stackFunction;
                    stackURL = INJECTED_SCRIPT_STRING;
                    var stackFunction = getStackTraceValues[1] !== undefined ? getStackTraceValues[1].slice(0, -1) : line.slice(0, getStackTraceValues.index).trim();
                    if ((_stackFunction = stackFunction) !== null && _stackFunction !== void 0 && _stackFunction.startsWith("at")) {
                        stackFunction = stackFunction.slice(2).trim();
                    }
                    stack = `${stackFunction} ${stackURL}${stackLine}${stackCol}`.trim();
                } else if (stackURL === documentURL) {
                    stack = `${INLINE_SCRIPT_STRING}${stackLine}${stackCol}`.trim();
                } else {
                    stack = `${stackURL}${stackLine}${stackCol}`.trim();
                }
            } else {
                stack = line;
            }
            return stack;
        }));
        if (stackLines) {
            for (var index = 0; index < stackLines.length; index += 1) {
                if (isInlineScript(stackMatch) && stackLines[index].startsWith(INLINE_SCRIPT_STRING) && stackLines[index].match(toRegExp(stackMatch))) {
                    return true;
                }
                if (isInjectedScript(stackMatch) && stackLines[index].startsWith(INJECTED_SCRIPT_STRING) && stackLines[index].match(toRegExp(stackMatch))) {
                    return true;
                }
            }
        }
        return false;
    }
    function getNativeRegexpTest() {
        var descriptor = Object.getOwnPropertyDescriptor(RegExp.prototype, "test");
        var nativeRegexTest = descriptor === null || descriptor === void 0 ? void 0 : descriptor.value;
        if (descriptor && typeof descriptor.value === "function") {
            return nativeRegexTest;
        }
        throw new Error("RegExp.prototype.test is not a function");
    }
    function backupRegExpValues() {
        try {
            var arrayOfRegexpValues = [];
            for (var index = 1; index < 10; index += 1) {
                var value = `$${index}`;
                if (!RegExp[value]) {
                    break;
                }
                arrayOfRegexpValues.push(RegExp[value]);
            }
            return arrayOfRegexpValues;
        } catch (error) {
            return [];
        }
    }
    function restoreRegExpValues(array) {
        if (!array.length) {
            return;
        }
        try {
            var stringPattern = "";
            if (array.length === 1) {
                stringPattern = `(${array[0]})`;
            } else {
                stringPattern = array.reduce((function(accumulator, currentValue, currentIndex) {
                    if (currentIndex === 1) {
                        return `(${accumulator}),(${currentValue})`;
                    }
                    return `${accumulator},(${currentValue})`;
                }));
            }
            var regExpGroup = new RegExp(stringPattern);
            array.toString().replace(regExpGroup, "");
        } catch (error) {
            var message = `Failed to restore RegExp values: ${error}`;
            console.log(message);
        }
    }
    function isKeyInObject(baseObj, path, valueToCheck) {
        var parts = path.split(".");
        var _check = function check(targetObject, pathSegments) {
            if (pathSegments.length === 0) {
                if (valueToCheck !== undefined) {
                    if (typeof targetObject === "string" && valueToCheck instanceof RegExp) {
                        return valueToCheck.test(targetObject);
                    }
                    return targetObject === valueToCheck;
                }
                return true;
            }
            var current = pathSegments[0];
            var rest = pathSegments.slice(1);
            if (current === "*" || current === "[]") {
                if (Array.isArray(targetObject)) {
                    return targetObject.some((function(item) {
                        return _check(item, rest);
                    }));
                }
                if (typeof targetObject === "object" && targetObject !== null) {
                    return Object.keys(targetObject).some((function(key) {
                        return _check(targetObject[key], rest);
                    }));
                }
            }
            if (Object.prototype.hasOwnProperty.call(targetObject, current)) {
                return _check(targetObject[current], rest);
            }
            return false;
        };
        return _check(baseObj, parts);
    }
    var updatedArgs = args ? [].concat(source).concat(args) : [ source ];
    try {
        jsonPruneXhrResponse.apply(this, updatedArgs);
        if (source.uniqueId) {
            Object.defineProperty(Window.prototype.toString, uniqueIdentifier, {
                value: flag,
                enumerable: false,
                writable: false,
                configurable: false
            });
        }
    } catch (e) {
        console.log(e);
    }
}

function log(source, args) {
    var flag = "done";
    var uniqueIdentifier = source.uniqueId + source.name + "_" + (Array.isArray(args) ? args.join("_") : "");
    if (source.uniqueId) {
        if (Window.prototype.toString[uniqueIdentifier] === flag) {
            return;
        }
    }
    function log() {
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
        }
        console.log(args);
    }
    var updatedArgs = args ? [].concat(source).concat(args) : [ source ];
    try {
        log.apply(this, updatedArgs);
        if (source.uniqueId) {
            Object.defineProperty(Window.prototype.toString, uniqueIdentifier, {
                value: flag,
                enumerable: false,
                writable: false,
                configurable: false
            });
        }
    } catch (e) {
        console.log(e);
    }
}

function logAddEventListener(source, args) {
    var flag = "done";
    var uniqueIdentifier = source.uniqueId + source.name + "_" + (Array.isArray(args) ? args.join("_") : "");
    if (source.uniqueId) {
        if (Window.prototype.toString[uniqueIdentifier] === flag) {
            return;
        }
    }
    function logAddEventListener(source) {
        var nativeAddEventListener = window.EventTarget.prototype.addEventListener;
        function addEventListenerWrapper(type, listener) {
            var _this$constructor;
            if (validateType(type) && validateListener(listener)) {
                var message = `addEventListener("${type}", ${listenerToString(listener)})`;
                logMessage(source, message, true);
                hit(source);
            } else {
                var _message = `Invalid event type or listener passed to addEventListener:\n        type: ${convertTypeToString(type)}\n        listener: ${convertTypeToString(listener)}`;
                logMessage(source, _message, true);
            }
            var context = this;
            if (this && ((_this$constructor = this.constructor) === null || _this$constructor === void 0 ? void 0 : _this$constructor.name) === "Window" && this !== window) {
                context = window;
            }
            for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
                args[_key - 2] = arguments[_key];
            }
            return nativeAddEventListener.apply(context, [ type, listener, ...args ]);
        }
        var descriptor = {
            configurable: true,
            set: function set() {},
            get: function get() {
                return addEventListenerWrapper;
            }
        };
        Object.defineProperty(window.EventTarget.prototype, "addEventListener", descriptor);
        Object.defineProperty(window, "addEventListener", descriptor);
        Object.defineProperty(document, "addEventListener", descriptor);
    }
    function hit(source) {
        var ADGUARD_PREFIX = "[AdGuard]";
        if (!source.verbose) {
            return;
        }
        try {
            var trace = console.trace.bind(console);
            var label = `${ADGUARD_PREFIX} `;
            if (source.engine === "corelibs") {
                label += source.ruleText;
            } else {
                if (source.domainName) {
                    label += `${source.domainName}`;
                }
                if (source.args) {
                    label += `#%#//scriptlet('${source.name}', '${source.args.join("', '")}')`;
                } else {
                    label += `#%#//scriptlet('${source.name}')`;
                }
            }
            if (trace) {
                trace(label);
            }
        } catch (e) {}
        if (typeof window.__debug === "function") {
            window.__debug(source);
        }
    }
    function validateType(type) {
        return typeof type !== "undefined";
    }
    function validateListener(listener) {
        return typeof listener !== "undefined" && (typeof listener === "function" || typeof listener === "object" && listener !== null && "handleEvent" in listener && typeof listener.handleEvent === "function");
    }
    function listenerToString(listener) {
        return typeof listener === "function" ? listener.toString() : listener.handleEvent.toString();
    }
    function convertTypeToString(value) {
        var output;
        if (typeof value === "undefined") {
            output = "undefined";
        } else if (typeof value === "object") {
            if (value === null) {
                output = "null";
            } else {
                output = objectToString(value);
            }
        } else {
            output = String(value);
        }
        return output;
    }
    function logMessage(source, message) {
        var forced = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
        var convertMessageToString = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
        var {name: name, verbose: verbose} = source;
        if (!forced && !verbose) {
            return;
        }
        var nativeConsole = console.log;
        if (!convertMessageToString) {
            nativeConsole(`${name}:`, message);
            return;
        }
        nativeConsole(`${name}: ${message}`);
    }
    function objectToString(obj) {
        if (!obj || typeof obj !== "object") {
            return String(obj);
        }
        if (isEmptyObject(obj)) {
            return "{}";
        }
        return Object.entries(obj).map((function(pair) {
            var key = pair[0];
            var value = pair[1];
            var recordValueStr = value;
            if (value instanceof Object) {
                recordValueStr = `{ ${objectToString(value)} }`;
            }
            return `${key}:"${recordValueStr}"`;
        })).join(" ");
    }
    function isEmptyObject(obj) {
        return Object.keys(obj).length === 0 && !obj.prototype;
    }
    var updatedArgs = args ? [].concat(source).concat(args) : [ source ];
    try {
        logAddEventListener.apply(this, updatedArgs);
        if (source.uniqueId) {
            Object.defineProperty(Window.prototype.toString, uniqueIdentifier, {
                value: flag,
                enumerable: false,
                writable: false,
                configurable: false
            });
        }
    } catch (e) {
        console.log(e);
    }
}

function logEval(source, args) {
    var flag = "done";
    var uniqueIdentifier = source.uniqueId + source.name + "_" + (Array.isArray(args) ? args.join("_") : "");
    if (source.uniqueId) {
        if (Window.prototype.toString[uniqueIdentifier] === flag) {
            return;
        }
    }
    function logEval(source) {
        var nativeEval = window.eval;
        function evalWrapper(str) {
            hit(source);
            logMessage(source, `eval("${str}")`, true);
            return nativeEval(str);
        }
        window.eval = evalWrapper;
        var nativeFunction = window.Function;
        function FunctionWrapper() {
            hit(source);
            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                args[_key] = arguments[_key];
            }
            logMessage(source, `new Function(${args.join(", ")})`, true);
            return nativeFunction.apply(this, [ ...args ]);
        }
        FunctionWrapper.prototype = Object.create(nativeFunction.prototype);
        FunctionWrapper.prototype.constructor = FunctionWrapper;
        window.Function = FunctionWrapper;
    }
    function hit(source) {
        var ADGUARD_PREFIX = "[AdGuard]";
        if (!source.verbose) {
            return;
        }
        try {
            var trace = console.trace.bind(console);
            var label = `${ADGUARD_PREFIX} `;
            if (source.engine === "corelibs") {
                label += source.ruleText;
            } else {
                if (source.domainName) {
                    label += `${source.domainName}`;
                }
                if (source.args) {
                    label += `#%#//scriptlet('${source.name}', '${source.args.join("', '")}')`;
                } else {
                    label += `#%#//scriptlet('${source.name}')`;
                }
            }
            if (trace) {
                trace(label);
            }
        } catch (e) {}
        if (typeof window.__debug === "function") {
            window.__debug(source);
        }
    }
    function logMessage(source, message) {
        var forced = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
        var convertMessageToString = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
        var {name: name, verbose: verbose} = source;
        if (!forced && !verbose) {
            return;
        }
        var nativeConsole = console.log;
        if (!convertMessageToString) {
            nativeConsole(`${name}:`, message);
            return;
        }
        nativeConsole(`${name}: ${message}`);
    }
    var updatedArgs = args ? [].concat(source).concat(args) : [ source ];
    try {
        logEval.apply(this, updatedArgs);
        if (source.uniqueId) {
            Object.defineProperty(Window.prototype.toString, uniqueIdentifier, {
                value: flag,
                enumerable: false,
                writable: false,
                configurable: false
            });
        }
    } catch (e) {
        console.log(e);
    }
}

function logOnStackTrace(source, args) {
    var flag = "done";
    var uniqueIdentifier = source.uniqueId + source.name + "_" + (Array.isArray(args) ? args.join("_") : "");
    if (source.uniqueId) {
        if (Window.prototype.toString[uniqueIdentifier] === flag) {
            return;
        }
    }
    function logOnStackTrace(source, property) {
        if (!property) {
            return;
        }
        var refineStackTrace = function refineStackTrace(stackString) {
            var regExpValues = backupRegExpValues();
            var stackSteps = stackString.split("\n").slice(2).map((function(line) {
                return line.replace(/ {4}at /, "");
            }));
            var logInfoArray = stackSteps.map((function(line) {
                var funcName;
                var funcFullPath;
                var reg = /\(([^\)]+)\)/;
                var regFirefox = /(.*?@)(\S+)(:\d+):\d+\)?$/;
                if (line.match(reg)) {
                    funcName = line.split(" ").slice(0, -1).join(" ");
                    funcFullPath = line.match(reg)[1];
                } else if (line.match(regFirefox)) {
                    funcName = line.split("@").slice(0, -1).join(" ");
                    funcFullPath = line.match(regFirefox)[2];
                } else {
                    funcName = "function name is not available";
                    funcFullPath = line;
                }
                return [ funcName, funcFullPath ];
            }));
            var logInfoObject = {};
            logInfoArray.forEach((function(pair) {
                logInfoObject[pair[0]] = pair[1];
            }));
            if (regExpValues.length && regExpValues[0] !== RegExp.$1) {
                restoreRegExpValues(regExpValues);
            }
            return logInfoObject;
        };
        var _setChainPropAccess = function setChainPropAccess(owner, property) {
            var chainInfo = getPropertyInChain(owner, property);
            var {base: base} = chainInfo;
            var {prop: prop, chain: chain} = chainInfo;
            if (chain) {
                var setter = function setter(a) {
                    base = a;
                    if (a instanceof Object) {
                        _setChainPropAccess(a, chain);
                    }
                };
                Object.defineProperty(owner, prop, {
                    get: function get() {
                        return base;
                    },
                    set: setter
                });
                return;
            }
            var value = base[prop];
            setPropertyAccess(base, prop, {
                get() {
                    hit(source);
                    logMessage(source, `Get ${prop}`, true);
                    console.table(refineStackTrace((new Error).stack));
                    return value;
                },
                set(newValue) {
                    hit(source);
                    logMessage(source, `Set ${prop}`, true);
                    console.table(refineStackTrace((new Error).stack));
                    value = newValue;
                }
            });
        };
        _setChainPropAccess(window, property);
    }
    function getPropertyInChain(base, chain) {
        var pos = chain.indexOf(".");
        if (pos === -1) {
            return {
                base: base,
                prop: chain
            };
        }
        var prop = chain.slice(0, pos);
        if (base === null) {
            return {
                base: base,
                prop: prop,
                chain: chain
            };
        }
        var nextBase = base[prop];
        chain = chain.slice(pos + 1);
        if ((base instanceof Object || typeof base === "object") && isEmptyObject(base)) {
            return {
                base: base,
                prop: prop,
                chain: chain
            };
        }
        if (nextBase === null) {
            return {
                base: base,
                prop: prop,
                chain: chain
            };
        }
        if (nextBase !== undefined) {
            return getPropertyInChain(nextBase, chain);
        }
        Object.defineProperty(base, prop, {
            configurable: true
        });
        return {
            base: base,
            prop: prop,
            chain: chain
        };
    }
    function setPropertyAccess(object, property, descriptor) {
        var currentDescriptor = Object.getOwnPropertyDescriptor(object, property);
        if (currentDescriptor && !currentDescriptor.configurable) {
            return false;
        }
        Object.defineProperty(object, property, descriptor);
        return true;
    }
    function hit(source) {
        var ADGUARD_PREFIX = "[AdGuard]";
        if (!source.verbose) {
            return;
        }
        try {
            var trace = console.trace.bind(console);
            var label = `${ADGUARD_PREFIX} `;
            if (source.engine === "corelibs") {
                label += source.ruleText;
            } else {
                if (source.domainName) {
                    label += `${source.domainName}`;
                }
                if (source.args) {
                    label += `#%#//scriptlet('${source.name}', '${source.args.join("', '")}')`;
                } else {
                    label += `#%#//scriptlet('${source.name}')`;
                }
            }
            if (trace) {
                trace(label);
            }
        } catch (e) {}
        if (typeof window.__debug === "function") {
            window.__debug(source);
        }
    }
    function logMessage(source, message) {
        var forced = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
        var convertMessageToString = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
        var {name: name, verbose: verbose} = source;
        if (!forced && !verbose) {
            return;
        }
        var nativeConsole = console.log;
        if (!convertMessageToString) {
            nativeConsole(`${name}:`, message);
            return;
        }
        nativeConsole(`${name}: ${message}`);
    }
    function isEmptyObject(obj) {
        return Object.keys(obj).length === 0 && !obj.prototype;
    }
    function backupRegExpValues() {
        try {
            var arrayOfRegexpValues = [];
            for (var index = 1; index < 10; index += 1) {
                var value = `$${index}`;
                if (!RegExp[value]) {
                    break;
                }
                arrayOfRegexpValues.push(RegExp[value]);
            }
            return arrayOfRegexpValues;
        } catch (error) {
            return [];
        }
    }
    function restoreRegExpValues(array) {
        if (!array.length) {
            return;
        }
        try {
            var stringPattern = "";
            if (array.length === 1) {
                stringPattern = `(${array[0]})`;
            } else {
                stringPattern = array.reduce((function(accumulator, currentValue, currentIndex) {
                    if (currentIndex === 1) {
                        return `(${accumulator}),(${currentValue})`;
                    }
                    return `${accumulator},(${currentValue})`;
                }));
            }
            var regExpGroup = new RegExp(stringPattern);
            array.toString().replace(regExpGroup, "");
        } catch (error) {
            var message = `Failed to restore RegExp values: ${error}`;
            console.log(message);
        }
    }
    var updatedArgs = args ? [].concat(source).concat(args) : [ source ];
    try {
        logOnStackTrace.apply(this, updatedArgs);
        if (source.uniqueId) {
            Object.defineProperty(Window.prototype.toString, uniqueIdentifier, {
                value: flag,
                enumerable: false,
                writable: false,
                configurable: false
            });
        }
    } catch (e) {
        console.log(e);
    }
}

function m3uPrune(source, args) {
    var flag = "done";
    var uniqueIdentifier = source.uniqueId + source.name + "_" + (Array.isArray(args) ? args.join("_") : "");
    if (source.uniqueId) {
        if (Window.prototype.toString[uniqueIdentifier] === flag) {
            return;
        }
    }
    function m3uPrune(source, propsToRemove) {
        var urlToMatch = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : "";
        var verbose = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
        if (typeof Reflect === "undefined" || typeof fetch === "undefined" || typeof Proxy === "undefined" || typeof Response === "undefined") {
            return;
        }
        var shouldPruneResponse = false;
        var shouldLogContent = verbose === "true";
        var urlMatchRegexp = toRegExp(urlToMatch);
        var SEGMENT_MARKER = "#";
        var AD_MARKER = {
            ASSET: "#EXT-X-ASSET:",
            CUE: "#EXT-X-CUE:",
            CUE_IN: "#EXT-X-CUE-IN",
            DISCONTINUITY: "#EXT-X-DISCONTINUITY",
            EXTINF: "#EXTINF",
            EXTM3U: "#EXTM3U",
            SCTE35: "#EXT-X-SCTE35:"
        };
        var COMCAST_AD_MARKER = {
            AD: "-AD-",
            VAST: "-VAST-",
            VMAP_AD: "-VMAP-AD-",
            VMAP_AD_BREAK: "#EXT-X-VMAP-AD-BREAK:"
        };
        var TAGS_ALLOWLIST = [ "#EXT-X-TARGETDURATION", "#EXT-X-MEDIA-SEQUENCE", "#EXT-X-DISCONTINUITY-SEQUENCE", "#EXT-X-ENDLIST", "#EXT-X-PLAYLIST-TYPE", "#EXT-X-I-FRAMES-ONLY", "#EXT-X-MEDIA", "#EXT-X-STREAM-INF", "#EXT-X-I-FRAME-STREAM-INF", "#EXT-X-SESSION-DATA", "#EXT-X-SESSION-KEY", "#EXT-X-INDEPENDENT-SEGMENTS", "#EXT-X-START" ];
        var isAllowedTag = function isAllowedTag(str) {
            return TAGS_ALLOWLIST.some((function(el) {
                return str.startsWith(el);
            }));
        };
        var _pruneExtinfFromVmapBlock = function pruneExtinfFromVmapBlock(lines, i) {
            var array = lines.slice();
            var index = i;
            if (array[index].includes(AD_MARKER.EXTINF)) {
                array[index] = undefined;
                index += 1;
                if (array[index].includes(AD_MARKER.DISCONTINUITY)) {
                    array[index] = undefined;
                    index += 1;
                    var prunedExtinf = _pruneExtinfFromVmapBlock(array, index);
                    array = prunedExtinf.array;
                    index = prunedExtinf.index;
                }
            }
            return {
                array: array,
                index: index
            };
        };
        var pruneVmapBlock = function pruneVmapBlock(lines) {
            var array = lines.slice();
            for (var i = 0; i < array.length - 1; i += 1) {
                if (array[i].includes(COMCAST_AD_MARKER.VMAP_AD) || array[i].includes(COMCAST_AD_MARKER.VAST) || array[i].includes(COMCAST_AD_MARKER.AD)) {
                    array[i] = undefined;
                    if (array[i + 1].includes(AD_MARKER.EXTINF)) {
                        i += 1;
                        var prunedExtinf = _pruneExtinfFromVmapBlock(array, i);
                        array = prunedExtinf.array;
                        i = prunedExtinf.index - 1;
                    }
                }
            }
            return array;
        };
        var pruneSpliceoutBlock = function pruneSpliceoutBlock(line, index, array) {
            if (!line.startsWith(AD_MARKER.CUE)) {
                return line;
            }
            line = undefined;
            index += 1;
            if (array[index].startsWith(AD_MARKER.ASSET)) {
                array[index] = undefined;
                index += 1;
            }
            if (array[index].startsWith(AD_MARKER.SCTE35)) {
                array[index] = undefined;
                index += 1;
            }
            if (array[index].startsWith(AD_MARKER.CUE_IN)) {
                array[index] = undefined;
                index += 1;
            }
            if (array[index].startsWith(AD_MARKER.SCTE35)) {
                array[index] = undefined;
            }
            return line;
        };
        var removeM3ULineRegexp = toRegExp(propsToRemove);
        var pruneInfBlock = function pruneInfBlock(line, index, array) {
            if (!line.startsWith(AD_MARKER.EXTINF)) {
                return line;
            }
            if (!removeM3ULineRegexp.test(array[index + 1])) {
                return line;
            }
            if (!isAllowedTag(array[index])) {
                array[index] = undefined;
            }
            index += 1;
            if (!isAllowedTag(array[index])) {
                array[index] = undefined;
            }
            index += 1;
            if (array[index].startsWith(AD_MARKER.DISCONTINUITY)) {
                array[index] = undefined;
            }
            return line;
        };
        var pruneSegments = function pruneSegments(lines) {
            for (var i = 0; i < lines.length - 1; i += 1) {
                var _lines$i;
                if ((_lines$i = lines[i]) !== null && _lines$i !== void 0 && _lines$i.startsWith(SEGMENT_MARKER) && removeM3ULineRegexp.test(lines[i])) {
                    var segmentName = lines[i].substring(0, lines[i].indexOf(":"));
                    if (!segmentName) {
                        return lines;
                    }
                    lines[i] = undefined;
                    i += 1;
                    for (var j = i; j < lines.length; j += 1) {
                        if (!lines[j].includes(segmentName) && !isAllowedTag(lines[j])) {
                            lines[j] = undefined;
                        } else {
                            i = j - 1;
                            break;
                        }
                    }
                }
            }
            return lines;
        };
        var isM3U = function isM3U(text) {
            if (typeof text === "string") {
                var trimmedText = text.trim();
                return trimmedText.startsWith(AD_MARKER.EXTM3U) || trimmedText.startsWith(COMCAST_AD_MARKER.VMAP_AD_BREAK);
            }
            return false;
        };
        var isPruningNeeded = function isPruningNeeded(text, regexp) {
            return isM3U(text) && regexp.test(text);
        };
        var pruneM3U = function pruneM3U(text) {
            if (shouldLogContent) {
                logMessage(source, `Original M3U content:\n${text}`);
            }
            var lines = text.split(/\r?\n/);
            if (text.includes(COMCAST_AD_MARKER.VMAP_AD_BREAK)) {
                lines = pruneVmapBlock(lines);
                lines = lines.filter((function(l) {
                    return !!l;
                })).join("\n");
                if (shouldLogContent) {
                    logMessage(source, `Modified M3U content:\n${lines}`);
                }
                return lines;
            }
            lines = pruneSegments(lines);
            lines = lines.map((function(line, index, array) {
                if (typeof line === "undefined") {
                    return line;
                }
                line = pruneSpliceoutBlock(line, index, array);
                if (typeof line !== "undefined") {
                    line = pruneInfBlock(line, index, array);
                }
                return line;
            })).filter((function(l) {
                return !!l;
            })).join("\n");
            if (shouldLogContent) {
                logMessage(source, `Modified M3U content:\n${lines}`);
            }
            return lines;
        };
        var nativeOpen = window.XMLHttpRequest.prototype.open;
        var nativeSend = window.XMLHttpRequest.prototype.send;
        var xhrData;
        var openWrapper = function openWrapper(target, thisArg, args) {
            xhrData = getXhrData.apply(null, args);
            if (matchRequestProps(source, urlToMatch, xhrData)) {
                thisArg.shouldBePruned = true;
            }
            if (thisArg.shouldBePruned) {
                thisArg.collectedHeaders = [];
                var setRequestHeaderWrapper = function setRequestHeaderWrapper(target, thisArg, args) {
                    thisArg.collectedHeaders.push(args);
                    return Reflect.apply(target, thisArg, args);
                };
                var setRequestHeaderHandler = {
                    apply: setRequestHeaderWrapper
                };
                thisArg.setRequestHeader = new Proxy(thisArg.setRequestHeader, setRequestHeaderHandler);
            }
            return Reflect.apply(target, thisArg, args);
        };
        var sendWrapper = function sendWrapper(target, thisArg, args) {
            var allowedResponseTypeValues = [ "", "text" ];
            if (!thisArg.shouldBePruned || !allowedResponseTypeValues.includes(thisArg.responseType)) {
                return Reflect.apply(target, thisArg, args);
            }
            var forgedRequest = new XMLHttpRequest;
            forgedRequest.addEventListener("readystatechange", (function() {
                if (forgedRequest.readyState !== 4) {
                    return;
                }
                var {readyState: readyState, response: response, responseText: responseText, responseURL: responseURL, responseXML: responseXML, status: status, statusText: statusText} = forgedRequest;
                var content = responseText || response;
                if (typeof content !== "string") {
                    return;
                }
                if (!propsToRemove) {
                    if (isM3U(response)) {
                        var message = `XMLHttpRequest.open() URL: ${responseURL}\nresponse: ${response}`;
                        logMessage(source, message);
                    }
                } else {
                    shouldPruneResponse = isPruningNeeded(response, removeM3ULineRegexp);
                }
                var responseContent = shouldPruneResponse ? pruneM3U(response) : response;
                Object.defineProperties(thisArg, {
                    readyState: {
                        value: readyState,
                        writable: false
                    },
                    responseURL: {
                        value: responseURL,
                        writable: false
                    },
                    responseXML: {
                        value: responseXML,
                        writable: false
                    },
                    status: {
                        value: status,
                        writable: false
                    },
                    statusText: {
                        value: statusText,
                        writable: false
                    },
                    response: {
                        value: responseContent,
                        writable: false
                    },
                    responseText: {
                        value: responseContent,
                        writable: false
                    }
                });
                setTimeout((function() {
                    var stateEvent = new Event("readystatechange");
                    thisArg.dispatchEvent(stateEvent);
                    var loadEvent = new Event("load");
                    thisArg.dispatchEvent(loadEvent);
                    var loadEndEvent = new Event("loadend");
                    thisArg.dispatchEvent(loadEndEvent);
                }), 1);
                hit(source);
            }));
            nativeOpen.apply(forgedRequest, [ xhrData.method, xhrData.url ]);
            thisArg.collectedHeaders.forEach((function(header) {
                var name = header[0];
                var value = header[1];
                forgedRequest.setRequestHeader(name, value);
            }));
            thisArg.collectedHeaders = [];
            try {
                nativeSend.call(forgedRequest, args);
            } catch (_unused) {
                return Reflect.apply(target, thisArg, args);
            }
            return undefined;
        };
        var openHandler = {
            apply: openWrapper
        };
        var sendHandler = {
            apply: sendWrapper
        };
        XMLHttpRequest.prototype.open = new Proxy(XMLHttpRequest.prototype.open, openHandler);
        XMLHttpRequest.prototype.send = new Proxy(XMLHttpRequest.prototype.send, sendHandler);
        var nativeFetch = window.fetch;
        var fetchWrapper = async function fetchWrapper(target, thisArg, args) {
            var fetchURL = args[0] instanceof Request ? args[0].url : args[0];
            if (typeof fetchURL !== "string" || fetchURL.length === 0) {
                return Reflect.apply(target, thisArg, args);
            }
            if (urlMatchRegexp.test(fetchURL)) {
                var response = await nativeFetch(...args);
                var clonedResponse = response.clone();
                var responseText = await response.text();
                if (!propsToRemove && isM3U(responseText)) {
                    var message = `fetch URL: ${fetchURL}\nresponse text: ${responseText}`;
                    logMessage(source, message);
                    return clonedResponse;
                }
                if (isPruningNeeded(responseText, removeM3ULineRegexp)) {
                    var prunedText = pruneM3U(responseText);
                    hit(source);
                    return new Response(prunedText, {
                        status: response.status,
                        statusText: response.statusText,
                        headers: response.headers
                    });
                }
                return clonedResponse;
            }
            return Reflect.apply(target, thisArg, args);
        };
        var fetchHandler = {
            apply: fetchWrapper
        };
        window.fetch = new Proxy(window.fetch, fetchHandler);
    }
    function hit(source) {
        var ADGUARD_PREFIX = "[AdGuard]";
        if (!source.verbose) {
            return;
        }
        try {
            var trace = console.trace.bind(console);
            var label = `${ADGUARD_PREFIX} `;
            if (source.engine === "corelibs") {
                label += source.ruleText;
            } else {
                if (source.domainName) {
                    label += `${source.domainName}`;
                }
                if (source.args) {
                    label += `#%#//scriptlet('${source.name}', '${source.args.join("', '")}')`;
                } else {
                    label += `#%#//scriptlet('${source.name}')`;
                }
            }
            if (trace) {
                trace(label);
            }
        } catch (e) {}
        if (typeof window.__debug === "function") {
            window.__debug(source);
        }
    }
    function toRegExp(rawInput) {
        var input = rawInput || "";
        var DEFAULT_VALUE = ".?";
        var FORWARD_SLASH = "/";
        if (input === "") {
            return new RegExp(DEFAULT_VALUE);
        }
        var delimiterIndex = input.lastIndexOf(FORWARD_SLASH);
        var flagsPart = input.substring(delimiterIndex + 1);
        var regExpPart = input.substring(0, delimiterIndex + 1);
        var isValidRegExpFlag = function isValidRegExpFlag(flag) {
            if (!flag) {
                return false;
            }
            try {
                new RegExp("", flag);
                return true;
            } catch (ex) {
                return false;
            }
        };
        var getRegExpFlags = function getRegExpFlags(regExpStr, flagsStr) {
            if (regExpStr.startsWith(FORWARD_SLASH) && regExpStr.endsWith(FORWARD_SLASH) && !regExpStr.endsWith("\\/") && isValidRegExpFlag(flagsStr)) {
                return flagsStr;
            }
            return "";
        };
        var flags = getRegExpFlags(regExpPart, flagsPart);
        if (input.startsWith(FORWARD_SLASH) && input.endsWith(FORWARD_SLASH) || flags) {
            var regExpInput = flags ? regExpPart : input;
            return new RegExp(regExpInput.slice(1, -1), flags);
        }
        var escaped = input.replace(/\\'/g, "'").replace(/\\"/g, '"').replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
        return new RegExp(escaped);
    }
    function logMessage(source, message) {
        var forced = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
        var convertMessageToString = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
        var {name: name, verbose: verbose} = source;
        if (!forced && !verbose) {
            return;
        }
        var nativeConsole = console.log;
        if (!convertMessageToString) {
            nativeConsole(`${name}:`, message);
            return;
        }
        nativeConsole(`${name}: ${message}`);
    }
    function getXhrData(method, url, async, user, password) {
        return {
            method: method,
            url: url,
            async: async,
            user: user,
            password: password
        };
    }
    function matchRequestProps(source, propsToMatch, requestData) {
        if (propsToMatch === "" || propsToMatch === "*") {
            return true;
        }
        var isMatched;
        var parsedData = parseMatchProps(propsToMatch);
        if (!isValidParsedData(parsedData)) {
            logMessage(source, `Invalid parameter: ${propsToMatch}`);
            isMatched = false;
        } else {
            var matchData = getMatchPropsData(parsedData);
            var matchKeys = Object.keys(matchData);
            isMatched = matchKeys.every((function(matchKey) {
                var matchValue = matchData[matchKey];
                var dataValue = requestData[matchKey];
                return Object.prototype.hasOwnProperty.call(requestData, matchKey) && typeof dataValue === "string" && (matchValue === null || matchValue === void 0 ? void 0 : matchValue.test(dataValue));
            }));
        }
        return isMatched;
    }
    function getMatchPropsData(data) {
        var matchData = {};
        var dataKeys = Object.keys(data);
        dataKeys.forEach((function(key) {
            matchData[key] = toRegExp(data[key]);
        }));
        return matchData;
    }
    function getRequestProps() {
        return [ "url", "method", "headers", "body", "credentials", "cache", "redirect", "referrer", "referrerPolicy", "integrity", "keepalive", "signal", "mode" ];
    }
    function isValidParsedData(data) {
        return Object.values(data).every((function(value) {
            return isValidStrPattern(value);
        }));
    }
    function parseMatchProps(propsToMatchStr) {
        var PROPS_DIVIDER = " ";
        var PAIRS_MARKER = ":";
        var isRequestProp = function isRequestProp(prop) {
            return getRequestProps().includes(prop);
        };
        var propsObj = {};
        var props = propsToMatchStr.split(PROPS_DIVIDER);
        props.forEach((function(prop) {
            var dividerInd = prop.indexOf(PAIRS_MARKER);
            var key = prop.slice(0, dividerInd);
            if (isRequestProp(key)) {
                var value = prop.slice(dividerInd + 1);
                propsObj[key] = value;
            } else {
                propsObj.url = prop;
            }
        }));
        return propsObj;
    }
    function isValidStrPattern(input) {
        var FORWARD_SLASH = "/";
        var str = escapeRegExp(input);
        if (input[0] === FORWARD_SLASH && input[input.length - 1] === FORWARD_SLASH) {
            str = input.slice(1, -1);
        }
        var isValid;
        try {
            isValid = new RegExp(str);
            isValid = true;
        } catch (e) {
            isValid = false;
        }
        return isValid;
    }
    function escapeRegExp(str) {
        return str.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
    }
    var updatedArgs = args ? [].concat(source).concat(args) : [ source ];
    try {
        m3uPrune.apply(this, updatedArgs);
        if (source.uniqueId) {
            Object.defineProperty(Window.prototype.toString, uniqueIdentifier, {
                value: flag,
                enumerable: false,
                writable: false,
                configurable: false
            });
        }
    } catch (e) {
        console.log(e);
    }
}

function metrikaYandexTag(source, args) {
    var flag = "done";
    var uniqueIdentifier = source.uniqueId + source.name + "_" + (Array.isArray(args) ? args.join("_") : "");
    if (source.uniqueId) {
        if (Window.prototype.toString[uniqueIdentifier] === flag) {
            return;
        }
    }
    function metrikaYandexTag(source) {
        var asyncCallbackFromOptions = function asyncCallbackFromOptions(id, param) {
            var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
            var {callback: callback} = options;
            var {ctx: ctx} = options;
            if (typeof callback === "function") {
                callback = ctx !== undefined ? callback.bind(ctx) : callback;
                setTimeout((function() {
                    return callback();
                }));
            }
        };
        var addFileExtension = noopFunc;
        var extLink = asyncCallbackFromOptions;
        var file = asyncCallbackFromOptions;
        var getClientID = function getClientID(id, cb) {
            if (!cb) {
                return;
            }
            setTimeout(cb(null));
        };
        var hitFunc = asyncCallbackFromOptions;
        var notBounce = asyncCallbackFromOptions;
        var params = noopFunc;
        var reachGoal = function reachGoal(id, target, params, callback, ctx) {
            asyncCallbackFromOptions(null, null, {
                callback: callback,
                ctx: ctx
            });
        };
        var setUserID = noopFunc;
        var userParams = noopFunc;
        var destruct = noopFunc;
        var api = {
            addFileExtension: addFileExtension,
            extLink: extLink,
            file: file,
            getClientID: getClientID,
            hit: hitFunc,
            notBounce: notBounce,
            params: params,
            reachGoal: reachGoal,
            setUserID: setUserID,
            userParams: userParams,
            destruct: destruct
        };
        function init(id) {
            window[`yaCounter${id}`] = api;
            document.dispatchEvent(new Event(`yacounter${id}inited`));
        }
        function ym(id, funcName) {
            if (funcName === "init") {
                return init(id);
            }
            for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
                args[_key - 2] = arguments[_key];
            }
            return api[funcName] && api[funcName](id, ...args);
        }
        if (typeof window.ym === "undefined") {
            window.ym = ym;
            ym.a = [];
        } else if (window.ym && window.ym.a) {
            ym.a = window.ym.a;
            window.ym = ym;
            window.ym.a.forEach((function(params) {
                var id = params[0];
                init(id);
            }));
        }
        hit(source);
    }
    function hit(source) {
        var ADGUARD_PREFIX = "[AdGuard]";
        if (!source.verbose) {
            return;
        }
        try {
            var trace = console.trace.bind(console);
            var label = `${ADGUARD_PREFIX} `;
            if (source.engine === "corelibs") {
                label += source.ruleText;
            } else {
                if (source.domainName) {
                    label += `${source.domainName}`;
                }
                if (source.args) {
                    label += `#%#//scriptlet('${source.name}', '${source.args.join("', '")}')`;
                } else {
                    label += `#%#//scriptlet('${source.name}')`;
                }
            }
            if (trace) {
                trace(label);
            }
        } catch (e) {}
        if (typeof window.__debug === "function") {
            window.__debug(source);
        }
    }
    function noopFunc() {}
    var updatedArgs = args ? [].concat(source).concat(args) : [ source ];
    try {
        metrikaYandexTag.apply(this, updatedArgs);
        if (source.uniqueId) {
            Object.defineProperty(Window.prototype.toString, uniqueIdentifier, {
                value: flag,
                enumerable: false,
                writable: false,
                configurable: false
            });
        }
    } catch (e) {
        console.log(e);
    }
}

function metrikaYandexWatch(source, args) {
    var flag = "done";
    var uniqueIdentifier = source.uniqueId + source.name + "_" + (Array.isArray(args) ? args.join("_") : "");
    if (source.uniqueId) {
        if (Window.prototype.toString[uniqueIdentifier] === flag) {
            return;
        }
    }
    function metrikaYandexWatch(source) {
        var cbName = "yandex_metrika_callbacks";
        var asyncCallbackFromOptions = function asyncCallbackFromOptions() {
            var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
            var {callback: callback} = options;
            var {ctx: ctx} = options;
            if (typeof callback === "function") {
                callback = ctx !== undefined ? callback.bind(ctx) : callback;
                setTimeout((function() {
                    return callback();
                }));
            }
        };
        function Metrika() {}
        Metrika.counters = noopArray;
        Metrika.prototype.addFileExtension = noopFunc;
        Metrika.prototype.getClientID = noopFunc;
        Metrika.prototype.setUserID = noopFunc;
        Metrika.prototype.userParams = noopFunc;
        Metrika.prototype.params = noopFunc;
        Metrika.prototype.counters = noopArray;
        Metrika.prototype.extLink = function(url, options) {
            asyncCallbackFromOptions(options);
        };
        Metrika.prototype.file = function(url, options) {
            asyncCallbackFromOptions(options);
        };
        Metrika.prototype.hit = function(url, options) {
            asyncCallbackFromOptions(options);
        };
        Metrika.prototype.reachGoal = function(target, params, cb, ctx) {
            asyncCallbackFromOptions({
                callback: cb,
                ctx: ctx
            });
        };
        Metrika.prototype.notBounce = asyncCallbackFromOptions;
        if (window.Ya) {
            window.Ya.Metrika = Metrika;
        } else {
            window.Ya = {
                Metrika: Metrika
            };
        }
        if (window[cbName] && Array.isArray(window[cbName])) {
            window[cbName].forEach((function(func) {
                if (typeof func === "function") {
                    func();
                }
            }));
        }
        hit(source);
    }
    function hit(source) {
        var ADGUARD_PREFIX = "[AdGuard]";
        if (!source.verbose) {
            return;
        }
        try {
            var trace = console.trace.bind(console);
            var label = `${ADGUARD_PREFIX} `;
            if (source.engine === "corelibs") {
                label += source.ruleText;
            } else {
                if (source.domainName) {
                    label += `${source.domainName}`;
                }
                if (source.args) {
                    label += `#%#//scriptlet('${source.name}', '${source.args.join("', '")}')`;
                } else {
                    label += `#%#//scriptlet('${source.name}')`;
                }
            }
            if (trace) {
                trace(label);
            }
        } catch (e) {}
        if (typeof window.__debug === "function") {
            window.__debug(source);
        }
    }
    function noopFunc() {}
    function noopArray() {
        return [];
    }
    var updatedArgs = args ? [].concat(source).concat(args) : [ source ];
    try {
        metrikaYandexWatch.apply(this, updatedArgs);
        if (source.uniqueId) {
            Object.defineProperty(Window.prototype.toString, uniqueIdentifier, {
                value: flag,
                enumerable: false,
                writable: false,
                configurable: false
            });
        }
    } catch (e) {
        console.log(e);
    }
}

function noProtectedAudience(source, args) {
    var flag = "done";
    var uniqueIdentifier = source.uniqueId + source.name + "_" + (Array.isArray(args) ? args.join("_") : "");
    if (source.uniqueId) {
        if (Window.prototype.toString[uniqueIdentifier] === flag) {
            return;
        }
    }
    function noProtectedAudience(source) {
        if (Document instanceof Object === false) {
            return;
        }
        var protectedAudienceMethods = {
            joinAdInterestGroup: noopResolveVoid,
            runAdAuction: noopResolveNull,
            leaveAdInterestGroup: noopResolveVoid,
            clearOriginJoinedAdInterestGroups: noopResolveVoid,
            createAuctionNonce: noopStr,
            updateAdInterestGroups: noopFunc
        };
        for (var _i = 0, _Object$keys = Object.keys(protectedAudienceMethods); _i < _Object$keys.length; _i++) {
            var key = _Object$keys[_i];
            var methodName = key;
            var prototype = Navigator.prototype;
            if (!Object.prototype.hasOwnProperty.call(prototype, methodName) || prototype[methodName] instanceof Function === false) {
                continue;
            }
            prototype[methodName] = protectedAudienceMethods[methodName];
        }
        hit(source);
    }
    function hit(source) {
        var ADGUARD_PREFIX = "[AdGuard]";
        if (!source.verbose) {
            return;
        }
        try {
            var trace = console.trace.bind(console);
            var label = `${ADGUARD_PREFIX} `;
            if (source.engine === "corelibs") {
                label += source.ruleText;
            } else {
                if (source.domainName) {
                    label += `${source.domainName}`;
                }
                if (source.args) {
                    label += `#%#//scriptlet('${source.name}', '${source.args.join("', '")}')`;
                } else {
                    label += `#%#//scriptlet('${source.name}')`;
                }
            }
            if (trace) {
                trace(label);
            }
        } catch (e) {}
        if (typeof window.__debug === "function") {
            window.__debug(source);
        }
    }
    function noopStr() {
        return "";
    }
    function noopFunc() {}
    function noopResolveVoid() {
        return Promise.resolve(undefined);
    }
    function noopResolveNull() {
        return Promise.resolve(null);
    }
    var updatedArgs = args ? [].concat(source).concat(args) : [ source ];
    try {
        noProtectedAudience.apply(this, updatedArgs);
        if (source.uniqueId) {
            Object.defineProperty(Window.prototype.toString, uniqueIdentifier, {
                value: flag,
                enumerable: false,
                writable: false,
                configurable: false
            });
        }
    } catch (e) {
        console.log(e);
    }
}

function noTopics(source, args) {
    var flag = "done";
    var uniqueIdentifier = source.uniqueId + source.name + "_" + (Array.isArray(args) ? args.join("_") : "");
    if (source.uniqueId) {
        if (Window.prototype.toString[uniqueIdentifier] === flag) {
            return;
        }
    }
    function noTopics(source) {
        var TOPICS_PROPERTY_NAME = "browsingTopics";
        if (Document instanceof Object === false) {
            return;
        }
        if (!Object.prototype.hasOwnProperty.call(Document.prototype, TOPICS_PROPERTY_NAME) || Document.prototype[TOPICS_PROPERTY_NAME] instanceof Function === false) {
            return;
        }
        Document.prototype[TOPICS_PROPERTY_NAME] = function() {
            return noopPromiseResolve("[]");
        };
        hit(source);
    }
    function hit(source) {
        var ADGUARD_PREFIX = "[AdGuard]";
        if (!source.verbose) {
            return;
        }
        try {
            var trace = console.trace.bind(console);
            var label = `${ADGUARD_PREFIX} `;
            if (source.engine === "corelibs") {
                label += source.ruleText;
            } else {
                if (source.domainName) {
                    label += `${source.domainName}`;
                }
                if (source.args) {
                    label += `#%#//scriptlet('${source.name}', '${source.args.join("', '")}')`;
                } else {
                    label += `#%#//scriptlet('${source.name}')`;
                }
            }
            if (trace) {
                trace(label);
            }
        } catch (e) {}
        if (typeof window.__debug === "function") {
            window.__debug(source);
        }
    }
    function noopPromiseResolve() {
        var responseBody = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "{}";
        var responseUrl = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "";
        var responseType = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : "basic";
        if (typeof Response === "undefined") {
            return;
        }
        var response = new Response(responseBody, {
            status: 200,
            statusText: "OK"
        });
        if (responseType === "opaque") {
            Object.defineProperties(response, {
                body: {
                    value: null
                },
                status: {
                    value: 0
                },
                ok: {
                    value: false
                },
                statusText: {
                    value: ""
                },
                url: {
                    value: ""
                },
                type: {
                    value: responseType
                }
            });
        } else {
            Object.defineProperties(response, {
                url: {
                    value: responseUrl
                },
                type: {
                    value: responseType
                }
            });
        }
        return Promise.resolve(response);
    }
    var updatedArgs = args ? [].concat(source).concat(args) : [ source ];
    try {
        noTopics.apply(this, updatedArgs);
        if (source.uniqueId) {
            Object.defineProperty(Window.prototype.toString, uniqueIdentifier, {
                value: flag,
                enumerable: false,
                writable: false,
                configurable: false
            });
        }
    } catch (e) {
        console.log(e);
    }
}

function noeval(source, args) {
    var flag = "done";
    var uniqueIdentifier = source.uniqueId + source.name + "_" + (Array.isArray(args) ? args.join("_") : "");
    if (source.uniqueId) {
        if (Window.prototype.toString[uniqueIdentifier] === flag) {
            return;
        }
    }
    function noeval(source) {
        window.eval = function evalWrapper(s) {
            hit(source);
            logMessage(source, `AdGuard has prevented eval:\n${s}`, true);
        }.bind();
    }
    function hit(source) {
        var ADGUARD_PREFIX = "[AdGuard]";
        if (!source.verbose) {
            return;
        }
        try {
            var trace = console.trace.bind(console);
            var label = `${ADGUARD_PREFIX} `;
            if (source.engine === "corelibs") {
                label += source.ruleText;
            } else {
                if (source.domainName) {
                    label += `${source.domainName}`;
                }
                if (source.args) {
                    label += `#%#//scriptlet('${source.name}', '${source.args.join("', '")}')`;
                } else {
                    label += `#%#//scriptlet('${source.name}')`;
                }
            }
            if (trace) {
                trace(label);
            }
        } catch (e) {}
        if (typeof window.__debug === "function") {
            window.__debug(source);
        }
    }
    function logMessage(source, message) {
        var forced = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
        var convertMessageToString = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
        var {name: name, verbose: verbose} = source;
        if (!forced && !verbose) {
            return;
        }
        var nativeConsole = console.log;
        if (!convertMessageToString) {
            nativeConsole(`${name}:`, message);
            return;
        }
        nativeConsole(`${name}: ${message}`);
    }
    var updatedArgs = args ? [].concat(source).concat(args) : [ source ];
    try {
        noeval.apply(this, updatedArgs);
        if (source.uniqueId) {
            Object.defineProperty(Window.prototype.toString, uniqueIdentifier, {
                value: flag,
                enumerable: false,
                writable: false,
                configurable: false
            });
        }
    } catch (e) {
        console.log(e);
    }
}

function nowebrtc(source, args) {
    var flag = "done";
    var uniqueIdentifier = source.uniqueId + source.name + "_" + (Array.isArray(args) ? args.join("_") : "");
    if (source.uniqueId) {
        if (Window.prototype.toString[uniqueIdentifier] === flag) {
            return;
        }
    }
    function nowebrtc(source) {
        var propertyName = "";
        if (window.RTCPeerConnection) {
            propertyName = "RTCPeerConnection";
        } else if (window.webkitRTCPeerConnection) {
            propertyName = "webkitRTCPeerConnection";
        }
        if (propertyName === "") {
            return;
        }
        var rtcReplacement = function rtcReplacement(config) {
            var message = `Document tried to create an RTCPeerConnection: ${convertRtcConfigToString(config)}`;
            logMessage(source, message);
            hit(source);
        };
        rtcReplacement.prototype = {
            close: noopFunc,
            createDataChannel: noopFunc,
            createOffer: noopFunc,
            setRemoteDescription: noopFunc
        };
        var rtc = window[propertyName];
        window[propertyName] = rtcReplacement;
        if (rtc.prototype) {
            rtc.prototype.createDataChannel = function(a, b) {
                return {
                    close: noopFunc,
                    send: noopFunc
                };
            }.bind(null);
        }
    }
    function hit(source) {
        var ADGUARD_PREFIX = "[AdGuard]";
        if (!source.verbose) {
            return;
        }
        try {
            var trace = console.trace.bind(console);
            var label = `${ADGUARD_PREFIX} `;
            if (source.engine === "corelibs") {
                label += source.ruleText;
            } else {
                if (source.domainName) {
                    label += `${source.domainName}`;
                }
                if (source.args) {
                    label += `#%#//scriptlet('${source.name}', '${source.args.join("', '")}')`;
                } else {
                    label += `#%#//scriptlet('${source.name}')`;
                }
            }
            if (trace) {
                trace(label);
            }
        } catch (e) {}
        if (typeof window.__debug === "function") {
            window.__debug(source);
        }
    }
    function noopFunc() {}
    function logMessage(source, message) {
        var forced = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
        var convertMessageToString = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
        var {name: name, verbose: verbose} = source;
        if (!forced && !verbose) {
            return;
        }
        var nativeConsole = console.log;
        if (!convertMessageToString) {
            nativeConsole(`${name}:`, message);
            return;
        }
        nativeConsole(`${name}: ${message}`);
    }
    function convertRtcConfigToString(config) {
        var UNDEF_STR = "undefined";
        var str = UNDEF_STR;
        if (config === null) {
            str = "null";
        } else if (config instanceof Object) {
            var SERVERS_PROP_NAME = "iceServers";
            var URLS_PROP_NAME = "urls";
            if (Object.prototype.hasOwnProperty.call(config, SERVERS_PROP_NAME) && config[SERVERS_PROP_NAME] && Object.prototype.hasOwnProperty.call(config[SERVERS_PROP_NAME][0], URLS_PROP_NAME) && !!config[SERVERS_PROP_NAME][0][URLS_PROP_NAME]) {
                str = config[SERVERS_PROP_NAME][0][URLS_PROP_NAME].toString();
            }
        }
        return str;
    }
    var updatedArgs = args ? [].concat(source).concat(args) : [ source ];
    try {
        nowebrtc.apply(this, updatedArgs);
        if (source.uniqueId) {
            Object.defineProperty(Window.prototype.toString, uniqueIdentifier, {
                value: flag,
                enumerable: false,
                writable: false,
                configurable: false
            });
        }
    } catch (e) {
        console.log(e);
    }
}

function preventAddEventListener(source, args) {
    var flag = "done";
    var uniqueIdentifier = source.uniqueId + source.name + "_" + (Array.isArray(args) ? args.join("_") : "");
    if (source.uniqueId) {
        if (Window.prototype.toString[uniqueIdentifier] === flag) {
            return;
        }
    }
    function preventAddEventListener(source, typeSearch, listenerSearch) {
        var typeSearchRegexp = toRegExp(typeSearch);
        var listenerSearchRegexp = toRegExp(listenerSearch);
        var nativeAddEventListener = window.EventTarget.prototype.addEventListener;
        function addEventListenerWrapper(type, listener) {
            var _this$constructor;
            var shouldPrevent = false;
            if (validateType(type) && validateListener(listener)) {
                shouldPrevent = typeSearchRegexp.test(type.toString()) && listenerSearchRegexp.test(listenerToString(listener));
            }
            if (shouldPrevent) {
                hit(source);
                return undefined;
            }
            var context = this;
            if (this && ((_this$constructor = this.constructor) === null || _this$constructor === void 0 ? void 0 : _this$constructor.name) === "Window" && this !== window) {
                context = window;
            }
            for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
                args[_key - 2] = arguments[_key];
            }
            return nativeAddEventListener.apply(context, [ type, listener, ...args ]);
        }
        var descriptor = {
            configurable: true,
            set: function set() {},
            get: function get() {
                return addEventListenerWrapper;
            }
        };
        Object.defineProperty(window.EventTarget.prototype, "addEventListener", descriptor);
        Object.defineProperty(window, "addEventListener", descriptor);
        Object.defineProperty(document, "addEventListener", descriptor);
    }
    function hit(source) {
        var ADGUARD_PREFIX = "[AdGuard]";
        if (!source.verbose) {
            return;
        }
        try {
            var trace = console.trace.bind(console);
            var label = `${ADGUARD_PREFIX} `;
            if (source.engine === "corelibs") {
                label += source.ruleText;
            } else {
                if (source.domainName) {
                    label += `${source.domainName}`;
                }
                if (source.args) {
                    label += `#%#//scriptlet('${source.name}', '${source.args.join("', '")}')`;
                } else {
                    label += `#%#//scriptlet('${source.name}')`;
                }
            }
            if (trace) {
                trace(label);
            }
        } catch (e) {}
        if (typeof window.__debug === "function") {
            window.__debug(source);
        }
    }
    function toRegExp(rawInput) {
        var input = rawInput || "";
        var DEFAULT_VALUE = ".?";
        var FORWARD_SLASH = "/";
        if (input === "") {
            return new RegExp(DEFAULT_VALUE);
        }
        var delimiterIndex = input.lastIndexOf(FORWARD_SLASH);
        var flagsPart = input.substring(delimiterIndex + 1);
        var regExpPart = input.substring(0, delimiterIndex + 1);
        var isValidRegExpFlag = function isValidRegExpFlag(flag) {
            if (!flag) {
                return false;
            }
            try {
                new RegExp("", flag);
                return true;
            } catch (ex) {
                return false;
            }
        };
        var getRegExpFlags = function getRegExpFlags(regExpStr, flagsStr) {
            if (regExpStr.startsWith(FORWARD_SLASH) && regExpStr.endsWith(FORWARD_SLASH) && !regExpStr.endsWith("\\/") && isValidRegExpFlag(flagsStr)) {
                return flagsStr;
            }
            return "";
        };
        var flags = getRegExpFlags(regExpPart, flagsPart);
        if (input.startsWith(FORWARD_SLASH) && input.endsWith(FORWARD_SLASH) || flags) {
            var regExpInput = flags ? regExpPart : input;
            return new RegExp(regExpInput.slice(1, -1), flags);
        }
        var escaped = input.replace(/\\'/g, "'").replace(/\\"/g, '"').replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
        return new RegExp(escaped);
    }
    function validateType(type) {
        return typeof type !== "undefined";
    }
    function validateListener(listener) {
        return typeof listener !== "undefined" && (typeof listener === "function" || typeof listener === "object" && listener !== null && "handleEvent" in listener && typeof listener.handleEvent === "function");
    }
    function listenerToString(listener) {
        return typeof listener === "function" ? listener.toString() : listener.handleEvent.toString();
    }
    var updatedArgs = args ? [].concat(source).concat(args) : [ source ];
    try {
        preventAddEventListener.apply(this, updatedArgs);
        if (source.uniqueId) {
            Object.defineProperty(Window.prototype.toString, uniqueIdentifier, {
                value: flag,
                enumerable: false,
                writable: false,
                configurable: false
            });
        }
    } catch (e) {
        console.log(e);
    }
}

function preventAdfly(source, args) {
    var flag = "done";
    var uniqueIdentifier = source.uniqueId + source.name + "_" + (Array.isArray(args) ? args.join("_") : "");
    if (source.uniqueId) {
        if (Window.prototype.toString[uniqueIdentifier] === flag) {
            return;
        }
    }
    function preventAdfly(source) {
        var isDigit = function isDigit(data) {
            return /^\d$/.test(data);
        };
        var handler = function handler(encodedURL) {
            var evenChars = "";
            var oddChars = "";
            for (var i = 0; i < encodedURL.length; i += 1) {
                if (i % 2 === 0) {
                    evenChars += encodedURL.charAt(i);
                } else {
                    oddChars = encodedURL.charAt(i) + oddChars;
                }
            }
            var data = (evenChars + oddChars).split("");
            for (var _i = 0; _i < data.length; _i += 1) {
                if (isDigit(data[_i])) {
                    for (var ii = _i + 1; ii < data.length; ii += 1) {
                        if (isDigit(data[ii])) {
                            var temp = parseInt(data[_i], 10) ^ parseInt(data[ii], 10);
                            if (temp < 10) {
                                data[_i] = temp.toString();
                            }
                            _i = ii;
                            break;
                        }
                    }
                }
            }
            data = data.join("");
            var decodedURL = window.atob(data).slice(16, -16);
            if (window.stop) {
                window.stop();
            }
            window.onbeforeunload = null;
            window.location.href = decodedURL;
        };
        var val;
        var applyHandler = true;
        var result = setPropertyAccess(window, "ysmm", {
            configurable: false,
            set: function set(value) {
                if (applyHandler) {
                    applyHandler = false;
                    try {
                        if (typeof value === "string") {
                            handler(value);
                        }
                    } catch (err) {}
                }
                val = value;
            },
            get: function get() {
                return val;
            }
        });
        if (result) {
            hit(source);
        } else {
            logMessage(source, "Failed to set up prevent-adfly scriptlet");
        }
    }
    function setPropertyAccess(object, property, descriptor) {
        var currentDescriptor = Object.getOwnPropertyDescriptor(object, property);
        if (currentDescriptor && !currentDescriptor.configurable) {
            return false;
        }
        Object.defineProperty(object, property, descriptor);
        return true;
    }
    function hit(source) {
        var ADGUARD_PREFIX = "[AdGuard]";
        if (!source.verbose) {
            return;
        }
        try {
            var trace = console.trace.bind(console);
            var label = `${ADGUARD_PREFIX} `;
            if (source.engine === "corelibs") {
                label += source.ruleText;
            } else {
                if (source.domainName) {
                    label += `${source.domainName}`;
                }
                if (source.args) {
                    label += `#%#//scriptlet('${source.name}', '${source.args.join("', '")}')`;
                } else {
                    label += `#%#//scriptlet('${source.name}')`;
                }
            }
            if (trace) {
                trace(label);
            }
        } catch (e) {}
        if (typeof window.__debug === "function") {
            window.__debug(source);
        }
    }
    function logMessage(source, message) {
        var forced = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
        var convertMessageToString = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
        var {name: name, verbose: verbose} = source;
        if (!forced && !verbose) {
            return;
        }
        var nativeConsole = console.log;
        if (!convertMessageToString) {
            nativeConsole(`${name}:`, message);
            return;
        }
        nativeConsole(`${name}: ${message}`);
    }
    var updatedArgs = args ? [].concat(source).concat(args) : [ source ];
    try {
        preventAdfly.apply(this, updatedArgs);
        if (source.uniqueId) {
            Object.defineProperty(Window.prototype.toString, uniqueIdentifier, {
                value: flag,
                enumerable: false,
                writable: false,
                configurable: false
            });
        }
    } catch (e) {
        console.log(e);
    }
}

function preventBab(source, args) {
    var flag = "done";
    var uniqueIdentifier = source.uniqueId + source.name + "_" + (Array.isArray(args) ? args.join("_") : "");
    if (source.uniqueId) {
        if (Window.prototype.toString[uniqueIdentifier] === flag) {
            return;
        }
    }
    function preventBab(source) {
        var nativeSetTimeout = window.setTimeout;
        var babRegex = /\.bab_elementid.$/;
        var timeoutWrapper = function timeoutWrapper(callback) {
            if (typeof callback !== "string" || !babRegex.test(callback)) {
                for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
                    args[_key - 1] = arguments[_key];
                }
                return nativeSetTimeout.apply(window, [ callback, ...args ]);
            }
            hit(source);
        };
        window.setTimeout = timeoutWrapper;
        var signatures = [ [ "blockadblock" ], [ "babasbm" ], [ /getItem\('babn'\)/ ], [ "getElementById", "String.fromCharCode", "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789", "charAt", "DOMContentLoaded", "AdBlock", "addEventListener", "doScroll", "fromCharCode", "<<2|r>>4", "sessionStorage", "clientWidth", "localStorage", "Math", "random" ] ];
        var check = function check(str) {
            if (typeof str !== "string") {
                return false;
            }
            for (var i = 0; i < signatures.length; i += 1) {
                var tokens = signatures[i];
                var match = 0;
                for (var j = 0; j < tokens.length; j += 1) {
                    var token = tokens[j];
                    var found = token instanceof RegExp ? token.test(str) : str.includes(token);
                    if (found) {
                        match += 1;
                    }
                }
                if (match / tokens.length >= .8) {
                    return true;
                }
            }
            return false;
        };
        var nativeEval = window.eval;
        var evalWrapper = function evalWrapper(str) {
            if (!check(str)) {
                return nativeEval(str);
            }
            hit(source);
            var bodyEl = document.body;
            if (bodyEl) {
                bodyEl.style.removeProperty("visibility");
            }
            var el = document.getElementById("babasbmsgx");
            if (el) {
                el.parentNode.removeChild(el);
            }
        };
        window.eval = evalWrapper.bind(window);
        window.eval.toString = nativeEval.toString.bind(nativeEval);
    }
    function hit(source) {
        var ADGUARD_PREFIX = "[AdGuard]";
        if (!source.verbose) {
            return;
        }
        try {
            var trace = console.trace.bind(console);
            var label = `${ADGUARD_PREFIX} `;
            if (source.engine === "corelibs") {
                label += source.ruleText;
            } else {
                if (source.domainName) {
                    label += `${source.domainName}`;
                }
                if (source.args) {
                    label += `#%#//scriptlet('${source.name}', '${source.args.join("', '")}')`;
                } else {
                    label += `#%#//scriptlet('${source.name}')`;
                }
            }
            if (trace) {
                trace(label);
            }
        } catch (e) {}
        if (typeof window.__debug === "function") {
            window.__debug(source);
        }
    }
    var updatedArgs = args ? [].concat(source).concat(args) : [ source ];
    try {
        preventBab.apply(this, updatedArgs);
        if (source.uniqueId) {
            Object.defineProperty(Window.prototype.toString, uniqueIdentifier, {
                value: flag,
                enumerable: false,
                writable: false,
                configurable: false
            });
        }
    } catch (e) {
        console.log(e);
    }
}

function preventCanvas(source, args) {
    var flag = "done";
    var uniqueIdentifier = source.uniqueId + source.name + "_" + (Array.isArray(args) ? args.join("_") : "");
    if (source.uniqueId) {
        if (Window.prototype.toString[uniqueIdentifier] === flag) {
            return;
        }
    }
    function preventCanvas(source, contextType) {
        var handlerWrapper = function handlerWrapper(target, thisArg, argumentsList) {
            var type = argumentsList[0];
            var shouldPrevent = false;
            if (!contextType) {
                shouldPrevent = true;
            } else if (isValidMatchStr(contextType)) {
                var {isInvertedMatch: isInvertedMatch, matchRegexp: matchRegexp} = parseMatchArg(contextType);
                shouldPrevent = matchRegexp.test(type) !== isInvertedMatch;
            } else {
                logMessage(source, `Invalid contextType parameter: ${contextType}`);
                shouldPrevent = false;
            }
            if (shouldPrevent) {
                hit(source);
                return null;
            }
            return Reflect.apply(target, thisArg, argumentsList);
        };
        var canvasHandler = {
            apply: handlerWrapper
        };
        window.HTMLCanvasElement.prototype.getContext = new Proxy(window.HTMLCanvasElement.prototype.getContext, canvasHandler);
    }
    function hit(source) {
        var ADGUARD_PREFIX = "[AdGuard]";
        if (!source.verbose) {
            return;
        }
        try {
            var trace = console.trace.bind(console);
            var label = `${ADGUARD_PREFIX} `;
            if (source.engine === "corelibs") {
                label += source.ruleText;
            } else {
                if (source.domainName) {
                    label += `${source.domainName}`;
                }
                if (source.args) {
                    label += `#%#//scriptlet('${source.name}', '${source.args.join("', '")}')`;
                } else {
                    label += `#%#//scriptlet('${source.name}')`;
                }
            }
            if (trace) {
                trace(label);
            }
        } catch (e) {}
        if (typeof window.__debug === "function") {
            window.__debug(source);
        }
    }
    function logMessage(source, message) {
        var forced = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
        var convertMessageToString = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
        var {name: name, verbose: verbose} = source;
        if (!forced && !verbose) {
            return;
        }
        var nativeConsole = console.log;
        if (!convertMessageToString) {
            nativeConsole(`${name}:`, message);
            return;
        }
        nativeConsole(`${name}: ${message}`);
    }
    function parseMatchArg(match) {
        var INVERT_MARKER = "!";
        var isInvertedMatch = match ? match === null || match === void 0 ? void 0 : match.startsWith(INVERT_MARKER) : false;
        var matchValue = isInvertedMatch ? match.slice(1) : match;
        var matchRegexp = toRegExp(matchValue);
        return {
            isInvertedMatch: isInvertedMatch,
            matchRegexp: matchRegexp,
            matchValue: matchValue
        };
    }
    function isValidMatchStr(match) {
        var INVERT_MARKER = "!";
        var str = match;
        if (match !== null && match !== void 0 && match.startsWith(INVERT_MARKER)) {
            str = match.slice(1);
        }
        return isValidStrPattern(str);
    }
    function toRegExp(rawInput) {
        var input = rawInput || "";
        var DEFAULT_VALUE = ".?";
        var FORWARD_SLASH = "/";
        if (input === "") {
            return new RegExp(DEFAULT_VALUE);
        }
        var delimiterIndex = input.lastIndexOf(FORWARD_SLASH);
        var flagsPart = input.substring(delimiterIndex + 1);
        var regExpPart = input.substring(0, delimiterIndex + 1);
        var isValidRegExpFlag = function isValidRegExpFlag(flag) {
            if (!flag) {
                return false;
            }
            try {
                new RegExp("", flag);
                return true;
            } catch (ex) {
                return false;
            }
        };
        var getRegExpFlags = function getRegExpFlags(regExpStr, flagsStr) {
            if (regExpStr.startsWith(FORWARD_SLASH) && regExpStr.endsWith(FORWARD_SLASH) && !regExpStr.endsWith("\\/") && isValidRegExpFlag(flagsStr)) {
                return flagsStr;
            }
            return "";
        };
        var flags = getRegExpFlags(regExpPart, flagsPart);
        if (input.startsWith(FORWARD_SLASH) && input.endsWith(FORWARD_SLASH) || flags) {
            var regExpInput = flags ? regExpPart : input;
            return new RegExp(regExpInput.slice(1, -1), flags);
        }
        var escaped = input.replace(/\\'/g, "'").replace(/\\"/g, '"').replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
        return new RegExp(escaped);
    }
    function escapeRegExp(str) {
        return str.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
    }
    function isValidStrPattern(input) {
        var FORWARD_SLASH = "/";
        var str = escapeRegExp(input);
        if (input[0] === FORWARD_SLASH && input[input.length - 1] === FORWARD_SLASH) {
            str = input.slice(1, -1);
        }
        var isValid;
        try {
            isValid = new RegExp(str);
            isValid = true;
        } catch (e) {
            isValid = false;
        }
        return isValid;
    }
    var updatedArgs = args ? [].concat(source).concat(args) : [ source ];
    try {
        preventCanvas.apply(this, updatedArgs);
        if (source.uniqueId) {
            Object.defineProperty(Window.prototype.toString, uniqueIdentifier, {
                value: flag,
                enumerable: false,
                writable: false,
                configurable: false
            });
        }
    } catch (e) {
        console.log(e);
    }
}

function preventElementSrcLoading(source, args) {
    var flag = "done";
    var uniqueIdentifier = source.uniqueId + source.name + "_" + (Array.isArray(args) ? args.join("_") : "");
    if (source.uniqueId) {
        if (Window.prototype.toString[uniqueIdentifier] === flag) {
            return;
        }
    }
    function preventElementSrcLoading(source, tagName, match) {
        if (typeof Proxy === "undefined" || typeof Reflect === "undefined") {
            return;
        }
        var srcMockData = {
            script: "data:text/javascript;base64,KCk9Pnt9",
            img: "data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==",
            iframe: "data:text/html;base64, PGRpdj48L2Rpdj4=",
            link: "data:text/plain;base64,"
        };
        var instance;
        if (tagName === "script") {
            instance = HTMLScriptElement;
        } else if (tagName === "img") {
            instance = HTMLImageElement;
        } else if (tagName === "iframe") {
            instance = HTMLIFrameElement;
        } else if (tagName === "link") {
            instance = HTMLLinkElement;
        } else {
            return;
        }
        var hasTrustedTypes = window.trustedTypes && typeof window.trustedTypes.createPolicy === "function";
        var policy;
        if (hasTrustedTypes) {
            policy = window.trustedTypes.createPolicy("AGPolicy", {
                createScriptURL: function createScriptURL(arg) {
                    return arg;
                }
            });
        }
        var SOURCE_PROPERTY_NAME = tagName === "link" ? "href" : "src";
        var ONERROR_PROPERTY_NAME = "onerror";
        var searchRegexp = toRegExp(match);
        var setMatchedAttribute = function setMatchedAttribute(elem) {
            return elem.setAttribute(source.name, "matched");
        };
        var setAttributeWrapper = function setAttributeWrapper(target, thisArg, args) {
            if (!args[0] || !args[1]) {
                return Reflect.apply(target, thisArg, args);
            }
            var nodeName = thisArg.nodeName.toLowerCase();
            var attrName = args[0].toLowerCase();
            var attrValue = args[1];
            var isMatched = attrName === SOURCE_PROPERTY_NAME && tagName.toLowerCase() === nodeName && srcMockData[nodeName] && searchRegexp.test(attrValue);
            if (!isMatched) {
                return Reflect.apply(target, thisArg, args);
            }
            hit(source);
            setMatchedAttribute(thisArg);
            return Reflect.apply(target, thisArg, [ attrName, srcMockData[nodeName] ]);
        };
        var setAttributeHandler = {
            apply: setAttributeWrapper
        };
        instance.prototype.setAttribute = new Proxy(Element.prototype.setAttribute, setAttributeHandler);
        var origSrcDescriptor = safeGetDescriptor(instance.prototype, SOURCE_PROPERTY_NAME);
        if (!origSrcDescriptor) {
            return;
        }
        Object.defineProperty(instance.prototype, SOURCE_PROPERTY_NAME, {
            enumerable: true,
            configurable: true,
            get() {
                return origSrcDescriptor.get.call(this);
            },
            set(urlValue) {
                var nodeName = this.nodeName.toLowerCase();
                var isMatched = tagName.toLowerCase() === nodeName && srcMockData[nodeName] && searchRegexp.test(urlValue);
                if (!isMatched) {
                    origSrcDescriptor.set.call(this, urlValue);
                    return true;
                }
                if (policy && urlValue instanceof TrustedScriptURL) {
                    var trustedSrc = policy.createScriptURL(urlValue);
                    origSrcDescriptor.set.call(this, trustedSrc);
                    hit(source);
                    return;
                }
                setMatchedAttribute(this);
                origSrcDescriptor.set.call(this, srcMockData[nodeName]);
                hit(source);
            }
        });
        var origOnerrorDescriptor = safeGetDescriptor(HTMLElement.prototype, ONERROR_PROPERTY_NAME);
        if (!origOnerrorDescriptor) {
            return;
        }
        Object.defineProperty(HTMLElement.prototype, ONERROR_PROPERTY_NAME, {
            enumerable: true,
            configurable: true,
            get() {
                return origOnerrorDescriptor.get.call(this);
            },
            set(cb) {
                var isMatched = this.getAttribute(source.name) === "matched";
                if (!isMatched) {
                    origOnerrorDescriptor.set.call(this, cb);
                    return true;
                }
                origOnerrorDescriptor.set.call(this, noopFunc);
                return true;
            }
        });
        var addEventListenerWrapper = function addEventListenerWrapper(target, thisArg, args) {
            if (!args[0] || !args[1] || !thisArg) {
                return Reflect.apply(target, thisArg, args);
            }
            var eventName = args[0];
            var isMatched = typeof thisArg.getAttribute === "function" && thisArg.getAttribute(source.name) === "matched" && eventName === "error";
            if (isMatched) {
                return Reflect.apply(target, thisArg, [ eventName, noopFunc ]);
            }
            return Reflect.apply(target, thisArg, args);
        };
        var addEventListenerHandler = {
            apply: addEventListenerWrapper
        };
        EventTarget.prototype.addEventListener = new Proxy(EventTarget.prototype.addEventListener, addEventListenerHandler);
        var preventInlineOnerror = function preventInlineOnerror(tagName, src) {
            window.addEventListener("error", (function(event) {
                if (!event.target || !event.target.nodeName || event.target.nodeName.toLowerCase() !== tagName || !event.target.src || !src.test(event.target.src)) {
                    return;
                }
                hit(source);
                if (typeof event.target.onload === "function") {
                    event.target.onerror = event.target.onload;
                    return;
                }
                event.target.onerror = noopFunc;
            }), true);
        };
        preventInlineOnerror(tagName, searchRegexp);
    }
    function hit(source) {
        var ADGUARD_PREFIX = "[AdGuard]";
        if (!source.verbose) {
            return;
        }
        try {
            var trace = console.trace.bind(console);
            var label = `${ADGUARD_PREFIX} `;
            if (source.engine === "corelibs") {
                label += source.ruleText;
            } else {
                if (source.domainName) {
                    label += `${source.domainName}`;
                }
                if (source.args) {
                    label += `#%#//scriptlet('${source.name}', '${source.args.join("', '")}')`;
                } else {
                    label += `#%#//scriptlet('${source.name}')`;
                }
            }
            if (trace) {
                trace(label);
            }
        } catch (e) {}
        if (typeof window.__debug === "function") {
            window.__debug(source);
        }
    }
    function toRegExp(rawInput) {
        var input = rawInput || "";
        var DEFAULT_VALUE = ".?";
        var FORWARD_SLASH = "/";
        if (input === "") {
            return new RegExp(DEFAULT_VALUE);
        }
        var delimiterIndex = input.lastIndexOf(FORWARD_SLASH);
        var flagsPart = input.substring(delimiterIndex + 1);
        var regExpPart = input.substring(0, delimiterIndex + 1);
        var isValidRegExpFlag = function isValidRegExpFlag(flag) {
            if (!flag) {
                return false;
            }
            try {
                new RegExp("", flag);
                return true;
            } catch (ex) {
                return false;
            }
        };
        var getRegExpFlags = function getRegExpFlags(regExpStr, flagsStr) {
            if (regExpStr.startsWith(FORWARD_SLASH) && regExpStr.endsWith(FORWARD_SLASH) && !regExpStr.endsWith("\\/") && isValidRegExpFlag(flagsStr)) {
                return flagsStr;
            }
            return "";
        };
        var flags = getRegExpFlags(regExpPart, flagsPart);
        if (input.startsWith(FORWARD_SLASH) && input.endsWith(FORWARD_SLASH) || flags) {
            var regExpInput = flags ? regExpPart : input;
            return new RegExp(regExpInput.slice(1, -1), flags);
        }
        var escaped = input.replace(/\\'/g, "'").replace(/\\"/g, '"').replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
        return new RegExp(escaped);
    }
    function safeGetDescriptor(obj, prop) {
        var descriptor = Object.getOwnPropertyDescriptor(obj, prop);
        if (descriptor && descriptor.configurable) {
            return descriptor;
        }
        return null;
    }
    function noopFunc() {}
    var updatedArgs = args ? [].concat(source).concat(args) : [ source ];
    try {
        preventElementSrcLoading.apply(this, updatedArgs);
        if (source.uniqueId) {
            Object.defineProperty(Window.prototype.toString, uniqueIdentifier, {
                value: flag,
                enumerable: false,
                writable: false,
                configurable: false
            });
        }
    } catch (e) {
        console.log(e);
    }
}

function preventEvalIf(source, args) {
    var flag = "done";
    var uniqueIdentifier = source.uniqueId + source.name + "_" + (Array.isArray(args) ? args.join("_") : "");
    if (source.uniqueId) {
        if (Window.prototype.toString[uniqueIdentifier] === flag) {
            return;
        }
    }
    function preventEvalIf(source, search) {
        var searchRegexp = toRegExp(search);
        var nativeEval = window.eval;
        window.eval = function(payload) {
            if (!searchRegexp.test(payload.toString())) {
                return nativeEval.call(window, payload);
            }
            hit(source);
            return undefined;
        }.bind(window);
        window.eval.toString = nativeEval.toString.bind(nativeEval);
    }
    function toRegExp(rawInput) {
        var input = rawInput || "";
        var DEFAULT_VALUE = ".?";
        var FORWARD_SLASH = "/";
        if (input === "") {
            return new RegExp(DEFAULT_VALUE);
        }
        var delimiterIndex = input.lastIndexOf(FORWARD_SLASH);
        var flagsPart = input.substring(delimiterIndex + 1);
        var regExpPart = input.substring(0, delimiterIndex + 1);
        var isValidRegExpFlag = function isValidRegExpFlag(flag) {
            if (!flag) {
                return false;
            }
            try {
                new RegExp("", flag);
                return true;
            } catch (ex) {
                return false;
            }
        };
        var getRegExpFlags = function getRegExpFlags(regExpStr, flagsStr) {
            if (regExpStr.startsWith(FORWARD_SLASH) && regExpStr.endsWith(FORWARD_SLASH) && !regExpStr.endsWith("\\/") && isValidRegExpFlag(flagsStr)) {
                return flagsStr;
            }
            return "";
        };
        var flags = getRegExpFlags(regExpPart, flagsPart);
        if (input.startsWith(FORWARD_SLASH) && input.endsWith(FORWARD_SLASH) || flags) {
            var regExpInput = flags ? regExpPart : input;
            return new RegExp(regExpInput.slice(1, -1), flags);
        }
        var escaped = input.replace(/\\'/g, "'").replace(/\\"/g, '"').replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
        return new RegExp(escaped);
    }
    function hit(source) {
        var ADGUARD_PREFIX = "[AdGuard]";
        if (!source.verbose) {
            return;
        }
        try {
            var trace = console.trace.bind(console);
            var label = `${ADGUARD_PREFIX} `;
            if (source.engine === "corelibs") {
                label += source.ruleText;
            } else {
                if (source.domainName) {
                    label += `${source.domainName}`;
                }
                if (source.args) {
                    label += `#%#//scriptlet('${source.name}', '${source.args.join("', '")}')`;
                } else {
                    label += `#%#//scriptlet('${source.name}')`;
                }
            }
            if (trace) {
                trace(label);
            }
        } catch (e) {}
        if (typeof window.__debug === "function") {
            window.__debug(source);
        }
    }
    var updatedArgs = args ? [].concat(source).concat(args) : [ source ];
    try {
        preventEvalIf.apply(this, updatedArgs);
        if (source.uniqueId) {
            Object.defineProperty(Window.prototype.toString, uniqueIdentifier, {
                value: flag,
                enumerable: false,
                writable: false,
                configurable: false
            });
        }
    } catch (e) {
        console.log(e);
    }
}

function preventFab(source, args) {
    var flag = "done";
    var uniqueIdentifier = source.uniqueId + source.name + "_" + (Array.isArray(args) ? args.join("_") : "");
    if (source.uniqueId) {
        if (Window.prototype.toString[uniqueIdentifier] === flag) {
            return;
        }
    }
    function preventFab(source) {
        hit(source);
        var Fab = function Fab() {};
        Fab.prototype.check = noopFunc;
        Fab.prototype.clearEvent = noopFunc;
        Fab.prototype.emitEvent = noopFunc;
        Fab.prototype.on = function(a, b) {
            if (!a) {
                b();
            }
            return this;
        };
        Fab.prototype.onDetected = noopThis;
        Fab.prototype.onNotDetected = function(a) {
            a();
            return this;
        };
        Fab.prototype.setOption = noopFunc;
        Fab.prototype.options = {
            set: noopFunc,
            get: noopFunc
        };
        var fab = new Fab;
        var getSetFab = {
            get() {
                return Fab;
            },
            set() {}
        };
        var getsetfab = {
            get() {
                return fab;
            },
            set() {}
        };
        if (Object.prototype.hasOwnProperty.call(window, "FuckAdBlock")) {
            window.FuckAdBlock = Fab;
        } else {
            Object.defineProperty(window, "FuckAdBlock", getSetFab);
        }
        if (Object.prototype.hasOwnProperty.call(window, "BlockAdBlock")) {
            window.BlockAdBlock = Fab;
        } else {
            Object.defineProperty(window, "BlockAdBlock", getSetFab);
        }
        if (Object.prototype.hasOwnProperty.call(window, "SniffAdBlock")) {
            window.SniffAdBlock = Fab;
        } else {
            Object.defineProperty(window, "SniffAdBlock", getSetFab);
        }
        if (Object.prototype.hasOwnProperty.call(window, "fuckAdBlock")) {
            window.fuckAdBlock = fab;
        } else {
            Object.defineProperty(window, "fuckAdBlock", getsetfab);
        }
        if (Object.prototype.hasOwnProperty.call(window, "blockAdBlock")) {
            window.blockAdBlock = fab;
        } else {
            Object.defineProperty(window, "blockAdBlock", getsetfab);
        }
        if (Object.prototype.hasOwnProperty.call(window, "sniffAdBlock")) {
            window.sniffAdBlock = fab;
        } else {
            Object.defineProperty(window, "sniffAdBlock", getsetfab);
        }
    }
    function hit(source) {
        var ADGUARD_PREFIX = "[AdGuard]";
        if (!source.verbose) {
            return;
        }
        try {
            var trace = console.trace.bind(console);
            var label = `${ADGUARD_PREFIX} `;
            if (source.engine === "corelibs") {
                label += source.ruleText;
            } else {
                if (source.domainName) {
                    label += `${source.domainName}`;
                }
                if (source.args) {
                    label += `#%#//scriptlet('${source.name}', '${source.args.join("', '")}')`;
                } else {
                    label += `#%#//scriptlet('${source.name}')`;
                }
            }
            if (trace) {
                trace(label);
            }
        } catch (e) {}
        if (typeof window.__debug === "function") {
            window.__debug(source);
        }
    }
    function noopFunc() {}
    function noopThis() {
        return this;
    }
    var updatedArgs = args ? [].concat(source).concat(args) : [ source ];
    try {
        preventFab.apply(this, updatedArgs);
        if (source.uniqueId) {
            Object.defineProperty(Window.prototype.toString, uniqueIdentifier, {
                value: flag,
                enumerable: false,
                writable: false,
                configurable: false
            });
        }
    } catch (e) {
        console.log(e);
    }
}

function preventFetch(source, args) {
    var flag = "done";
    var uniqueIdentifier = source.uniqueId + source.name + "_" + (Array.isArray(args) ? args.join("_") : "");
    if (source.uniqueId) {
        if (Window.prototype.toString[uniqueIdentifier] === flag) {
            return;
        }
    }
    function preventFetch(source, propsToMatch) {
        var responseBody = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : "emptyObj";
        var responseType = arguments.length > 3 ? arguments[3] : undefined;
        if (typeof fetch === "undefined" || typeof Proxy === "undefined" || typeof Response === "undefined") {
            return;
        }
        var nativeRequestClone = Request.prototype.clone;
        var strResponseBody;
        if (responseBody === "" || responseBody === "emptyObj") {
            strResponseBody = "{}";
        } else if (responseBody === "emptyArr") {
            strResponseBody = "[]";
        } else if (responseBody === "emptyStr") {
            strResponseBody = "";
        } else {
            logMessage(source, `Invalid responseBody parameter: '${responseBody}'`);
            return;
        }
        var isResponseTypeSpecified = typeof responseType !== "undefined";
        var isResponseTypeSupported = function isResponseTypeSupported(responseType) {
            var SUPPORTED_TYPES = [ "basic", "cors", "opaque" ];
            return SUPPORTED_TYPES.includes(responseType);
        };
        if (isResponseTypeSpecified && !isResponseTypeSupported(responseType)) {
            logMessage(source, `Invalid responseType parameter: '${responseType}'`);
            return;
        }
        var getResponseType = function getResponseType(request) {
            try {
                var {mode: mode} = request;
                if (mode === undefined || mode === "cors" || mode === "no-cors") {
                    var fetchURL = new URL(request.url);
                    if (fetchURL.origin === document.location.origin) {
                        return "basic";
                    }
                    return mode === "no-cors" ? "opaque" : "cors";
                }
            } catch (error) {
                logMessage(source, `Could not determine response type: ${error}`);
            }
            return undefined;
        };
        var handlerWrapper = async function handlerWrapper(target, thisArg, args) {
            var shouldPrevent = false;
            var fetchData = getFetchData(args, nativeRequestClone);
            if (typeof propsToMatch === "undefined") {
                logMessage(source, `fetch( ${objectToString(fetchData)} )`, true);
                hit(source);
                return Reflect.apply(target, thisArg, args);
            }
            shouldPrevent = matchRequestProps(source, propsToMatch, fetchData);
            if (shouldPrevent) {
                hit(source);
                var finalResponseType;
                try {
                    finalResponseType = responseType || getResponseType(fetchData);
                    var origResponse = await Reflect.apply(target, thisArg, args);
                    if (!origResponse.ok) {
                        return noopPromiseResolve(strResponseBody, fetchData.url, finalResponseType);
                    }
                    return modifyResponse(origResponse, {
                        body: strResponseBody,
                        type: finalResponseType
                    });
                } catch (ex) {
                    return noopPromiseResolve(strResponseBody, fetchData.url, finalResponseType);
                }
            }
            return Reflect.apply(target, thisArg, args);
        };
        var fetchHandler = {
            apply: handlerWrapper
        };
        fetch = new Proxy(fetch, fetchHandler);
    }
    function hit(source) {
        var ADGUARD_PREFIX = "[AdGuard]";
        if (!source.verbose) {
            return;
        }
        try {
            var trace = console.trace.bind(console);
            var label = `${ADGUARD_PREFIX} `;
            if (source.engine === "corelibs") {
                label += source.ruleText;
            } else {
                if (source.domainName) {
                    label += `${source.domainName}`;
                }
                if (source.args) {
                    label += `#%#//scriptlet('${source.name}', '${source.args.join("', '")}')`;
                } else {
                    label += `#%#//scriptlet('${source.name}')`;
                }
            }
            if (trace) {
                trace(label);
            }
        } catch (e) {}
        if (typeof window.__debug === "function") {
            window.__debug(source);
        }
    }
    function getFetchData(args, nativeRequestClone) {
        var fetchPropsObj = {};
        var resource = args[0];
        var fetchUrl;
        var fetchInit;
        if (resource instanceof Request) {
            var realData = nativeRequestClone.call(resource);
            var requestData = getRequestData(realData);
            fetchUrl = requestData.url;
            fetchInit = requestData;
        } else {
            fetchUrl = resource;
            fetchInit = args[1];
        }
        fetchPropsObj.url = fetchUrl;
        if (fetchInit instanceof Object) {
            var props = Object.keys(fetchInit);
            props.forEach((function(prop) {
                fetchPropsObj[prop] = fetchInit[prop];
            }));
        }
        return fetchPropsObj;
    }
    function objectToString(obj) {
        if (!obj || typeof obj !== "object") {
            return String(obj);
        }
        if (isEmptyObject(obj)) {
            return "{}";
        }
        return Object.entries(obj).map((function(pair) {
            var key = pair[0];
            var value = pair[1];
            var recordValueStr = value;
            if (value instanceof Object) {
                recordValueStr = `{ ${objectToString(value)} }`;
            }
            return `${key}:"${recordValueStr}"`;
        })).join(" ");
    }
    function matchRequestProps(source, propsToMatch, requestData) {
        if (propsToMatch === "" || propsToMatch === "*") {
            return true;
        }
        var isMatched;
        var parsedData = parseMatchProps(propsToMatch);
        if (!isValidParsedData(parsedData)) {
            logMessage(source, `Invalid parameter: ${propsToMatch}`);
            isMatched = false;
        } else {
            var matchData = getMatchPropsData(parsedData);
            var matchKeys = Object.keys(matchData);
            isMatched = matchKeys.every((function(matchKey) {
                var matchValue = matchData[matchKey];
                var dataValue = requestData[matchKey];
                return Object.prototype.hasOwnProperty.call(requestData, matchKey) && typeof dataValue === "string" && (matchValue === null || matchValue === void 0 ? void 0 : matchValue.test(dataValue));
            }));
        }
        return isMatched;
    }
    function logMessage(source, message) {
        var forced = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
        var convertMessageToString = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
        var {name: name, verbose: verbose} = source;
        if (!forced && !verbose) {
            return;
        }
        var nativeConsole = console.log;
        if (!convertMessageToString) {
            nativeConsole(`${name}:`, message);
            return;
        }
        nativeConsole(`${name}: ${message}`);
    }
    function noopPromiseResolve() {
        var responseBody = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "{}";
        var responseUrl = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "";
        var responseType = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : "basic";
        if (typeof Response === "undefined") {
            return;
        }
        var response = new Response(responseBody, {
            status: 200,
            statusText: "OK"
        });
        if (responseType === "opaque") {
            Object.defineProperties(response, {
                body: {
                    value: null
                },
                status: {
                    value: 0
                },
                ok: {
                    value: false
                },
                statusText: {
                    value: ""
                },
                url: {
                    value: ""
                },
                type: {
                    value: responseType
                }
            });
        } else {
            Object.defineProperties(response, {
                url: {
                    value: responseUrl
                },
                type: {
                    value: responseType
                }
            });
        }
        return Promise.resolve(response);
    }
    function modifyResponse(origResponse) {
        var _origResponse$headers;
        var replacement = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {
            body: "{}"
        };
        var headers = {};
        origResponse === null || origResponse === void 0 || (_origResponse$headers = origResponse.headers) === null || _origResponse$headers === void 0 || _origResponse$headers.forEach((function(value, key) {
            headers[key] = value;
        }));
        var modifiedResponse = new Response(replacement.body, {
            status: origResponse.status,
            statusText: origResponse.statusText,
            headers: headers
        });
        Object.defineProperties(modifiedResponse, {
            url: {
                value: origResponse.url
            },
            type: {
                value: replacement.type || origResponse.type
            }
        });
        return modifiedResponse;
    }
    function toRegExp(rawInput) {
        var input = rawInput || "";
        var DEFAULT_VALUE = ".?";
        var FORWARD_SLASH = "/";
        if (input === "") {
            return new RegExp(DEFAULT_VALUE);
        }
        var delimiterIndex = input.lastIndexOf(FORWARD_SLASH);
        var flagsPart = input.substring(delimiterIndex + 1);
        var regExpPart = input.substring(0, delimiterIndex + 1);
        var isValidRegExpFlag = function isValidRegExpFlag(flag) {
            if (!flag) {
                return false;
            }
            try {
                new RegExp("", flag);
                return true;
            } catch (ex) {
                return false;
            }
        };
        var getRegExpFlags = function getRegExpFlags(regExpStr, flagsStr) {
            if (regExpStr.startsWith(FORWARD_SLASH) && regExpStr.endsWith(FORWARD_SLASH) && !regExpStr.endsWith("\\/") && isValidRegExpFlag(flagsStr)) {
                return flagsStr;
            }
            return "";
        };
        var flags = getRegExpFlags(regExpPart, flagsPart);
        if (input.startsWith(FORWARD_SLASH) && input.endsWith(FORWARD_SLASH) || flags) {
            var regExpInput = flags ? regExpPart : input;
            return new RegExp(regExpInput.slice(1, -1), flags);
        }
        var escaped = input.replace(/\\'/g, "'").replace(/\\"/g, '"').replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
        return new RegExp(escaped);
    }
    function isValidStrPattern(input) {
        var FORWARD_SLASH = "/";
        var str = escapeRegExp(input);
        if (input[0] === FORWARD_SLASH && input[input.length - 1] === FORWARD_SLASH) {
            str = input.slice(1, -1);
        }
        var isValid;
        try {
            isValid = new RegExp(str);
            isValid = true;
        } catch (e) {
            isValid = false;
        }
        return isValid;
    }
    function escapeRegExp(str) {
        return str.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
    }
    function isEmptyObject(obj) {
        return Object.keys(obj).length === 0 && !obj.prototype;
    }
    function getRequestData(request) {
        var requestInitOptions = getRequestProps();
        var entries = requestInitOptions.map((function(key) {
            var value = request[key];
            return [ key, value ];
        }));
        return Object.fromEntries(entries);
    }
    function getRequestProps() {
        return [ "url", "method", "headers", "body", "credentials", "cache", "redirect", "referrer", "referrerPolicy", "integrity", "keepalive", "signal", "mode" ];
    }
    function parseMatchProps(propsToMatchStr) {
        var PROPS_DIVIDER = " ";
        var PAIRS_MARKER = ":";
        var isRequestProp = function isRequestProp(prop) {
            return getRequestProps().includes(prop);
        };
        var propsObj = {};
        var props = propsToMatchStr.split(PROPS_DIVIDER);
        props.forEach((function(prop) {
            var dividerInd = prop.indexOf(PAIRS_MARKER);
            var key = prop.slice(0, dividerInd);
            if (isRequestProp(key)) {
                var value = prop.slice(dividerInd + 1);
                propsObj[key] = value;
            } else {
                propsObj.url = prop;
            }
        }));
        return propsObj;
    }
    function isValidParsedData(data) {
        return Object.values(data).every((function(value) {
            return isValidStrPattern(value);
        }));
    }
    function getMatchPropsData(data) {
        var matchData = {};
        var dataKeys = Object.keys(data);
        dataKeys.forEach((function(key) {
            matchData[key] = toRegExp(data[key]);
        }));
        return matchData;
    }
    var updatedArgs = args ? [].concat(source).concat(args) : [ source ];
    try {
        preventFetch.apply(this, updatedArgs);
        if (source.uniqueId) {
            Object.defineProperty(Window.prototype.toString, uniqueIdentifier, {
                value: flag,
                enumerable: false,
                writable: false,
                configurable: false
            });
        }
    } catch (e) {
        console.log(e);
    }
}

function preventPopadsNet(source, args) {
    var flag = "done";
    var uniqueIdentifier = source.uniqueId + source.name + "_" + (Array.isArray(args) ? args.join("_") : "");
    if (source.uniqueId) {
        if (Window.prototype.toString[uniqueIdentifier] === flag) {
            return;
        }
    }
    function preventPopadsNet(source) {
        var rid = randomId();
        var throwError = function throwError() {
            throw new ReferenceError(rid);
        };
        delete window.PopAds;
        delete window.popns;
        Object.defineProperties(window, {
            PopAds: {
                set: throwError
            },
            popns: {
                set: throwError
            }
        });
        window.onerror = createOnErrorHandler(rid).bind();
        hit(source);
    }
    function createOnErrorHandler(rid) {
        var nativeOnError = window.onerror;
        return function onError(error) {
            if (typeof error === "string" && error.includes(rid)) {
                return true;
            }
            if (nativeOnError instanceof Function) {
                for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
                    args[_key - 1] = arguments[_key];
                }
                return nativeOnError.apply(window, [ error, ...args ]);
            }
            return false;
        };
    }
    function randomId() {
        return Math.random().toString(36).slice(2, 9);
    }
    function hit(source) {
        var ADGUARD_PREFIX = "[AdGuard]";
        if (!source.verbose) {
            return;
        }
        try {
            var trace = console.trace.bind(console);
            var label = `${ADGUARD_PREFIX} `;
            if (source.engine === "corelibs") {
                label += source.ruleText;
            } else {
                if (source.domainName) {
                    label += `${source.domainName}`;
                }
                if (source.args) {
                    label += `#%#//scriptlet('${source.name}', '${source.args.join("', '")}')`;
                } else {
                    label += `#%#//scriptlet('${source.name}')`;
                }
            }
            if (trace) {
                trace(label);
            }
        } catch (e) {}
        if (typeof window.__debug === "function") {
            window.__debug(source);
        }
    }
    var updatedArgs = args ? [].concat(source).concat(args) : [ source ];
    try {
        preventPopadsNet.apply(this, updatedArgs);
        if (source.uniqueId) {
            Object.defineProperty(Window.prototype.toString, uniqueIdentifier, {
                value: flag,
                enumerable: false,
                writable: false,
                configurable: false
            });
        }
    } catch (e) {
        console.log(e);
    }
}

function preventRefresh(source, args) {
    var flag = "done";
    var uniqueIdentifier = source.uniqueId + source.name + "_" + (Array.isArray(args) ? args.join("_") : "");
    if (source.uniqueId) {
        if (Window.prototype.toString[uniqueIdentifier] === flag) {
            return;
        }
    }
    function preventRefresh(source, delaySec) {
        var getMetaElements = function getMetaElements() {
            var metaNodes = [];
            try {
                metaNodes = document.querySelectorAll('meta[http-equiv="refresh" i][content]');
            } catch (e) {
                try {
                    metaNodes = document.querySelectorAll('meta[http-equiv="refresh"][content]');
                } catch (e) {
                    logMessage(source, e);
                }
            }
            return Array.from(metaNodes);
        };
        var getMetaContentDelay = function getMetaContentDelay(metaElements) {
            var delays = metaElements.map((function(meta) {
                var contentString = meta.getAttribute("content");
                if (contentString.length === 0) {
                    return null;
                }
                var contentDelay;
                var limiterIndex = contentString.indexOf(";");
                if (limiterIndex !== -1) {
                    var delaySubstring = contentString.substring(0, limiterIndex);
                    contentDelay = getNumberFromString(delaySubstring);
                } else {
                    contentDelay = getNumberFromString(contentString);
                }
                return contentDelay;
            })).filter((function(delay) {
                return delay !== null;
            }));
            if (!delays.length) {
                return null;
            }
            var minDelay = delays.reduce((function(a, b) {
                return Math.min(a, b);
            }));
            return minDelay;
        };
        var stop = function stop() {
            var metaElements = getMetaElements();
            if (metaElements.length === 0) {
                return;
            }
            var secondsToRun = getNumberFromString(delaySec);
            if (secondsToRun === null) {
                secondsToRun = getMetaContentDelay(metaElements);
            }
            if (secondsToRun === null) {
                return;
            }
            var delayMs = secondsToRun * 1e3;
            setTimeout((function() {
                window.stop();
                hit(source);
            }), delayMs);
        };
        if (document.readyState === "loading") {
            document.addEventListener("DOMContentLoaded", stop, {
                once: true
            });
        } else {
            stop();
        }
    }
    function hit(source) {
        var ADGUARD_PREFIX = "[AdGuard]";
        if (!source.verbose) {
            return;
        }
        try {
            var trace = console.trace.bind(console);
            var label = `${ADGUARD_PREFIX} `;
            if (source.engine === "corelibs") {
                label += source.ruleText;
            } else {
                if (source.domainName) {
                    label += `${source.domainName}`;
                }
                if (source.args) {
                    label += `#%#//scriptlet('${source.name}', '${source.args.join("', '")}')`;
                } else {
                    label += `#%#//scriptlet('${source.name}')`;
                }
            }
            if (trace) {
                trace(label);
            }
        } catch (e) {}
        if (typeof window.__debug === "function") {
            window.__debug(source);
        }
    }
    function getNumberFromString(rawString) {
        var parsedDelay = parseInt(rawString, 10);
        var validDelay = nativeIsNaN(parsedDelay) ? null : parsedDelay;
        return validDelay;
    }
    function logMessage(source, message) {
        var forced = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
        var convertMessageToString = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
        var {name: name, verbose: verbose} = source;
        if (!forced && !verbose) {
            return;
        }
        var nativeConsole = console.log;
        if (!convertMessageToString) {
            nativeConsole(`${name}:`, message);
            return;
        }
        nativeConsole(`${name}: ${message}`);
    }
    function nativeIsNaN(num) {
        var native = Number.isNaN || window.isNaN;
        return native(num);
    }
    var updatedArgs = args ? [].concat(source).concat(args) : [ source ];
    try {
        preventRefresh.apply(this, updatedArgs);
        if (source.uniqueId) {
            Object.defineProperty(Window.prototype.toString, uniqueIdentifier, {
                value: flag,
                enumerable: false,
                writable: false,
                configurable: false
            });
        }
    } catch (e) {
        console.log(e);
    }
}

function preventRequestAnimationFrame(source, args) {
    var flag = "done";
    var uniqueIdentifier = source.uniqueId + source.name + "_" + (Array.isArray(args) ? args.join("_") : "");
    if (source.uniqueId) {
        if (Window.prototype.toString[uniqueIdentifier] === flag) {
            return;
        }
    }
    function preventRequestAnimationFrame(source, match) {
        var nativeRequestAnimationFrame = window.requestAnimationFrame;
        var shouldLog = typeof match === "undefined";
        var {isInvertedMatch: isInvertedMatch, matchRegexp: matchRegexp} = parseMatchArg(match);
        var rafWrapper = function rafWrapper(callback) {
            var shouldPrevent = false;
            if (shouldLog) {
                hit(source);
                logMessage(source, `requestAnimationFrame(${String(callback)})`, true);
            } else if (isValidCallback(callback) && isValidStrPattern(match)) {
                shouldPrevent = matchRegexp.test(callback.toString()) !== isInvertedMatch;
            }
            if (shouldPrevent) {
                hit(source);
                return nativeRequestAnimationFrame(noopFunc);
            }
            for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
                args[_key - 1] = arguments[_key];
            }
            return nativeRequestAnimationFrame.apply(window, [ callback, ...args ]);
        };
        window.requestAnimationFrame = rafWrapper;
    }
    function hit(source) {
        var ADGUARD_PREFIX = "[AdGuard]";
        if (!source.verbose) {
            return;
        }
        try {
            var trace = console.trace.bind(console);
            var label = `${ADGUARD_PREFIX} `;
            if (source.engine === "corelibs") {
                label += source.ruleText;
            } else {
                if (source.domainName) {
                    label += `${source.domainName}`;
                }
                if (source.args) {
                    label += `#%#//scriptlet('${source.name}', '${source.args.join("', '")}')`;
                } else {
                    label += `#%#//scriptlet('${source.name}')`;
                }
            }
            if (trace) {
                trace(label);
            }
        } catch (e) {}
        if (typeof window.__debug === "function") {
            window.__debug(source);
        }
    }
    function noopFunc() {}
    function parseMatchArg(match) {
        var INVERT_MARKER = "!";
        var isInvertedMatch = match ? match === null || match === void 0 ? void 0 : match.startsWith(INVERT_MARKER) : false;
        var matchValue = isInvertedMatch ? match.slice(1) : match;
        var matchRegexp = toRegExp(matchValue);
        return {
            isInvertedMatch: isInvertedMatch,
            matchRegexp: matchRegexp,
            matchValue: matchValue
        };
    }
    function isValidStrPattern(input) {
        var FORWARD_SLASH = "/";
        var str = escapeRegExp(input);
        if (input[0] === FORWARD_SLASH && input[input.length - 1] === FORWARD_SLASH) {
            str = input.slice(1, -1);
        }
        var isValid;
        try {
            isValid = new RegExp(str);
            isValid = true;
        } catch (e) {
            isValid = false;
        }
        return isValid;
    }
    function isValidCallback(callback) {
        return callback instanceof Function || typeof callback === "string";
    }
    function logMessage(source, message) {
        var forced = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
        var convertMessageToString = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
        var {name: name, verbose: verbose} = source;
        if (!forced && !verbose) {
            return;
        }
        var nativeConsole = console.log;
        if (!convertMessageToString) {
            nativeConsole(`${name}:`, message);
            return;
        }
        nativeConsole(`${name}: ${message}`);
    }
    function escapeRegExp(str) {
        return str.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
    }
    function toRegExp(rawInput) {
        var input = rawInput || "";
        var DEFAULT_VALUE = ".?";
        var FORWARD_SLASH = "/";
        if (input === "") {
            return new RegExp(DEFAULT_VALUE);
        }
        var delimiterIndex = input.lastIndexOf(FORWARD_SLASH);
        var flagsPart = input.substring(delimiterIndex + 1);
        var regExpPart = input.substring(0, delimiterIndex + 1);
        var isValidRegExpFlag = function isValidRegExpFlag(flag) {
            if (!flag) {
                return false;
            }
            try {
                new RegExp("", flag);
                return true;
            } catch (ex) {
                return false;
            }
        };
        var getRegExpFlags = function getRegExpFlags(regExpStr, flagsStr) {
            if (regExpStr.startsWith(FORWARD_SLASH) && regExpStr.endsWith(FORWARD_SLASH) && !regExpStr.endsWith("\\/") && isValidRegExpFlag(flagsStr)) {
                return flagsStr;
            }
            return "";
        };
        var flags = getRegExpFlags(regExpPart, flagsPart);
        if (input.startsWith(FORWARD_SLASH) && input.endsWith(FORWARD_SLASH) || flags) {
            var regExpInput = flags ? regExpPart : input;
            return new RegExp(regExpInput.slice(1, -1), flags);
        }
        var escaped = input.replace(/\\'/g, "'").replace(/\\"/g, '"').replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
        return new RegExp(escaped);
    }
    var updatedArgs = args ? [].concat(source).concat(args) : [ source ];
    try {
        preventRequestAnimationFrame.apply(this, updatedArgs);
        if (source.uniqueId) {
            Object.defineProperty(Window.prototype.toString, uniqueIdentifier, {
                value: flag,
                enumerable: false,
                writable: false,
                configurable: false
            });
        }
    } catch (e) {
        console.log(e);
    }
}

function preventSetInterval(source, args) {
    var flag = "done";
    var uniqueIdentifier = source.uniqueId + source.name + "_" + (Array.isArray(args) ? args.join("_") : "");
    if (source.uniqueId) {
        if (Window.prototype.toString[uniqueIdentifier] === flag) {
            return;
        }
    }
    function preventSetInterval(source, matchCallback, matchDelay) {
        var shouldLog = typeof matchCallback === "undefined" && typeof matchDelay === "undefined";
        var handlerWrapper = function handlerWrapper(target, thisArg, args) {
            var callback = args[0];
            var delay = args[1];
            var shouldPrevent = false;
            if (shouldLog) {
                hit(source);
                logMessage(source, `setInterval(${String(callback)}, ${delay})`, true);
            } else {
                shouldPrevent = isPreventionNeeded({
                    callback: callback,
                    delay: delay,
                    matchCallback: matchCallback,
                    matchDelay: matchDelay
                });
            }
            if (shouldPrevent) {
                hit(source);
                args[0] = noopFunc;
            }
            return target.apply(thisArg, args);
        };
        var setIntervalHandler = {
            apply: handlerWrapper
        };
        window.setInterval = new Proxy(window.setInterval, setIntervalHandler);
    }
    function hit(source) {
        var ADGUARD_PREFIX = "[AdGuard]";
        if (!source.verbose) {
            return;
        }
        try {
            var trace = console.trace.bind(console);
            var label = `${ADGUARD_PREFIX} `;
            if (source.engine === "corelibs") {
                label += source.ruleText;
            } else {
                if (source.domainName) {
                    label += `${source.domainName}`;
                }
                if (source.args) {
                    label += `#%#//scriptlet('${source.name}', '${source.args.join("', '")}')`;
                } else {
                    label += `#%#//scriptlet('${source.name}')`;
                }
            }
            if (trace) {
                trace(label);
            }
        } catch (e) {}
        if (typeof window.__debug === "function") {
            window.__debug(source);
        }
    }
    function noopFunc() {}
    function isPreventionNeeded(_ref) {
        var {callback: callback, delay: delay, matchCallback: matchCallback, matchDelay: matchDelay} = _ref;
        if (!isValidCallback(callback)) {
            return false;
        }
        if (!isValidMatchStr(matchCallback) || matchDelay && !isValidMatchNumber(matchDelay)) {
            return false;
        }
        var {isInvertedMatch: isInvertedMatch, matchRegexp: matchRegexp} = parseMatchArg(matchCallback);
        var {isInvertedDelayMatch: isInvertedDelayMatch, delayMatch: delayMatch} = parseDelayArg(matchDelay);
        var parsedDelay = parseRawDelay(delay);
        var shouldPrevent = false;
        var callbackStr = String(callback);
        if (delayMatch === null) {
            shouldPrevent = matchRegexp.test(callbackStr) !== isInvertedMatch;
        } else if (!matchCallback) {
            shouldPrevent = parsedDelay === delayMatch !== isInvertedDelayMatch;
        } else {
            shouldPrevent = matchRegexp.test(callbackStr) !== isInvertedMatch && parsedDelay === delayMatch !== isInvertedDelayMatch;
        }
        return shouldPrevent;
    }
    function logMessage(source, message) {
        var forced = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
        var convertMessageToString = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
        var {name: name, verbose: verbose} = source;
        if (!forced && !verbose) {
            return;
        }
        var nativeConsole = console.log;
        if (!convertMessageToString) {
            nativeConsole(`${name}:`, message);
            return;
        }
        nativeConsole(`${name}: ${message}`);
    }
    function toRegExp(rawInput) {
        var input = rawInput || "";
        var DEFAULT_VALUE = ".?";
        var FORWARD_SLASH = "/";
        if (input === "") {
            return new RegExp(DEFAULT_VALUE);
        }
        var delimiterIndex = input.lastIndexOf(FORWARD_SLASH);
        var flagsPart = input.substring(delimiterIndex + 1);
        var regExpPart = input.substring(0, delimiterIndex + 1);
        var isValidRegExpFlag = function isValidRegExpFlag(flag) {
            if (!flag) {
                return false;
            }
            try {
                new RegExp("", flag);
                return true;
            } catch (ex) {
                return false;
            }
        };
        var getRegExpFlags = function getRegExpFlags(regExpStr, flagsStr) {
            if (regExpStr.startsWith(FORWARD_SLASH) && regExpStr.endsWith(FORWARD_SLASH) && !regExpStr.endsWith("\\/") && isValidRegExpFlag(flagsStr)) {
                return flagsStr;
            }
            return "";
        };
        var flags = getRegExpFlags(regExpPart, flagsPart);
        if (input.startsWith(FORWARD_SLASH) && input.endsWith(FORWARD_SLASH) || flags) {
            var regExpInput = flags ? regExpPart : input;
            return new RegExp(regExpInput.slice(1, -1), flags);
        }
        var escaped = input.replace(/\\'/g, "'").replace(/\\"/g, '"').replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
        return new RegExp(escaped);
    }
    function nativeIsNaN(num) {
        var native = Number.isNaN || window.isNaN;
        return native(num);
    }
    function parseMatchArg(match) {
        var INVERT_MARKER = "!";
        var isInvertedMatch = match ? match === null || match === void 0 ? void 0 : match.startsWith(INVERT_MARKER) : false;
        var matchValue = isInvertedMatch ? match.slice(1) : match;
        var matchRegexp = toRegExp(matchValue);
        return {
            isInvertedMatch: isInvertedMatch,
            matchRegexp: matchRegexp,
            matchValue: matchValue
        };
    }
    function parseDelayArg(delay) {
        var INVERT_MARKER = "!";
        var isInvertedDelayMatch = delay === null || delay === void 0 ? void 0 : delay.startsWith(INVERT_MARKER);
        var delayValue = isInvertedDelayMatch ? delay.slice(1) : delay;
        var parsedDelay = parseInt(delayValue, 10);
        var delayMatch = nativeIsNaN(parsedDelay) ? null : parsedDelay;
        return {
            isInvertedDelayMatch: isInvertedDelayMatch,
            delayMatch: delayMatch
        };
    }
    function isValidCallback(callback) {
        return callback instanceof Function || typeof callback === "string";
    }
    function isValidMatchStr(match) {
        var INVERT_MARKER = "!";
        var str = match;
        if (match !== null && match !== void 0 && match.startsWith(INVERT_MARKER)) {
            str = match.slice(1);
        }
        return isValidStrPattern(str);
    }
    function isValidStrPattern(input) {
        var FORWARD_SLASH = "/";
        var str = escapeRegExp(input);
        if (input[0] === FORWARD_SLASH && input[input.length - 1] === FORWARD_SLASH) {
            str = input.slice(1, -1);
        }
        var isValid;
        try {
            isValid = new RegExp(str);
            isValid = true;
        } catch (e) {
            isValid = false;
        }
        return isValid;
    }
    function escapeRegExp(str) {
        return str.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
    }
    function nativeIsFinite(num) {
        var native = Number.isFinite || window.isFinite;
        return native(num);
    }
    function isValidMatchNumber(match) {
        var INVERT_MARKER = "!";
        var str = match;
        if (match !== null && match !== void 0 && match.startsWith(INVERT_MARKER)) {
            str = match.slice(1);
        }
        var num = parseFloat(str);
        return !nativeIsNaN(num) && nativeIsFinite(num);
    }
    function parseRawDelay(delay) {
        var parsedDelay = Math.floor(parseInt(delay, 10));
        return typeof parsedDelay === "number" && !nativeIsNaN(parsedDelay) ? parsedDelay : delay;
    }
    var updatedArgs = args ? [].concat(source).concat(args) : [ source ];
    try {
        preventSetInterval.apply(this, updatedArgs);
        if (source.uniqueId) {
            Object.defineProperty(Window.prototype.toString, uniqueIdentifier, {
                value: flag,
                enumerable: false,
                writable: false,
                configurable: false
            });
        }
    } catch (e) {
        console.log(e);
    }
}

function preventSetTimeout(source, args) {
    var flag = "done";
    var uniqueIdentifier = source.uniqueId + source.name + "_" + (Array.isArray(args) ? args.join("_") : "");
    if (source.uniqueId) {
        if (Window.prototype.toString[uniqueIdentifier] === flag) {
            return;
        }
    }
    function preventSetTimeout(source, matchCallback, matchDelay) {
        var shouldLog = typeof matchCallback === "undefined" && typeof matchDelay === "undefined";
        var handlerWrapper = function handlerWrapper(target, thisArg, args) {
            var callback = args[0];
            var delay = args[1];
            var shouldPrevent = false;
            if (shouldLog) {
                hit(source);
                logMessage(source, `setTimeout(${String(callback)}, ${delay})`, true);
            } else {
                shouldPrevent = isPreventionNeeded({
                    callback: callback,
                    delay: delay,
                    matchCallback: matchCallback,
                    matchDelay: matchDelay
                });
            }
            if (shouldPrevent) {
                hit(source);
                args[0] = noopFunc;
            }
            return target.apply(thisArg, args);
        };
        var setTimeoutHandler = {
            apply: handlerWrapper
        };
        window.setTimeout = new Proxy(window.setTimeout, setTimeoutHandler);
    }
    function hit(source) {
        var ADGUARD_PREFIX = "[AdGuard]";
        if (!source.verbose) {
            return;
        }
        try {
            var trace = console.trace.bind(console);
            var label = `${ADGUARD_PREFIX} `;
            if (source.engine === "corelibs") {
                label += source.ruleText;
            } else {
                if (source.domainName) {
                    label += `${source.domainName}`;
                }
                if (source.args) {
                    label += `#%#//scriptlet('${source.name}', '${source.args.join("', '")}')`;
                } else {
                    label += `#%#//scriptlet('${source.name}')`;
                }
            }
            if (trace) {
                trace(label);
            }
        } catch (e) {}
        if (typeof window.__debug === "function") {
            window.__debug(source);
        }
    }
    function noopFunc() {}
    function isPreventionNeeded(_ref) {
        var {callback: callback, delay: delay, matchCallback: matchCallback, matchDelay: matchDelay} = _ref;
        if (!isValidCallback(callback)) {
            return false;
        }
        if (!isValidMatchStr(matchCallback) || matchDelay && !isValidMatchNumber(matchDelay)) {
            return false;
        }
        var {isInvertedMatch: isInvertedMatch, matchRegexp: matchRegexp} = parseMatchArg(matchCallback);
        var {isInvertedDelayMatch: isInvertedDelayMatch, delayMatch: delayMatch} = parseDelayArg(matchDelay);
        var parsedDelay = parseRawDelay(delay);
        var shouldPrevent = false;
        var callbackStr = String(callback);
        if (delayMatch === null) {
            shouldPrevent = matchRegexp.test(callbackStr) !== isInvertedMatch;
        } else if (!matchCallback) {
            shouldPrevent = parsedDelay === delayMatch !== isInvertedDelayMatch;
        } else {
            shouldPrevent = matchRegexp.test(callbackStr) !== isInvertedMatch && parsedDelay === delayMatch !== isInvertedDelayMatch;
        }
        return shouldPrevent;
    }
    function logMessage(source, message) {
        var forced = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
        var convertMessageToString = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
        var {name: name, verbose: verbose} = source;
        if (!forced && !verbose) {
            return;
        }
        var nativeConsole = console.log;
        if (!convertMessageToString) {
            nativeConsole(`${name}:`, message);
            return;
        }
        nativeConsole(`${name}: ${message}`);
    }
    function parseMatchArg(match) {
        var INVERT_MARKER = "!";
        var isInvertedMatch = match ? match === null || match === void 0 ? void 0 : match.startsWith(INVERT_MARKER) : false;
        var matchValue = isInvertedMatch ? match.slice(1) : match;
        var matchRegexp = toRegExp(matchValue);
        return {
            isInvertedMatch: isInvertedMatch,
            matchRegexp: matchRegexp,
            matchValue: matchValue
        };
    }
    function parseDelayArg(delay) {
        var INVERT_MARKER = "!";
        var isInvertedDelayMatch = delay === null || delay === void 0 ? void 0 : delay.startsWith(INVERT_MARKER);
        var delayValue = isInvertedDelayMatch ? delay.slice(1) : delay;
        var parsedDelay = parseInt(delayValue, 10);
        var delayMatch = nativeIsNaN(parsedDelay) ? null : parsedDelay;
        return {
            isInvertedDelayMatch: isInvertedDelayMatch,
            delayMatch: delayMatch
        };
    }
    function toRegExp(rawInput) {
        var input = rawInput || "";
        var DEFAULT_VALUE = ".?";
        var FORWARD_SLASH = "/";
        if (input === "") {
            return new RegExp(DEFAULT_VALUE);
        }
        var delimiterIndex = input.lastIndexOf(FORWARD_SLASH);
        var flagsPart = input.substring(delimiterIndex + 1);
        var regExpPart = input.substring(0, delimiterIndex + 1);
        var isValidRegExpFlag = function isValidRegExpFlag(flag) {
            if (!flag) {
                return false;
            }
            try {
                new RegExp("", flag);
                return true;
            } catch (ex) {
                return false;
            }
        };
        var getRegExpFlags = function getRegExpFlags(regExpStr, flagsStr) {
            if (regExpStr.startsWith(FORWARD_SLASH) && regExpStr.endsWith(FORWARD_SLASH) && !regExpStr.endsWith("\\/") && isValidRegExpFlag(flagsStr)) {
                return flagsStr;
            }
            return "";
        };
        var flags = getRegExpFlags(regExpPart, flagsPart);
        if (input.startsWith(FORWARD_SLASH) && input.endsWith(FORWARD_SLASH) || flags) {
            var regExpInput = flags ? regExpPart : input;
            return new RegExp(regExpInput.slice(1, -1), flags);
        }
        var escaped = input.replace(/\\'/g, "'").replace(/\\"/g, '"').replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
        return new RegExp(escaped);
    }
    function nativeIsNaN(num) {
        var native = Number.isNaN || window.isNaN;
        return native(num);
    }
    function isValidCallback(callback) {
        return callback instanceof Function || typeof callback === "string";
    }
    function isValidMatchStr(match) {
        var INVERT_MARKER = "!";
        var str = match;
        if (match !== null && match !== void 0 && match.startsWith(INVERT_MARKER)) {
            str = match.slice(1);
        }
        return isValidStrPattern(str);
    }
    function escapeRegExp(str) {
        return str.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
    }
    function isValidStrPattern(input) {
        var FORWARD_SLASH = "/";
        var str = escapeRegExp(input);
        if (input[0] === FORWARD_SLASH && input[input.length - 1] === FORWARD_SLASH) {
            str = input.slice(1, -1);
        }
        var isValid;
        try {
            isValid = new RegExp(str);
            isValid = true;
        } catch (e) {
            isValid = false;
        }
        return isValid;
    }
    function nativeIsFinite(num) {
        var native = Number.isFinite || window.isFinite;
        return native(num);
    }
    function isValidMatchNumber(match) {
        var INVERT_MARKER = "!";
        var str = match;
        if (match !== null && match !== void 0 && match.startsWith(INVERT_MARKER)) {
            str = match.slice(1);
        }
        var num = parseFloat(str);
        return !nativeIsNaN(num) && nativeIsFinite(num);
    }
    function parseRawDelay(delay) {
        var parsedDelay = Math.floor(parseInt(delay, 10));
        return typeof parsedDelay === "number" && !nativeIsNaN(parsedDelay) ? parsedDelay : delay;
    }
    var updatedArgs = args ? [].concat(source).concat(args) : [ source ];
    try {
        preventSetTimeout.apply(this, updatedArgs);
        if (source.uniqueId) {
            Object.defineProperty(Window.prototype.toString, uniqueIdentifier, {
                value: flag,
                enumerable: false,
                writable: false,
                configurable: false
            });
        }
    } catch (e) {
        console.log(e);
    }
}

function preventWindowOpen(source, args) {
    var flag = "done";
    var uniqueIdentifier = source.uniqueId + source.name + "_" + (Array.isArray(args) ? args.join("_") : "");
    if (source.uniqueId) {
        if (Window.prototype.toString[uniqueIdentifier] === flag) {
            return;
        }
    }
    function preventWindowOpen(source) {
        var match = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "*";
        var delay = arguments.length > 2 ? arguments[2] : undefined;
        var replacement = arguments.length > 3 ? arguments[3] : undefined;
        var nativeOpen = window.open;
        var isNewSyntax = match !== "0" && match !== "1";
        var oldOpenWrapper = function oldOpenWrapper(str) {
            match = Number(match) > 0;
            for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
                args[_key - 1] = arguments[_key];
            }
            if (!isValidStrPattern(delay)) {
                logMessage(source, `Invalid parameter: ${delay}`);
                return nativeOpen.apply(window, [ str, ...args ]);
            }
            var searchRegexp = toRegExp(delay);
            if (match !== searchRegexp.test(str)) {
                return nativeOpen.apply(window, [ str, ...args ]);
            }
            hit(source);
            return handleOldReplacement(replacement);
        };
        var newOpenWrapper = function newOpenWrapper(url) {
            var shouldLog = replacement && replacement.includes("log");
            for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
                args[_key2 - 1] = arguments[_key2];
            }
            if (shouldLog) {
                var argsStr = args && args.length > 0 ? `, ${args.join(", ")}` : "";
                var message = `${url}${argsStr}`;
                logMessage(source, message, true);
                hit(source);
            }
            var shouldPrevent = false;
            if (match === "*") {
                shouldPrevent = true;
            } else if (isValidMatchStr(match)) {
                var {isInvertedMatch: isInvertedMatch, matchRegexp: matchRegexp} = parseMatchArg(match);
                shouldPrevent = matchRegexp.test(url) !== isInvertedMatch;
            } else {
                logMessage(source, `Invalid parameter: ${match}`);
                shouldPrevent = false;
            }
            if (shouldPrevent) {
                var parsedDelay = parseInt(delay, 10);
                var result;
                if (nativeIsNaN(parsedDelay)) {
                    result = noopNull();
                } else {
                    var decoyArgs = {
                        replacement: replacement,
                        url: url,
                        delay: parsedDelay
                    };
                    var decoy = createDecoy(decoyArgs);
                    var popup = decoy.contentWindow;
                    if (typeof popup === "object" && popup !== null) {
                        Object.defineProperty(popup, "closed", {
                            value: false
                        });
                        Object.defineProperty(popup, "opener", {
                            value: window
                        });
                        Object.defineProperty(popup, "frameElement", {
                            value: null
                        });
                    } else {
                        var nativeGetter = decoy.contentWindow && decoy.contentWindow.get;
                        Object.defineProperty(decoy, "contentWindow", {
                            get: getPreventGetter(nativeGetter)
                        });
                        popup = decoy.contentWindow;
                    }
                    result = popup;
                }
                hit(source);
                return result;
            }
            return nativeOpen.apply(window, [ url, ...args ]);
        };
        window.open = isNewSyntax ? newOpenWrapper : oldOpenWrapper;
        window.open.toString = nativeOpen.toString.bind(nativeOpen);
    }
    function hit(source) {
        var ADGUARD_PREFIX = "[AdGuard]";
        if (!source.verbose) {
            return;
        }
        try {
            var trace = console.trace.bind(console);
            var label = `${ADGUARD_PREFIX} `;
            if (source.engine === "corelibs") {
                label += source.ruleText;
            } else {
                if (source.domainName) {
                    label += `${source.domainName}`;
                }
                if (source.args) {
                    label += `#%#//scriptlet('${source.name}', '${source.args.join("', '")}')`;
                } else {
                    label += `#%#//scriptlet('${source.name}')`;
                }
            }
            if (trace) {
                trace(label);
            }
        } catch (e) {}
        if (typeof window.__debug === "function") {
            window.__debug(source);
        }
    }
    function isValidStrPattern(input) {
        var FORWARD_SLASH = "/";
        var str = escapeRegExp(input);
        if (input[0] === FORWARD_SLASH && input[input.length - 1] === FORWARD_SLASH) {
            str = input.slice(1, -1);
        }
        var isValid;
        try {
            isValid = new RegExp(str);
            isValid = true;
        } catch (e) {
            isValid = false;
        }
        return isValid;
    }
    function escapeRegExp(str) {
        return str.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
    }
    function isValidMatchStr(match) {
        var INVERT_MARKER = "!";
        var str = match;
        if (match !== null && match !== void 0 && match.startsWith(INVERT_MARKER)) {
            str = match.slice(1);
        }
        return isValidStrPattern(str);
    }
    function toRegExp(rawInput) {
        var input = rawInput || "";
        var DEFAULT_VALUE = ".?";
        var FORWARD_SLASH = "/";
        if (input === "") {
            return new RegExp(DEFAULT_VALUE);
        }
        var delimiterIndex = input.lastIndexOf(FORWARD_SLASH);
        var flagsPart = input.substring(delimiterIndex + 1);
        var regExpPart = input.substring(0, delimiterIndex + 1);
        var isValidRegExpFlag = function isValidRegExpFlag(flag) {
            if (!flag) {
                return false;
            }
            try {
                new RegExp("", flag);
                return true;
            } catch (ex) {
                return false;
            }
        };
        var getRegExpFlags = function getRegExpFlags(regExpStr, flagsStr) {
            if (regExpStr.startsWith(FORWARD_SLASH) && regExpStr.endsWith(FORWARD_SLASH) && !regExpStr.endsWith("\\/") && isValidRegExpFlag(flagsStr)) {
                return flagsStr;
            }
            return "";
        };
        var flags = getRegExpFlags(regExpPart, flagsPart);
        if (input.startsWith(FORWARD_SLASH) && input.endsWith(FORWARD_SLASH) || flags) {
            var regExpInput = flags ? regExpPart : input;
            return new RegExp(regExpInput.slice(1, -1), flags);
        }
        var escaped = input.replace(/\\'/g, "'").replace(/\\"/g, '"').replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
        return new RegExp(escaped);
    }
    function nativeIsNaN(num) {
        var native = Number.isNaN || window.isNaN;
        return native(num);
    }
    function parseMatchArg(match) {
        var INVERT_MARKER = "!";
        var isInvertedMatch = match ? match === null || match === void 0 ? void 0 : match.startsWith(INVERT_MARKER) : false;
        var matchValue = isInvertedMatch ? match.slice(1) : match;
        var matchRegexp = toRegExp(matchValue);
        return {
            isInvertedMatch: isInvertedMatch,
            matchRegexp: matchRegexp,
            matchValue: matchValue
        };
    }
    function handleOldReplacement(replacement) {
        var result;
        if (!replacement) {
            result = noopFunc;
        } else if (replacement === "trueFunc") {
            result = trueFunc;
        } else if (replacement.includes("=")) {
            var isProp = replacement.startsWith("{") && replacement.endsWith("}");
            if (isProp) {
                var propertyPart = replacement.slice(1, -1);
                var propertyName = substringBefore(propertyPart, "=");
                var propertyValue = substringAfter(propertyPart, "=");
                if (propertyValue === "noopFunc") {
                    result = {};
                    result[propertyName] = noopFunc;
                }
            }
        }
        return result;
    }
    function createDecoy(args) {
        var UrlPropNameOf = function(UrlPropNameOf) {
            UrlPropNameOf["Object"] = "data";
            UrlPropNameOf["Iframe"] = "src";
            return UrlPropNameOf;
        }({});
        var {replacement: replacement, url: url, delay: delay} = args;
        var tag;
        if (replacement === "obj") {
            tag = "object";
        } else {
            tag = "iframe";
        }
        var decoy = document.createElement(tag);
        if (decoy instanceof HTMLObjectElement) {
            decoy[UrlPropNameOf.Object] = url;
        } else if (decoy instanceof HTMLIFrameElement) {
            decoy[UrlPropNameOf.Iframe] = url;
        }
        decoy.style.setProperty("height", "1px", "important");
        decoy.style.setProperty("position", "fixed", "important");
        decoy.style.setProperty("top", "-1px", "important");
        decoy.style.setProperty("width", "1px", "important");
        document.body.appendChild(decoy);
        setTimeout((function() {
            return decoy.remove();
        }), delay * 1e3);
        return decoy;
    }
    function getPreventGetter(nativeGetter) {
        var preventGetter = function preventGetter(target, prop) {
            if (prop && prop === "closed") {
                return false;
            }
            if (typeof nativeGetter === "function") {
                return noopFunc;
            }
            return prop && target[prop];
        };
        return preventGetter;
    }
    function noopNull() {
        return null;
    }
    function logMessage(source, message) {
        var forced = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
        var convertMessageToString = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
        var {name: name, verbose: verbose} = source;
        if (!forced && !verbose) {
            return;
        }
        var nativeConsole = console.log;
        if (!convertMessageToString) {
            nativeConsole(`${name}:`, message);
            return;
        }
        nativeConsole(`${name}: ${message}`);
    }
    function noopFunc() {}
    function trueFunc() {
        return true;
    }
    function substringBefore(str, separator) {
        if (!str || !separator) {
            return str;
        }
        var index = str.indexOf(separator);
        return index < 0 ? str : str.substring(0, index);
    }
    function substringAfter(str, separator) {
        if (!str) {
            return str;
        }
        var index = str.indexOf(separator);
        return index < 0 ? "" : str.substring(index + separator.length);
    }
    var updatedArgs = args ? [].concat(source).concat(args) : [ source ];
    try {
        preventWindowOpen.apply(this, updatedArgs);
        if (source.uniqueId) {
            Object.defineProperty(Window.prototype.toString, uniqueIdentifier, {
                value: flag,
                enumerable: false,
                writable: false,
                configurable: false
            });
        }
    } catch (e) {
        console.log(e);
    }
}

function preventXHR(source, args) {
    var flag = "done";
    var uniqueIdentifier = source.uniqueId + source.name + "_" + (Array.isArray(args) ? args.join("_") : "");
    if (source.uniqueId) {
        if (Window.prototype.toString[uniqueIdentifier] === flag) {
            return;
        }
    }
    function preventXHR(source, propsToMatch, customResponseText) {
        if (typeof Proxy === "undefined") {
            return;
        }
        var nativeOpen = window.XMLHttpRequest.prototype.open;
        var nativeGetResponseHeader = window.XMLHttpRequest.prototype.getResponseHeader;
        var nativeGetAllResponseHeaders = window.XMLHttpRequest.prototype.getAllResponseHeaders;
        var xhrData;
        var modifiedResponse = "";
        var modifiedResponseText = "";
        var openWrapper = function openWrapper(target, thisArg, args) {
            xhrData = getXhrData.apply(null, args);
            if (typeof propsToMatch === "undefined") {
                logMessage(source, `xhr( ${objectToString(xhrData)} )`, true);
                hit(source);
            } else if (matchRequestProps(source, propsToMatch, xhrData)) {
                thisArg.shouldBePrevented = true;
                thisArg.xhrData = xhrData;
            }
            if (thisArg.shouldBePrevented) {
                thisArg.collectedHeaders = [];
                var setRequestHeaderWrapper = function setRequestHeaderWrapper(target, thisArg, args) {
                    thisArg.collectedHeaders.push(args);
                    return Reflect.apply(target, thisArg, args);
                };
                var setRequestHeaderHandler = {
                    apply: setRequestHeaderWrapper
                };
                thisArg.setRequestHeader = new Proxy(thisArg.setRequestHeader, setRequestHeaderHandler);
            }
            return Reflect.apply(target, thisArg, args);
        };
        var sendWrapper = function sendWrapper(target, thisArg, args) {
            if (!thisArg.shouldBePrevented) {
                return Reflect.apply(target, thisArg, args);
            }
            if (thisArg.responseType === "blob") {
                modifiedResponse = new Blob;
            }
            if (thisArg.responseType === "arraybuffer") {
                modifiedResponse = new ArrayBuffer;
            }
            if (customResponseText) {
                var randomText = generateRandomResponse(customResponseText);
                if (randomText) {
                    modifiedResponse = randomText;
                    modifiedResponseText = randomText;
                } else {
                    logMessage(source, `Invalid randomize parameter: '${customResponseText}'`);
                }
            }
            var forgedRequest = new XMLHttpRequest;
            var transitionReadyState = function transitionReadyState(state) {
                if (state === 4) {
                    var {responseURL: responseURL, responseXML: responseXML} = forgedRequest;
                    Object.defineProperties(thisArg, {
                        readyState: {
                            value: 4,
                            writable: false
                        },
                        statusText: {
                            value: "OK",
                            writable: false
                        },
                        responseURL: {
                            value: responseURL || thisArg.xhrData.url,
                            writable: false
                        },
                        responseXML: {
                            value: responseXML,
                            writable: false
                        },
                        status: {
                            value: 200,
                            writable: false
                        },
                        response: {
                            value: modifiedResponse,
                            writable: false
                        },
                        responseText: {
                            value: modifiedResponseText,
                            writable: false
                        }
                    });
                    hit(source);
                } else {
                    Object.defineProperty(thisArg, "readyState", {
                        value: state,
                        writable: true,
                        configurable: true
                    });
                }
                var stateEvent = new Event("readystatechange");
                thisArg.dispatchEvent(stateEvent);
            };
            forgedRequest.addEventListener("readystatechange", (function() {
                transitionReadyState(1);
                var loadStartEvent = new ProgressEvent("loadstart");
                thisArg.dispatchEvent(loadStartEvent);
                transitionReadyState(2);
                transitionReadyState(3);
                var progressEvent = new ProgressEvent("progress");
                thisArg.dispatchEvent(progressEvent);
                transitionReadyState(4);
            }));
            setTimeout((function() {
                var loadEvent = new ProgressEvent("load");
                thisArg.dispatchEvent(loadEvent);
                var loadEndEvent = new ProgressEvent("loadend");
                thisArg.dispatchEvent(loadEndEvent);
            }), 1);
            nativeOpen.apply(forgedRequest, [ thisArg.xhrData.method, thisArg.xhrData.url ]);
            thisArg.collectedHeaders.forEach((function(header) {
                var name = header[0];
                var value = header[1];
                forgedRequest.setRequestHeader(name, value);
            }));
            return undefined;
        };
        var getHeaderWrapper = function getHeaderWrapper(target, thisArg, args) {
            if (!thisArg.shouldBePrevented) {
                return nativeGetResponseHeader.apply(thisArg, args);
            }
            if (!thisArg.collectedHeaders.length) {
                return null;
            }
            var searchHeaderName = args[0].toLowerCase();
            var matchedHeader = thisArg.collectedHeaders.find((function(header) {
                var headerName = header[0].toLowerCase();
                return headerName === searchHeaderName;
            }));
            return matchedHeader ? matchedHeader[1] : null;
        };
        var getAllHeadersWrapper = function getAllHeadersWrapper(target, thisArg) {
            if (!thisArg.shouldBePrevented) {
                return nativeGetAllResponseHeaders.call(thisArg);
            }
            if (!thisArg.collectedHeaders.length) {
                return "";
            }
            var allHeadersStr = thisArg.collectedHeaders.map((function(header) {
                var headerName = header[0];
                var headerValue = header[1];
                return `${headerName.toLowerCase()}: ${headerValue}`;
            })).join("\r\n");
            return allHeadersStr;
        };
        var openHandler = {
            apply: openWrapper
        };
        var sendHandler = {
            apply: sendWrapper
        };
        var getHeaderHandler = {
            apply: getHeaderWrapper
        };
        var getAllHeadersHandler = {
            apply: getAllHeadersWrapper
        };
        XMLHttpRequest.prototype.open = new Proxy(XMLHttpRequest.prototype.open, openHandler);
        XMLHttpRequest.prototype.send = new Proxy(XMLHttpRequest.prototype.send, sendHandler);
        XMLHttpRequest.prototype.getResponseHeader = new Proxy(XMLHttpRequest.prototype.getResponseHeader, getHeaderHandler);
        XMLHttpRequest.prototype.getAllResponseHeaders = new Proxy(XMLHttpRequest.prototype.getAllResponseHeaders, getAllHeadersHandler);
    }
    function hit(source) {
        var ADGUARD_PREFIX = "[AdGuard]";
        if (!source.verbose) {
            return;
        }
        try {
            var trace = console.trace.bind(console);
            var label = `${ADGUARD_PREFIX} `;
            if (source.engine === "corelibs") {
                label += source.ruleText;
            } else {
                if (source.domainName) {
                    label += `${source.domainName}`;
                }
                if (source.args) {
                    label += `#%#//scriptlet('${source.name}', '${source.args.join("', '")}')`;
                } else {
                    label += `#%#//scriptlet('${source.name}')`;
                }
            }
            if (trace) {
                trace(label);
            }
        } catch (e) {}
        if (typeof window.__debug === "function") {
            window.__debug(source);
        }
    }
    function objectToString(obj) {
        if (!obj || typeof obj !== "object") {
            return String(obj);
        }
        if (isEmptyObject(obj)) {
            return "{}";
        }
        return Object.entries(obj).map((function(pair) {
            var key = pair[0];
            var value = pair[1];
            var recordValueStr = value;
            if (value instanceof Object) {
                recordValueStr = `{ ${objectToString(value)} }`;
            }
            return `${key}:"${recordValueStr}"`;
        })).join(" ");
    }
    function generateRandomResponse(customResponseText) {
        var customResponse = customResponseText;
        if (customResponse === "true") {
            customResponse = Math.random().toString(36).slice(-10);
            return customResponse;
        }
        customResponse = customResponse.replace("length:", "");
        var rangeRegex = /^\d+-\d+$/;
        if (!rangeRegex.test(customResponse)) {
            return null;
        }
        var rangeMin = getNumberFromString(customResponse.split("-")[0]);
        var rangeMax = getNumberFromString(customResponse.split("-")[1]);
        if (!nativeIsFinite(rangeMin) || !nativeIsFinite(rangeMax)) {
            return null;
        }
        if (rangeMin > rangeMax) {
            var temp = rangeMin;
            rangeMin = rangeMax;
            rangeMax = temp;
        }
        var LENGTH_RANGE_LIMIT = 500 * 1e3;
        if (rangeMax > LENGTH_RANGE_LIMIT) {
            return null;
        }
        var length = getRandomIntInclusive(rangeMin, rangeMax);
        customResponse = getRandomStrByLength(length);
        return customResponse;
    }
    function matchRequestProps(source, propsToMatch, requestData) {
        if (propsToMatch === "" || propsToMatch === "*") {
            return true;
        }
        var isMatched;
        var parsedData = parseMatchProps(propsToMatch);
        if (!isValidParsedData(parsedData)) {
            logMessage(source, `Invalid parameter: ${propsToMatch}`);
            isMatched = false;
        } else {
            var matchData = getMatchPropsData(parsedData);
            var matchKeys = Object.keys(matchData);
            isMatched = matchKeys.every((function(matchKey) {
                var matchValue = matchData[matchKey];
                var dataValue = requestData[matchKey];
                return Object.prototype.hasOwnProperty.call(requestData, matchKey) && typeof dataValue === "string" && (matchValue === null || matchValue === void 0 ? void 0 : matchValue.test(dataValue));
            }));
        }
        return isMatched;
    }
    function getXhrData(method, url, async, user, password) {
        return {
            method: method,
            url: url,
            async: async,
            user: user,
            password: password
        };
    }
    function logMessage(source, message) {
        var forced = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
        var convertMessageToString = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
        var {name: name, verbose: verbose} = source;
        if (!forced && !verbose) {
            return;
        }
        var nativeConsole = console.log;
        if (!convertMessageToString) {
            nativeConsole(`${name}:`, message);
            return;
        }
        nativeConsole(`${name}: ${message}`);
    }
    function toRegExp(rawInput) {
        var input = rawInput || "";
        var DEFAULT_VALUE = ".?";
        var FORWARD_SLASH = "/";
        if (input === "") {
            return new RegExp(DEFAULT_VALUE);
        }
        var delimiterIndex = input.lastIndexOf(FORWARD_SLASH);
        var flagsPart = input.substring(delimiterIndex + 1);
        var regExpPart = input.substring(0, delimiterIndex + 1);
        var isValidRegExpFlag = function isValidRegExpFlag(flag) {
            if (!flag) {
                return false;
            }
            try {
                new RegExp("", flag);
                return true;
            } catch (ex) {
                return false;
            }
        };
        var getRegExpFlags = function getRegExpFlags(regExpStr, flagsStr) {
            if (regExpStr.startsWith(FORWARD_SLASH) && regExpStr.endsWith(FORWARD_SLASH) && !regExpStr.endsWith("\\/") && isValidRegExpFlag(flagsStr)) {
                return flagsStr;
            }
            return "";
        };
        var flags = getRegExpFlags(regExpPart, flagsPart);
        if (input.startsWith(FORWARD_SLASH) && input.endsWith(FORWARD_SLASH) || flags) {
            var regExpInput = flags ? regExpPart : input;
            return new RegExp(regExpInput.slice(1, -1), flags);
        }
        var escaped = input.replace(/\\'/g, "'").replace(/\\"/g, '"').replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
        return new RegExp(escaped);
    }
    function isValidStrPattern(input) {
        var FORWARD_SLASH = "/";
        var str = escapeRegExp(input);
        if (input[0] === FORWARD_SLASH && input[input.length - 1] === FORWARD_SLASH) {
            str = input.slice(1, -1);
        }
        var isValid;
        try {
            isValid = new RegExp(str);
            isValid = true;
        } catch (e) {
            isValid = false;
        }
        return isValid;
    }
    function escapeRegExp(str) {
        return str.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
    }
    function isEmptyObject(obj) {
        return Object.keys(obj).length === 0 && !obj.prototype;
    }
    function getNumberFromString(rawString) {
        var parsedDelay = parseInt(rawString, 10);
        var validDelay = nativeIsNaN(parsedDelay) ? null : parsedDelay;
        return validDelay;
    }
    function nativeIsFinite(num) {
        var native = Number.isFinite || window.isFinite;
        return native(num);
    }
    function nativeIsNaN(num) {
        var native = Number.isNaN || window.isNaN;
        return native(num);
    }
    function parseMatchProps(propsToMatchStr) {
        var PROPS_DIVIDER = " ";
        var PAIRS_MARKER = ":";
        var isRequestProp = function isRequestProp(prop) {
            return getRequestProps().includes(prop);
        };
        var propsObj = {};
        var props = propsToMatchStr.split(PROPS_DIVIDER);
        props.forEach((function(prop) {
            var dividerInd = prop.indexOf(PAIRS_MARKER);
            var key = prop.slice(0, dividerInd);
            if (isRequestProp(key)) {
                var value = prop.slice(dividerInd + 1);
                propsObj[key] = value;
            } else {
                propsObj.url = prop;
            }
        }));
        return propsObj;
    }
    function isValidParsedData(data) {
        return Object.values(data).every((function(value) {
            return isValidStrPattern(value);
        }));
    }
    function getMatchPropsData(data) {
        var matchData = {};
        var dataKeys = Object.keys(data);
        dataKeys.forEach((function(key) {
            matchData[key] = toRegExp(data[key]);
        }));
        return matchData;
    }
    function getRequestProps() {
        return [ "url", "method", "headers", "body", "credentials", "cache", "redirect", "referrer", "referrerPolicy", "integrity", "keepalive", "signal", "mode" ];
    }
    function getRandomIntInclusive(min, max) {
        min = Math.ceil(min);
        max = Math.floor(max);
        return Math.floor(Math.random() * (max - min + 1) + min);
    }
    function getRandomStrByLength(length) {
        var result = "";
        var characters = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789!@#$%^&*()_+=~";
        var charactersLength = characters.length;
        for (var i = 0; i < length; i += 1) {
            result += characters.charAt(Math.floor(Math.random() * charactersLength));
        }
        return result;
    }
    var updatedArgs = args ? [].concat(source).concat(args) : [ source ];
    try {
        preventXHR.apply(this, updatedArgs);
        if (source.uniqueId) {
            Object.defineProperty(Window.prototype.toString, uniqueIdentifier, {
                value: flag,
                enumerable: false,
                writable: false,
                configurable: false
            });
        }
    } catch (e) {
        console.log(e);
    }
}

function removeAttr(source, args) {
    var flag = "done";
    var uniqueIdentifier = source.uniqueId + source.name + "_" + (Array.isArray(args) ? args.join("_") : "");
    if (source.uniqueId) {
        if (Window.prototype.toString[uniqueIdentifier] === flag) {
            return;
        }
    }
    function removeAttr(source, attrs, selector) {
        var applying = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : "asap stay";
        if (!attrs) {
            return;
        }
        attrs = attrs.split(/\s*\|\s*/);
        if (!selector) {
            selector = `[${attrs.join("],[")}]`;
        }
        var rmattr = function rmattr() {
            var nodes = [];
            try {
                nodes = [].slice.call(document.querySelectorAll(selector));
            } catch (e) {
                logMessage(source, `Invalid selector arg: '${selector}'`);
            }
            var removed = false;
            nodes.forEach((function(node) {
                attrs.forEach((function(attr) {
                    node.removeAttribute(attr);
                    removed = true;
                }));
            }));
            if (removed) {
                hit(source);
            }
        };
        var flags = parseFlags(applying);
        var run = function run() {
            rmattr();
            if (!flags.hasFlag(flags.STAY)) {
                return;
            }
            observeDOMChanges(rmattr, true);
        };
        if (flags.hasFlag(flags.ASAP)) {
            if (document.readyState === "loading") {
                window.addEventListener("DOMContentLoaded", rmattr, {
                    once: true
                });
            } else {
                rmattr();
            }
        }
        if (document.readyState !== "complete" && flags.hasFlag(flags.COMPLETE)) {
            window.addEventListener("load", run, {
                once: true
            });
        } else if (flags.hasFlag(flags.STAY)) {
            if (!applying.includes(" ")) {
                rmattr();
            }
            observeDOMChanges(rmattr, true);
        }
    }
    function hit(source) {
        var ADGUARD_PREFIX = "[AdGuard]";
        if (!source.verbose) {
            return;
        }
        try {
            var trace = console.trace.bind(console);
            var label = `${ADGUARD_PREFIX} `;
            if (source.engine === "corelibs") {
                label += source.ruleText;
            } else {
                if (source.domainName) {
                    label += `${source.domainName}`;
                }
                if (source.args) {
                    label += `#%#//scriptlet('${source.name}', '${source.args.join("', '")}')`;
                } else {
                    label += `#%#//scriptlet('${source.name}')`;
                }
            }
            if (trace) {
                trace(label);
            }
        } catch (e) {}
        if (typeof window.__debug === "function") {
            window.__debug(source);
        }
    }
    function observeDOMChanges(callback) {
        var observeAttrs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
        var attrsToObserve = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];
        var THROTTLE_DELAY_MS = 20;
        var observer = new MutationObserver(throttle(callbackWrapper, THROTTLE_DELAY_MS));
        var connect = function connect() {
            if (attrsToObserve.length > 0) {
                observer.observe(document.documentElement, {
                    childList: true,
                    subtree: true,
                    attributes: observeAttrs,
                    attributeFilter: attrsToObserve
                });
            } else {
                observer.observe(document.documentElement, {
                    childList: true,
                    subtree: true,
                    attributes: observeAttrs
                });
            }
        };
        var disconnect = function disconnect() {
            observer.disconnect();
        };
        function callbackWrapper() {
            disconnect();
            callback();
            connect();
        }
        connect();
    }
    function parseFlags(flags) {
        var FLAGS_DIVIDER = " ";
        var ASAP_FLAG = "asap";
        var COMPLETE_FLAG = "complete";
        var STAY_FLAG = "stay";
        var VALID_FLAGS = new Set([ ASAP_FLAG, COMPLETE_FLAG, STAY_FLAG ]);
        var passedFlags = new Set(flags.trim().split(FLAGS_DIVIDER).filter((function(flag) {
            return VALID_FLAGS.has(flag);
        })));
        return {
            ASAP: ASAP_FLAG,
            COMPLETE: COMPLETE_FLAG,
            STAY: STAY_FLAG,
            hasFlag: function hasFlag(flag) {
                return passedFlags.has(flag);
            }
        };
    }
    function logMessage(source, message) {
        var forced = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
        var convertMessageToString = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
        var {name: name, verbose: verbose} = source;
        if (!forced && !verbose) {
            return;
        }
        var nativeConsole = console.log;
        if (!convertMessageToString) {
            nativeConsole(`${name}:`, message);
            return;
        }
        nativeConsole(`${name}: ${message}`);
    }
    function throttle(cb, delay) {
        var wait = false;
        var savedArgs;
        var _wrapper = function wrapper() {
            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                args[_key] = arguments[_key];
            }
            if (wait) {
                savedArgs = args;
                return;
            }
            cb(...args);
            wait = true;
            setTimeout((function() {
                wait = false;
                if (savedArgs) {
                    _wrapper(...savedArgs);
                    savedArgs = null;
                }
            }), delay);
        };
        return _wrapper;
    }
    var updatedArgs = args ? [].concat(source).concat(args) : [ source ];
    try {
        removeAttr.apply(this, updatedArgs);
        if (source.uniqueId) {
            Object.defineProperty(Window.prototype.toString, uniqueIdentifier, {
                value: flag,
                enumerable: false,
                writable: false,
                configurable: false
            });
        }
    } catch (e) {
        console.log(e);
    }
}

function removeClass(source, args) {
    var flag = "done";
    var uniqueIdentifier = source.uniqueId + source.name + "_" + (Array.isArray(args) ? args.join("_") : "");
    if (source.uniqueId) {
        if (Window.prototype.toString[uniqueIdentifier] === flag) {
            return;
        }
    }
    function removeClass(source, classNames, selector) {
        var applying = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : "asap stay";
        if (!classNames) {
            return;
        }
        classNames = classNames.split(/\s*\|\s*/);
        var selectors = [];
        if (!selector) {
            selectors = classNames.map((function(className) {
                return `.${className}`;
            }));
        }
        var removeClassHandler = function removeClassHandler() {
            var nodes = new Set;
            if (selector) {
                var foundNodes = [];
                try {
                    foundNodes = [].slice.call(document.querySelectorAll(selector));
                } catch (e) {
                    logMessage(source, `Invalid selector arg: '${selector}'`);
                }
                foundNodes.forEach((function(n) {
                    return nodes.add(n);
                }));
            } else if (selectors.length > 0) {
                selectors.forEach((function(s) {
                    var elements = document.querySelectorAll(s);
                    for (var i = 0; i < elements.length; i += 1) {
                        var element = elements[i];
                        nodes.add(element);
                    }
                }));
            }
            var removed = false;
            nodes.forEach((function(node) {
                classNames.forEach((function(className) {
                    if (node.classList.contains(className)) {
                        node.classList.remove(className);
                        removed = true;
                    }
                }));
            }));
            if (removed) {
                hit(source);
            }
        };
        var CLASS_ATTR_NAME = [ "class" ];
        var flags = parseFlags(applying);
        var run = function run() {
            removeClassHandler();
            if (!flags.hasFlag(flags.STAY)) {
                return;
            }
            observeDOMChanges(removeClassHandler, true, CLASS_ATTR_NAME);
        };
        if (flags.hasFlag(flags.ASAP)) {
            if (document.readyState === "loading") {
                window.addEventListener("DOMContentLoaded", removeClassHandler, {
                    once: true
                });
            } else {
                removeClassHandler();
            }
        }
        if (document.readyState !== "complete" && flags.hasFlag(flags.COMPLETE)) {
            window.addEventListener("load", run, {
                once: true
            });
        } else if (flags.hasFlag(flags.STAY)) {
            if (!applying.includes(" ")) {
                removeClassHandler();
            }
            observeDOMChanges(removeClassHandler, true, CLASS_ATTR_NAME);
        }
    }
    function hit(source) {
        var ADGUARD_PREFIX = "[AdGuard]";
        if (!source.verbose) {
            return;
        }
        try {
            var trace = console.trace.bind(console);
            var label = `${ADGUARD_PREFIX} `;
            if (source.engine === "corelibs") {
                label += source.ruleText;
            } else {
                if (source.domainName) {
                    label += `${source.domainName}`;
                }
                if (source.args) {
                    label += `#%#//scriptlet('${source.name}', '${source.args.join("', '")}')`;
                } else {
                    label += `#%#//scriptlet('${source.name}')`;
                }
            }
            if (trace) {
                trace(label);
            }
        } catch (e) {}
        if (typeof window.__debug === "function") {
            window.__debug(source);
        }
    }
    function logMessage(source, message) {
        var forced = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
        var convertMessageToString = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
        var {name: name, verbose: verbose} = source;
        if (!forced && !verbose) {
            return;
        }
        var nativeConsole = console.log;
        if (!convertMessageToString) {
            nativeConsole(`${name}:`, message);
            return;
        }
        nativeConsole(`${name}: ${message}`);
    }
    function observeDOMChanges(callback) {
        var observeAttrs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
        var attrsToObserve = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];
        var THROTTLE_DELAY_MS = 20;
        var observer = new MutationObserver(throttle(callbackWrapper, THROTTLE_DELAY_MS));
        var connect = function connect() {
            if (attrsToObserve.length > 0) {
                observer.observe(document.documentElement, {
                    childList: true,
                    subtree: true,
                    attributes: observeAttrs,
                    attributeFilter: attrsToObserve
                });
            } else {
                observer.observe(document.documentElement, {
                    childList: true,
                    subtree: true,
                    attributes: observeAttrs
                });
            }
        };
        var disconnect = function disconnect() {
            observer.disconnect();
        };
        function callbackWrapper() {
            disconnect();
            callback();
            connect();
        }
        connect();
    }
    function parseFlags(flags) {
        var FLAGS_DIVIDER = " ";
        var ASAP_FLAG = "asap";
        var COMPLETE_FLAG = "complete";
        var STAY_FLAG = "stay";
        var VALID_FLAGS = new Set([ ASAP_FLAG, COMPLETE_FLAG, STAY_FLAG ]);
        var passedFlags = new Set(flags.trim().split(FLAGS_DIVIDER).filter((function(flag) {
            return VALID_FLAGS.has(flag);
        })));
        return {
            ASAP: ASAP_FLAG,
            COMPLETE: COMPLETE_FLAG,
            STAY: STAY_FLAG,
            hasFlag: function hasFlag(flag) {
                return passedFlags.has(flag);
            }
        };
    }
    function throttle(cb, delay) {
        var wait = false;
        var savedArgs;
        var _wrapper = function wrapper() {
            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                args[_key] = arguments[_key];
            }
            if (wait) {
                savedArgs = args;
                return;
            }
            cb(...args);
            wait = true;
            setTimeout((function() {
                wait = false;
                if (savedArgs) {
                    _wrapper(...savedArgs);
                    savedArgs = null;
                }
            }), delay);
        };
        return _wrapper;
    }
    var updatedArgs = args ? [].concat(source).concat(args) : [ source ];
    try {
        removeClass.apply(this, updatedArgs);
        if (source.uniqueId) {
            Object.defineProperty(Window.prototype.toString, uniqueIdentifier, {
                value: flag,
                enumerable: false,
                writable: false,
                configurable: false
            });
        }
    } catch (e) {
        console.log(e);
    }
}

function removeCookie(source, args) {
    var flag = "done";
    var uniqueIdentifier = source.uniqueId + source.name + "_" + (Array.isArray(args) ? args.join("_") : "");
    if (source.uniqueId) {
        if (Window.prototype.toString[uniqueIdentifier] === flag) {
            return;
        }
    }
    function removeCookie(source, match) {
        var matchRegexp = toRegExp(match);
        var removeCookieFromHost = function removeCookieFromHost(cookieName, hostName) {
            var cookieSpec = `${cookieName}=`;
            var domain1 = `; domain=${hostName}`;
            var domain2 = `; domain=.${hostName}`;
            var path = "; path=/";
            var expiration = "; expires=Thu, 01 Jan 1970 00:00:00 GMT";
            document.cookie = cookieSpec + expiration;
            document.cookie = cookieSpec + domain1 + expiration;
            document.cookie = cookieSpec + domain2 + expiration;
            document.cookie = cookieSpec + path + expiration;
            document.cookie = cookieSpec + domain1 + path + expiration;
            document.cookie = cookieSpec + domain2 + path + expiration;
            hit(source);
        };
        var rmCookie = function rmCookie() {
            document.cookie.split(";").forEach((function(cookieStr) {
                var pos = cookieStr.indexOf("=");
                if (pos === -1) {
                    return;
                }
                var cookieName = cookieStr.slice(0, pos).trim();
                if (!matchRegexp.test(cookieName)) {
                    return;
                }
                var hostParts = document.location.hostname.split(".");
                for (var i = 0; i <= hostParts.length - 1; i += 1) {
                    var hostName = hostParts.slice(i).join(".");
                    if (hostName) {
                        removeCookieFromHost(cookieName, hostName);
                    }
                }
            }));
        };
        rmCookie();
        window.addEventListener("beforeunload", rmCookie);
    }
    function toRegExp(rawInput) {
        var input = rawInput || "";
        var DEFAULT_VALUE = ".?";
        var FORWARD_SLASH = "/";
        if (input === "") {
            return new RegExp(DEFAULT_VALUE);
        }
        var delimiterIndex = input.lastIndexOf(FORWARD_SLASH);
        var flagsPart = input.substring(delimiterIndex + 1);
        var regExpPart = input.substring(0, delimiterIndex + 1);
        var isValidRegExpFlag = function isValidRegExpFlag(flag) {
            if (!flag) {
                return false;
            }
            try {
                new RegExp("", flag);
                return true;
            } catch (ex) {
                return false;
            }
        };
        var getRegExpFlags = function getRegExpFlags(regExpStr, flagsStr) {
            if (regExpStr.startsWith(FORWARD_SLASH) && regExpStr.endsWith(FORWARD_SLASH) && !regExpStr.endsWith("\\/") && isValidRegExpFlag(flagsStr)) {
                return flagsStr;
            }
            return "";
        };
        var flags = getRegExpFlags(regExpPart, flagsPart);
        if (input.startsWith(FORWARD_SLASH) && input.endsWith(FORWARD_SLASH) || flags) {
            var regExpInput = flags ? regExpPart : input;
            return new RegExp(regExpInput.slice(1, -1), flags);
        }
        var escaped = input.replace(/\\'/g, "'").replace(/\\"/g, '"').replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
        return new RegExp(escaped);
    }
    function hit(source) {
        var ADGUARD_PREFIX = "[AdGuard]";
        if (!source.verbose) {
            return;
        }
        try {
            var trace = console.trace.bind(console);
            var label = `${ADGUARD_PREFIX} `;
            if (source.engine === "corelibs") {
                label += source.ruleText;
            } else {
                if (source.domainName) {
                    label += `${source.domainName}`;
                }
                if (source.args) {
                    label += `#%#//scriptlet('${source.name}', '${source.args.join("', '")}')`;
                } else {
                    label += `#%#//scriptlet('${source.name}')`;
                }
            }
            if (trace) {
                trace(label);
            }
        } catch (e) {}
        if (typeof window.__debug === "function") {
            window.__debug(source);
        }
    }
    var updatedArgs = args ? [].concat(source).concat(args) : [ source ];
    try {
        removeCookie.apply(this, updatedArgs);
        if (source.uniqueId) {
            Object.defineProperty(Window.prototype.toString, uniqueIdentifier, {
                value: flag,
                enumerable: false,
                writable: false,
                configurable: false
            });
        }
    } catch (e) {
        console.log(e);
    }
}

function removeInShadowDom(source, args) {
    var flag = "done";
    var uniqueIdentifier = source.uniqueId + source.name + "_" + (Array.isArray(args) ? args.join("_") : "");
    if (source.uniqueId) {
        if (Window.prototype.toString[uniqueIdentifier] === flag) {
            return;
        }
    }
    function removeInShadowDom(source, selector, baseSelector) {
        if (!Element.prototype.attachShadow) {
            return;
        }
        var removeElement = function removeElement(targetElement) {
            targetElement.remove();
        };
        var removeHandler = function removeHandler() {
            var hostElements = !baseSelector ? findHostElements(document.documentElement) : document.querySelectorAll(baseSelector);
            var _loop = function _loop() {
                var isRemoved = false;
                var {targets: targets, innerHosts: innerHosts} = pierceShadowDom(selector, hostElements);
                targets.forEach((function(targetEl) {
                    removeElement(targetEl);
                    isRemoved = true;
                }));
                if (isRemoved) {
                    hit(source);
                }
                hostElements = innerHosts;
            };
            while (hostElements.length !== 0) {
                _loop();
            }
        };
        removeHandler();
        observeDOMChanges(removeHandler, true);
    }
    function hit(source) {
        var ADGUARD_PREFIX = "[AdGuard]";
        if (!source.verbose) {
            return;
        }
        try {
            var trace = console.trace.bind(console);
            var label = `${ADGUARD_PREFIX} `;
            if (source.engine === "corelibs") {
                label += source.ruleText;
            } else {
                if (source.domainName) {
                    label += `${source.domainName}`;
                }
                if (source.args) {
                    label += `#%#//scriptlet('${source.name}', '${source.args.join("', '")}')`;
                } else {
                    label += `#%#//scriptlet('${source.name}')`;
                }
            }
            if (trace) {
                trace(label);
            }
        } catch (e) {}
        if (typeof window.__debug === "function") {
            window.__debug(source);
        }
    }
    function observeDOMChanges(callback) {
        var observeAttrs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
        var attrsToObserve = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];
        var THROTTLE_DELAY_MS = 20;
        var observer = new MutationObserver(throttle(callbackWrapper, THROTTLE_DELAY_MS));
        var connect = function connect() {
            if (attrsToObserve.length > 0) {
                observer.observe(document.documentElement, {
                    childList: true,
                    subtree: true,
                    attributes: observeAttrs,
                    attributeFilter: attrsToObserve
                });
            } else {
                observer.observe(document.documentElement, {
                    childList: true,
                    subtree: true,
                    attributes: observeAttrs
                });
            }
        };
        var disconnect = function disconnect() {
            observer.disconnect();
        };
        function callbackWrapper() {
            disconnect();
            callback();
            connect();
        }
        connect();
    }
    function findHostElements(rootElement) {
        var hosts = [];
        if (rootElement) {
            var domElems = rootElement.querySelectorAll("*");
            domElems.forEach((function(el) {
                if (el.shadowRoot) {
                    hosts.push(el);
                }
            }));
        }
        return hosts;
    }
    function pierceShadowDom(selector, hostElements) {
        var targets = [];
        var innerHostsAcc = [];
        hostElements.forEach((function(host) {
            var simpleElems = host.querySelectorAll(selector);
            targets = targets.concat([].slice.call(simpleElems));
            var shadowRootElem = host.shadowRoot;
            var shadowChildren = shadowRootElem.querySelectorAll(selector);
            targets = targets.concat([].slice.call(shadowChildren));
            innerHostsAcc.push(findHostElements(shadowRootElem));
        }));
        var innerHosts = flatten(innerHostsAcc);
        return {
            targets: targets,
            innerHosts: innerHosts
        };
    }
    function flatten(input) {
        var stack = [];
        input.forEach((function(el) {
            return stack.push(el);
        }));
        var res = [];
        while (stack.length) {
            var next = stack.pop();
            if (Array.isArray(next)) {
                next.forEach((function(el) {
                    return stack.push(el);
                }));
            } else {
                res.push(next);
            }
        }
        return res.reverse();
    }
    function throttle(cb, delay) {
        var wait = false;
        var savedArgs;
        var _wrapper = function wrapper() {
            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                args[_key] = arguments[_key];
            }
            if (wait) {
                savedArgs = args;
                return;
            }
            cb(...args);
            wait = true;
            setTimeout((function() {
                wait = false;
                if (savedArgs) {
                    _wrapper(...savedArgs);
                    savedArgs = null;
                }
            }), delay);
        };
        return _wrapper;
    }
    var updatedArgs = args ? [].concat(source).concat(args) : [ source ];
    try {
        removeInShadowDom.apply(this, updatedArgs);
        if (source.uniqueId) {
            Object.defineProperty(Window.prototype.toString, uniqueIdentifier, {
                value: flag,
                enumerable: false,
                writable: false,
                configurable: false
            });
        }
    } catch (e) {
        console.log(e);
    }
}

function removeNodeText(source, args) {
    var flag = "done";
    var uniqueIdentifier = source.uniqueId + source.name + "_" + (Array.isArray(args) ? args.join("_") : "");
    if (source.uniqueId) {
        if (Window.prototype.toString[uniqueIdentifier] === flag) {
            return;
        }
    }
    function removeNodeText(source, nodeName, textMatch, parentSelector) {
        var {selector: selector, nodeNameMatch: nodeNameMatch, textContentMatch: textContentMatch} = parseNodeTextParams(nodeName, textMatch);
        var handleNodes = function handleNodes(nodes) {
            return nodes.forEach((function(node) {
                var shouldReplace = isTargetNode(node, nodeNameMatch, textContentMatch);
                if (shouldReplace) {
                    var ALL_TEXT_PATTERN = /^[^]*$/;
                    var REPLACEMENT = "";
                    replaceNodeText(source, node, ALL_TEXT_PATTERN, REPLACEMENT);
                }
            }));
        };
        if (document.documentElement) {
            handleExistingNodes(selector, handleNodes, parentSelector);
        }
        observeDocumentWithTimeout((function(mutations) {
            return handleMutations(mutations, handleNodes, selector, parentSelector);
        }));
    }
    function observeDocumentWithTimeout(callback) {
        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {
            subtree: true,
            childList: true
        };
        var timeout = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1e4;
        var documentObserver = new MutationObserver((function(mutations, observer) {
            observer.disconnect();
            callback(mutations, observer);
            observer.observe(document.documentElement, options);
        }));
        documentObserver.observe(document.documentElement, options);
        if (typeof timeout === "number") {
            setTimeout((function() {
                return documentObserver.disconnect();
            }), timeout);
        }
    }
    function handleExistingNodes(selector, handler, parentSelector) {
        var processNodes = function processNodes(parent) {
            if (selector === "#text") {
                var textNodes = nodeListToArray(parent.childNodes).filter((function(node) {
                    return node.nodeType === Node.TEXT_NODE;
                }));
                handler(textNodes);
            } else {
                var _nodes = nodeListToArray(parent.querySelectorAll(selector));
                handler(_nodes);
            }
        };
        var parents = parentSelector ? document.querySelectorAll(parentSelector) : [ document ];
        parents.forEach((function(parent) {
            return processNodes(parent);
        }));
    }
    function handleMutations(mutations, handler, selector, parentSelector) {
        var addedNodes = getAddedNodes(mutations);
        if (selector && parentSelector) {
            addedNodes.forEach((function() {
                handleExistingNodes(selector, handler, parentSelector);
            }));
        } else {
            handler(addedNodes);
        }
    }
    function replaceNodeText(source, node, pattern, replacement) {
        var {textContent: textContent} = node;
        if (textContent) {
            if (node.nodeName === "SCRIPT" && window.trustedTypes && window.trustedTypes.createPolicy) {
                var policy = window.trustedTypes.createPolicy("AGPolicy", {
                    createScript: function createScript(string) {
                        return string;
                    }
                });
                var modifiedText = textContent.replace(pattern, replacement);
                var trustedReplacement = policy.createScript(modifiedText);
                node.textContent = trustedReplacement;
            } else {
                node.textContent = textContent.replace(pattern, replacement);
            }
            hit(source);
        }
    }
    function isTargetNode(node, nodeNameMatch, textContentMatch) {
        var {nodeName: nodeName, textContent: textContent} = node;
        var nodeNameLowerCase = nodeName.toLowerCase();
        return textContent !== null && textContent !== "" && (nodeNameMatch instanceof RegExp ? nodeNameMatch.test(nodeNameLowerCase) : nodeNameMatch === nodeNameLowerCase) && (textContentMatch instanceof RegExp ? textContentMatch.test(textContent) : textContent.includes(textContentMatch));
    }
    function parseNodeTextParams(nodeName, textMatch) {
        var pattern = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
        var REGEXP_START_MARKER = "/";
        var isStringNameMatch = !(nodeName.startsWith(REGEXP_START_MARKER) && nodeName.endsWith(REGEXP_START_MARKER));
        var selector = isStringNameMatch ? nodeName : "*";
        var nodeNameMatch = isStringNameMatch ? nodeName : toRegExp(nodeName);
        var textContentMatch = !textMatch.startsWith(REGEXP_START_MARKER) ? textMatch : toRegExp(textMatch);
        var patternMatch;
        if (pattern) {
            patternMatch = !pattern.startsWith(REGEXP_START_MARKER) ? pattern : toRegExp(pattern);
        }
        return {
            selector: selector,
            nodeNameMatch: nodeNameMatch,
            textContentMatch: textContentMatch,
            patternMatch: patternMatch
        };
    }
    function hit(source) {
        var ADGUARD_PREFIX = "[AdGuard]";
        if (!source.verbose) {
            return;
        }
        try {
            var trace = console.trace.bind(console);
            var label = `${ADGUARD_PREFIX} `;
            if (source.engine === "corelibs") {
                label += source.ruleText;
            } else {
                if (source.domainName) {
                    label += `${source.domainName}`;
                }
                if (source.args) {
                    label += `#%#//scriptlet('${source.name}', '${source.args.join("', '")}')`;
                } else {
                    label += `#%#//scriptlet('${source.name}')`;
                }
            }
            if (trace) {
                trace(label);
            }
        } catch (e) {}
        if (typeof window.__debug === "function") {
            window.__debug(source);
        }
    }
    function nodeListToArray(nodeList) {
        var nodes = [];
        for (var i = 0; i < nodeList.length; i += 1) {
            nodes.push(nodeList[i]);
        }
        return nodes;
    }
    function getAddedNodes(mutations) {
        var nodes = [];
        for (var i = 0; i < mutations.length; i += 1) {
            var {addedNodes: addedNodes} = mutations[i];
            for (var j = 0; j < addedNodes.length; j += 1) {
                nodes.push(addedNodes[j]);
            }
        }
        return nodes;
    }
    function toRegExp(rawInput) {
        var input = rawInput || "";
        var DEFAULT_VALUE = ".?";
        var FORWARD_SLASH = "/";
        if (input === "") {
            return new RegExp(DEFAULT_VALUE);
        }
        var delimiterIndex = input.lastIndexOf(FORWARD_SLASH);
        var flagsPart = input.substring(delimiterIndex + 1);
        var regExpPart = input.substring(0, delimiterIndex + 1);
        var isValidRegExpFlag = function isValidRegExpFlag(flag) {
            if (!flag) {
                return false;
            }
            try {
                new RegExp("", flag);
                return true;
            } catch (ex) {
                return false;
            }
        };
        var getRegExpFlags = function getRegExpFlags(regExpStr, flagsStr) {
            if (regExpStr.startsWith(FORWARD_SLASH) && regExpStr.endsWith(FORWARD_SLASH) && !regExpStr.endsWith("\\/") && isValidRegExpFlag(flagsStr)) {
                return flagsStr;
            }
            return "";
        };
        var flags = getRegExpFlags(regExpPart, flagsPart);
        if (input.startsWith(FORWARD_SLASH) && input.endsWith(FORWARD_SLASH) || flags) {
            var regExpInput = flags ? regExpPart : input;
            return new RegExp(regExpInput.slice(1, -1), flags);
        }
        var escaped = input.replace(/\\'/g, "'").replace(/\\"/g, '"').replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
        return new RegExp(escaped);
    }
    var updatedArgs = args ? [].concat(source).concat(args) : [ source ];
    try {
        removeNodeText.apply(this, updatedArgs);
        if (source.uniqueId) {
            Object.defineProperty(Window.prototype.toString, uniqueIdentifier, {
                value: flag,
                enumerable: false,
                writable: false,
                configurable: false
            });
        }
    } catch (e) {
        console.log(e);
    }
}

function setAttr(source, args) {
    var flag = "done";
    var uniqueIdentifier = source.uniqueId + source.name + "_" + (Array.isArray(args) ? args.join("_") : "");
    if (source.uniqueId) {
        if (Window.prototype.toString[uniqueIdentifier] === flag) {
            return;
        }
    }
    function setAttr(source, selector, attr) {
        var value = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : "";
        if (!selector || !attr) {
            return;
        }
        var allowedValues = [ "true", "false" ];
        var shouldCopyValue = value.startsWith("[") && value.endsWith("]");
        var isValidValue = value.length === 0 || !nativeIsNaN(parseInt(value, 10)) && parseInt(value, 10) >= 0 && parseInt(value, 10) <= 32767 || allowedValues.includes(value.toLowerCase());
        if (!shouldCopyValue && !isValidValue) {
            logMessage(source, `Invalid attribute value provided: '${convertTypeToString(value)}'`);
            return;
        }
        var attributeHandler;
        if (shouldCopyValue) {
            attributeHandler = function attributeHandler(elem, attr, value) {
                var valueToCopy = elem.getAttribute(value.slice(1, -1));
                if (valueToCopy === null) {
                    logMessage(source, `No element attribute found to copy value from: ${value}`);
                }
                elem.setAttribute(attr, valueToCopy);
            };
        }
        setAttributeBySelector(source, selector, attr, value, attributeHandler);
        observeDOMChanges((function() {
            return setAttributeBySelector(source, selector, attr, value, attributeHandler);
        }), true);
    }
    function setAttributeBySelector(source, selector, attribute, value) {
        var attributeSetter = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : defaultAttributeSetter;
        var elements;
        try {
            elements = document.querySelectorAll(selector);
        } catch (_unused) {
            logMessage(source, `Failed to find elements matching selector "${selector}"`);
            return;
        }
        if (!elements || elements.length === 0) {
            return;
        }
        try {
            elements.forEach((function(elem) {
                return attributeSetter(elem, attribute, value);
            }));
            hit(source);
        } catch (_unused2) {
            logMessage(source, `Failed to set [${attribute}="${value}"] to each of selected elements.`);
        }
    }
    function observeDOMChanges(callback) {
        var observeAttrs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
        var attrsToObserve = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];
        var THROTTLE_DELAY_MS = 20;
        var observer = new MutationObserver(throttle(callbackWrapper, THROTTLE_DELAY_MS));
        var connect = function connect() {
            if (attrsToObserve.length > 0) {
                observer.observe(document.documentElement, {
                    childList: true,
                    subtree: true,
                    attributes: observeAttrs,
                    attributeFilter: attrsToObserve
                });
            } else {
                observer.observe(document.documentElement, {
                    childList: true,
                    subtree: true,
                    attributes: observeAttrs
                });
            }
        };
        var disconnect = function disconnect() {
            observer.disconnect();
        };
        function callbackWrapper() {
            disconnect();
            callback();
            connect();
        }
        connect();
    }
    function nativeIsNaN(num) {
        var native = Number.isNaN || window.isNaN;
        return native(num);
    }
    function convertTypeToString(value) {
        var output;
        if (typeof value === "undefined") {
            output = "undefined";
        } else if (typeof value === "object") {
            if (value === null) {
                output = "null";
            } else {
                output = objectToString(value);
            }
        } else {
            output = String(value);
        }
        return output;
    }
    function defaultAttributeSetter(elem, attribute, value) {
        return elem.setAttribute(attribute, value);
    }
    function logMessage(source, message) {
        var forced = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
        var convertMessageToString = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
        var {name: name, verbose: verbose} = source;
        if (!forced && !verbose) {
            return;
        }
        var nativeConsole = console.log;
        if (!convertMessageToString) {
            nativeConsole(`${name}:`, message);
            return;
        }
        nativeConsole(`${name}: ${message}`);
    }
    function throttle(cb, delay) {
        var wait = false;
        var savedArgs;
        var _wrapper = function wrapper() {
            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                args[_key] = arguments[_key];
            }
            if (wait) {
                savedArgs = args;
                return;
            }
            cb(...args);
            wait = true;
            setTimeout((function() {
                wait = false;
                if (savedArgs) {
                    _wrapper(...savedArgs);
                    savedArgs = null;
                }
            }), delay);
        };
        return _wrapper;
    }
    function hit(source) {
        var ADGUARD_PREFIX = "[AdGuard]";
        if (!source.verbose) {
            return;
        }
        try {
            var trace = console.trace.bind(console);
            var label = `${ADGUARD_PREFIX} `;
            if (source.engine === "corelibs") {
                label += source.ruleText;
            } else {
                if (source.domainName) {
                    label += `${source.domainName}`;
                }
                if (source.args) {
                    label += `#%#//scriptlet('${source.name}', '${source.args.join("', '")}')`;
                } else {
                    label += `#%#//scriptlet('${source.name}')`;
                }
            }
            if (trace) {
                trace(label);
            }
        } catch (e) {}
        if (typeof window.__debug === "function") {
            window.__debug(source);
        }
    }
    var updatedArgs = args ? [].concat(source).concat(args) : [ source ];
    try {
        setAttr.apply(this, updatedArgs);
        if (source.uniqueId) {
            Object.defineProperty(Window.prototype.toString, uniqueIdentifier, {
                value: flag,
                enumerable: false,
                writable: false,
                configurable: false
            });
        }
    } catch (e) {
        console.log(e);
    }
}

function setConstant(source, args) {
    var flag = "done";
    var uniqueIdentifier = source.uniqueId + source.name + "_" + (Array.isArray(args) ? args.join("_") : "");
    if (source.uniqueId) {
        if (Window.prototype.toString[uniqueIdentifier] === flag) {
            return;
        }
    }
    function setConstant(source, property, value) {
        var stack = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : "";
        var valueWrapper = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : "";
        var setProxyTrap = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;
        var uboAliases = [ "set-constant.js", "ubo-set-constant.js", "set.js", "ubo-set.js", "ubo-set-constant", "ubo-set" ];
        if (uboAliases.includes(source.name)) {
            if (stack.length !== 1 && !getNumberFromString(stack)) {
                valueWrapper = stack;
            }
            stack = undefined;
        }
        if (!property || !matchStackTrace(stack, (new Error).stack)) {
            return;
        }
        var isProxyTrapSet = false;
        var emptyArr = noopArray();
        var emptyObj = noopObject();
        var constantValue;
        if (value === "undefined") {
            constantValue = undefined;
        } else if (value === "false") {
            constantValue = false;
        } else if (value === "true") {
            constantValue = true;
        } else if (value === "null") {
            constantValue = null;
        } else if (value === "emptyArr") {
            constantValue = emptyArr;
        } else if (value === "emptyObj") {
            constantValue = emptyObj;
        } else if (value === "noopFunc") {
            constantValue = noopFunc;
        } else if (value === "noopCallbackFunc") {
            constantValue = noopCallbackFunc;
        } else if (value === "trueFunc") {
            constantValue = trueFunc;
        } else if (value === "falseFunc") {
            constantValue = falseFunc;
        } else if (value === "throwFunc") {
            constantValue = throwFunc;
        } else if (value === "noopPromiseResolve") {
            constantValue = noopPromiseResolve;
        } else if (value === "noopPromiseReject") {
            constantValue = noopPromiseReject;
        } else if (/^\d+$/.test(value)) {
            constantValue = parseFloat(value);
            if (nativeIsNaN(constantValue)) {
                return;
            }
            if (Math.abs(constantValue) > 32767) {
                return;
            }
        } else if (value === "-1") {
            constantValue = -1;
        } else if (value === "") {
            constantValue = "";
        } else if (value === "yes") {
            constantValue = "yes";
        } else if (value === "no") {
            constantValue = "no";
        } else {
            return;
        }
        var valueWrapperNames = [ "asFunction", "asCallback", "asResolved", "asRejected" ];
        if (valueWrapperNames.includes(valueWrapper)) {
            var valueWrappersMap = {
                asFunction(v) {
                    return function() {
                        return v;
                    };
                },
                asCallback(v) {
                    return function() {
                        return function() {
                            return v;
                        };
                    };
                },
                asResolved(v) {
                    return Promise.resolve(v);
                },
                asRejected(v) {
                    return Promise.reject(v);
                }
            };
            constantValue = valueWrappersMap[valueWrapper](constantValue);
        }
        var canceled = false;
        var mustCancel = function mustCancel(value) {
            if (canceled) {
                return canceled;
            }
            canceled = value !== undefined && constantValue !== undefined && typeof value !== typeof constantValue && value !== null;
            return canceled;
        };
        var trapProp = function trapProp(base, prop, configurable, handler) {
            if (!handler.init(base[prop])) {
                return false;
            }
            var origDescriptor = Object.getOwnPropertyDescriptor(base, prop);
            var prevSetter;
            if (origDescriptor instanceof Object) {
                if (!origDescriptor.configurable) {
                    var message = `Property '${prop}' is not configurable`;
                    logMessage(source, message);
                    return false;
                }
                if (base[prop]) {
                    base[prop] = constantValue;
                }
                if (origDescriptor.set instanceof Function) {
                    prevSetter = origDescriptor.set;
                }
            }
            Object.defineProperty(base, prop, {
                configurable: configurable,
                get() {
                    return handler.get();
                },
                set(a) {
                    if (prevSetter !== undefined) {
                        prevSetter(a);
                    }
                    if (a instanceof Object) {
                        var propertiesToCheck = property.split(".").slice(1);
                        if (setProxyTrap && !isProxyTrapSet) {
                            isProxyTrapSet = true;
                            a = new Proxy(a, {
                                get: function get(target, propertyKey, val) {
                                    propertiesToCheck.reduce((function(object, currentProp, index, array) {
                                        var currentObj = object === null || object === void 0 ? void 0 : object[currentProp];
                                        if (index === array.length - 1 && currentObj !== constantValue) {
                                            object[currentProp] = constantValue;
                                        }
                                        return currentObj || object;
                                    }), target);
                                    return Reflect.get(target, propertyKey, val);
                                }
                            });
                        }
                    }
                    handler.set(a);
                }
            });
            return true;
        };
        var _setChainPropAccess = function setChainPropAccess(owner, property) {
            var chainInfo = getPropertyInChain(owner, property);
            var {base: base} = chainInfo;
            var {prop: prop, chain: chain} = chainInfo;
            var inChainPropHandler = {
                factValue: undefined,
                init(a) {
                    this.factValue = a;
                    return true;
                },
                get() {
                    return this.factValue;
                },
                set(a) {
                    if (this.factValue === a) {
                        return;
                    }
                    this.factValue = a;
                    if (a instanceof Object) {
                        _setChainPropAccess(a, chain);
                    }
                }
            };
            var endPropHandler = {
                init(a) {
                    if (mustCancel(a)) {
                        return false;
                    }
                    return true;
                },
                get() {
                    return constantValue;
                },
                set(a) {
                    if (!mustCancel(a)) {
                        return;
                    }
                    constantValue = a;
                }
            };
            if (!chain) {
                var isTrapped = trapProp(base, prop, false, endPropHandler);
                if (isTrapped) {
                    hit(source);
                }
                return;
            }
            if (base !== undefined && base[prop] === null) {
                trapProp(base, prop, true, inChainPropHandler);
                return;
            }
            if ((base instanceof Object || typeof base === "object") && isEmptyObject(base)) {
                trapProp(base, prop, true, inChainPropHandler);
            }
            var propValue = owner[prop];
            if (propValue instanceof Object || typeof propValue === "object" && propValue !== null) {
                _setChainPropAccess(propValue, chain);
            }
            trapProp(base, prop, true, inChainPropHandler);
        };
        _setChainPropAccess(window, property);
    }
    function hit(source) {
        var ADGUARD_PREFIX = "[AdGuard]";
        if (!source.verbose) {
            return;
        }
        try {
            var trace = console.trace.bind(console);
            var label = `${ADGUARD_PREFIX} `;
            if (source.engine === "corelibs") {
                label += source.ruleText;
            } else {
                if (source.domainName) {
                    label += `${source.domainName}`;
                }
                if (source.args) {
                    label += `#%#//scriptlet('${source.name}', '${source.args.join("', '")}')`;
                } else {
                    label += `#%#//scriptlet('${source.name}')`;
                }
            }
            if (trace) {
                trace(label);
            }
        } catch (e) {}
        if (typeof window.__debug === "function") {
            window.__debug(source);
        }
    }
    function logMessage(source, message) {
        var forced = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
        var convertMessageToString = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
        var {name: name, verbose: verbose} = source;
        if (!forced && !verbose) {
            return;
        }
        var nativeConsole = console.log;
        if (!convertMessageToString) {
            nativeConsole(`${name}:`, message);
            return;
        }
        nativeConsole(`${name}: ${message}`);
    }
    function getNumberFromString(rawString) {
        var parsedDelay = parseInt(rawString, 10);
        var validDelay = nativeIsNaN(parsedDelay) ? null : parsedDelay;
        return validDelay;
    }
    function noopArray() {
        return [];
    }
    function noopObject() {
        return {};
    }
    function noopFunc() {}
    function noopCallbackFunc() {
        return noopFunc;
    }
    function trueFunc() {
        return true;
    }
    function falseFunc() {
        return false;
    }
    function throwFunc() {
        throw new Error;
    }
    function noopPromiseReject() {
        return Promise.reject();
    }
    function noopPromiseResolve() {
        var responseBody = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "{}";
        var responseUrl = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "";
        var responseType = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : "basic";
        if (typeof Response === "undefined") {
            return;
        }
        var response = new Response(responseBody, {
            status: 200,
            statusText: "OK"
        });
        if (responseType === "opaque") {
            Object.defineProperties(response, {
                body: {
                    value: null
                },
                status: {
                    value: 0
                },
                ok: {
                    value: false
                },
                statusText: {
                    value: ""
                },
                url: {
                    value: ""
                },
                type: {
                    value: responseType
                }
            });
        } else {
            Object.defineProperties(response, {
                url: {
                    value: responseUrl
                },
                type: {
                    value: responseType
                }
            });
        }
        return Promise.resolve(response);
    }
    function getPropertyInChain(base, chain) {
        var pos = chain.indexOf(".");
        if (pos === -1) {
            return {
                base: base,
                prop: chain
            };
        }
        var prop = chain.slice(0, pos);
        if (base === null) {
            return {
                base: base,
                prop: prop,
                chain: chain
            };
        }
        var nextBase = base[prop];
        chain = chain.slice(pos + 1);
        if ((base instanceof Object || typeof base === "object") && isEmptyObject(base)) {
            return {
                base: base,
                prop: prop,
                chain: chain
            };
        }
        if (nextBase === null) {
            return {
                base: base,
                prop: prop,
                chain: chain
            };
        }
        if (nextBase !== undefined) {
            return getPropertyInChain(nextBase, chain);
        }
        Object.defineProperty(base, prop, {
            configurable: true
        });
        return {
            base: base,
            prop: prop,
            chain: chain
        };
    }
    function matchStackTrace(stackMatch, stackTrace) {
        if (!stackMatch || stackMatch === "") {
            return true;
        }
        var regExpValues = backupRegExpValues();
        if (shouldAbortInlineOrInjectedScript(stackMatch, stackTrace)) {
            if (regExpValues.length && regExpValues[0] !== RegExp.$1) {
                restoreRegExpValues(regExpValues);
            }
            return true;
        }
        var stackRegexp = toRegExp(stackMatch);
        var refinedStackTrace = stackTrace.split("\n").slice(2).map((function(line) {
            return line.trim();
        })).join("\n");
        if (regExpValues.length && regExpValues[0] !== RegExp.$1) {
            restoreRegExpValues(regExpValues);
        }
        return getNativeRegexpTest().call(stackRegexp, refinedStackTrace);
    }
    function nativeIsNaN(num) {
        var native = Number.isNaN || window.isNaN;
        return native(num);
    }
    function isEmptyObject(obj) {
        return Object.keys(obj).length === 0 && !obj.prototype;
    }
    function shouldAbortInlineOrInjectedScript(stackMatch, stackTrace) {
        var INLINE_SCRIPT_STRING = "inlineScript";
        var INJECTED_SCRIPT_STRING = "injectedScript";
        var INJECTED_SCRIPT_MARKER = "<anonymous>";
        var isInlineScript = function isInlineScript(match) {
            return match.includes(INLINE_SCRIPT_STRING);
        };
        var isInjectedScript = function isInjectedScript(match) {
            return match.includes(INJECTED_SCRIPT_STRING);
        };
        if (!(isInlineScript(stackMatch) || isInjectedScript(stackMatch))) {
            return false;
        }
        var documentURL = window.location.href;
        var pos = documentURL.indexOf("#");
        if (pos !== -1) {
            documentURL = documentURL.slice(0, pos);
        }
        var stackSteps = stackTrace.split("\n").slice(2).map((function(line) {
            return line.trim();
        }));
        var stackLines = stackSteps.map((function(line) {
            var stack;
            var getStackTraceValues = /(.*?@)?(\S+)(:\d+)(:\d+)\)?$/.exec(line);
            if (getStackTraceValues) {
                var _stackURL, _stackURL2;
                var stackURL = getStackTraceValues[2];
                var stackLine = getStackTraceValues[3];
                var stackCol = getStackTraceValues[4];
                if ((_stackURL = stackURL) !== null && _stackURL !== void 0 && _stackURL.startsWith("(")) {
                    stackURL = stackURL.slice(1);
                }
                if ((_stackURL2 = stackURL) !== null && _stackURL2 !== void 0 && _stackURL2.startsWith(INJECTED_SCRIPT_MARKER)) {
                    var _stackFunction;
                    stackURL = INJECTED_SCRIPT_STRING;
                    var stackFunction = getStackTraceValues[1] !== undefined ? getStackTraceValues[1].slice(0, -1) : line.slice(0, getStackTraceValues.index).trim();
                    if ((_stackFunction = stackFunction) !== null && _stackFunction !== void 0 && _stackFunction.startsWith("at")) {
                        stackFunction = stackFunction.slice(2).trim();
                    }
                    stack = `${stackFunction} ${stackURL}${stackLine}${stackCol}`.trim();
                } else if (stackURL === documentURL) {
                    stack = `${INLINE_SCRIPT_STRING}${stackLine}${stackCol}`.trim();
                } else {
                    stack = `${stackURL}${stackLine}${stackCol}`.trim();
                }
            } else {
                stack = line;
            }
            return stack;
        }));
        if (stackLines) {
            for (var index = 0; index < stackLines.length; index += 1) {
                if (isInlineScript(stackMatch) && stackLines[index].startsWith(INLINE_SCRIPT_STRING) && stackLines[index].match(toRegExp(stackMatch))) {
                    return true;
                }
                if (isInjectedScript(stackMatch) && stackLines[index].startsWith(INJECTED_SCRIPT_STRING) && stackLines[index].match(toRegExp(stackMatch))) {
                    return true;
                }
            }
        }
        return false;
    }
    function getNativeRegexpTest() {
        var descriptor = Object.getOwnPropertyDescriptor(RegExp.prototype, "test");
        var nativeRegexTest = descriptor === null || descriptor === void 0 ? void 0 : descriptor.value;
        if (descriptor && typeof descriptor.value === "function") {
            return nativeRegexTest;
        }
        throw new Error("RegExp.prototype.test is not a function");
    }
    function toRegExp(rawInput) {
        var input = rawInput || "";
        var DEFAULT_VALUE = ".?";
        var FORWARD_SLASH = "/";
        if (input === "") {
            return new RegExp(DEFAULT_VALUE);
        }
        var delimiterIndex = input.lastIndexOf(FORWARD_SLASH);
        var flagsPart = input.substring(delimiterIndex + 1);
        var regExpPart = input.substring(0, delimiterIndex + 1);
        var isValidRegExpFlag = function isValidRegExpFlag(flag) {
            if (!flag) {
                return false;
            }
            try {
                new RegExp("", flag);
                return true;
            } catch (ex) {
                return false;
            }
        };
        var getRegExpFlags = function getRegExpFlags(regExpStr, flagsStr) {
            if (regExpStr.startsWith(FORWARD_SLASH) && regExpStr.endsWith(FORWARD_SLASH) && !regExpStr.endsWith("\\/") && isValidRegExpFlag(flagsStr)) {
                return flagsStr;
            }
            return "";
        };
        var flags = getRegExpFlags(regExpPart, flagsPart);
        if (input.startsWith(FORWARD_SLASH) && input.endsWith(FORWARD_SLASH) || flags) {
            var regExpInput = flags ? regExpPart : input;
            return new RegExp(regExpInput.slice(1, -1), flags);
        }
        var escaped = input.replace(/\\'/g, "'").replace(/\\"/g, '"').replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
        return new RegExp(escaped);
    }
    function backupRegExpValues() {
        try {
            var arrayOfRegexpValues = [];
            for (var index = 1; index < 10; index += 1) {
                var value = `$${index}`;
                if (!RegExp[value]) {
                    break;
                }
                arrayOfRegexpValues.push(RegExp[value]);
            }
            return arrayOfRegexpValues;
        } catch (error) {
            return [];
        }
    }
    function restoreRegExpValues(array) {
        if (!array.length) {
            return;
        }
        try {
            var stringPattern = "";
            if (array.length === 1) {
                stringPattern = `(${array[0]})`;
            } else {
                stringPattern = array.reduce((function(accumulator, currentValue, currentIndex) {
                    if (currentIndex === 1) {
                        return `(${accumulator}),(${currentValue})`;
                    }
                    return `${accumulator},(${currentValue})`;
                }));
            }
            var regExpGroup = new RegExp(stringPattern);
            array.toString().replace(regExpGroup, "");
        } catch (error) {
            var message = `Failed to restore RegExp values: ${error}`;
            console.log(message);
        }
    }
    var updatedArgs = args ? [].concat(source).concat(args) : [ source ];
    try {
        setConstant.apply(this, updatedArgs);
        if (source.uniqueId) {
            Object.defineProperty(Window.prototype.toString, uniqueIdentifier, {
                value: flag,
                enumerable: false,
                writable: false,
                configurable: false
            });
        }
    } catch (e) {
        console.log(e);
    }
}

function setCookie(source, args) {
    var flag = "done";
    var uniqueIdentifier = source.uniqueId + source.name + "_" + (Array.isArray(args) ? args.join("_") : "");
    if (source.uniqueId) {
        if (Window.prototype.toString[uniqueIdentifier] === flag) {
            return;
        }
    }
    function setCookie(source, name, value) {
        var path = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : "/";
        var domain = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : "";
        var validValue = getLimitedCookieValue(value);
        if (validValue === null) {
            logMessage(source, `Invalid cookie value: '${validValue}'`);
            return;
        }
        if (!isValidCookiePath(path)) {
            logMessage(source, `Invalid cookie path: '${path}'`);
            return;
        }
        if (!document.location.origin.includes(domain)) {
            logMessage(source, `Cookie domain not matched by origin: '${domain}'`);
            return;
        }
        var cookieToSet = serializeCookie(name, validValue, path, domain);
        if (!cookieToSet) {
            logMessage(source, "Invalid cookie name or value");
            return;
        }
        hit(source);
        document.cookie = cookieToSet;
    }
    function hit(source) {
        var ADGUARD_PREFIX = "[AdGuard]";
        if (!source.verbose) {
            return;
        }
        try {
            var trace = console.trace.bind(console);
            var label = `${ADGUARD_PREFIX} `;
            if (source.engine === "corelibs") {
                label += source.ruleText;
            } else {
                if (source.domainName) {
                    label += `${source.domainName}`;
                }
                if (source.args) {
                    label += `#%#//scriptlet('${source.name}', '${source.args.join("', '")}')`;
                } else {
                    label += `#%#//scriptlet('${source.name}')`;
                }
            }
            if (trace) {
                trace(label);
            }
        } catch (e) {}
        if (typeof window.__debug === "function") {
            window.__debug(source);
        }
    }
    function logMessage(source, message) {
        var forced = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
        var convertMessageToString = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
        var {name: name, verbose: verbose} = source;
        if (!forced && !verbose) {
            return;
        }
        var nativeConsole = console.log;
        if (!convertMessageToString) {
            nativeConsole(`${name}:`, message);
            return;
        }
        nativeConsole(`${name}: ${message}`);
    }
    function nativeIsNaN(num) {
        var native = Number.isNaN || window.isNaN;
        return native(num);
    }
    function getLimitedCookieValue(value) {
        if (!value) {
            return null;
        }
        var allowedCookieValues = new Set([ "true", "t", "false", "f", "yes", "y", "no", "n", "ok", "on", "off", "accept", "accepted", "notaccepted", "reject", "rejected", "allow", "allowed", "disallow", "deny", "enable", "enabled", "disable", "disabled", "necessary", "required", "hide", "hidden", "essential", "nonessential", "checked", "unchecked", "forbidden", "forever" ]);
        var validValue;
        if (allowedCookieValues.has(value.toLowerCase())) {
            validValue = value;
        } else if (/^\d+$/.test(value)) {
            validValue = parseFloat(value);
            if (nativeIsNaN(validValue)) {
                return null;
            }
            if (Math.abs(validValue) < 0 || Math.abs(validValue) > 32767) {
                return null;
            }
        } else {
            return null;
        }
        return validValue;
    }
    function serializeCookie(name, rawValue, rawPath) {
        var domainValue = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : "";
        var shouldEncodeValue = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : true;
        var HOST_PREFIX = "__Host-";
        var SECURE_PREFIX = "__Secure-";
        var COOKIE_BREAKER = ";";
        if (!shouldEncodeValue && `${rawValue}`.includes(COOKIE_BREAKER) || name.includes(COOKIE_BREAKER)) {
            return null;
        }
        var value = shouldEncodeValue ? encodeURIComponent(rawValue) : rawValue;
        var resultCookie = `${name}=${value}`;
        if (name.startsWith(HOST_PREFIX)) {
            resultCookie += "; path=/; secure";
            if (domainValue) {
                console.debug(`Domain value: "${domainValue}" has been ignored, because is not allowed for __Host- prefixed cookies`);
            }
            return resultCookie;
        }
        var path = getCookiePath(rawPath);
        if (path) {
            resultCookie += `; ${path}`;
        }
        if (name.startsWith(SECURE_PREFIX)) {
            resultCookie += "; secure";
        }
        if (domainValue) {
            resultCookie += `; domain=${domainValue}`;
        }
        return resultCookie;
    }
    function isValidCookiePath(rawPath) {
        return rawPath === "/" || rawPath === "none";
    }
    function getCookiePath(rawPath) {
        if (rawPath === "/") {
            return "path=/";
        }
        return "";
    }
    var updatedArgs = args ? [].concat(source).concat(args) : [ source ];
    try {
        setCookie.apply(this, updatedArgs);
        if (source.uniqueId) {
            Object.defineProperty(Window.prototype.toString, uniqueIdentifier, {
                value: flag,
                enumerable: false,
                writable: false,
                configurable: false
            });
        }
    } catch (e) {
        console.log(e);
    }
}

function setCookieReload(source, args) {
    var flag = "done";
    var uniqueIdentifier = source.uniqueId + source.name + "_" + (Array.isArray(args) ? args.join("_") : "");
    if (source.uniqueId) {
        if (Window.prototype.toString[uniqueIdentifier] === flag) {
            return;
        }
    }
    function setCookieReload(source, name, value) {
        var path = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : "/";
        var domain = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : "";
        if (isCookieSetWithValue(document.cookie, name, value)) {
            return;
        }
        var validValue = getLimitedCookieValue(value);
        if (validValue === null) {
            logMessage(source, `Invalid cookie value: '${value}'`);
            return;
        }
        if (!isValidCookiePath(path)) {
            logMessage(source, `Invalid cookie path: '${path}'`);
            return;
        }
        if (!document.location.origin.includes(domain)) {
            logMessage(source, `Cookie domain not matched by origin: '${domain}'`);
            return;
        }
        var cookieToSet = serializeCookie(name, validValue, path, domain);
        if (!cookieToSet) {
            logMessage(source, "Invalid cookie name or value");
            return;
        }
        document.cookie = cookieToSet;
        hit(source);
        if (isCookieSetWithValue(document.cookie, name, value)) {
            window.location.reload();
        }
    }
    function hit(source) {
        var ADGUARD_PREFIX = "[AdGuard]";
        if (!source.verbose) {
            return;
        }
        try {
            var trace = console.trace.bind(console);
            var label = `${ADGUARD_PREFIX} `;
            if (source.engine === "corelibs") {
                label += source.ruleText;
            } else {
                if (source.domainName) {
                    label += `${source.domainName}`;
                }
                if (source.args) {
                    label += `#%#//scriptlet('${source.name}', '${source.args.join("', '")}')`;
                } else {
                    label += `#%#//scriptlet('${source.name}')`;
                }
            }
            if (trace) {
                trace(label);
            }
        } catch (e) {}
        if (typeof window.__debug === "function") {
            window.__debug(source);
        }
    }
    function logMessage(source, message) {
        var forced = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
        var convertMessageToString = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
        var {name: name, verbose: verbose} = source;
        if (!forced && !verbose) {
            return;
        }
        var nativeConsole = console.log;
        if (!convertMessageToString) {
            nativeConsole(`${name}:`, message);
            return;
        }
        nativeConsole(`${name}: ${message}`);
    }
    function nativeIsNaN(num) {
        var native = Number.isNaN || window.isNaN;
        return native(num);
    }
    function isCookieSetWithValue(cookieString, name, value) {
        return cookieString.split(";").some((function(cookieStr) {
            var pos = cookieStr.indexOf("=");
            if (pos === -1) {
                return false;
            }
            var cookieName = cookieStr.slice(0, pos).trim();
            var cookieValue = cookieStr.slice(pos + 1).trim();
            return name === cookieName && value === cookieValue;
        }));
    }
    function getLimitedCookieValue(value) {
        if (!value) {
            return null;
        }
        var allowedCookieValues = new Set([ "true", "t", "false", "f", "yes", "y", "no", "n", "ok", "on", "off", "accept", "accepted", "notaccepted", "reject", "rejected", "allow", "allowed", "disallow", "deny", "enable", "enabled", "disable", "disabled", "necessary", "required", "hide", "hidden", "essential", "nonessential", "checked", "unchecked", "forbidden", "forever" ]);
        var validValue;
        if (allowedCookieValues.has(value.toLowerCase())) {
            validValue = value;
        } else if (/^\d+$/.test(value)) {
            validValue = parseFloat(value);
            if (nativeIsNaN(validValue)) {
                return null;
            }
            if (Math.abs(validValue) < 0 || Math.abs(validValue) > 32767) {
                return null;
            }
        } else {
            return null;
        }
        return validValue;
    }
    function serializeCookie(name, rawValue, rawPath) {
        var domainValue = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : "";
        var shouldEncodeValue = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : true;
        var HOST_PREFIX = "__Host-";
        var SECURE_PREFIX = "__Secure-";
        var COOKIE_BREAKER = ";";
        if (!shouldEncodeValue && `${rawValue}`.includes(COOKIE_BREAKER) || name.includes(COOKIE_BREAKER)) {
            return null;
        }
        var value = shouldEncodeValue ? encodeURIComponent(rawValue) : rawValue;
        var resultCookie = `${name}=${value}`;
        if (name.startsWith(HOST_PREFIX)) {
            resultCookie += "; path=/; secure";
            if (domainValue) {
                console.debug(`Domain value: "${domainValue}" has been ignored, because is not allowed for __Host- prefixed cookies`);
            }
            return resultCookie;
        }
        var path = getCookiePath(rawPath);
        if (path) {
            resultCookie += `; ${path}`;
        }
        if (name.startsWith(SECURE_PREFIX)) {
            resultCookie += "; secure";
        }
        if (domainValue) {
            resultCookie += `; domain=${domainValue}`;
        }
        return resultCookie;
    }
    function isValidCookiePath(rawPath) {
        return rawPath === "/" || rawPath === "none";
    }
    function getCookiePath(rawPath) {
        if (rawPath === "/") {
            return "path=/";
        }
        return "";
    }
    var updatedArgs = args ? [].concat(source).concat(args) : [ source ];
    try {
        setCookieReload.apply(this, updatedArgs);
        if (source.uniqueId) {
            Object.defineProperty(Window.prototype.toString, uniqueIdentifier, {
                value: flag,
                enumerable: false,
                writable: false,
                configurable: false
            });
        }
    } catch (e) {
        console.log(e);
    }
}

function setLocalStorageItem(source, args) {
    var flag = "done";
    var uniqueIdentifier = source.uniqueId + source.name + "_" + (Array.isArray(args) ? args.join("_") : "");
    if (source.uniqueId) {
        if (Window.prototype.toString[uniqueIdentifier] === flag) {
            return;
        }
    }
    function setLocalStorageItem(source, key, value) {
        if (typeof key === "undefined") {
            logMessage(source, "Item key should be specified.");
            return;
        }
        var validValue;
        try {
            validValue = getLimitedStorageItemValue(value);
        } catch (_unused) {
            logMessage(source, `Invalid storage item value: '${value}'`);
            return;
        }
        var {localStorage: localStorage} = window;
        if (validValue === "$remove$") {
            removeStorageItem(source, localStorage, key);
        } else {
            setStorageItem(source, localStorage, key, validValue);
        }
        hit(source);
    }
    function hit(source) {
        var ADGUARD_PREFIX = "[AdGuard]";
        if (!source.verbose) {
            return;
        }
        try {
            var trace = console.trace.bind(console);
            var label = `${ADGUARD_PREFIX} `;
            if (source.engine === "corelibs") {
                label += source.ruleText;
            } else {
                if (source.domainName) {
                    label += `${source.domainName}`;
                }
                if (source.args) {
                    label += `#%#//scriptlet('${source.name}', '${source.args.join("', '")}')`;
                } else {
                    label += `#%#//scriptlet('${source.name}')`;
                }
            }
            if (trace) {
                trace(label);
            }
        } catch (e) {}
        if (typeof window.__debug === "function") {
            window.__debug(source);
        }
    }
    function logMessage(source, message) {
        var forced = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
        var convertMessageToString = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
        var {name: name, verbose: verbose} = source;
        if (!forced && !verbose) {
            return;
        }
        var nativeConsole = console.log;
        if (!convertMessageToString) {
            nativeConsole(`${name}:`, message);
            return;
        }
        nativeConsole(`${name}: ${message}`);
    }
    function nativeIsNaN(num) {
        var native = Number.isNaN || window.isNaN;
        return native(num);
    }
    function setStorageItem(source, storage, key, value) {
        try {
            storage.setItem(key, value);
        } catch (e) {
            var message = `Unable to set storage item due to: ${e.message}`;
            logMessage(source, message);
        }
    }
    function removeStorageItem(source, storage, key) {
        try {
            if (key.startsWith("/") && (key.endsWith("/") || key.endsWith("/i")) && isValidStrPattern(key)) {
                var regExpKey = toRegExp(key);
                var storageKeys = Object.keys(storage);
                storageKeys.forEach((function(storageKey) {
                    if (regExpKey.test(storageKey)) {
                        storage.removeItem(storageKey);
                    }
                }));
            } else {
                storage.removeItem(key);
            }
        } catch (e) {
            var message = `Unable to remove storage item due to: ${e.message}`;
            logMessage(source, message);
        }
    }
    function getLimitedStorageItemValue(value) {
        if (typeof value !== "string") {
            throw new Error("Invalid value");
        }
        var allowedStorageValues = new Set([ "undefined", "false", "true", "null", "", "yes", "no", "on", "off", "accept", "accepted", "reject", "rejected", "allowed", "denied", "forbidden", "forever" ]);
        var validValue;
        if (allowedStorageValues.has(value.toLowerCase())) {
            validValue = value;
        } else if (value === "emptyArr") {
            validValue = "[]";
        } else if (value === "emptyObj") {
            validValue = "{}";
        } else if (/^\d+$/.test(value)) {
            validValue = parseFloat(value);
            if (nativeIsNaN(validValue)) {
                throw new Error("Invalid value");
            }
            if (Math.abs(validValue) > 32767) {
                throw new Error("Invalid value");
            }
        } else if (value === "$remove$") {
            validValue = "$remove$";
        } else {
            throw new Error("Invalid value");
        }
        return validValue;
    }
    function isValidStrPattern(input) {
        var FORWARD_SLASH = "/";
        var str = escapeRegExp(input);
        if (input[0] === FORWARD_SLASH && input[input.length - 1] === FORWARD_SLASH) {
            str = input.slice(1, -1);
        }
        var isValid;
        try {
            isValid = new RegExp(str);
            isValid = true;
        } catch (e) {
            isValid = false;
        }
        return isValid;
    }
    function toRegExp(rawInput) {
        var input = rawInput || "";
        var DEFAULT_VALUE = ".?";
        var FORWARD_SLASH = "/";
        if (input === "") {
            return new RegExp(DEFAULT_VALUE);
        }
        var delimiterIndex = input.lastIndexOf(FORWARD_SLASH);
        var flagsPart = input.substring(delimiterIndex + 1);
        var regExpPart = input.substring(0, delimiterIndex + 1);
        var isValidRegExpFlag = function isValidRegExpFlag(flag) {
            if (!flag) {
                return false;
            }
            try {
                new RegExp("", flag);
                return true;
            } catch (ex) {
                return false;
            }
        };
        var getRegExpFlags = function getRegExpFlags(regExpStr, flagsStr) {
            if (regExpStr.startsWith(FORWARD_SLASH) && regExpStr.endsWith(FORWARD_SLASH) && !regExpStr.endsWith("\\/") && isValidRegExpFlag(flagsStr)) {
                return flagsStr;
            }
            return "";
        };
        var flags = getRegExpFlags(regExpPart, flagsPart);
        if (input.startsWith(FORWARD_SLASH) && input.endsWith(FORWARD_SLASH) || flags) {
            var regExpInput = flags ? regExpPart : input;
            return new RegExp(regExpInput.slice(1, -1), flags);
        }
        var escaped = input.replace(/\\'/g, "'").replace(/\\"/g, '"').replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
        return new RegExp(escaped);
    }
    function escapeRegExp(str) {
        return str.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
    }
    var updatedArgs = args ? [].concat(source).concat(args) : [ source ];
    try {
        setLocalStorageItem.apply(this, updatedArgs);
        if (source.uniqueId) {
            Object.defineProperty(Window.prototype.toString, uniqueIdentifier, {
                value: flag,
                enumerable: false,
                writable: false,
                configurable: false
            });
        }
    } catch (e) {
        console.log(e);
    }
}

function setPopadsDummy(source, args) {
    var flag = "done";
    var uniqueIdentifier = source.uniqueId + source.name + "_" + (Array.isArray(args) ? args.join("_") : "");
    if (source.uniqueId) {
        if (Window.prototype.toString[uniqueIdentifier] === flag) {
            return;
        }
    }
    function setPopadsDummy(source) {
        delete window.PopAds;
        delete window.popns;
        Object.defineProperties(window, {
            PopAds: {
                get: function get() {
                    hit(source);
                    return {};
                }
            },
            popns: {
                get: function get() {
                    hit(source);
                    return {};
                }
            }
        });
    }
    function hit(source) {
        var ADGUARD_PREFIX = "[AdGuard]";
        if (!source.verbose) {
            return;
        }
        try {
            var trace = console.trace.bind(console);
            var label = `${ADGUARD_PREFIX} `;
            if (source.engine === "corelibs") {
                label += source.ruleText;
            } else {
                if (source.domainName) {
                    label += `${source.domainName}`;
                }
                if (source.args) {
                    label += `#%#//scriptlet('${source.name}', '${source.args.join("', '")}')`;
                } else {
                    label += `#%#//scriptlet('${source.name}')`;
                }
            }
            if (trace) {
                trace(label);
            }
        } catch (e) {}
        if (typeof window.__debug === "function") {
            window.__debug(source);
        }
    }
    var updatedArgs = args ? [].concat(source).concat(args) : [ source ];
    try {
        setPopadsDummy.apply(this, updatedArgs);
        if (source.uniqueId) {
            Object.defineProperty(Window.prototype.toString, uniqueIdentifier, {
                value: flag,
                enumerable: false,
                writable: false,
                configurable: false
            });
        }
    } catch (e) {
        console.log(e);
    }
}

function setSessionStorageItem(source, args) {
    var flag = "done";
    var uniqueIdentifier = source.uniqueId + source.name + "_" + (Array.isArray(args) ? args.join("_") : "");
    if (source.uniqueId) {
        if (Window.prototype.toString[uniqueIdentifier] === flag) {
            return;
        }
    }
    function setSessionStorageItem(source, key, value) {
        if (typeof key === "undefined") {
            logMessage(source, "Item key should be specified.");
            return;
        }
        var validValue;
        try {
            validValue = getLimitedStorageItemValue(value);
        } catch (_unused) {
            logMessage(source, `Invalid storage item value: '${value}'`);
            return;
        }
        var {sessionStorage: sessionStorage} = window;
        if (validValue === "$remove$") {
            removeStorageItem(source, sessionStorage, key);
        } else {
            setStorageItem(source, sessionStorage, key, validValue);
        }
        hit(source);
    }
    function hit(source) {
        var ADGUARD_PREFIX = "[AdGuard]";
        if (!source.verbose) {
            return;
        }
        try {
            var trace = console.trace.bind(console);
            var label = `${ADGUARD_PREFIX} `;
            if (source.engine === "corelibs") {
                label += source.ruleText;
            } else {
                if (source.domainName) {
                    label += `${source.domainName}`;
                }
                if (source.args) {
                    label += `#%#//scriptlet('${source.name}', '${source.args.join("', '")}')`;
                } else {
                    label += `#%#//scriptlet('${source.name}')`;
                }
            }
            if (trace) {
                trace(label);
            }
        } catch (e) {}
        if (typeof window.__debug === "function") {
            window.__debug(source);
        }
    }
    function logMessage(source, message) {
        var forced = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
        var convertMessageToString = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
        var {name: name, verbose: verbose} = source;
        if (!forced && !verbose) {
            return;
        }
        var nativeConsole = console.log;
        if (!convertMessageToString) {
            nativeConsole(`${name}:`, message);
            return;
        }
        nativeConsole(`${name}: ${message}`);
    }
    function nativeIsNaN(num) {
        var native = Number.isNaN || window.isNaN;
        return native(num);
    }
    function setStorageItem(source, storage, key, value) {
        try {
            storage.setItem(key, value);
        } catch (e) {
            var message = `Unable to set storage item due to: ${e.message}`;
            logMessage(source, message);
        }
    }
    function removeStorageItem(source, storage, key) {
        try {
            if (key.startsWith("/") && (key.endsWith("/") || key.endsWith("/i")) && isValidStrPattern(key)) {
                var regExpKey = toRegExp(key);
                var storageKeys = Object.keys(storage);
                storageKeys.forEach((function(storageKey) {
                    if (regExpKey.test(storageKey)) {
                        storage.removeItem(storageKey);
                    }
                }));
            } else {
                storage.removeItem(key);
            }
        } catch (e) {
            var message = `Unable to remove storage item due to: ${e.message}`;
            logMessage(source, message);
        }
    }
    function getLimitedStorageItemValue(value) {
        if (typeof value !== "string") {
            throw new Error("Invalid value");
        }
        var allowedStorageValues = new Set([ "undefined", "false", "true", "null", "", "yes", "no", "on", "off", "accept", "accepted", "reject", "rejected", "allowed", "denied", "forbidden", "forever" ]);
        var validValue;
        if (allowedStorageValues.has(value.toLowerCase())) {
            validValue = value;
        } else if (value === "emptyArr") {
            validValue = "[]";
        } else if (value === "emptyObj") {
            validValue = "{}";
        } else if (/^\d+$/.test(value)) {
            validValue = parseFloat(value);
            if (nativeIsNaN(validValue)) {
                throw new Error("Invalid value");
            }
            if (Math.abs(validValue) > 32767) {
                throw new Error("Invalid value");
            }
        } else if (value === "$remove$") {
            validValue = "$remove$";
        } else {
            throw new Error("Invalid value");
        }
        return validValue;
    }
    function isValidStrPattern(input) {
        var FORWARD_SLASH = "/";
        var str = escapeRegExp(input);
        if (input[0] === FORWARD_SLASH && input[input.length - 1] === FORWARD_SLASH) {
            str = input.slice(1, -1);
        }
        var isValid;
        try {
            isValid = new RegExp(str);
            isValid = true;
        } catch (e) {
            isValid = false;
        }
        return isValid;
    }
    function toRegExp(rawInput) {
        var input = rawInput || "";
        var DEFAULT_VALUE = ".?";
        var FORWARD_SLASH = "/";
        if (input === "") {
            return new RegExp(DEFAULT_VALUE);
        }
        var delimiterIndex = input.lastIndexOf(FORWARD_SLASH);
        var flagsPart = input.substring(delimiterIndex + 1);
        var regExpPart = input.substring(0, delimiterIndex + 1);
        var isValidRegExpFlag = function isValidRegExpFlag(flag) {
            if (!flag) {
                return false;
            }
            try {
                new RegExp("", flag);
                return true;
            } catch (ex) {
                return false;
            }
        };
        var getRegExpFlags = function getRegExpFlags(regExpStr, flagsStr) {
            if (regExpStr.startsWith(FORWARD_SLASH) && regExpStr.endsWith(FORWARD_SLASH) && !regExpStr.endsWith("\\/") && isValidRegExpFlag(flagsStr)) {
                return flagsStr;
            }
            return "";
        };
        var flags = getRegExpFlags(regExpPart, flagsPart);
        if (input.startsWith(FORWARD_SLASH) && input.endsWith(FORWARD_SLASH) || flags) {
            var regExpInput = flags ? regExpPart : input;
            return new RegExp(regExpInput.slice(1, -1), flags);
        }
        var escaped = input.replace(/\\'/g, "'").replace(/\\"/g, '"').replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
        return new RegExp(escaped);
    }
    function escapeRegExp(str) {
        return str.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
    }
    var updatedArgs = args ? [].concat(source).concat(args) : [ source ];
    try {
        setSessionStorageItem.apply(this, updatedArgs);
        if (source.uniqueId) {
            Object.defineProperty(Window.prototype.toString, uniqueIdentifier, {
                value: flag,
                enumerable: false,
                writable: false,
                configurable: false
            });
        }
    } catch (e) {
        console.log(e);
    }
}

function spoofCSS(source, args) {
    var flag = "done";
    var uniqueIdentifier = source.uniqueId + source.name + "_" + (Array.isArray(args) ? args.join("_") : "");
    if (source.uniqueId) {
        if (Window.prototype.toString[uniqueIdentifier] === flag) {
            return;
        }
    }
    function spoofCSS(source, selectors, cssPropertyName, cssPropertyValue) {
        if (!selectors) {
            return;
        }
        var uboAliases = [ "spoof-css.js", "ubo-spoof-css.js", "ubo-spoof-css" ];
        function convertToCamelCase(cssProperty) {
            if (!cssProperty.includes("-")) {
                return cssProperty;
            }
            var splittedProperty = cssProperty.split("-");
            var firstPart = splittedProperty[0];
            var secondPart = splittedProperty[1];
            return `${firstPart}${secondPart[0].toUpperCase()}${secondPart.slice(1)}`;
        }
        var shouldDebug = !!(cssPropertyName === "debug" && cssPropertyValue);
        var propToValueMap = new Map;
        if (uboAliases.includes(source.name)) {
            var {args: args} = source;
            var arrayOfProperties = [];
            var isDebug = args.at(-2);
            if (isDebug === "debug") {
                arrayOfProperties = args.slice(1, -2);
            } else {
                arrayOfProperties = args.slice(1);
            }
            for (var i = 0; i < arrayOfProperties.length; i += 2) {
                if (arrayOfProperties[i] === "") {
                    break;
                }
                propToValueMap.set(convertToCamelCase(arrayOfProperties[i]), arrayOfProperties[i + 1]);
            }
        } else if (cssPropertyName && cssPropertyValue && !shouldDebug) {
            propToValueMap.set(convertToCamelCase(cssPropertyName), cssPropertyValue);
        }
        var spoofStyle = function spoofStyle(cssProperty, realCssValue) {
            return propToValueMap.has(cssProperty) ? propToValueMap.get(cssProperty) : realCssValue;
        };
        var setRectValue = function setRectValue(rect, prop, value) {
            Object.defineProperty(rect, prop, {
                value: parseFloat(value)
            });
        };
        var getter = function getter(target, prop, receiver) {
            hit(source);
            if (prop === "toString") {
                return target.toString.bind(target);
            }
            return Reflect.get(target, prop, receiver);
        };
        var getComputedStyleWrapper = function getComputedStyleWrapper(target, thisArg, args) {
            if (shouldDebug) {
                debugger;
            }
            var style = Reflect.apply(target, thisArg, args);
            if (!args[0].matches(selectors)) {
                return style;
            }
            var proxiedStyle = new Proxy(style, {
                get(target, prop) {
                    var CSSStyleProp = target[prop];
                    if (typeof CSSStyleProp !== "function") {
                        return spoofStyle(prop, CSSStyleProp || "");
                    }
                    if (prop !== "getPropertyValue") {
                        return CSSStyleProp.bind(target);
                    }
                    var getPropertyValueFunc = new Proxy(CSSStyleProp, {
                        apply(target, thisArg, args) {
                            var cssName = args[0];
                            var cssValue = thisArg[cssName];
                            return spoofStyle(cssName, cssValue);
                        },
                        get: getter
                    });
                    return getPropertyValueFunc;
                },
                getOwnPropertyDescriptor(target, prop) {
                    if (propToValueMap.has(prop)) {
                        return {
                            configurable: true,
                            enumerable: true,
                            value: propToValueMap.get(prop),
                            writable: true
                        };
                    }
                    return Reflect.getOwnPropertyDescriptor(target, prop);
                }
            });
            hit(source);
            return proxiedStyle;
        };
        var getComputedStyleHandler = {
            apply: getComputedStyleWrapper,
            get: getter
        };
        window.getComputedStyle = new Proxy(window.getComputedStyle, getComputedStyleHandler);
        var getBoundingClientRectWrapper = function getBoundingClientRectWrapper(target, thisArg, args) {
            if (shouldDebug) {
                debugger;
            }
            var rect = Reflect.apply(target, thisArg, args);
            if (!thisArg.matches(selectors)) {
                return rect;
            }
            var {top: top, bottom: bottom, height: height, width: width, left: left, right: right} = rect;
            var newDOMRect = new window.DOMRect(rect.x, rect.y, top, bottom, width, height, left, right);
            if (propToValueMap.has("top")) {
                setRectValue(newDOMRect, "top", propToValueMap.get("top"));
            }
            if (propToValueMap.has("bottom")) {
                setRectValue(newDOMRect, "bottom", propToValueMap.get("bottom"));
            }
            if (propToValueMap.has("left")) {
                setRectValue(newDOMRect, "left", propToValueMap.get("left"));
            }
            if (propToValueMap.has("right")) {
                setRectValue(newDOMRect, "right", propToValueMap.get("right"));
            }
            if (propToValueMap.has("height")) {
                setRectValue(newDOMRect, "height", propToValueMap.get("height"));
            }
            if (propToValueMap.has("width")) {
                setRectValue(newDOMRect, "width", propToValueMap.get("width"));
            }
            hit(source);
            return newDOMRect;
        };
        var getBoundingClientRectHandler = {
            apply: getBoundingClientRectWrapper,
            get: getter
        };
        window.Element.prototype.getBoundingClientRect = new Proxy(window.Element.prototype.getBoundingClientRect, getBoundingClientRectHandler);
    }
    function hit(source) {
        var ADGUARD_PREFIX = "[AdGuard]";
        if (!source.verbose) {
            return;
        }
        try {
            var trace = console.trace.bind(console);
            var label = `${ADGUARD_PREFIX} `;
            if (source.engine === "corelibs") {
                label += source.ruleText;
            } else {
                if (source.domainName) {
                    label += `${source.domainName}`;
                }
                if (source.args) {
                    label += `#%#//scriptlet('${source.name}', '${source.args.join("', '")}')`;
                } else {
                    label += `#%#//scriptlet('${source.name}')`;
                }
            }
            if (trace) {
                trace(label);
            }
        } catch (e) {}
        if (typeof window.__debug === "function") {
            window.__debug(source);
        }
    }
    var updatedArgs = args ? [].concat(source).concat(args) : [ source ];
    try {
        spoofCSS.apply(this, updatedArgs);
        if (source.uniqueId) {
            Object.defineProperty(Window.prototype.toString, uniqueIdentifier, {
                value: flag,
                enumerable: false,
                writable: false,
                configurable: false
            });
        }
    } catch (e) {
        console.log(e);
    }
}

function trustedClickElement(source, args) {
    var flag = "done";
    var uniqueIdentifier = source.uniqueId + source.name + "_" + (Array.isArray(args) ? args.join("_") : "");
    if (source.uniqueId) {
        if (Window.prototype.toString[uniqueIdentifier] === flag) {
            return;
        }
    }
    function trustedClickElement(source, selectors) {
        var extraMatch = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : "";
        var delay = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : NaN;
        var reload = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : "";
        if (!selectors) {
            return;
        }
        var SHADOW_COMBINATOR = " >>> ";
        var OBSERVER_TIMEOUT_MS = 1e4;
        var THROTTLE_DELAY_MS = 20;
        var STATIC_CLICK_DELAY_MS = 150;
        var STATIC_RELOAD_DELAY_MS = 500;
        var COOKIE_MATCH_MARKER = "cookie:";
        var LOCAL_STORAGE_MATCH_MARKER = "localStorage:";
        var TEXT_MATCH_MARKER = "containsText:";
        var RELOAD_ON_FINAL_CLICK_MARKER = "reloadAfterClick";
        var SELECTORS_DELIMITER = ",";
        var COOKIE_STRING_DELIMITER = ";";
        var COLON = ":";
        var EXTRA_MATCH_DELIMITER = /(,\s*){1}(?=!?cookie:|!?localStorage:|containsText:)/;
        var sleep = function sleep(delayMs) {
            return new Promise((function(resolve) {
                setTimeout(resolve, delayMs);
            }));
        };
        if (selectors.includes(SHADOW_COMBINATOR)) {
            var attachShadowWrapper = function attachShadowWrapper(target, thisArg, argumentsList) {
                var _argumentsList$;
                var mode = (_argumentsList$ = argumentsList[0]) === null || _argumentsList$ === void 0 ? void 0 : _argumentsList$.mode;
                if (mode === "closed") {
                    argumentsList[0].mode = "open";
                }
                return Reflect.apply(target, thisArg, argumentsList);
            };
            var attachShadowHandler = {
                apply: attachShadowWrapper
            };
            window.Element.prototype.attachShadow = new Proxy(window.Element.prototype.attachShadow, attachShadowHandler);
        }
        var parsedDelay;
        if (delay) {
            parsedDelay = parseInt(String(delay), 10);
            var isValidDelay = !Number.isNaN(parsedDelay) || parsedDelay < OBSERVER_TIMEOUT_MS;
            if (!isValidDelay) {
                var message = `Passed delay '${delay}' is invalid or bigger than ${OBSERVER_TIMEOUT_MS} ms`;
                logMessage(source, message);
                return;
            }
        }
        var canClick = !parsedDelay;
        var cookieMatches = [];
        var localStorageMatches = [];
        var textMatches = "";
        var isInvertedMatchCookie = false;
        var isInvertedMatchLocalStorage = false;
        if (extraMatch) {
            var parsedExtraMatch = extraMatch.split(EXTRA_MATCH_DELIMITER).map((function(matchStr) {
                return matchStr.trim();
            }));
            parsedExtraMatch.forEach((function(matchStr) {
                if (matchStr.includes(COOKIE_MATCH_MARKER)) {
                    var {isInvertedMatch: isInvertedMatch, matchValue: matchValue} = parseMatchArg(matchStr);
                    isInvertedMatchCookie = isInvertedMatch;
                    var cookieMatch = matchValue.replace(COOKIE_MATCH_MARKER, "");
                    cookieMatches.push(cookieMatch);
                }
                if (matchStr.includes(LOCAL_STORAGE_MATCH_MARKER)) {
                    var {isInvertedMatch: _isInvertedMatch, matchValue: _matchValue} = parseMatchArg(matchStr);
                    isInvertedMatchLocalStorage = _isInvertedMatch;
                    var localStorageMatch = _matchValue.replace(LOCAL_STORAGE_MATCH_MARKER, "");
                    localStorageMatches.push(localStorageMatch);
                }
                if (matchStr.includes(TEXT_MATCH_MARKER)) {
                    var {matchValue: _matchValue2} = parseMatchArg(matchStr);
                    var textMatch = _matchValue2.replace(TEXT_MATCH_MARKER, "");
                    textMatches = textMatch;
                }
            }));
        }
        if (cookieMatches.length > 0) {
            var parsedCookieMatches = parseCookieString(cookieMatches.join(COOKIE_STRING_DELIMITER));
            var parsedCookies = parseCookieString(document.cookie);
            var cookieKeys = Object.keys(parsedCookies);
            if (cookieKeys.length === 0) {
                return;
            }
            var cookiesMatched = Object.keys(parsedCookieMatches).every((function(key) {
                var valueMatch = parsedCookieMatches[key] ? toRegExp(parsedCookieMatches[key]) : null;
                var keyMatch = toRegExp(key);
                return cookieKeys.some((function(cookieKey) {
                    var keysMatched = keyMatch.test(cookieKey);
                    if (!keysMatched) {
                        return false;
                    }
                    if (!valueMatch) {
                        return true;
                    }
                    var parsedCookieValue = parsedCookies[cookieKey];
                    if (!parsedCookieValue) {
                        return false;
                    }
                    return valueMatch.test(parsedCookieValue);
                }));
            }));
            var shouldRun = cookiesMatched !== isInvertedMatchCookie;
            if (!shouldRun) {
                return;
            }
        }
        if (localStorageMatches.length > 0) {
            var localStorageMatched = localStorageMatches.every((function(str) {
                var itemValue = window.localStorage.getItem(str);
                return itemValue || itemValue === "";
            }));
            var _shouldRun = localStorageMatched !== isInvertedMatchLocalStorage;
            if (!_shouldRun) {
                return;
            }
        }
        var textMatchRegexp = textMatches ? toRegExp(textMatches) : null;
        var selectorsSequence = selectors.split(SELECTORS_DELIMITER).map((function(selector) {
            return selector.trim();
        }));
        var createElementObj = function createElementObj(element, selector) {
            return {
                element: element || null,
                clicked: false,
                selectorText: selector || null
            };
        };
        var elementsSequence = Array(selectorsSequence.length).fill(createElementObj(null));
        var findAndClickElement = function findAndClickElement(elementObj) {
            try {
                if (!elementObj.selectorText) {
                    return;
                }
                var element = queryShadowSelector(elementObj.selectorText);
                if (!element) {
                    logMessage(source, `Could not find element: '${elementObj.selectorText}'`);
                    return;
                }
                element.click();
                elementObj.clicked = true;
            } catch (error) {
                logMessage(source, `Could not click element: '${elementObj.selectorText}'`);
            }
        };
        var shouldReloadAfterClick = false;
        var reloadDelayMs = STATIC_RELOAD_DELAY_MS;
        if (reload) {
            var reloadSplit = reload.split(COLON);
            var reloadMarker = reloadSplit[0];
            var reloadValue = reloadSplit[1];
            if (reloadMarker !== RELOAD_ON_FINAL_CLICK_MARKER) {
                logMessage(source, `Passed reload option '${reload}' is invalid`);
                return;
            }
            if (reloadValue) {
                var passedReload = Number(reloadValue);
                if (Number.isNaN(passedReload)) {
                    logMessage(source, `Passed reload delay value '${passedReload}' is invalid`);
                    return;
                }
                if (passedReload > OBSERVER_TIMEOUT_MS) {
                    logMessage(source, `Passed reload delay value '${passedReload}' is bigger than maximum ${OBSERVER_TIMEOUT_MS} ms`);
                    return;
                }
                reloadDelayMs = passedReload;
            }
            shouldReloadAfterClick = true;
        }
        var canReload = true;
        var clickElementsBySequence = async function clickElementsBySequence() {
            for (var i = 0; i < elementsSequence.length; i += 1) {
                var elementObj = elementsSequence[i];
                if (i >= 1) {
                    await sleep(STATIC_CLICK_DELAY_MS);
                }
                if (!elementObj.element) {
                    break;
                }
                if (!elementObj.clicked) {
                    if (elementObj.element.isConnected) {
                        elementObj.element.click();
                        elementObj.clicked = true;
                    } else {
                        findAndClickElement(elementObj);
                    }
                }
            }
            var allElementsClicked = elementsSequence.every((function(elementObj) {
                return elementObj.clicked === true;
            }));
            if (allElementsClicked) {
                if (shouldReloadAfterClick && canReload) {
                    canReload = false;
                    setTimeout((function() {
                        window.location.reload();
                    }), reloadDelayMs);
                }
                hit(source);
            }
        };
        var handleElement = function handleElement(element, i, selector) {
            var elementObj = createElementObj(element, selector);
            elementsSequence[i] = elementObj;
            if (canClick) {
                clickElementsBySequence();
            }
        };
        var fulfillAndHandleSelectors = function fulfillAndHandleSelectors() {
            var fulfilledSelectors = [];
            selectorsSequence.forEach((function(selector, i) {
                if (!selector) {
                    return;
                }
                var element = queryShadowSelector(selector, document.documentElement, textMatchRegexp);
                if (!element) {
                    return;
                }
                handleElement(element, i, selector);
                fulfilledSelectors.push(selector);
            }));
            selectorsSequence = selectorsSequence.map((function(selector) {
                return selector && fulfilledSelectors.includes(selector) ? null : selector;
            }));
            return selectorsSequence;
        };
        var findElements = function findElements(mutations, observer) {
            selectorsSequence = fulfillAndHandleSelectors();
            var allSelectorsFulfilled = selectorsSequence.every((function(selector) {
                return selector === null;
            }));
            if (allSelectorsFulfilled) {
                observer.disconnect();
            }
        };
        var initializeMutationObserver = function initializeMutationObserver() {
            var observer = new MutationObserver(throttle(findElements, THROTTLE_DELAY_MS));
            observer.observe(document.documentElement, {
                attributes: true,
                childList: true,
                subtree: true
            });
            setTimeout((function() {
                return observer.disconnect();
            }), OBSERVER_TIMEOUT_MS);
        };
        var checkInitialElements = function checkInitialElements() {
            var foundElements = selectorsSequence.every((function(selector) {
                if (!selector) {
                    return false;
                }
                var element = queryShadowSelector(selector, document.documentElement, textMatchRegexp);
                return !!element;
            }));
            if (foundElements) {
                fulfillAndHandleSelectors();
            } else {
                initializeMutationObserver();
            }
        };
        checkInitialElements();
        if (parsedDelay) {
            setTimeout((function() {
                clickElementsBySequence();
                canClick = true;
            }), parsedDelay);
        }
    }
    function hit(source) {
        var ADGUARD_PREFIX = "[AdGuard]";
        if (!source.verbose) {
            return;
        }
        try {
            var trace = console.trace.bind(console);
            var label = `${ADGUARD_PREFIX} `;
            if (source.engine === "corelibs") {
                label += source.ruleText;
            } else {
                if (source.domainName) {
                    label += `${source.domainName}`;
                }
                if (source.args) {
                    label += `#%#//scriptlet('${source.name}', '${source.args.join("', '")}')`;
                } else {
                    label += `#%#//scriptlet('${source.name}')`;
                }
            }
            if (trace) {
                trace(label);
            }
        } catch (e) {}
        if (typeof window.__debug === "function") {
            window.__debug(source);
        }
    }
    function toRegExp(rawInput) {
        var input = rawInput || "";
        var DEFAULT_VALUE = ".?";
        var FORWARD_SLASH = "/";
        if (input === "") {
            return new RegExp(DEFAULT_VALUE);
        }
        var delimiterIndex = input.lastIndexOf(FORWARD_SLASH);
        var flagsPart = input.substring(delimiterIndex + 1);
        var regExpPart = input.substring(0, delimiterIndex + 1);
        var isValidRegExpFlag = function isValidRegExpFlag(flag) {
            if (!flag) {
                return false;
            }
            try {
                new RegExp("", flag);
                return true;
            } catch (ex) {
                return false;
            }
        };
        var getRegExpFlags = function getRegExpFlags(regExpStr, flagsStr) {
            if (regExpStr.startsWith(FORWARD_SLASH) && regExpStr.endsWith(FORWARD_SLASH) && !regExpStr.endsWith("\\/") && isValidRegExpFlag(flagsStr)) {
                return flagsStr;
            }
            return "";
        };
        var flags = getRegExpFlags(regExpPart, flagsPart);
        if (input.startsWith(FORWARD_SLASH) && input.endsWith(FORWARD_SLASH) || flags) {
            var regExpInput = flags ? regExpPart : input;
            return new RegExp(regExpInput.slice(1, -1), flags);
        }
        var escaped = input.replace(/\\'/g, "'").replace(/\\"/g, '"').replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
        return new RegExp(escaped);
    }
    function parseCookieString(cookieString) {
        var COOKIE_DELIMITER = "=";
        var COOKIE_PAIRS_DELIMITER = ";";
        var cookieChunks = cookieString.split(COOKIE_PAIRS_DELIMITER);
        var cookieData = {};
        cookieChunks.forEach((function(singleCookie) {
            var cookieKey;
            var cookieValue = "";
            var delimiterIndex = singleCookie.indexOf(COOKIE_DELIMITER);
            if (delimiterIndex === -1) {
                cookieKey = singleCookie.trim();
            } else {
                cookieKey = singleCookie.slice(0, delimiterIndex).trim();
                cookieValue = singleCookie.slice(delimiterIndex + 1);
            }
            cookieData[cookieKey] = cookieValue || null;
        }));
        return cookieData;
    }
    function throttle(cb, delay) {
        var wait = false;
        var savedArgs;
        var _wrapper = function wrapper() {
            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                args[_key] = arguments[_key];
            }
            if (wait) {
                savedArgs = args;
                return;
            }
            cb(...args);
            wait = true;
            setTimeout((function() {
                wait = false;
                if (savedArgs) {
                    _wrapper(...savedArgs);
                    savedArgs = null;
                }
            }), delay);
        };
        return _wrapper;
    }
    function logMessage(source, message) {
        var forced = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
        var convertMessageToString = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
        var {name: name, verbose: verbose} = source;
        if (!forced && !verbose) {
            return;
        }
        var nativeConsole = console.log;
        if (!convertMessageToString) {
            nativeConsole(`${name}:`, message);
            return;
        }
        nativeConsole(`${name}: ${message}`);
    }
    function parseMatchArg(match) {
        var INVERT_MARKER = "!";
        var isInvertedMatch = match ? match === null || match === void 0 ? void 0 : match.startsWith(INVERT_MARKER) : false;
        var matchValue = isInvertedMatch ? match.slice(1) : match;
        var matchRegexp = toRegExp(matchValue);
        return {
            isInvertedMatch: isInvertedMatch,
            matchRegexp: matchRegexp,
            matchValue: matchValue
        };
    }
    function queryShadowSelector(selector) {
        var context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : document.documentElement;
        var textContent = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
        var SHADOW_COMBINATOR = " >>> ";
        var pos = selector.indexOf(SHADOW_COMBINATOR);
        if (pos === -1) {
            if (textContent) {
                return findElementWithText(context, selector, textContent);
            }
            return context.querySelector(selector);
        }
        var shadowHostSelector = selector.slice(0, pos).trim();
        var elem = context.querySelector(shadowHostSelector);
        if (!elem || !elem.shadowRoot) {
            return null;
        }
        var shadowRootSelector = selector.slice(pos + SHADOW_COMBINATOR.length).trim();
        return queryShadowSelector(shadowRootSelector, elem.shadowRoot, textContent);
    }
    function doesElementContainText(element, matchRegexp) {
        var {textContent: textContent} = element;
        if (!textContent) {
            return false;
        }
        return matchRegexp.test(textContent);
    }
    function findElementWithText(rootElement, selector, matchRegexp) {
        var elements = rootElement.querySelectorAll(selector);
        for (var i = 0; i < elements.length; i += 1) {
            if (doesElementContainText(elements[i], matchRegexp)) {
                return elements[i];
            }
        }
        return null;
    }
    var updatedArgs = args ? [].concat(source).concat(args) : [ source ];
    try {
        trustedClickElement.apply(this, updatedArgs);
        if (source.uniqueId) {
            Object.defineProperty(Window.prototype.toString, uniqueIdentifier, {
                value: flag,
                enumerable: false,
                writable: false,
                configurable: false
            });
        }
    } catch (e) {
        console.log(e);
    }
}

function trustedCreateElement(source, args) {
    var flag = "done";
    var uniqueIdentifier = source.uniqueId + source.name + "_" + (Array.isArray(args) ? args.join("_") : "");
    if (source.uniqueId) {
        if (Window.prototype.toString[uniqueIdentifier] === flag) {
            return;
        }
    }
    function trustedCreateElement(source, parentSelector, tagName) {
        var attributePairs = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : "";
        var textContent = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : "";
        var cleanupDelayMs = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : NaN;
        if (!parentSelector || !tagName) {
            return;
        }
        var IFRAME_WINDOW_NAME = "trusted-create-element-window";
        if (window.name === IFRAME_WINDOW_NAME) {
            return;
        }
        var logError = function logError(prefix, error) {
            logMessage(source, `${prefix} due to ${getErrorMessage(error)}`);
        };
        var element;
        try {
            element = document.createElement(tagName);
            element.textContent = textContent;
        } catch (e) {
            logError(`Cannot create element with tag name '${tagName}'`, e);
            return;
        }
        var attributes = [];
        try {
            attributes = parseAttributePairs(attributePairs);
        } catch (e) {
            logError(`Cannot parse attributePairs param: '${attributePairs}'`, e);
            return;
        }
        attributes.forEach((function(attr) {
            try {
                element.setAttribute(attr.name, attr.value);
            } catch (e) {
                logError(`Cannot set attribute '${attr.name}' with value '${attr.value}'`, e);
            }
        }));
        var timerId;
        var elementCreated = false;
        var elementRemoved = false;
        var findParentAndAppendEl = function findParentAndAppendEl(parentElSelector, el, removeElDelayMs) {
            var parentEl;
            try {
                parentEl = document.querySelector(parentElSelector);
            } catch (e) {
                logError(`Cannot find parent element by selector '${parentElSelector}'`, e);
                return false;
            }
            if (!parentEl) {
                logMessage(source, `No parent element found by selector: '${parentElSelector}'`);
                return false;
            }
            try {
                if (!parentEl.contains(el)) {
                    parentEl.append(el);
                }
                if (el instanceof HTMLIFrameElement && el.contentWindow) {
                    el.contentWindow.name = IFRAME_WINDOW_NAME;
                }
                elementCreated = true;
                hit(source);
            } catch (e) {
                logError(`Cannot append child to parent by selector '${parentElSelector}'`, e);
                return false;
            }
            if (!nativeIsNaN(removeElDelayMs)) {
                timerId = setTimeout((function() {
                    el.remove();
                    elementRemoved = true;
                    clearTimeout(timerId);
                }), removeElDelayMs);
            }
            return true;
        };
        if (!findParentAndAppendEl(parentSelector, element, cleanupDelayMs)) {
            observeDocumentWithTimeout((function(mutations, observer) {
                if (elementRemoved || elementCreated || findParentAndAppendEl(parentSelector, element, cleanupDelayMs)) {
                    observer.disconnect();
                }
            }));
        }
    }
    function hit(source) {
        var ADGUARD_PREFIX = "[AdGuard]";
        if (!source.verbose) {
            return;
        }
        try {
            var trace = console.trace.bind(console);
            var label = `${ADGUARD_PREFIX} `;
            if (source.engine === "corelibs") {
                label += source.ruleText;
            } else {
                if (source.domainName) {
                    label += `${source.domainName}`;
                }
                if (source.args) {
                    label += `#%#//scriptlet('${source.name}', '${source.args.join("', '")}')`;
                } else {
                    label += `#%#//scriptlet('${source.name}')`;
                }
            }
            if (trace) {
                trace(label);
            }
        } catch (e) {}
        if (typeof window.__debug === "function") {
            window.__debug(source);
        }
    }
    function logMessage(source, message) {
        var forced = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
        var convertMessageToString = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
        var {name: name, verbose: verbose} = source;
        if (!forced && !verbose) {
            return;
        }
        var nativeConsole = console.log;
        if (!convertMessageToString) {
            nativeConsole(`${name}:`, message);
            return;
        }
        nativeConsole(`${name}: ${message}`);
    }
    function observeDocumentWithTimeout(callback) {
        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {
            subtree: true,
            childList: true
        };
        var timeout = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1e4;
        var documentObserver = new MutationObserver((function(mutations, observer) {
            observer.disconnect();
            callback(mutations, observer);
            observer.observe(document.documentElement, options);
        }));
        documentObserver.observe(document.documentElement, options);
        if (typeof timeout === "number") {
            setTimeout((function() {
                return documentObserver.disconnect();
            }), timeout);
        }
    }
    function nativeIsNaN(num) {
        var native = Number.isNaN || window.isNaN;
        return native(num);
    }
    function parseAttributePairs(input) {
        if (!input) {
            return [];
        }
        var NAME_VALUE_SEPARATOR = "=";
        var PAIRS_SEPARATOR = " ";
        var SINGLE_QUOTE = "'";
        var DOUBLE_QUOTE = '"';
        var BACKSLASH = "\\";
        var pairs = [];
        for (var i = 0; i < input.length; i += 1) {
            var name = "";
            var value = "";
            while (i < input.length && input[i] !== NAME_VALUE_SEPARATOR && input[i] !== PAIRS_SEPARATOR) {
                name += input[i];
                i += 1;
            }
            if (i < input.length && input[i] === NAME_VALUE_SEPARATOR) {
                i += 1;
                var quote = null;
                if (input[i] === SINGLE_QUOTE || input[i] === DOUBLE_QUOTE) {
                    quote = input[i];
                    i += 1;
                    for (;i < input.length; i += 1) {
                        if (input[i] === quote) {
                            if (input[i - 1] === BACKSLASH) {
                                value = `${value.slice(0, -1)}${quote}`;
                            } else {
                                i += 1;
                                quote = null;
                                break;
                            }
                        } else {
                            value += input[i];
                        }
                    }
                    if (quote !== null) {
                        throw new Error(`Unbalanced quote for attribute value: '${input}'`);
                    }
                } else {
                    throw new Error(`Attribute value should be quoted: "${input.slice(i)}"`);
                }
            }
            name = name.trim();
            value = value.trim();
            if (!name) {
                if (!value) {
                    continue;
                }
                throw new Error(`Attribute name before '=' should be specified: '${input}'`);
            }
            pairs.push({
                name: name,
                value: value
            });
            if (input[i] && input[i] !== PAIRS_SEPARATOR) {
                throw new Error(`No space before attribute: '${input.slice(i)}'`);
            }
        }
        return pairs;
    }
    function getErrorMessage(error) {
        var isErrorWithMessage = function isErrorWithMessage(e) {
            return typeof e === "object" && e !== null && "message" in e && typeof e.message === "string";
        };
        if (isErrorWithMessage(error)) {
            return error.message;
        }
        try {
            return new Error(JSON.stringify(error)).message;
        } catch (_unused) {
            return new Error(String(error)).message;
        }
    }
    var updatedArgs = args ? [].concat(source).concat(args) : [ source ];
    try {
        trustedCreateElement.apply(this, updatedArgs);
        if (source.uniqueId) {
            Object.defineProperty(Window.prototype.toString, uniqueIdentifier, {
                value: flag,
                enumerable: false,
                writable: false,
                configurable: false
            });
        }
    } catch (e) {
        console.log(e);
    }
}

function trustedDispatchEvent(source, args) {
    var flag = "done";
    var uniqueIdentifier = source.uniqueId + source.name + "_" + (Array.isArray(args) ? args.join("_") : "");
    if (source.uniqueId) {
        if (Window.prototype.toString[uniqueIdentifier] === flag) {
            return;
        }
    }
    function trustedDispatchEvent(source, event, target) {
        if (!event) {
            return;
        }
        var hasBeenDispatched = false;
        var eventTarget = document;
        if (target === "window") {
            eventTarget = window;
        }
        var events = new Set;
        var dispatch = function dispatch() {
            var customEvent = new Event(event);
            if (typeof target === "string" && target !== "window") {
                eventTarget = document.querySelector(target);
            }
            var isEventAdded = events.has(event);
            if (!hasBeenDispatched && isEventAdded && eventTarget) {
                hasBeenDispatched = true;
                hit(source);
                eventTarget.dispatchEvent(customEvent);
            }
        };
        var wrapper = function wrapper(eventListener, thisArg, args) {
            var eventName = args[0];
            if (thisArg && eventName) {
                events.add(eventName);
                setTimeout((function() {
                    dispatch();
                }), 1);
            }
            return Reflect.apply(eventListener, thisArg, args);
        };
        var handler = {
            apply: wrapper
        };
        EventTarget.prototype.addEventListener = new Proxy(EventTarget.prototype.addEventListener, handler);
    }
    function hit(source) {
        var ADGUARD_PREFIX = "[AdGuard]";
        if (!source.verbose) {
            return;
        }
        try {
            var trace = console.trace.bind(console);
            var label = `${ADGUARD_PREFIX} `;
            if (source.engine === "corelibs") {
                label += source.ruleText;
            } else {
                if (source.domainName) {
                    label += `${source.domainName}`;
                }
                if (source.args) {
                    label += `#%#//scriptlet('${source.name}', '${source.args.join("', '")}')`;
                } else {
                    label += `#%#//scriptlet('${source.name}')`;
                }
            }
            if (trace) {
                trace(label);
            }
        } catch (e) {}
        if (typeof window.__debug === "function") {
            window.__debug(source);
        }
    }
    var updatedArgs = args ? [].concat(source).concat(args) : [ source ];
    try {
        trustedDispatchEvent.apply(this, updatedArgs);
        if (source.uniqueId) {
            Object.defineProperty(Window.prototype.toString, uniqueIdentifier, {
                value: flag,
                enumerable: false,
                writable: false,
                configurable: false
            });
        }
    } catch (e) {
        console.log(e);
    }
}

function trustedPruneInboundObject(source, args) {
    var flag = "done";
    var uniqueIdentifier = source.uniqueId + source.name + "_" + (Array.isArray(args) ? args.join("_") : "");
    if (source.uniqueId) {
        if (Window.prototype.toString[uniqueIdentifier] === flag) {
            return;
        }
    }
    function trustedPruneInboundObject(source, functionName, propsToRemove, requiredInitialProps) {
        var stack = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : "";
        if (!functionName) {
            return;
        }
        var nativeObjects = {
            nativeStringify: window.JSON.stringify
        };
        var {base: base, prop: prop} = getPropertyInChain(window, functionName);
        if (!base || !prop || typeof base[prop] !== "function") {
            var message = `${functionName} is not a function`;
            logMessage(source, message);
            return;
        }
        var prunePaths = getPrunePath(propsToRemove);
        var requiredPaths = getPrunePath(requiredInitialProps);
        var objectWrapper = function objectWrapper(target, thisArg, args) {
            var data = args[0];
            if (typeof data === "object") {
                data = jsonPruner(source, data, prunePaths, requiredPaths, stack, nativeObjects);
                args[0] = data;
            }
            return Reflect.apply(target, thisArg, args);
        };
        var objectHandler = {
            apply: objectWrapper
        };
        base[prop] = new Proxy(base[prop], objectHandler);
    }
    function hit(source) {
        var ADGUARD_PREFIX = "[AdGuard]";
        if (!source.verbose) {
            return;
        }
        try {
            var trace = console.trace.bind(console);
            var label = `${ADGUARD_PREFIX} `;
            if (source.engine === "corelibs") {
                label += source.ruleText;
            } else {
                if (source.domainName) {
                    label += `${source.domainName}`;
                }
                if (source.args) {
                    label += `#%#//scriptlet('${source.name}', '${source.args.join("', '")}')`;
                } else {
                    label += `#%#//scriptlet('${source.name}')`;
                }
            }
            if (trace) {
                trace(label);
            }
        } catch (e) {}
        if (typeof window.__debug === "function") {
            window.__debug(source);
        }
    }
    function matchStackTrace(stackMatch, stackTrace) {
        if (!stackMatch || stackMatch === "") {
            return true;
        }
        var regExpValues = backupRegExpValues();
        if (shouldAbortInlineOrInjectedScript(stackMatch, stackTrace)) {
            if (regExpValues.length && regExpValues[0] !== RegExp.$1) {
                restoreRegExpValues(regExpValues);
            }
            return true;
        }
        var stackRegexp = toRegExp(stackMatch);
        var refinedStackTrace = stackTrace.split("\n").slice(2).map((function(line) {
            return line.trim();
        })).join("\n");
        if (regExpValues.length && regExpValues[0] !== RegExp.$1) {
            restoreRegExpValues(regExpValues);
        }
        return getNativeRegexpTest().call(stackRegexp, refinedStackTrace);
    }
    function getPropertyInChain(base, chain) {
        var pos = chain.indexOf(".");
        if (pos === -1) {
            return {
                base: base,
                prop: chain
            };
        }
        var prop = chain.slice(0, pos);
        if (base === null) {
            return {
                base: base,
                prop: prop,
                chain: chain
            };
        }
        var nextBase = base[prop];
        chain = chain.slice(pos + 1);
        if ((base instanceof Object || typeof base === "object") && isEmptyObject(base)) {
            return {
                base: base,
                prop: prop,
                chain: chain
            };
        }
        if (nextBase === null) {
            return {
                base: base,
                prop: prop,
                chain: chain
            };
        }
        if (nextBase !== undefined) {
            return getPropertyInChain(nextBase, chain);
        }
        Object.defineProperty(base, prop, {
            configurable: true
        });
        return {
            base: base,
            prop: prop,
            chain: chain
        };
    }
    function getWildcardPropertyInChain(base, chain) {
        var lookThrough = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
        var output = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [];
        var valueToCheck = arguments.length > 4 ? arguments[4] : undefined;
        var pos = chain.indexOf(".");
        if (pos === -1) {
            if (chain === "*" || chain === "[]") {
                for (var key in base) {
                    if (Object.prototype.hasOwnProperty.call(base, key)) {
                        if (valueToCheck !== undefined) {
                            var objectValue = base[key];
                            if (typeof objectValue === "string" && valueToCheck instanceof RegExp) {
                                if (valueToCheck.test(objectValue)) {
                                    output.push({
                                        base: base,
                                        prop: key
                                    });
                                }
                            } else if (objectValue === valueToCheck) {
                                output.push({
                                    base: base,
                                    prop: key
                                });
                            }
                        } else {
                            output.push({
                                base: base,
                                prop: key
                            });
                        }
                    }
                }
            } else if (valueToCheck !== undefined) {
                var _objectValue = base[chain];
                if (typeof _objectValue === "string" && valueToCheck instanceof RegExp) {
                    if (valueToCheck.test(_objectValue)) {
                        output.push({
                            base: base,
                            prop: chain
                        });
                    }
                } else if (base[chain] === valueToCheck) {
                    output.push({
                        base: base,
                        prop: chain
                    });
                }
            } else {
                output.push({
                    base: base,
                    prop: chain
                });
            }
            return output;
        }
        var prop = chain.slice(0, pos);
        var shouldLookThrough = prop === "[]" && Array.isArray(base) || prop === "*" && base instanceof Object || prop === "[-]" && Array.isArray(base) || prop === "{-}" && base instanceof Object;
        if (shouldLookThrough) {
            var nextProp = chain.slice(pos + 1);
            var baseKeys = Object.keys(base);
            if (prop === "{-}" || prop === "[-]") {
                var type = Array.isArray(base) ? "array" : "object";
                var shouldRemove = !!(prop === "{-}" && type === "object") || !!(prop === "[-]" && type === "array");
                if (!shouldRemove) {
                    return output;
                }
                baseKeys.forEach((function(key) {
                    var item = base[key];
                    if (isKeyInObject(item, nextProp, valueToCheck)) {
                        output.push({
                            base: base,
                            prop: key
                        });
                    }
                }));
                return output;
            }
            baseKeys.forEach((function(key) {
                var item = base[key];
                getWildcardPropertyInChain(item, nextProp, lookThrough, output, valueToCheck);
            }));
        }
        if (Array.isArray(base)) {
            base.forEach((function(key) {
                var nextBase = key;
                if (nextBase !== undefined) {
                    getWildcardPropertyInChain(nextBase, chain, lookThrough, output, valueToCheck);
                }
            }));
        }
        var nextBase = base[prop];
        chain = chain.slice(pos + 1);
        if (nextBase !== undefined) {
            getWildcardPropertyInChain(nextBase, chain, lookThrough, output, valueToCheck);
        }
        return output;
    }
    function logMessage(source, message) {
        var forced = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
        var convertMessageToString = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
        var {name: name, verbose: verbose} = source;
        if (!forced && !verbose) {
            return;
        }
        var nativeConsole = console.log;
        if (!convertMessageToString) {
            nativeConsole(`${name}:`, message);
            return;
        }
        nativeConsole(`${name}: ${message}`);
    }
    function isPruningNeeded(source, root, prunePaths, requiredPaths, stack, nativeObjects) {
        if (!root) {
            return false;
        }
        var {nativeStringify: nativeStringify} = nativeObjects;
        var shouldProcess;
        var prunePathsToCheck = prunePaths.map((function(obj) {
            return obj.path;
        }));
        var requiredPathsToCheck = requiredPaths.map((function(obj) {
            return obj.path;
        }));
        if (prunePathsToCheck.length === 0 && requiredPathsToCheck.length > 0) {
            var rootString = nativeStringify(root);
            var matchRegex = toRegExp(requiredPathsToCheck.join(""));
            var shouldLog = matchRegex.test(rootString);
            if (shouldLog) {
                logMessage(source, `${window.location.hostname}\n${nativeStringify(root, null, 2)}\nStack trace:\n${(new Error).stack}`, true);
                if (root && typeof root === "object") {
                    logMessage(source, root, true, false);
                }
                shouldProcess = false;
                return shouldProcess;
            }
        }
        if (stack && !matchStackTrace(stack, (new Error).stack || "")) {
            shouldProcess = false;
            return shouldProcess;
        }
        var wildcardSymbols = [ ".*.", "*.", ".*", ".[].", "[].", ".[]" ];
        var _loop = function _loop() {
            var requiredPath = requiredPathsToCheck[i];
            var lastNestedPropName = requiredPath.split(".").pop();
            var hasWildcard = wildcardSymbols.some((function(symbol) {
                return requiredPath.includes(symbol);
            }));
            var details = getWildcardPropertyInChain(root, requiredPath, hasWildcard);
            if (!details.length) {
                shouldProcess = false;
                return {
                    v: shouldProcess
                };
            }
            shouldProcess = !hasWildcard;
            for (var j = 0; j < details.length; j += 1) {
                var hasRequiredProp = typeof lastNestedPropName === "string" && details[j].base[lastNestedPropName] !== undefined;
                if (hasWildcard) {
                    shouldProcess = hasRequiredProp || shouldProcess;
                } else {
                    shouldProcess = hasRequiredProp && shouldProcess;
                }
            }
        }, _ret;
        for (var i = 0; i < requiredPathsToCheck.length; i += 1) {
            _ret = _loop();
            if (_ret) return _ret.v;
        }
        return shouldProcess;
    }
    function jsonPruner(source, root, prunePaths, requiredPaths, stack, nativeObjects) {
        var {nativeStringify: nativeStringify} = nativeObjects;
        if (prunePaths.length === 0 && requiredPaths.length === 0) {
            logMessage(source, `${window.location.hostname}\n${nativeStringify(root, null, 2)}\nStack trace:\n${(new Error).stack}`, true);
            if (root && typeof root === "object") {
                logMessage(source, root, true, false);
            }
            return root;
        }
        try {
            if (isPruningNeeded(source, root, prunePaths, requiredPaths, stack, nativeObjects) === false) {
                return root;
            }
            prunePaths.forEach((function(path) {
                var pathToCheck = path.path;
                var valueToCheck = path.value;
                var ownerObjArr = getWildcardPropertyInChain(root, pathToCheck, true, [], valueToCheck);
                for (var i = ownerObjArr.length - 1; i >= 0; i -= 1) {
                    var ownerObj = ownerObjArr[i];
                    if (ownerObj === undefined || !ownerObj.base) {
                        continue;
                    }
                    hit(source);
                    if (!Array.isArray(ownerObj.base)) {
                        delete ownerObj.base[ownerObj.prop];
                        continue;
                    }
                    try {
                        var index = Number(ownerObj.prop);
                        if (Number.isNaN(index)) {
                            continue;
                        }
                        ownerObj.base.splice(index, 1);
                    } catch (error) {
                        console.error("Error while deleting array element", error);
                    }
                }
            }));
        } catch (e) {
            logMessage(source, e);
        }
        return root;
    }
    function getPrunePath(props) {
        var VALUE_MARKER = ".[=].";
        var REGEXP_START_MARKER = "/";
        var validPropsString = typeof props === "string" && props !== undefined && props !== "";
        if (validPropsString) {
            var splitRegexp = /(?<!\.\[=\]\.\/(?:[^/]|\\.)*)\s+/;
            var parts = props.split(splitRegexp).map((function(part) {
                var splitPart = part.split(VALUE_MARKER);
                var path = splitPart[0];
                var value = splitPart[1];
                if (value !== undefined) {
                    if (value === "true") {
                        value = true;
                    } else if (value === "false") {
                        value = false;
                    } else if (value.startsWith(REGEXP_START_MARKER)) {
                        value = toRegExp(value);
                    } else if (typeof value === "string" && /^\d+$/.test(value)) {
                        value = parseFloat(value);
                    }
                    return {
                        path: path,
                        value: value
                    };
                }
                return {
                    path: path
                };
            }));
            return parts;
        }
        return [];
    }
    function toRegExp(rawInput) {
        var input = rawInput || "";
        var DEFAULT_VALUE = ".?";
        var FORWARD_SLASH = "/";
        if (input === "") {
            return new RegExp(DEFAULT_VALUE);
        }
        var delimiterIndex = input.lastIndexOf(FORWARD_SLASH);
        var flagsPart = input.substring(delimiterIndex + 1);
        var regExpPart = input.substring(0, delimiterIndex + 1);
        var isValidRegExpFlag = function isValidRegExpFlag(flag) {
            if (!flag) {
                return false;
            }
            try {
                new RegExp("", flag);
                return true;
            } catch (ex) {
                return false;
            }
        };
        var getRegExpFlags = function getRegExpFlags(regExpStr, flagsStr) {
            if (regExpStr.startsWith(FORWARD_SLASH) && regExpStr.endsWith(FORWARD_SLASH) && !regExpStr.endsWith("\\/") && isValidRegExpFlag(flagsStr)) {
                return flagsStr;
            }
            return "";
        };
        var flags = getRegExpFlags(regExpPart, flagsPart);
        if (input.startsWith(FORWARD_SLASH) && input.endsWith(FORWARD_SLASH) || flags) {
            var regExpInput = flags ? regExpPart : input;
            return new RegExp(regExpInput.slice(1, -1), flags);
        }
        var escaped = input.replace(/\\'/g, "'").replace(/\\"/g, '"').replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
        return new RegExp(escaped);
    }
    function getNativeRegexpTest() {
        var descriptor = Object.getOwnPropertyDescriptor(RegExp.prototype, "test");
        var nativeRegexTest = descriptor === null || descriptor === void 0 ? void 0 : descriptor.value;
        if (descriptor && typeof descriptor.value === "function") {
            return nativeRegexTest;
        }
        throw new Error("RegExp.prototype.test is not a function");
    }
    function shouldAbortInlineOrInjectedScript(stackMatch, stackTrace) {
        var INLINE_SCRIPT_STRING = "inlineScript";
        var INJECTED_SCRIPT_STRING = "injectedScript";
        var INJECTED_SCRIPT_MARKER = "<anonymous>";
        var isInlineScript = function isInlineScript(match) {
            return match.includes(INLINE_SCRIPT_STRING);
        };
        var isInjectedScript = function isInjectedScript(match) {
            return match.includes(INJECTED_SCRIPT_STRING);
        };
        if (!(isInlineScript(stackMatch) || isInjectedScript(stackMatch))) {
            return false;
        }
        var documentURL = window.location.href;
        var pos = documentURL.indexOf("#");
        if (pos !== -1) {
            documentURL = documentURL.slice(0, pos);
        }
        var stackSteps = stackTrace.split("\n").slice(2).map((function(line) {
            return line.trim();
        }));
        var stackLines = stackSteps.map((function(line) {
            var stack;
            var getStackTraceValues = /(.*?@)?(\S+)(:\d+)(:\d+)\)?$/.exec(line);
            if (getStackTraceValues) {
                var _stackURL, _stackURL2;
                var stackURL = getStackTraceValues[2];
                var stackLine = getStackTraceValues[3];
                var stackCol = getStackTraceValues[4];
                if ((_stackURL = stackURL) !== null && _stackURL !== void 0 && _stackURL.startsWith("(")) {
                    stackURL = stackURL.slice(1);
                }
                if ((_stackURL2 = stackURL) !== null && _stackURL2 !== void 0 && _stackURL2.startsWith(INJECTED_SCRIPT_MARKER)) {
                    var _stackFunction;
                    stackURL = INJECTED_SCRIPT_STRING;
                    var stackFunction = getStackTraceValues[1] !== undefined ? getStackTraceValues[1].slice(0, -1) : line.slice(0, getStackTraceValues.index).trim();
                    if ((_stackFunction = stackFunction) !== null && _stackFunction !== void 0 && _stackFunction.startsWith("at")) {
                        stackFunction = stackFunction.slice(2).trim();
                    }
                    stack = `${stackFunction} ${stackURL}${stackLine}${stackCol}`.trim();
                } else if (stackURL === documentURL) {
                    stack = `${INLINE_SCRIPT_STRING}${stackLine}${stackCol}`.trim();
                } else {
                    stack = `${stackURL}${stackLine}${stackCol}`.trim();
                }
            } else {
                stack = line;
            }
            return stack;
        }));
        if (stackLines) {
            for (var index = 0; index < stackLines.length; index += 1) {
                if (isInlineScript(stackMatch) && stackLines[index].startsWith(INLINE_SCRIPT_STRING) && stackLines[index].match(toRegExp(stackMatch))) {
                    return true;
                }
                if (isInjectedScript(stackMatch) && stackLines[index].startsWith(INJECTED_SCRIPT_STRING) && stackLines[index].match(toRegExp(stackMatch))) {
                    return true;
                }
            }
        }
        return false;
    }
    function isEmptyObject(obj) {
        return Object.keys(obj).length === 0 && !obj.prototype;
    }
    function backupRegExpValues() {
        try {
            var arrayOfRegexpValues = [];
            for (var index = 1; index < 10; index += 1) {
                var value = `$${index}`;
                if (!RegExp[value]) {
                    break;
                }
                arrayOfRegexpValues.push(RegExp[value]);
            }
            return arrayOfRegexpValues;
        } catch (error) {
            return [];
        }
    }
    function restoreRegExpValues(array) {
        if (!array.length) {
            return;
        }
        try {
            var stringPattern = "";
            if (array.length === 1) {
                stringPattern = `(${array[0]})`;
            } else {
                stringPattern = array.reduce((function(accumulator, currentValue, currentIndex) {
                    if (currentIndex === 1) {
                        return `(${accumulator}),(${currentValue})`;
                    }
                    return `${accumulator},(${currentValue})`;
                }));
            }
            var regExpGroup = new RegExp(stringPattern);
            array.toString().replace(regExpGroup, "");
        } catch (error) {
            var message = `Failed to restore RegExp values: ${error}`;
            console.log(message);
        }
    }
    function isKeyInObject(baseObj, path, valueToCheck) {
        var parts = path.split(".");
        var _check = function check(targetObject, pathSegments) {
            if (pathSegments.length === 0) {
                if (valueToCheck !== undefined) {
                    if (typeof targetObject === "string" && valueToCheck instanceof RegExp) {
                        return valueToCheck.test(targetObject);
                    }
                    return targetObject === valueToCheck;
                }
                return true;
            }
            var current = pathSegments[0];
            var rest = pathSegments.slice(1);
            if (current === "*" || current === "[]") {
                if (Array.isArray(targetObject)) {
                    return targetObject.some((function(item) {
                        return _check(item, rest);
                    }));
                }
                if (typeof targetObject === "object" && targetObject !== null) {
                    return Object.keys(targetObject).some((function(key) {
                        return _check(targetObject[key], rest);
                    }));
                }
            }
            if (Object.prototype.hasOwnProperty.call(targetObject, current)) {
                return _check(targetObject[current], rest);
            }
            return false;
        };
        return _check(baseObj, parts);
    }
    var updatedArgs = args ? [].concat(source).concat(args) : [ source ];
    try {
        trustedPruneInboundObject.apply(this, updatedArgs);
        if (source.uniqueId) {
            Object.defineProperty(Window.prototype.toString, uniqueIdentifier, {
                value: flag,
                enumerable: false,
                writable: false,
                configurable: false
            });
        }
    } catch (e) {
        console.log(e);
    }
}

function trustedReplaceFetchResponse(source, args) {
    var flag = "done";
    var uniqueIdentifier = source.uniqueId + source.name + "_" + (Array.isArray(args) ? args.join("_") : "");
    if (source.uniqueId) {
        if (Window.prototype.toString[uniqueIdentifier] === flag) {
            return;
        }
    }
    function trustedReplaceFetchResponse(source) {
        var pattern = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "";
        var replacement = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : "";
        var propsToMatch = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : "";
        var verbose = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;
        if (typeof fetch === "undefined" || typeof Proxy === "undefined" || typeof Response === "undefined") {
            return;
        }
        if (pattern === "" && replacement !== "") {
            logMessage(source, "Pattern argument should not be empty string");
            return;
        }
        var shouldLog = pattern === "" && replacement === "";
        var shouldLogContent = verbose === "true";
        var nativeRequestClone = Request.prototype.clone;
        var nativeFetch = fetch;
        var shouldReplace = false;
        var fetchData;
        var handlerWrapper = function handlerWrapper(target, thisArg, args) {
            fetchData = getFetchData(args, nativeRequestClone);
            if (shouldLog) {
                logMessage(source, `fetch( ${objectToString(fetchData)} )`, true);
                hit(source);
                return Reflect.apply(target, thisArg, args);
            }
            shouldReplace = matchRequestProps(source, propsToMatch, fetchData);
            if (!shouldReplace) {
                return Reflect.apply(target, thisArg, args);
            }
            return nativeFetch.apply(null, args).then((function(response) {
                return response.text().then((function(bodyText) {
                    var patternRegexp = pattern === "*" ? /(\n|.)*/ : toRegExp(pattern);
                    if (shouldLogContent) {
                        logMessage(source, `Original text content: ${bodyText}`);
                    }
                    var modifiedTextContent = bodyText.replace(patternRegexp, replacement);
                    if (shouldLogContent) {
                        logMessage(source, `Modified text content: ${modifiedTextContent}`);
                    }
                    var forgedResponse = forgeResponse(response, modifiedTextContent);
                    hit(source);
                    return forgedResponse;
                })).catch((function() {
                    var fetchDataStr = objectToString(fetchData);
                    var message = `Response body can't be converted to text: ${fetchDataStr}`;
                    logMessage(source, message);
                    return Reflect.apply(target, thisArg, args);
                }));
            })).catch((function() {
                return Reflect.apply(target, thisArg, args);
            }));
        };
        var fetchHandler = {
            apply: handlerWrapper
        };
        fetch = new Proxy(fetch, fetchHandler);
    }
    function hit(source) {
        var ADGUARD_PREFIX = "[AdGuard]";
        if (!source.verbose) {
            return;
        }
        try {
            var trace = console.trace.bind(console);
            var label = `${ADGUARD_PREFIX} `;
            if (source.engine === "corelibs") {
                label += source.ruleText;
            } else {
                if (source.domainName) {
                    label += `${source.domainName}`;
                }
                if (source.args) {
                    label += `#%#//scriptlet('${source.name}', '${source.args.join("', '")}')`;
                } else {
                    label += `#%#//scriptlet('${source.name}')`;
                }
            }
            if (trace) {
                trace(label);
            }
        } catch (e) {}
        if (typeof window.__debug === "function") {
            window.__debug(source);
        }
    }
    function logMessage(source, message) {
        var forced = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
        var convertMessageToString = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
        var {name: name, verbose: verbose} = source;
        if (!forced && !verbose) {
            return;
        }
        var nativeConsole = console.log;
        if (!convertMessageToString) {
            nativeConsole(`${name}:`, message);
            return;
        }
        nativeConsole(`${name}: ${message}`);
    }
    function getFetchData(args, nativeRequestClone) {
        var fetchPropsObj = {};
        var resource = args[0];
        var fetchUrl;
        var fetchInit;
        if (resource instanceof Request) {
            var realData = nativeRequestClone.call(resource);
            var requestData = getRequestData(realData);
            fetchUrl = requestData.url;
            fetchInit = requestData;
        } else {
            fetchUrl = resource;
            fetchInit = args[1];
        }
        fetchPropsObj.url = fetchUrl;
        if (fetchInit instanceof Object) {
            var props = Object.keys(fetchInit);
            props.forEach((function(prop) {
                fetchPropsObj[prop] = fetchInit[prop];
            }));
        }
        return fetchPropsObj;
    }
    function objectToString(obj) {
        if (!obj || typeof obj !== "object") {
            return String(obj);
        }
        if (isEmptyObject(obj)) {
            return "{}";
        }
        return Object.entries(obj).map((function(pair) {
            var key = pair[0];
            var value = pair[1];
            var recordValueStr = value;
            if (value instanceof Object) {
                recordValueStr = `{ ${objectToString(value)} }`;
            }
            return `${key}:"${recordValueStr}"`;
        })).join(" ");
    }
    function matchRequestProps(source, propsToMatch, requestData) {
        if (propsToMatch === "" || propsToMatch === "*") {
            return true;
        }
        var isMatched;
        var parsedData = parseMatchProps(propsToMatch);
        if (!isValidParsedData(parsedData)) {
            logMessage(source, `Invalid parameter: ${propsToMatch}`);
            isMatched = false;
        } else {
            var matchData = getMatchPropsData(parsedData);
            var matchKeys = Object.keys(matchData);
            isMatched = matchKeys.every((function(matchKey) {
                var matchValue = matchData[matchKey];
                var dataValue = requestData[matchKey];
                return Object.prototype.hasOwnProperty.call(requestData, matchKey) && typeof dataValue === "string" && (matchValue === null || matchValue === void 0 ? void 0 : matchValue.test(dataValue));
            }));
        }
        return isMatched;
    }
    function forgeResponse(response, textContent) {
        var {bodyUsed: bodyUsed, headers: headers, ok: ok, redirected: redirected, status: status, statusText: statusText, type: type, url: url} = response;
        var forgedResponse = new Response(textContent, {
            status: status,
            statusText: statusText,
            headers: headers
        });
        Object.defineProperties(forgedResponse, {
            url: {
                value: url
            },
            type: {
                value: type
            },
            ok: {
                value: ok
            },
            bodyUsed: {
                value: bodyUsed
            },
            redirected: {
                value: redirected
            }
        });
        return forgedResponse;
    }
    function toRegExp(rawInput) {
        var input = rawInput || "";
        var DEFAULT_VALUE = ".?";
        var FORWARD_SLASH = "/";
        if (input === "") {
            return new RegExp(DEFAULT_VALUE);
        }
        var delimiterIndex = input.lastIndexOf(FORWARD_SLASH);
        var flagsPart = input.substring(delimiterIndex + 1);
        var regExpPart = input.substring(0, delimiterIndex + 1);
        var isValidRegExpFlag = function isValidRegExpFlag(flag) {
            if (!flag) {
                return false;
            }
            try {
                new RegExp("", flag);
                return true;
            } catch (ex) {
                return false;
            }
        };
        var getRegExpFlags = function getRegExpFlags(regExpStr, flagsStr) {
            if (regExpStr.startsWith(FORWARD_SLASH) && regExpStr.endsWith(FORWARD_SLASH) && !regExpStr.endsWith("\\/") && isValidRegExpFlag(flagsStr)) {
                return flagsStr;
            }
            return "";
        };
        var flags = getRegExpFlags(regExpPart, flagsPart);
        if (input.startsWith(FORWARD_SLASH) && input.endsWith(FORWARD_SLASH) || flags) {
            var regExpInput = flags ? regExpPart : input;
            return new RegExp(regExpInput.slice(1, -1), flags);
        }
        var escaped = input.replace(/\\'/g, "'").replace(/\\"/g, '"').replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
        return new RegExp(escaped);
    }
    function isValidStrPattern(input) {
        var FORWARD_SLASH = "/";
        var str = escapeRegExp(input);
        if (input[0] === FORWARD_SLASH && input[input.length - 1] === FORWARD_SLASH) {
            str = input.slice(1, -1);
        }
        var isValid;
        try {
            isValid = new RegExp(str);
            isValid = true;
        } catch (e) {
            isValid = false;
        }
        return isValid;
    }
    function escapeRegExp(str) {
        return str.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
    }
    function isEmptyObject(obj) {
        return Object.keys(obj).length === 0 && !obj.prototype;
    }
    function getRequestData(request) {
        var requestInitOptions = getRequestProps();
        var entries = requestInitOptions.map((function(key) {
            var value = request[key];
            return [ key, value ];
        }));
        return Object.fromEntries(entries);
    }
    function getRequestProps() {
        return [ "url", "method", "headers", "body", "credentials", "cache", "redirect", "referrer", "referrerPolicy", "integrity", "keepalive", "signal", "mode" ];
    }
    function parseMatchProps(propsToMatchStr) {
        var PROPS_DIVIDER = " ";
        var PAIRS_MARKER = ":";
        var isRequestProp = function isRequestProp(prop) {
            return getRequestProps().includes(prop);
        };
        var propsObj = {};
        var props = propsToMatchStr.split(PROPS_DIVIDER);
        props.forEach((function(prop) {
            var dividerInd = prop.indexOf(PAIRS_MARKER);
            var key = prop.slice(0, dividerInd);
            if (isRequestProp(key)) {
                var value = prop.slice(dividerInd + 1);
                propsObj[key] = value;
            } else {
                propsObj.url = prop;
            }
        }));
        return propsObj;
    }
    function isValidParsedData(data) {
        return Object.values(data).every((function(value) {
            return isValidStrPattern(value);
        }));
    }
    function getMatchPropsData(data) {
        var matchData = {};
        var dataKeys = Object.keys(data);
        dataKeys.forEach((function(key) {
            matchData[key] = toRegExp(data[key]);
        }));
        return matchData;
    }
    var updatedArgs = args ? [].concat(source).concat(args) : [ source ];
    try {
        trustedReplaceFetchResponse.apply(this, updatedArgs);
        if (source.uniqueId) {
            Object.defineProperty(Window.prototype.toString, uniqueIdentifier, {
                value: flag,
                enumerable: false,
                writable: false,
                configurable: false
            });
        }
    } catch (e) {
        console.log(e);
    }
}

function trustedReplaceNodeText(source, args) {
    var flag = "done";
    var uniqueIdentifier = source.uniqueId + source.name + "_" + (Array.isArray(args) ? args.join("_") : "");
    if (source.uniqueId) {
        if (Window.prototype.toString[uniqueIdentifier] === flag) {
            return;
        }
    }
    function trustedReplaceNodeText(source, nodeName, textMatch, pattern, replacement) {
        var {selector: selector, nodeNameMatch: nodeNameMatch, textContentMatch: textContentMatch, patternMatch: patternMatch} = parseNodeTextParams(nodeName, textMatch, pattern);
        for (var _len = arguments.length, extraArgs = new Array(_len > 5 ? _len - 5 : 0), _key = 5; _key < _len; _key++) {
            extraArgs[_key - 5] = arguments[_key];
        }
        var shouldLog = extraArgs.includes("verbose");
        var handleNodes = function handleNodes(nodes) {
            return nodes.forEach((function(node) {
                var shouldReplace = isTargetNode(node, nodeNameMatch, textContentMatch);
                if (shouldReplace) {
                    if (shouldLog) {
                        var originalText = node.textContent;
                        if (originalText) {
                            logMessage(source, `Original text content: ${originalText}`);
                        }
                    }
                    replaceNodeText(source, node, patternMatch, replacement);
                    if (shouldLog) {
                        var modifiedText = node.textContent;
                        if (modifiedText) {
                            logMessage(source, `Modified text content: ${modifiedText}`);
                        }
                    }
                }
            }));
        };
        if (document.documentElement) {
            handleExistingNodes(selector, handleNodes);
        }
        observeDocumentWithTimeout((function(mutations) {
            return handleMutations(mutations, handleNodes);
        }));
    }
    function observeDocumentWithTimeout(callback) {
        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {
            subtree: true,
            childList: true
        };
        var timeout = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1e4;
        var documentObserver = new MutationObserver((function(mutations, observer) {
            observer.disconnect();
            callback(mutations, observer);
            observer.observe(document.documentElement, options);
        }));
        documentObserver.observe(document.documentElement, options);
        if (typeof timeout === "number") {
            setTimeout((function() {
                return documentObserver.disconnect();
            }), timeout);
        }
    }
    function handleExistingNodes(selector, handler, parentSelector) {
        var processNodes = function processNodes(parent) {
            if (selector === "#text") {
                var textNodes = nodeListToArray(parent.childNodes).filter((function(node) {
                    return node.nodeType === Node.TEXT_NODE;
                }));
                handler(textNodes);
            } else {
                var _nodes = nodeListToArray(parent.querySelectorAll(selector));
                handler(_nodes);
            }
        };
        var parents = [ document ];
        parents.forEach((function(parent) {
            return processNodes(parent);
        }));
    }
    function handleMutations(mutations, handler, selector, parentSelector) {
        var addedNodes = getAddedNodes(mutations);
        {
            handler(addedNodes);
        }
    }
    function replaceNodeText(source, node, pattern, replacement) {
        var {textContent: textContent} = node;
        if (textContent) {
            if (node.nodeName === "SCRIPT" && window.trustedTypes && window.trustedTypes.createPolicy) {
                var policy = window.trustedTypes.createPolicy("AGPolicy", {
                    createScript: function createScript(string) {
                        return string;
                    }
                });
                var modifiedText = textContent.replace(pattern, replacement);
                var trustedReplacement = policy.createScript(modifiedText);
                node.textContent = trustedReplacement;
            } else {
                node.textContent = textContent.replace(pattern, replacement);
            }
            hit(source);
        }
    }
    function isTargetNode(node, nodeNameMatch, textContentMatch) {
        var {nodeName: nodeName, textContent: textContent} = node;
        var nodeNameLowerCase = nodeName.toLowerCase();
        return textContent !== null && textContent !== "" && (nodeNameMatch instanceof RegExp ? nodeNameMatch.test(nodeNameLowerCase) : nodeNameMatch === nodeNameLowerCase) && (textContentMatch instanceof RegExp ? textContentMatch.test(textContent) : textContent.includes(textContentMatch));
    }
    function parseNodeTextParams(nodeName, textMatch) {
        var pattern = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
        var REGEXP_START_MARKER = "/";
        var isStringNameMatch = !(nodeName.startsWith(REGEXP_START_MARKER) && nodeName.endsWith(REGEXP_START_MARKER));
        var selector = isStringNameMatch ? nodeName : "*";
        var nodeNameMatch = isStringNameMatch ? nodeName : toRegExp(nodeName);
        var textContentMatch = !textMatch.startsWith(REGEXP_START_MARKER) ? textMatch : toRegExp(textMatch);
        var patternMatch;
        if (pattern) {
            patternMatch = !pattern.startsWith(REGEXP_START_MARKER) ? pattern : toRegExp(pattern);
        }
        return {
            selector: selector,
            nodeNameMatch: nodeNameMatch,
            textContentMatch: textContentMatch,
            patternMatch: patternMatch
        };
    }
    function logMessage(source, message) {
        var forced = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
        var convertMessageToString = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
        var {name: name, verbose: verbose} = source;
        if (!forced && !verbose) {
            return;
        }
        var nativeConsole = console.log;
        if (!convertMessageToString) {
            nativeConsole(`${name}:`, message);
            return;
        }
        nativeConsole(`${name}: ${message}`);
    }
    function hit(source) {
        var ADGUARD_PREFIX = "[AdGuard]";
        if (!source.verbose) {
            return;
        }
        try {
            var trace = console.trace.bind(console);
            var label = `${ADGUARD_PREFIX} `;
            if (source.engine === "corelibs") {
                label += source.ruleText;
            } else {
                if (source.domainName) {
                    label += `${source.domainName}`;
                }
                if (source.args) {
                    label += `#%#//scriptlet('${source.name}', '${source.args.join("', '")}')`;
                } else {
                    label += `#%#//scriptlet('${source.name}')`;
                }
            }
            if (trace) {
                trace(label);
            }
        } catch (e) {}
        if (typeof window.__debug === "function") {
            window.__debug(source);
        }
    }
    function nodeListToArray(nodeList) {
        var nodes = [];
        for (var i = 0; i < nodeList.length; i += 1) {
            nodes.push(nodeList[i]);
        }
        return nodes;
    }
    function getAddedNodes(mutations) {
        var nodes = [];
        for (var i = 0; i < mutations.length; i += 1) {
            var {addedNodes: addedNodes} = mutations[i];
            for (var j = 0; j < addedNodes.length; j += 1) {
                nodes.push(addedNodes[j]);
            }
        }
        return nodes;
    }
    function toRegExp(rawInput) {
        var input = rawInput || "";
        var DEFAULT_VALUE = ".?";
        var FORWARD_SLASH = "/";
        if (input === "") {
            return new RegExp(DEFAULT_VALUE);
        }
        var delimiterIndex = input.lastIndexOf(FORWARD_SLASH);
        var flagsPart = input.substring(delimiterIndex + 1);
        var regExpPart = input.substring(0, delimiterIndex + 1);
        var isValidRegExpFlag = function isValidRegExpFlag(flag) {
            if (!flag) {
                return false;
            }
            try {
                new RegExp("", flag);
                return true;
            } catch (ex) {
                return false;
            }
        };
        var getRegExpFlags = function getRegExpFlags(regExpStr, flagsStr) {
            if (regExpStr.startsWith(FORWARD_SLASH) && regExpStr.endsWith(FORWARD_SLASH) && !regExpStr.endsWith("\\/") && isValidRegExpFlag(flagsStr)) {
                return flagsStr;
            }
            return "";
        };
        var flags = getRegExpFlags(regExpPart, flagsPart);
        if (input.startsWith(FORWARD_SLASH) && input.endsWith(FORWARD_SLASH) || flags) {
            var regExpInput = flags ? regExpPart : input;
            return new RegExp(regExpInput.slice(1, -1), flags);
        }
        var escaped = input.replace(/\\'/g, "'").replace(/\\"/g, '"').replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
        return new RegExp(escaped);
    }
    var updatedArgs = args ? [].concat(source).concat(args) : [ source ];
    try {
        trustedReplaceNodeText.apply(this, updatedArgs);
        if (source.uniqueId) {
            Object.defineProperty(Window.prototype.toString, uniqueIdentifier, {
                value: flag,
                enumerable: false,
                writable: false,
                configurable: false
            });
        }
    } catch (e) {
        console.log(e);
    }
}

function trustedReplaceOutboundText(source, args) {
    var flag = "done";
    var uniqueIdentifier = source.uniqueId + source.name + "_" + (Array.isArray(args) ? args.join("_") : "");
    if (source.uniqueId) {
        if (Window.prototype.toString[uniqueIdentifier] === flag) {
            return;
        }
    }
    function trustedReplaceOutboundText(source, methodPath) {
        var textToReplace = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : "";
        var replacement = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : "";
        var decodeMethod = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : "";
        var stack = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : "";
        var logContent = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : "";
        if (!methodPath) {
            return;
        }
        var getPathParts = getPropertyInChain;
        var {base: base, chain: chain, prop: prop} = getPathParts(window, methodPath);
        if (typeof chain !== "undefined") {
            logMessage(source, `Could not reach the end of the prop chain: ${methodPath}`);
            return;
        }
        var nativeMethod = base[prop];
        if (!nativeMethod || typeof nativeMethod !== "function") {
            logMessage(source, `Could not retrieve the method: ${methodPath}`);
            return;
        }
        var isValidBase64 = function isValidBase64(str) {
            try {
                if (str === "") {
                    return false;
                }
                var decodedString = atob(str);
                var encodedString = btoa(decodedString);
                var stringWithoutPadding = str.replace(/=+$/, "");
                var encodedStringWithoutPadding = encodedString.replace(/=+$/, "");
                return encodedStringWithoutPadding === stringWithoutPadding;
            } catch (e) {
                return false;
            }
        };
        var decodeAndReplaceContent = function decodeAndReplaceContent(content, pattern, textReplacement, decode, log) {
            switch (decode) {
              case "base64":
                try {
                    if (!isValidBase64(content)) {
                        logMessage(source, `Text content is not a valid base64 encoded string: ${content}`);
                        return content;
                    }
                    var decodedContent = atob(content);
                    if (log) {
                        logMessage(source, `Decoded text content: ${decodedContent}`);
                    }
                    var modifiedContent = textToReplace ? decodedContent.replace(pattern, textReplacement) : decodedContent;
                    if (log) {
                        var message = modifiedContent !== decodedContent ? `Modified decoded text content: ${modifiedContent}` : "Decoded text content was not modified";
                        logMessage(source, message);
                    }
                    var encodedContent = btoa(modifiedContent);
                    return encodedContent;
                } catch (e) {
                    return content;
                }

              default:
                return content.replace(pattern, textReplacement);
            }
        };
        var logOriginalContent = !textToReplace || !!logContent;
        var logModifiedContent = !!logContent;
        var logDecodedContent = !!decodeMethod && !!logContent;
        var isMatchingSuspended = false;
        var objectWrapper = function objectWrapper(target, thisArg, argumentsList) {
            if (isMatchingSuspended) {
                return Reflect.apply(target, thisArg, argumentsList);
            }
            isMatchingSuspended = true;
            hit(source);
            var result = Reflect.apply(target, thisArg, argumentsList);
            if (stack && !matchStackTrace(stack, (new Error).stack || "")) {
                return result;
            }
            if (typeof result === "string") {
                if (logOriginalContent) {
                    logMessage(source, `Original text content: ${result}`);
                }
                var patternRegexp = toRegExp(textToReplace);
                var modifiedContent = textToReplace || logDecodedContent ? decodeAndReplaceContent(result, patternRegexp, replacement, decodeMethod, logContent) : result;
                if (logModifiedContent) {
                    var message = modifiedContent !== result ? `Modified text content: ${modifiedContent}` : "Text content was not modified";
                    logMessage(source, message);
                }
                isMatchingSuspended = false;
                return modifiedContent;
            }
            isMatchingSuspended = false;
            logMessage(source, "Content is not a string");
            return result;
        };
        var objectHandler = {
            apply: objectWrapper
        };
        base[prop] = new Proxy(nativeMethod, objectHandler);
    }
    function hit(source) {
        var ADGUARD_PREFIX = "[AdGuard]";
        if (!source.verbose) {
            return;
        }
        try {
            var trace = console.trace.bind(console);
            var label = `${ADGUARD_PREFIX} `;
            if (source.engine === "corelibs") {
                label += source.ruleText;
            } else {
                if (source.domainName) {
                    label += `${source.domainName}`;
                }
                if (source.args) {
                    label += `#%#//scriptlet('${source.name}', '${source.args.join("', '")}')`;
                } else {
                    label += `#%#//scriptlet('${source.name}')`;
                }
            }
            if (trace) {
                trace(label);
            }
        } catch (e) {}
        if (typeof window.__debug === "function") {
            window.__debug(source);
        }
    }
    function matchStackTrace(stackMatch, stackTrace) {
        if (!stackMatch || stackMatch === "") {
            return true;
        }
        var regExpValues = backupRegExpValues();
        if (shouldAbortInlineOrInjectedScript(stackMatch, stackTrace)) {
            if (regExpValues.length && regExpValues[0] !== RegExp.$1) {
                restoreRegExpValues(regExpValues);
            }
            return true;
        }
        var stackRegexp = toRegExp(stackMatch);
        var refinedStackTrace = stackTrace.split("\n").slice(2).map((function(line) {
            return line.trim();
        })).join("\n");
        if (regExpValues.length && regExpValues[0] !== RegExp.$1) {
            restoreRegExpValues(regExpValues);
        }
        return getNativeRegexpTest().call(stackRegexp, refinedStackTrace);
    }
    function getPropertyInChain(base, chain) {
        var pos = chain.indexOf(".");
        if (pos === -1) {
            return {
                base: base,
                prop: chain
            };
        }
        var prop = chain.slice(0, pos);
        if (base === null) {
            return {
                base: base,
                prop: prop,
                chain: chain
            };
        }
        var nextBase = base[prop];
        chain = chain.slice(pos + 1);
        if ((base instanceof Object || typeof base === "object") && isEmptyObject(base)) {
            return {
                base: base,
                prop: prop,
                chain: chain
            };
        }
        if (nextBase === null) {
            return {
                base: base,
                prop: prop,
                chain: chain
            };
        }
        if (nextBase !== undefined) {
            return getPropertyInChain(nextBase, chain);
        }
        Object.defineProperty(base, prop, {
            configurable: true
        });
        return {
            base: base,
            prop: prop,
            chain: chain
        };
    }
    function logMessage(source, message) {
        var forced = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
        var convertMessageToString = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
        var {name: name, verbose: verbose} = source;
        if (!forced && !verbose) {
            return;
        }
        var nativeConsole = console.log;
        if (!convertMessageToString) {
            nativeConsole(`${name}:`, message);
            return;
        }
        nativeConsole(`${name}: ${message}`);
    }
    function shouldAbortInlineOrInjectedScript(stackMatch, stackTrace) {
        var INLINE_SCRIPT_STRING = "inlineScript";
        var INJECTED_SCRIPT_STRING = "injectedScript";
        var INJECTED_SCRIPT_MARKER = "<anonymous>";
        var isInlineScript = function isInlineScript(match) {
            return match.includes(INLINE_SCRIPT_STRING);
        };
        var isInjectedScript = function isInjectedScript(match) {
            return match.includes(INJECTED_SCRIPT_STRING);
        };
        if (!(isInlineScript(stackMatch) || isInjectedScript(stackMatch))) {
            return false;
        }
        var documentURL = window.location.href;
        var pos = documentURL.indexOf("#");
        if (pos !== -1) {
            documentURL = documentURL.slice(0, pos);
        }
        var stackSteps = stackTrace.split("\n").slice(2).map((function(line) {
            return line.trim();
        }));
        var stackLines = stackSteps.map((function(line) {
            var stack;
            var getStackTraceValues = /(.*?@)?(\S+)(:\d+)(:\d+)\)?$/.exec(line);
            if (getStackTraceValues) {
                var _stackURL, _stackURL2;
                var stackURL = getStackTraceValues[2];
                var stackLine = getStackTraceValues[3];
                var stackCol = getStackTraceValues[4];
                if ((_stackURL = stackURL) !== null && _stackURL !== void 0 && _stackURL.startsWith("(")) {
                    stackURL = stackURL.slice(1);
                }
                if ((_stackURL2 = stackURL) !== null && _stackURL2 !== void 0 && _stackURL2.startsWith(INJECTED_SCRIPT_MARKER)) {
                    var _stackFunction;
                    stackURL = INJECTED_SCRIPT_STRING;
                    var stackFunction = getStackTraceValues[1] !== undefined ? getStackTraceValues[1].slice(0, -1) : line.slice(0, getStackTraceValues.index).trim();
                    if ((_stackFunction = stackFunction) !== null && _stackFunction !== void 0 && _stackFunction.startsWith("at")) {
                        stackFunction = stackFunction.slice(2).trim();
                    }
                    stack = `${stackFunction} ${stackURL}${stackLine}${stackCol}`.trim();
                } else if (stackURL === documentURL) {
                    stack = `${INLINE_SCRIPT_STRING}${stackLine}${stackCol}`.trim();
                } else {
                    stack = `${stackURL}${stackLine}${stackCol}`.trim();
                }
            } else {
                stack = line;
            }
            return stack;
        }));
        if (stackLines) {
            for (var index = 0; index < stackLines.length; index += 1) {
                if (isInlineScript(stackMatch) && stackLines[index].startsWith(INLINE_SCRIPT_STRING) && stackLines[index].match(toRegExp(stackMatch))) {
                    return true;
                }
                if (isInjectedScript(stackMatch) && stackLines[index].startsWith(INJECTED_SCRIPT_STRING) && stackLines[index].match(toRegExp(stackMatch))) {
                    return true;
                }
            }
        }
        return false;
    }
    function getNativeRegexpTest() {
        var descriptor = Object.getOwnPropertyDescriptor(RegExp.prototype, "test");
        var nativeRegexTest = descriptor === null || descriptor === void 0 ? void 0 : descriptor.value;
        if (descriptor && typeof descriptor.value === "function") {
            return nativeRegexTest;
        }
        throw new Error("RegExp.prototype.test is not a function");
    }
    function toRegExp(rawInput) {
        var input = rawInput || "";
        var DEFAULT_VALUE = ".?";
        var FORWARD_SLASH = "/";
        if (input === "") {
            return new RegExp(DEFAULT_VALUE);
        }
        var delimiterIndex = input.lastIndexOf(FORWARD_SLASH);
        var flagsPart = input.substring(delimiterIndex + 1);
        var regExpPart = input.substring(0, delimiterIndex + 1);
        var isValidRegExpFlag = function isValidRegExpFlag(flag) {
            if (!flag) {
                return false;
            }
            try {
                new RegExp("", flag);
                return true;
            } catch (ex) {
                return false;
            }
        };
        var getRegExpFlags = function getRegExpFlags(regExpStr, flagsStr) {
            if (regExpStr.startsWith(FORWARD_SLASH) && regExpStr.endsWith(FORWARD_SLASH) && !regExpStr.endsWith("\\/") && isValidRegExpFlag(flagsStr)) {
                return flagsStr;
            }
            return "";
        };
        var flags = getRegExpFlags(regExpPart, flagsPart);
        if (input.startsWith(FORWARD_SLASH) && input.endsWith(FORWARD_SLASH) || flags) {
            var regExpInput = flags ? regExpPart : input;
            return new RegExp(regExpInput.slice(1, -1), flags);
        }
        var escaped = input.replace(/\\'/g, "'").replace(/\\"/g, '"').replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
        return new RegExp(escaped);
    }
    function isEmptyObject(obj) {
        return Object.keys(obj).length === 0 && !obj.prototype;
    }
    function backupRegExpValues() {
        try {
            var arrayOfRegexpValues = [];
            for (var index = 1; index < 10; index += 1) {
                var value = `$${index}`;
                if (!RegExp[value]) {
                    break;
                }
                arrayOfRegexpValues.push(RegExp[value]);
            }
            return arrayOfRegexpValues;
        } catch (error) {
            return [];
        }
    }
    function restoreRegExpValues(array) {
        if (!array.length) {
            return;
        }
        try {
            var stringPattern = "";
            if (array.length === 1) {
                stringPattern = `(${array[0]})`;
            } else {
                stringPattern = array.reduce((function(accumulator, currentValue, currentIndex) {
                    if (currentIndex === 1) {
                        return `(${accumulator}),(${currentValue})`;
                    }
                    return `${accumulator},(${currentValue})`;
                }));
            }
            var regExpGroup = new RegExp(stringPattern);
            array.toString().replace(regExpGroup, "");
        } catch (error) {
            var message = `Failed to restore RegExp values: ${error}`;
            console.log(message);
        }
    }
    var updatedArgs = args ? [].concat(source).concat(args) : [ source ];
    try {
        trustedReplaceOutboundText.apply(this, updatedArgs);
        if (source.uniqueId) {
            Object.defineProperty(Window.prototype.toString, uniqueIdentifier, {
                value: flag,
                enumerable: false,
                writable: false,
                configurable: false
            });
        }
    } catch (e) {
        console.log(e);
    }
}

function trustedReplaceXhrResponse(source, args) {
    var flag = "done";
    var uniqueIdentifier = source.uniqueId + source.name + "_" + (Array.isArray(args) ? args.join("_") : "");
    if (source.uniqueId) {
        if (Window.prototype.toString[uniqueIdentifier] === flag) {
            return;
        }
    }
    function trustedReplaceXhrResponse(source) {
        var pattern = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "";
        var replacement = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : "";
        var propsToMatch = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : "";
        var verbose = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;
        if (typeof Proxy === "undefined") {
            return;
        }
        if (pattern === "" && replacement !== "") {
            var message = "Pattern argument should not be empty string.";
            logMessage(source, message);
            return;
        }
        var shouldLog = pattern === "" && replacement === "";
        var shouldLogContent = verbose === "true";
        var nativeOpen = window.XMLHttpRequest.prototype.open;
        var nativeSend = window.XMLHttpRequest.prototype.send;
        var xhrData;
        var openWrapper = function openWrapper(target, thisArg, args) {
            xhrData = getXhrData.apply(null, args);
            if (shouldLog) {
                var _message = `xhr( ${objectToString(xhrData)} )`;
                logMessage(source, _message, true);
                hit(source);
                return Reflect.apply(target, thisArg, args);
            }
            if (matchRequestProps(source, propsToMatch, xhrData)) {
                thisArg.shouldBePrevented = true;
                thisArg.headersReceived = !!thisArg.headersReceived;
            }
            if (thisArg.shouldBePrevented && !thisArg.headersReceived) {
                thisArg.headersReceived = true;
                thisArg.collectedHeaders = [];
                var setRequestHeaderWrapper = function setRequestHeaderWrapper(target, thisArg, args) {
                    thisArg.collectedHeaders.push(args);
                    return Reflect.apply(target, thisArg, args);
                };
                var setRequestHeaderHandler = {
                    apply: setRequestHeaderWrapper
                };
                thisArg.setRequestHeader = new Proxy(thisArg.setRequestHeader, setRequestHeaderHandler);
            }
            return Reflect.apply(target, thisArg, args);
        };
        var sendWrapper = function sendWrapper(target, thisArg, args) {
            if (!thisArg.shouldBePrevented) {
                return Reflect.apply(target, thisArg, args);
            }
            var forgedRequest = new XMLHttpRequest;
            forgedRequest.addEventListener("readystatechange", (function() {
                if (forgedRequest.readyState !== 4) {
                    return;
                }
                var {readyState: readyState, response: response, responseText: responseText, responseURL: responseURL, responseXML: responseXML, status: status, statusText: statusText} = forgedRequest;
                var content = responseText || response;
                if (typeof content !== "string") {
                    return;
                }
                var patternRegexp = pattern === "*" ? /(\n|.)*/ : toRegExp(pattern);
                if (shouldLogContent) {
                    logMessage(source, `Original text content: ${content}`);
                }
                var modifiedContent = content.replace(patternRegexp, replacement);
                if (shouldLogContent) {
                    logMessage(source, `Modified text content: ${modifiedContent}`);
                }
                Object.defineProperties(thisArg, {
                    readyState: {
                        value: readyState,
                        writable: false
                    },
                    responseURL: {
                        value: responseURL,
                        writable: false
                    },
                    responseXML: {
                        value: responseXML,
                        writable: false
                    },
                    status: {
                        value: status,
                        writable: false
                    },
                    statusText: {
                        value: statusText,
                        writable: false
                    },
                    response: {
                        value: modifiedContent,
                        writable: false
                    },
                    responseText: {
                        value: modifiedContent,
                        writable: false
                    }
                });
                setTimeout((function() {
                    var stateEvent = new Event("readystatechange");
                    thisArg.dispatchEvent(stateEvent);
                    var loadEvent = new Event("load");
                    thisArg.dispatchEvent(loadEvent);
                    var loadEndEvent = new Event("loadend");
                    thisArg.dispatchEvent(loadEndEvent);
                }), 1);
                hit(source);
            }));
            nativeOpen.apply(forgedRequest, [ xhrData.method, xhrData.url ]);
            thisArg.collectedHeaders.forEach((function(header) {
                var name = header[0];
                var value = header[1];
                forgedRequest.setRequestHeader(name, value);
            }));
            thisArg.collectedHeaders = [];
            try {
                nativeSend.call(forgedRequest, args);
            } catch (_unused) {
                return Reflect.apply(target, thisArg, args);
            }
            return undefined;
        };
        var openHandler = {
            apply: openWrapper
        };
        var sendHandler = {
            apply: sendWrapper
        };
        XMLHttpRequest.prototype.open = new Proxy(XMLHttpRequest.prototype.open, openHandler);
        XMLHttpRequest.prototype.send = new Proxy(XMLHttpRequest.prototype.send, sendHandler);
    }
    function hit(source) {
        var ADGUARD_PREFIX = "[AdGuard]";
        if (!source.verbose) {
            return;
        }
        try {
            var trace = console.trace.bind(console);
            var label = `${ADGUARD_PREFIX} `;
            if (source.engine === "corelibs") {
                label += source.ruleText;
            } else {
                if (source.domainName) {
                    label += `${source.domainName}`;
                }
                if (source.args) {
                    label += `#%#//scriptlet('${source.name}', '${source.args.join("', '")}')`;
                } else {
                    label += `#%#//scriptlet('${source.name}')`;
                }
            }
            if (trace) {
                trace(label);
            }
        } catch (e) {}
        if (typeof window.__debug === "function") {
            window.__debug(source);
        }
    }
    function logMessage(source, message) {
        var forced = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
        var convertMessageToString = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
        var {name: name, verbose: verbose} = source;
        if (!forced && !verbose) {
            return;
        }
        var nativeConsole = console.log;
        if (!convertMessageToString) {
            nativeConsole(`${name}:`, message);
            return;
        }
        nativeConsole(`${name}: ${message}`);
    }
    function toRegExp(rawInput) {
        var input = rawInput || "";
        var DEFAULT_VALUE = ".?";
        var FORWARD_SLASH = "/";
        if (input === "") {
            return new RegExp(DEFAULT_VALUE);
        }
        var delimiterIndex = input.lastIndexOf(FORWARD_SLASH);
        var flagsPart = input.substring(delimiterIndex + 1);
        var regExpPart = input.substring(0, delimiterIndex + 1);
        var isValidRegExpFlag = function isValidRegExpFlag(flag) {
            if (!flag) {
                return false;
            }
            try {
                new RegExp("", flag);
                return true;
            } catch (ex) {
                return false;
            }
        };
        var getRegExpFlags = function getRegExpFlags(regExpStr, flagsStr) {
            if (regExpStr.startsWith(FORWARD_SLASH) && regExpStr.endsWith(FORWARD_SLASH) && !regExpStr.endsWith("\\/") && isValidRegExpFlag(flagsStr)) {
                return flagsStr;
            }
            return "";
        };
        var flags = getRegExpFlags(regExpPart, flagsPart);
        if (input.startsWith(FORWARD_SLASH) && input.endsWith(FORWARD_SLASH) || flags) {
            var regExpInput = flags ? regExpPart : input;
            return new RegExp(regExpInput.slice(1, -1), flags);
        }
        var escaped = input.replace(/\\'/g, "'").replace(/\\"/g, '"').replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
        return new RegExp(escaped);
    }
    function objectToString(obj) {
        if (!obj || typeof obj !== "object") {
            return String(obj);
        }
        if (isEmptyObject(obj)) {
            return "{}";
        }
        return Object.entries(obj).map((function(pair) {
            var key = pair[0];
            var value = pair[1];
            var recordValueStr = value;
            if (value instanceof Object) {
                recordValueStr = `{ ${objectToString(value)} }`;
            }
            return `${key}:"${recordValueStr}"`;
        })).join(" ");
    }
    function matchRequestProps(source, propsToMatch, requestData) {
        if (propsToMatch === "" || propsToMatch === "*") {
            return true;
        }
        var isMatched;
        var parsedData = parseMatchProps(propsToMatch);
        if (!isValidParsedData(parsedData)) {
            logMessage(source, `Invalid parameter: ${propsToMatch}`);
            isMatched = false;
        } else {
            var matchData = getMatchPropsData(parsedData);
            var matchKeys = Object.keys(matchData);
            isMatched = matchKeys.every((function(matchKey) {
                var matchValue = matchData[matchKey];
                var dataValue = requestData[matchKey];
                return Object.prototype.hasOwnProperty.call(requestData, matchKey) && typeof dataValue === "string" && (matchValue === null || matchValue === void 0 ? void 0 : matchValue.test(dataValue));
            }));
        }
        return isMatched;
    }
    function getXhrData(method, url, async, user, password) {
        return {
            method: method,
            url: url,
            async: async,
            user: user,
            password: password
        };
    }
    function getMatchPropsData(data) {
        var matchData = {};
        var dataKeys = Object.keys(data);
        dataKeys.forEach((function(key) {
            matchData[key] = toRegExp(data[key]);
        }));
        return matchData;
    }
    function getRequestProps() {
        return [ "url", "method", "headers", "body", "credentials", "cache", "redirect", "referrer", "referrerPolicy", "integrity", "keepalive", "signal", "mode" ];
    }
    function isValidParsedData(data) {
        return Object.values(data).every((function(value) {
            return isValidStrPattern(value);
        }));
    }
    function parseMatchProps(propsToMatchStr) {
        var PROPS_DIVIDER = " ";
        var PAIRS_MARKER = ":";
        var isRequestProp = function isRequestProp(prop) {
            return getRequestProps().includes(prop);
        };
        var propsObj = {};
        var props = propsToMatchStr.split(PROPS_DIVIDER);
        props.forEach((function(prop) {
            var dividerInd = prop.indexOf(PAIRS_MARKER);
            var key = prop.slice(0, dividerInd);
            if (isRequestProp(key)) {
                var value = prop.slice(dividerInd + 1);
                propsObj[key] = value;
            } else {
                propsObj.url = prop;
            }
        }));
        return propsObj;
    }
    function isValidStrPattern(input) {
        var FORWARD_SLASH = "/";
        var str = escapeRegExp(input);
        if (input[0] === FORWARD_SLASH && input[input.length - 1] === FORWARD_SLASH) {
            str = input.slice(1, -1);
        }
        var isValid;
        try {
            isValid = new RegExp(str);
            isValid = true;
        } catch (e) {
            isValid = false;
        }
        return isValid;
    }
    function escapeRegExp(str) {
        return str.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
    }
    function isEmptyObject(obj) {
        return Object.keys(obj).length === 0 && !obj.prototype;
    }
    var updatedArgs = args ? [].concat(source).concat(args) : [ source ];
    try {
        trustedReplaceXhrResponse.apply(this, updatedArgs);
        if (source.uniqueId) {
            Object.defineProperty(Window.prototype.toString, uniqueIdentifier, {
                value: flag,
                enumerable: false,
                writable: false,
                configurable: false
            });
        }
    } catch (e) {
        console.log(e);
    }
}

function trustedSetAttr(source, args) {
    var flag = "done";
    var uniqueIdentifier = source.uniqueId + source.name + "_" + (Array.isArray(args) ? args.join("_") : "");
    if (source.uniqueId) {
        if (Window.prototype.toString[uniqueIdentifier] === flag) {
            return;
        }
    }
    function trustedSetAttr(source, selector, attr) {
        var value = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : "";
        if (!selector || !attr) {
            return;
        }
        setAttributeBySelector(source, selector, attr, value);
        observeDOMChanges((function() {
            return setAttributeBySelector(source, selector, attr, value);
        }), true);
    }
    function setAttributeBySelector(source, selector, attribute, value) {
        var attributeSetter = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : defaultAttributeSetter;
        var elements;
        try {
            elements = document.querySelectorAll(selector);
        } catch (_unused) {
            logMessage(source, `Failed to find elements matching selector "${selector}"`);
            return;
        }
        if (!elements || elements.length === 0) {
            return;
        }
        try {
            elements.forEach((function(elem) {
                return attributeSetter(elem, attribute, value);
            }));
            hit(source);
        } catch (_unused2) {
            logMessage(source, `Failed to set [${attribute}="${value}"] to each of selected elements.`);
        }
    }
    function observeDOMChanges(callback) {
        var observeAttrs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
        var attrsToObserve = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];
        var THROTTLE_DELAY_MS = 20;
        var observer = new MutationObserver(throttle(callbackWrapper, THROTTLE_DELAY_MS));
        var connect = function connect() {
            if (attrsToObserve.length > 0) {
                observer.observe(document.documentElement, {
                    childList: true,
                    subtree: true,
                    attributes: observeAttrs,
                    attributeFilter: attrsToObserve
                });
            } else {
                observer.observe(document.documentElement, {
                    childList: true,
                    subtree: true,
                    attributes: observeAttrs
                });
            }
        };
        var disconnect = function disconnect() {
            observer.disconnect();
        };
        function callbackWrapper() {
            disconnect();
            callback();
            connect();
        }
        connect();
    }
    function defaultAttributeSetter(elem, attribute, value) {
        return elem.setAttribute(attribute, value);
    }
    function logMessage(source, message) {
        var forced = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
        var convertMessageToString = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
        var {name: name, verbose: verbose} = source;
        if (!forced && !verbose) {
            return;
        }
        var nativeConsole = console.log;
        if (!convertMessageToString) {
            nativeConsole(`${name}:`, message);
            return;
        }
        nativeConsole(`${name}: ${message}`);
    }
    function throttle(cb, delay) {
        var wait = false;
        var savedArgs;
        var _wrapper = function wrapper() {
            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                args[_key] = arguments[_key];
            }
            if (wait) {
                savedArgs = args;
                return;
            }
            cb(...args);
            wait = true;
            setTimeout((function() {
                wait = false;
                if (savedArgs) {
                    _wrapper(...savedArgs);
                    savedArgs = null;
                }
            }), delay);
        };
        return _wrapper;
    }
    function hit(source) {
        var ADGUARD_PREFIX = "[AdGuard]";
        if (!source.verbose) {
            return;
        }
        try {
            var trace = console.trace.bind(console);
            var label = `${ADGUARD_PREFIX} `;
            if (source.engine === "corelibs") {
                label += source.ruleText;
            } else {
                if (source.domainName) {
                    label += `${source.domainName}`;
                }
                if (source.args) {
                    label += `#%#//scriptlet('${source.name}', '${source.args.join("', '")}')`;
                } else {
                    label += `#%#//scriptlet('${source.name}')`;
                }
            }
            if (trace) {
                trace(label);
            }
        } catch (e) {}
        if (typeof window.__debug === "function") {
            window.__debug(source);
        }
    }
    var updatedArgs = args ? [].concat(source).concat(args) : [ source ];
    try {
        trustedSetAttr.apply(this, updatedArgs);
        if (source.uniqueId) {
            Object.defineProperty(Window.prototype.toString, uniqueIdentifier, {
                value: flag,
                enumerable: false,
                writable: false,
                configurable: false
            });
        }
    } catch (e) {
        console.log(e);
    }
}

function trustedSetConstant(source, args) {
    var flag = "done";
    var uniqueIdentifier = source.uniqueId + source.name + "_" + (Array.isArray(args) ? args.join("_") : "");
    if (source.uniqueId) {
        if (Window.prototype.toString[uniqueIdentifier] === flag) {
            return;
        }
    }
    function trustedSetConstant(source, property, value, stack) {
        if (!property || !matchStackTrace(stack, (new Error).stack)) {
            return;
        }
        var constantValue;
        try {
            constantValue = inferValue(value);
        } catch (e) {
            logMessage(source, e);
            return;
        }
        var canceled = false;
        var mustCancel = function mustCancel(value) {
            if (canceled) {
                return canceled;
            }
            canceled = value !== undefined && constantValue !== undefined && typeof value !== typeof constantValue && value !== null;
            return canceled;
        };
        var trapProp = function trapProp(base, prop, configurable, handler) {
            if (!handler.init(base[prop])) {
                return false;
            }
            var origDescriptor = Object.getOwnPropertyDescriptor(base, prop);
            var prevSetter;
            if (origDescriptor instanceof Object) {
                if (!origDescriptor.configurable) {
                    var message = `Property '${prop}' is not configurable`;
                    logMessage(source, message);
                    return false;
                }
                base[prop] = constantValue;
                if (origDescriptor.set instanceof Function) {
                    prevSetter = origDescriptor.set;
                }
            }
            Object.defineProperty(base, prop, {
                configurable: configurable,
                get() {
                    return handler.get();
                },
                set(a) {
                    if (prevSetter !== undefined) {
                        prevSetter(a);
                    }
                    handler.set(a);
                }
            });
            return true;
        };
        var _setChainPropAccess = function setChainPropAccess(owner, property) {
            var chainInfo = getPropertyInChain(owner, property);
            var {base: base} = chainInfo;
            var {prop: prop, chain: chain} = chainInfo;
            var inChainPropHandler = {
                factValue: undefined,
                init(a) {
                    this.factValue = a;
                    return true;
                },
                get() {
                    return this.factValue;
                },
                set(a) {
                    if (this.factValue === a) {
                        return;
                    }
                    this.factValue = a;
                    if (a instanceof Object) {
                        _setChainPropAccess(a, chain);
                    }
                }
            };
            var endPropHandler = {
                init(a) {
                    if (mustCancel(a)) {
                        return false;
                    }
                    return true;
                },
                get() {
                    return constantValue;
                },
                set(a) {
                    if (!mustCancel(a)) {
                        return;
                    }
                    constantValue = a;
                }
            };
            if (!chain) {
                var isTrapped = trapProp(base, prop, false, endPropHandler);
                if (isTrapped) {
                    hit(source);
                }
                return;
            }
            if (base !== undefined && base[prop] === null) {
                trapProp(base, prop, true, inChainPropHandler);
                return;
            }
            if ((base instanceof Object || typeof base === "object") && isEmptyObject(base)) {
                trapProp(base, prop, true, inChainPropHandler);
            }
            var propValue = owner[prop];
            if (propValue instanceof Object || typeof propValue === "object" && propValue !== null) {
                _setChainPropAccess(propValue, chain);
            }
            trapProp(base, prop, true, inChainPropHandler);
        };
        _setChainPropAccess(window, property);
    }
    function hit(source) {
        var ADGUARD_PREFIX = "[AdGuard]";
        if (!source.verbose) {
            return;
        }
        try {
            var trace = console.trace.bind(console);
            var label = `${ADGUARD_PREFIX} `;
            if (source.engine === "corelibs") {
                label += source.ruleText;
            } else {
                if (source.domainName) {
                    label += `${source.domainName}`;
                }
                if (source.args) {
                    label += `#%#//scriptlet('${source.name}', '${source.args.join("', '")}')`;
                } else {
                    label += `#%#//scriptlet('${source.name}')`;
                }
            }
            if (trace) {
                trace(label);
            }
        } catch (e) {}
        if (typeof window.__debug === "function") {
            window.__debug(source);
        }
    }
    function inferValue(value) {
        if (value === "undefined") {
            return undefined;
        }
        if (value === "false") {
            return false;
        }
        if (value === "true") {
            return true;
        }
        if (value === "null") {
            return null;
        }
        if (value === "NaN") {
            return NaN;
        }
        if (value.startsWith("/") && value.endsWith("/")) {
            return toRegExp(value);
        }
        var MAX_ALLOWED_NUM = 32767;
        var numVal = Number(value);
        if (!nativeIsNaN(numVal)) {
            if (Math.abs(numVal) > MAX_ALLOWED_NUM) {
                throw new Error("number values bigger than 32767 are not allowed");
            }
            return numVal;
        }
        var errorMessage = `'${value}' value type can't be inferred`;
        try {
            var parsableVal = JSON.parse(value);
            if (parsableVal instanceof Object || typeof parsableVal === "string") {
                return parsableVal;
            }
        } catch (e) {
            errorMessage += `: ${e}`;
        }
        throw new TypeError(errorMessage);
    }
    function logMessage(source, message) {
        var forced = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
        var convertMessageToString = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
        var {name: name, verbose: verbose} = source;
        if (!forced && !verbose) {
            return;
        }
        var nativeConsole = console.log;
        if (!convertMessageToString) {
            nativeConsole(`${name}:`, message);
            return;
        }
        nativeConsole(`${name}: ${message}`);
    }
    function getPropertyInChain(base, chain) {
        var pos = chain.indexOf(".");
        if (pos === -1) {
            return {
                base: base,
                prop: chain
            };
        }
        var prop = chain.slice(0, pos);
        if (base === null) {
            return {
                base: base,
                prop: prop,
                chain: chain
            };
        }
        var nextBase = base[prop];
        chain = chain.slice(pos + 1);
        if ((base instanceof Object || typeof base === "object") && isEmptyObject(base)) {
            return {
                base: base,
                prop: prop,
                chain: chain
            };
        }
        if (nextBase === null) {
            return {
                base: base,
                prop: prop,
                chain: chain
            };
        }
        if (nextBase !== undefined) {
            return getPropertyInChain(nextBase, chain);
        }
        Object.defineProperty(base, prop, {
            configurable: true
        });
        return {
            base: base,
            prop: prop,
            chain: chain
        };
    }
    function toRegExp(rawInput) {
        var input = rawInput || "";
        var DEFAULT_VALUE = ".?";
        var FORWARD_SLASH = "/";
        if (input === "") {
            return new RegExp(DEFAULT_VALUE);
        }
        var delimiterIndex = input.lastIndexOf(FORWARD_SLASH);
        var flagsPart = input.substring(delimiterIndex + 1);
        var regExpPart = input.substring(0, delimiterIndex + 1);
        var isValidRegExpFlag = function isValidRegExpFlag(flag) {
            if (!flag) {
                return false;
            }
            try {
                new RegExp("", flag);
                return true;
            } catch (ex) {
                return false;
            }
        };
        var getRegExpFlags = function getRegExpFlags(regExpStr, flagsStr) {
            if (regExpStr.startsWith(FORWARD_SLASH) && regExpStr.endsWith(FORWARD_SLASH) && !regExpStr.endsWith("\\/") && isValidRegExpFlag(flagsStr)) {
                return flagsStr;
            }
            return "";
        };
        var flags = getRegExpFlags(regExpPart, flagsPart);
        if (input.startsWith(FORWARD_SLASH) && input.endsWith(FORWARD_SLASH) || flags) {
            var regExpInput = flags ? regExpPart : input;
            return new RegExp(regExpInput.slice(1, -1), flags);
        }
        var escaped = input.replace(/\\'/g, "'").replace(/\\"/g, '"').replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
        return new RegExp(escaped);
    }
    function matchStackTrace(stackMatch, stackTrace) {
        if (!stackMatch || stackMatch === "") {
            return true;
        }
        var regExpValues = backupRegExpValues();
        if (shouldAbortInlineOrInjectedScript(stackMatch, stackTrace)) {
            if (regExpValues.length && regExpValues[0] !== RegExp.$1) {
                restoreRegExpValues(regExpValues);
            }
            return true;
        }
        var stackRegexp = toRegExp(stackMatch);
        var refinedStackTrace = stackTrace.split("\n").slice(2).map((function(line) {
            return line.trim();
        })).join("\n");
        if (regExpValues.length && regExpValues[0] !== RegExp.$1) {
            restoreRegExpValues(regExpValues);
        }
        return getNativeRegexpTest().call(stackRegexp, refinedStackTrace);
    }
    function nativeIsNaN(num) {
        var native = Number.isNaN || window.isNaN;
        return native(num);
    }
    function isEmptyObject(obj) {
        return Object.keys(obj).length === 0 && !obj.prototype;
    }
    function getNativeRegexpTest() {
        var descriptor = Object.getOwnPropertyDescriptor(RegExp.prototype, "test");
        var nativeRegexTest = descriptor === null || descriptor === void 0 ? void 0 : descriptor.value;
        if (descriptor && typeof descriptor.value === "function") {
            return nativeRegexTest;
        }
        throw new Error("RegExp.prototype.test is not a function");
    }
    function shouldAbortInlineOrInjectedScript(stackMatch, stackTrace) {
        var INLINE_SCRIPT_STRING = "inlineScript";
        var INJECTED_SCRIPT_STRING = "injectedScript";
        var INJECTED_SCRIPT_MARKER = "<anonymous>";
        var isInlineScript = function isInlineScript(match) {
            return match.includes(INLINE_SCRIPT_STRING);
        };
        var isInjectedScript = function isInjectedScript(match) {
            return match.includes(INJECTED_SCRIPT_STRING);
        };
        if (!(isInlineScript(stackMatch) || isInjectedScript(stackMatch))) {
            return false;
        }
        var documentURL = window.location.href;
        var pos = documentURL.indexOf("#");
        if (pos !== -1) {
            documentURL = documentURL.slice(0, pos);
        }
        var stackSteps = stackTrace.split("\n").slice(2).map((function(line) {
            return line.trim();
        }));
        var stackLines = stackSteps.map((function(line) {
            var stack;
            var getStackTraceValues = /(.*?@)?(\S+)(:\d+)(:\d+)\)?$/.exec(line);
            if (getStackTraceValues) {
                var _stackURL, _stackURL2;
                var stackURL = getStackTraceValues[2];
                var stackLine = getStackTraceValues[3];
                var stackCol = getStackTraceValues[4];
                if ((_stackURL = stackURL) !== null && _stackURL !== void 0 && _stackURL.startsWith("(")) {
                    stackURL = stackURL.slice(1);
                }
                if ((_stackURL2 = stackURL) !== null && _stackURL2 !== void 0 && _stackURL2.startsWith(INJECTED_SCRIPT_MARKER)) {
                    var _stackFunction;
                    stackURL = INJECTED_SCRIPT_STRING;
                    var stackFunction = getStackTraceValues[1] !== undefined ? getStackTraceValues[1].slice(0, -1) : line.slice(0, getStackTraceValues.index).trim();
                    if ((_stackFunction = stackFunction) !== null && _stackFunction !== void 0 && _stackFunction.startsWith("at")) {
                        stackFunction = stackFunction.slice(2).trim();
                    }
                    stack = `${stackFunction} ${stackURL}${stackLine}${stackCol}`.trim();
                } else if (stackURL === documentURL) {
                    stack = `${INLINE_SCRIPT_STRING}${stackLine}${stackCol}`.trim();
                } else {
                    stack = `${stackURL}${stackLine}${stackCol}`.trim();
                }
            } else {
                stack = line;
            }
            return stack;
        }));
        if (stackLines) {
            for (var index = 0; index < stackLines.length; index += 1) {
                if (isInlineScript(stackMatch) && stackLines[index].startsWith(INLINE_SCRIPT_STRING) && stackLines[index].match(toRegExp(stackMatch))) {
                    return true;
                }
                if (isInjectedScript(stackMatch) && stackLines[index].startsWith(INJECTED_SCRIPT_STRING) && stackLines[index].match(toRegExp(stackMatch))) {
                    return true;
                }
            }
        }
        return false;
    }
    function backupRegExpValues() {
        try {
            var arrayOfRegexpValues = [];
            for (var index = 1; index < 10; index += 1) {
                var value = `$${index}`;
                if (!RegExp[value]) {
                    break;
                }
                arrayOfRegexpValues.push(RegExp[value]);
            }
            return arrayOfRegexpValues;
        } catch (error) {
            return [];
        }
    }
    function restoreRegExpValues(array) {
        if (!array.length) {
            return;
        }
        try {
            var stringPattern = "";
            if (array.length === 1) {
                stringPattern = `(${array[0]})`;
            } else {
                stringPattern = array.reduce((function(accumulator, currentValue, currentIndex) {
                    if (currentIndex === 1) {
                        return `(${accumulator}),(${currentValue})`;
                    }
                    return `${accumulator},(${currentValue})`;
                }));
            }
            var regExpGroup = new RegExp(stringPattern);
            array.toString().replace(regExpGroup, "");
        } catch (error) {
            var message = `Failed to restore RegExp values: ${error}`;
            console.log(message);
        }
    }
    var updatedArgs = args ? [].concat(source).concat(args) : [ source ];
    try {
        trustedSetConstant.apply(this, updatedArgs);
        if (source.uniqueId) {
            Object.defineProperty(Window.prototype.toString, uniqueIdentifier, {
                value: flag,
                enumerable: false,
                writable: false,
                configurable: false
            });
        }
    } catch (e) {
        console.log(e);
    }
}

function trustedSetCookie(source, args) {
    var flag = "done";
    var uniqueIdentifier = source.uniqueId + source.name + "_" + (Array.isArray(args) ? args.join("_") : "");
    if (source.uniqueId) {
        if (Window.prototype.toString[uniqueIdentifier] === flag) {
            return;
        }
    }
    function trustedSetCookie(source, name, value) {
        var offsetExpiresSec = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : "";
        var path = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : "/";
        var domain = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : "";
        if (typeof name === "undefined") {
            logMessage(source, "Cookie name should be specified");
            return;
        }
        if (typeof value === "undefined") {
            logMessage(source, "Cookie value should be specified");
            return;
        }
        var parsedValue = parseKeywordValue(value);
        if (!isValidCookiePath(path)) {
            logMessage(source, `Invalid cookie path: '${path}'`);
            return;
        }
        if (!document.location.origin.includes(domain)) {
            logMessage(source, `Cookie domain not matched by origin: '${domain}'`);
            return;
        }
        var cookieToSet = serializeCookie(name, parsedValue, path, domain, false);
        if (!cookieToSet) {
            logMessage(source, "Invalid cookie name or value");
            return;
        }
        if (offsetExpiresSec) {
            var parsedOffsetMs = getTrustedCookieOffsetMs(offsetExpiresSec);
            if (!parsedOffsetMs) {
                logMessage(source, `Invalid offsetExpiresSec value: ${offsetExpiresSec}`);
                return;
            }
            var expires = Date.now() + parsedOffsetMs;
            cookieToSet += `; expires=${new Date(expires).toUTCString()}`;
        }
        document.cookie = cookieToSet;
        hit(source);
    }
    function hit(source) {
        var ADGUARD_PREFIX = "[AdGuard]";
        if (!source.verbose) {
            return;
        }
        try {
            var trace = console.trace.bind(console);
            var label = `${ADGUARD_PREFIX} `;
            if (source.engine === "corelibs") {
                label += source.ruleText;
            } else {
                if (source.domainName) {
                    label += `${source.domainName}`;
                }
                if (source.args) {
                    label += `#%#//scriptlet('${source.name}', '${source.args.join("', '")}')`;
                } else {
                    label += `#%#//scriptlet('${source.name}')`;
                }
            }
            if (trace) {
                trace(label);
            }
        } catch (e) {}
        if (typeof window.__debug === "function") {
            window.__debug(source);
        }
    }
    function logMessage(source, message) {
        var forced = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
        var convertMessageToString = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
        var {name: name, verbose: verbose} = source;
        if (!forced && !verbose) {
            return;
        }
        var nativeConsole = console.log;
        if (!convertMessageToString) {
            nativeConsole(`${name}:`, message);
            return;
        }
        nativeConsole(`${name}: ${message}`);
    }
    function serializeCookie(name, rawValue, rawPath) {
        var domainValue = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : "";
        var shouldEncodeValue = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : true;
        var HOST_PREFIX = "__Host-";
        var SECURE_PREFIX = "__Secure-";
        var COOKIE_BREAKER = ";";
        if (!shouldEncodeValue && `${rawValue}`.includes(COOKIE_BREAKER) || name.includes(COOKIE_BREAKER)) {
            return null;
        }
        var value = shouldEncodeValue ? encodeURIComponent(rawValue) : rawValue;
        var resultCookie = `${name}=${value}`;
        if (name.startsWith(HOST_PREFIX)) {
            resultCookie += "; path=/; secure";
            if (domainValue) {
                console.debug(`Domain value: "${domainValue}" has been ignored, because is not allowed for __Host- prefixed cookies`);
            }
            return resultCookie;
        }
        var path = getCookiePath(rawPath);
        if (path) {
            resultCookie += `; ${path}`;
        }
        if (name.startsWith(SECURE_PREFIX)) {
            resultCookie += "; secure";
        }
        if (domainValue) {
            resultCookie += `; domain=${domainValue}`;
        }
        return resultCookie;
    }
    function isValidCookiePath(rawPath) {
        return rawPath === "/" || rawPath === "none";
    }
    function getTrustedCookieOffsetMs(offsetExpiresSec) {
        var ONE_YEAR_EXPIRATION_KEYWORD = "1year";
        var ONE_DAY_EXPIRATION_KEYWORD = "1day";
        var MS_IN_SEC = 1e3;
        var SECONDS_IN_YEAR = 365 * 24 * 60 * 60;
        var SECONDS_IN_DAY = 24 * 60 * 60;
        var parsedSec;
        if (offsetExpiresSec === ONE_YEAR_EXPIRATION_KEYWORD) {
            parsedSec = SECONDS_IN_YEAR;
        } else if (offsetExpiresSec === ONE_DAY_EXPIRATION_KEYWORD) {
            parsedSec = SECONDS_IN_DAY;
        } else {
            parsedSec = Number.parseInt(offsetExpiresSec, 10);
            if (Number.isNaN(parsedSec)) {
                return null;
            }
        }
        return parsedSec * MS_IN_SEC;
    }
    function parseKeywordValue(rawValue) {
        var NOW_VALUE_KEYWORD = "$now$";
        var CURRENT_DATE_KEYWORD = "$currentDate$";
        var CURRENT_ISO_DATE_KEYWORD = "$currentISODate$";
        var parsedValue = rawValue;
        if (rawValue === NOW_VALUE_KEYWORD) {
            parsedValue = Date.now().toString();
        } else if (rawValue === CURRENT_DATE_KEYWORD) {
            parsedValue = Date();
        } else if (rawValue === CURRENT_ISO_DATE_KEYWORD) {
            parsedValue = (new Date).toISOString();
        }
        return parsedValue;
    }
    function getCookiePath(rawPath) {
        if (rawPath === "/") {
            return "path=/";
        }
        return "";
    }
    var updatedArgs = args ? [].concat(source).concat(args) : [ source ];
    try {
        trustedSetCookie.apply(this, updatedArgs);
        if (source.uniqueId) {
            Object.defineProperty(Window.prototype.toString, uniqueIdentifier, {
                value: flag,
                enumerable: false,
                writable: false,
                configurable: false
            });
        }
    } catch (e) {
        console.log(e);
    }
}

function trustedSetCookieReload(source, args) {
    var flag = "done";
    var uniqueIdentifier = source.uniqueId + source.name + "_" + (Array.isArray(args) ? args.join("_") : "");
    if (source.uniqueId) {
        if (Window.prototype.toString[uniqueIdentifier] === flag) {
            return;
        }
    }
    function trustedSetCookieReload(source, name, value) {
        var offsetExpiresSec = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : "";
        var path = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : "/";
        var domain = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : "";
        if (typeof name === "undefined") {
            logMessage(source, "Cookie name should be specified");
            return;
        }
        if (typeof value === "undefined") {
            logMessage(source, "Cookie value should be specified");
            return;
        }
        if (isCookieSetWithValue(document.cookie, name, value)) {
            return;
        }
        var parsedValue = parseKeywordValue(value);
        if (!isValidCookiePath(path)) {
            logMessage(source, `Invalid cookie path: '${path}'`);
            return;
        }
        if (!document.location.origin.includes(domain)) {
            logMessage(source, `Cookie domain not matched by origin: '${domain}'`);
            return;
        }
        var cookieToSet = serializeCookie(name, parsedValue, path, domain, false);
        if (!cookieToSet) {
            logMessage(source, "Invalid cookie name or value");
            return;
        }
        if (offsetExpiresSec) {
            var parsedOffsetMs = getTrustedCookieOffsetMs(offsetExpiresSec);
            if (!parsedOffsetMs) {
                logMessage(source, `Invalid offsetExpiresSec value: ${offsetExpiresSec}`);
                return;
            }
            var expires = Date.now() + parsedOffsetMs;
            cookieToSet += `; expires=${new Date(expires).toUTCString()}`;
        }
        document.cookie = cookieToSet;
        hit(source);
        var cookieValueToCheck = parseCookieString(document.cookie)[name];
        if (isCookieSetWithValue(document.cookie, name, cookieValueToCheck)) {
            window.location.reload();
        }
    }
    function hit(source) {
        var ADGUARD_PREFIX = "[AdGuard]";
        if (!source.verbose) {
            return;
        }
        try {
            var trace = console.trace.bind(console);
            var label = `${ADGUARD_PREFIX} `;
            if (source.engine === "corelibs") {
                label += source.ruleText;
            } else {
                if (source.domainName) {
                    label += `${source.domainName}`;
                }
                if (source.args) {
                    label += `#%#//scriptlet('${source.name}', '${source.args.join("', '")}')`;
                } else {
                    label += `#%#//scriptlet('${source.name}')`;
                }
            }
            if (trace) {
                trace(label);
            }
        } catch (e) {}
        if (typeof window.__debug === "function") {
            window.__debug(source);
        }
    }
    function logMessage(source, message) {
        var forced = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
        var convertMessageToString = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
        var {name: name, verbose: verbose} = source;
        if (!forced && !verbose) {
            return;
        }
        var nativeConsole = console.log;
        if (!convertMessageToString) {
            nativeConsole(`${name}:`, message);
            return;
        }
        nativeConsole(`${name}: ${message}`);
    }
    function isCookieSetWithValue(cookieString, name, value) {
        return cookieString.split(";").some((function(cookieStr) {
            var pos = cookieStr.indexOf("=");
            if (pos === -1) {
                return false;
            }
            var cookieName = cookieStr.slice(0, pos).trim();
            var cookieValue = cookieStr.slice(pos + 1).trim();
            return name === cookieName && value === cookieValue;
        }));
    }
    function serializeCookie(name, rawValue, rawPath) {
        var domainValue = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : "";
        var shouldEncodeValue = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : true;
        var HOST_PREFIX = "__Host-";
        var SECURE_PREFIX = "__Secure-";
        var COOKIE_BREAKER = ";";
        if (!shouldEncodeValue && `${rawValue}`.includes(COOKIE_BREAKER) || name.includes(COOKIE_BREAKER)) {
            return null;
        }
        var value = shouldEncodeValue ? encodeURIComponent(rawValue) : rawValue;
        var resultCookie = `${name}=${value}`;
        if (name.startsWith(HOST_PREFIX)) {
            resultCookie += "; path=/; secure";
            if (domainValue) {
                console.debug(`Domain value: "${domainValue}" has been ignored, because is not allowed for __Host- prefixed cookies`);
            }
            return resultCookie;
        }
        var path = getCookiePath(rawPath);
        if (path) {
            resultCookie += `; ${path}`;
        }
        if (name.startsWith(SECURE_PREFIX)) {
            resultCookie += "; secure";
        }
        if (domainValue) {
            resultCookie += `; domain=${domainValue}`;
        }
        return resultCookie;
    }
    function isValidCookiePath(rawPath) {
        return rawPath === "/" || rawPath === "none";
    }
    function getTrustedCookieOffsetMs(offsetExpiresSec) {
        var ONE_YEAR_EXPIRATION_KEYWORD = "1year";
        var ONE_DAY_EXPIRATION_KEYWORD = "1day";
        var MS_IN_SEC = 1e3;
        var SECONDS_IN_YEAR = 365 * 24 * 60 * 60;
        var SECONDS_IN_DAY = 24 * 60 * 60;
        var parsedSec;
        if (offsetExpiresSec === ONE_YEAR_EXPIRATION_KEYWORD) {
            parsedSec = SECONDS_IN_YEAR;
        } else if (offsetExpiresSec === ONE_DAY_EXPIRATION_KEYWORD) {
            parsedSec = SECONDS_IN_DAY;
        } else {
            parsedSec = Number.parseInt(offsetExpiresSec, 10);
            if (Number.isNaN(parsedSec)) {
                return null;
            }
        }
        return parsedSec * MS_IN_SEC;
    }
    function parseKeywordValue(rawValue) {
        var NOW_VALUE_KEYWORD = "$now$";
        var CURRENT_DATE_KEYWORD = "$currentDate$";
        var CURRENT_ISO_DATE_KEYWORD = "$currentISODate$";
        var parsedValue = rawValue;
        if (rawValue === NOW_VALUE_KEYWORD) {
            parsedValue = Date.now().toString();
        } else if (rawValue === CURRENT_DATE_KEYWORD) {
            parsedValue = Date();
        } else if (rawValue === CURRENT_ISO_DATE_KEYWORD) {
            parsedValue = (new Date).toISOString();
        }
        return parsedValue;
    }
    function parseCookieString(cookieString) {
        var COOKIE_DELIMITER = "=";
        var COOKIE_PAIRS_DELIMITER = ";";
        var cookieChunks = cookieString.split(COOKIE_PAIRS_DELIMITER);
        var cookieData = {};
        cookieChunks.forEach((function(singleCookie) {
            var cookieKey;
            var cookieValue = "";
            var delimiterIndex = singleCookie.indexOf(COOKIE_DELIMITER);
            if (delimiterIndex === -1) {
                cookieKey = singleCookie.trim();
            } else {
                cookieKey = singleCookie.slice(0, delimiterIndex).trim();
                cookieValue = singleCookie.slice(delimiterIndex + 1);
            }
            cookieData[cookieKey] = cookieValue || null;
        }));
        return cookieData;
    }
    function getCookiePath(rawPath) {
        if (rawPath === "/") {
            return "path=/";
        }
        return "";
    }
    var updatedArgs = args ? [].concat(source).concat(args) : [ source ];
    try {
        trustedSetCookieReload.apply(this, updatedArgs);
        if (source.uniqueId) {
            Object.defineProperty(Window.prototype.toString, uniqueIdentifier, {
                value: flag,
                enumerable: false,
                writable: false,
                configurable: false
            });
        }
    } catch (e) {
        console.log(e);
    }
}

function trustedSetLocalStorageItem(source, args) {
    var flag = "done";
    var uniqueIdentifier = source.uniqueId + source.name + "_" + (Array.isArray(args) ? args.join("_") : "");
    if (source.uniqueId) {
        if (Window.prototype.toString[uniqueIdentifier] === flag) {
            return;
        }
    }
    function trustedSetLocalStorageItem(source, key, value) {
        if (typeof key === "undefined") {
            logMessage(source, "Item key should be specified");
            return;
        }
        if (typeof value === "undefined") {
            logMessage(source, "Item value should be specified");
            return;
        }
        var parsedValue = parseKeywordValue(value);
        var {localStorage: localStorage} = window;
        setStorageItem(source, localStorage, key, parsedValue);
        hit(source);
    }
    function hit(source) {
        var ADGUARD_PREFIX = "[AdGuard]";
        if (!source.verbose) {
            return;
        }
        try {
            var trace = console.trace.bind(console);
            var label = `${ADGUARD_PREFIX} `;
            if (source.engine === "corelibs") {
                label += source.ruleText;
            } else {
                if (source.domainName) {
                    label += `${source.domainName}`;
                }
                if (source.args) {
                    label += `#%#//scriptlet('${source.name}', '${source.args.join("', '")}')`;
                } else {
                    label += `#%#//scriptlet('${source.name}')`;
                }
            }
            if (trace) {
                trace(label);
            }
        } catch (e) {}
        if (typeof window.__debug === "function") {
            window.__debug(source);
        }
    }
    function logMessage(source, message) {
        var forced = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
        var convertMessageToString = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
        var {name: name, verbose: verbose} = source;
        if (!forced && !verbose) {
            return;
        }
        var nativeConsole = console.log;
        if (!convertMessageToString) {
            nativeConsole(`${name}:`, message);
            return;
        }
        nativeConsole(`${name}: ${message}`);
    }
    function setStorageItem(source, storage, key, value) {
        try {
            storage.setItem(key, value);
        } catch (e) {
            var message = `Unable to set storage item due to: ${e.message}`;
            logMessage(source, message);
        }
    }
    function parseKeywordValue(rawValue) {
        var NOW_VALUE_KEYWORD = "$now$";
        var CURRENT_DATE_KEYWORD = "$currentDate$";
        var CURRENT_ISO_DATE_KEYWORD = "$currentISODate$";
        var parsedValue = rawValue;
        if (rawValue === NOW_VALUE_KEYWORD) {
            parsedValue = Date.now().toString();
        } else if (rawValue === CURRENT_DATE_KEYWORD) {
            parsedValue = Date();
        } else if (rawValue === CURRENT_ISO_DATE_KEYWORD) {
            parsedValue = (new Date).toISOString();
        }
        return parsedValue;
    }
    var updatedArgs = args ? [].concat(source).concat(args) : [ source ];
    try {
        trustedSetLocalStorageItem.apply(this, updatedArgs);
        if (source.uniqueId) {
            Object.defineProperty(Window.prototype.toString, uniqueIdentifier, {
                value: flag,
                enumerable: false,
                writable: false,
                configurable: false
            });
        }
    } catch (e) {
        console.log(e);
    }
}

function trustedSetSessionStorageItem(source, args) {
    var flag = "done";
    var uniqueIdentifier = source.uniqueId + source.name + "_" + (Array.isArray(args) ? args.join("_") : "");
    if (source.uniqueId) {
        if (Window.prototype.toString[uniqueIdentifier] === flag) {
            return;
        }
    }
    function trustedSetSessionStorageItem(source, key, value) {
        if (typeof key === "undefined") {
            logMessage(source, "Item key should be specified");
            return;
        }
        if (typeof value === "undefined") {
            logMessage(source, "Item value should be specified");
            return;
        }
        var parsedValue = parseKeywordValue(value);
        var {sessionStorage: sessionStorage} = window;
        setStorageItem(source, sessionStorage, key, parsedValue);
        hit(source);
    }
    function hit(source) {
        var ADGUARD_PREFIX = "[AdGuard]";
        if (!source.verbose) {
            return;
        }
        try {
            var trace = console.trace.bind(console);
            var label = `${ADGUARD_PREFIX} `;
            if (source.engine === "corelibs") {
                label += source.ruleText;
            } else {
                if (source.domainName) {
                    label += `${source.domainName}`;
                }
                if (source.args) {
                    label += `#%#//scriptlet('${source.name}', '${source.args.join("', '")}')`;
                } else {
                    label += `#%#//scriptlet('${source.name}')`;
                }
            }
            if (trace) {
                trace(label);
            }
        } catch (e) {}
        if (typeof window.__debug === "function") {
            window.__debug(source);
        }
    }
    function logMessage(source, message) {
        var forced = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
        var convertMessageToString = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
        var {name: name, verbose: verbose} = source;
        if (!forced && !verbose) {
            return;
        }
        var nativeConsole = console.log;
        if (!convertMessageToString) {
            nativeConsole(`${name}:`, message);
            return;
        }
        nativeConsole(`${name}: ${message}`);
    }
    function setStorageItem(source, storage, key, value) {
        try {
            storage.setItem(key, value);
        } catch (e) {
            var message = `Unable to set storage item due to: ${e.message}`;
            logMessage(source, message);
        }
    }
    function parseKeywordValue(rawValue) {
        var NOW_VALUE_KEYWORD = "$now$";
        var CURRENT_DATE_KEYWORD = "$currentDate$";
        var CURRENT_ISO_DATE_KEYWORD = "$currentISODate$";
        var parsedValue = rawValue;
        if (rawValue === NOW_VALUE_KEYWORD) {
            parsedValue = Date.now().toString();
        } else if (rawValue === CURRENT_DATE_KEYWORD) {
            parsedValue = Date();
        } else if (rawValue === CURRENT_ISO_DATE_KEYWORD) {
            parsedValue = (new Date).toISOString();
        }
        return parsedValue;
    }
    var updatedArgs = args ? [].concat(source).concat(args) : [ source ];
    try {
        trustedSetSessionStorageItem.apply(this, updatedArgs);
        if (source.uniqueId) {
            Object.defineProperty(Window.prototype.toString, uniqueIdentifier, {
                value: flag,
                enumerable: false,
                writable: false,
                configurable: false
            });
        }
    } catch (e) {
        console.log(e);
    }
}

function trustedSuppressNativeMethod(source, args) {
    var flag = "done";
    var uniqueIdentifier = source.uniqueId + source.name + "_" + (Array.isArray(args) ? args.join("_") : "");
    if (source.uniqueId) {
        if (Window.prototype.toString[uniqueIdentifier] === flag) {
            return;
        }
    }
    function trustedSuppressNativeMethod(source, methodPath, signatureStr) {
        var how = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : "abort";
        var stack = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : "";
        if (!methodPath || !signatureStr) {
            return;
        }
        var IGNORE_ARG_SYMBOL = " ";
        var suppress = how === "abort" ? getAbortFunc() : function() {};
        var signatureMatcher;
        try {
            signatureMatcher = signatureStr.split("|").map((function(value) {
                return value === IGNORE_ARG_SYMBOL ? value : inferValue(value);
            }));
        } catch (e) {
            logMessage(source, `Could not parse the signature matcher: ${getErrorMessage(e)}`);
            return;
        }
        var getPathParts = getPropertyInChain;
        var {base: base, chain: chain, prop: prop} = getPathParts(window, methodPath);
        if (typeof chain !== "undefined") {
            logMessage(source, `Could not reach the end of the prop chain: ${methodPath}`);
            return;
        }
        var nativeMethod = base[prop];
        if (!nativeMethod || typeof nativeMethod !== "function") {
            logMessage(source, `Could not retrieve the method: ${methodPath}`);
            return;
        }
        function matchMethodCall(nativeArguments, matchArguments) {
            return matchArguments.every((function(matcher, i) {
                if (matcher === IGNORE_ARG_SYMBOL) {
                    return true;
                }
                var argument = nativeArguments[i];
                return isValueMatched(argument, matcher);
            }));
        }
        var isMatchingSuspended = false;
        function apply(target, thisArg, argumentsList) {
            if (isMatchingSuspended) {
                return Reflect.apply(target, thisArg, argumentsList);
            }
            isMatchingSuspended = true;
            if (stack && !matchStackTrace(stack, (new Error).stack || "")) {
                return Reflect.apply(target, thisArg, argumentsList);
            }
            var isMatching = matchMethodCall(argumentsList, signatureMatcher);
            isMatchingSuspended = false;
            if (isMatching) {
                hit(source);
                return suppress();
            }
            return Reflect.apply(target, thisArg, argumentsList);
        }
        base[prop] = new Proxy(nativeMethod, {
            apply: apply
        });
    }
    function hit(source) {
        var ADGUARD_PREFIX = "[AdGuard]";
        if (!source.verbose) {
            return;
        }
        try {
            var trace = console.trace.bind(console);
            var label = `${ADGUARD_PREFIX} `;
            if (source.engine === "corelibs") {
                label += source.ruleText;
            } else {
                if (source.domainName) {
                    label += `${source.domainName}`;
                }
                if (source.args) {
                    label += `#%#//scriptlet('${source.name}', '${source.args.join("', '")}')`;
                } else {
                    label += `#%#//scriptlet('${source.name}')`;
                }
            }
            if (trace) {
                trace(label);
            }
        } catch (e) {}
        if (typeof window.__debug === "function") {
            window.__debug(source);
        }
    }
    function logMessage(source, message) {
        var forced = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
        var convertMessageToString = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
        var {name: name, verbose: verbose} = source;
        if (!forced && !verbose) {
            return;
        }
        var nativeConsole = console.log;
        if (!convertMessageToString) {
            nativeConsole(`${name}:`, message);
            return;
        }
        nativeConsole(`${name}: ${message}`);
    }
    function getPropertyInChain(base, chain) {
        var pos = chain.indexOf(".");
        if (pos === -1) {
            return {
                base: base,
                prop: chain
            };
        }
        var prop = chain.slice(0, pos);
        if (base === null) {
            return {
                base: base,
                prop: prop,
                chain: chain
            };
        }
        var nextBase = base[prop];
        chain = chain.slice(pos + 1);
        if ((base instanceof Object || typeof base === "object") && isEmptyObject(base)) {
            return {
                base: base,
                prop: prop,
                chain: chain
            };
        }
        if (nextBase === null) {
            return {
                base: base,
                prop: prop,
                chain: chain
            };
        }
        if (nextBase !== undefined) {
            return getPropertyInChain(nextBase, chain);
        }
        Object.defineProperty(base, prop, {
            configurable: true
        });
        return {
            base: base,
            prop: prop,
            chain: chain
        };
    }
    function inferValue(value) {
        if (value === "undefined") {
            return undefined;
        }
        if (value === "false") {
            return false;
        }
        if (value === "true") {
            return true;
        }
        if (value === "null") {
            return null;
        }
        if (value === "NaN") {
            return NaN;
        }
        if (value.startsWith("/") && value.endsWith("/")) {
            return toRegExp(value);
        }
        var MAX_ALLOWED_NUM = 32767;
        var numVal = Number(value);
        if (!nativeIsNaN(numVal)) {
            if (Math.abs(numVal) > MAX_ALLOWED_NUM) {
                throw new Error("number values bigger than 32767 are not allowed");
            }
            return numVal;
        }
        var errorMessage = `'${value}' value type can't be inferred`;
        try {
            var parsableVal = JSON.parse(value);
            if (parsableVal instanceof Object || typeof parsableVal === "string") {
                return parsableVal;
            }
        } catch (e) {
            errorMessage += `: ${e}`;
        }
        throw new TypeError(errorMessage);
    }
    function isValueMatched(value, matcher) {
        if (typeof value === "function") {
            return false;
        }
        if (nativeIsNaN(value)) {
            return nativeIsNaN(matcher);
        }
        if (value === null || typeof value === "undefined" || typeof value === "number" || typeof value === "boolean") {
            return value === matcher;
        }
        if (typeof value === "string") {
            if (typeof matcher === "string" || matcher instanceof RegExp) {
                return isStringMatched(value, matcher);
            }
            return false;
        }
        if (Array.isArray(value) && Array.isArray(matcher)) {
            return isArrayMatched(value, matcher);
        }
        if (isArbitraryObject(value) && isArbitraryObject(matcher)) {
            return isObjectMatched(value, matcher);
        }
        return false;
    }
    function getAbortFunc() {
        var rid = randomId();
        var isErrorHandlerSet = false;
        return function abort() {
            if (!isErrorHandlerSet) {
                window.onerror = createOnErrorHandler(rid);
                isErrorHandlerSet = true;
            }
            throw new ReferenceError(rid);
        };
    }
    function matchStackTrace(stackMatch, stackTrace) {
        if (!stackMatch || stackMatch === "") {
            return true;
        }
        var regExpValues = backupRegExpValues();
        if (shouldAbortInlineOrInjectedScript(stackMatch, stackTrace)) {
            if (regExpValues.length && regExpValues[0] !== RegExp.$1) {
                restoreRegExpValues(regExpValues);
            }
            return true;
        }
        var stackRegexp = toRegExp(stackMatch);
        var refinedStackTrace = stackTrace.split("\n").slice(2).map((function(line) {
            return line.trim();
        })).join("\n");
        if (regExpValues.length && regExpValues[0] !== RegExp.$1) {
            restoreRegExpValues(regExpValues);
        }
        return getNativeRegexpTest().call(stackRegexp, refinedStackTrace);
    }
    function getErrorMessage(error) {
        var isErrorWithMessage = function isErrorWithMessage(e) {
            return typeof e === "object" && e !== null && "message" in e && typeof e.message === "string";
        };
        if (isErrorWithMessage(error)) {
            return error.message;
        }
        try {
            return new Error(JSON.stringify(error)).message;
        } catch (_unused) {
            return new Error(String(error)).message;
        }
    }
    function shouldAbortInlineOrInjectedScript(stackMatch, stackTrace) {
        var INLINE_SCRIPT_STRING = "inlineScript";
        var INJECTED_SCRIPT_STRING = "injectedScript";
        var INJECTED_SCRIPT_MARKER = "<anonymous>";
        var isInlineScript = function isInlineScript(match) {
            return match.includes(INLINE_SCRIPT_STRING);
        };
        var isInjectedScript = function isInjectedScript(match) {
            return match.includes(INJECTED_SCRIPT_STRING);
        };
        if (!(isInlineScript(stackMatch) || isInjectedScript(stackMatch))) {
            return false;
        }
        var documentURL = window.location.href;
        var pos = documentURL.indexOf("#");
        if (pos !== -1) {
            documentURL = documentURL.slice(0, pos);
        }
        var stackSteps = stackTrace.split("\n").slice(2).map((function(line) {
            return line.trim();
        }));
        var stackLines = stackSteps.map((function(line) {
            var stack;
            var getStackTraceValues = /(.*?@)?(\S+)(:\d+)(:\d+)\)?$/.exec(line);
            if (getStackTraceValues) {
                var _stackURL, _stackURL2;
                var stackURL = getStackTraceValues[2];
                var stackLine = getStackTraceValues[3];
                var stackCol = getStackTraceValues[4];
                if ((_stackURL = stackURL) !== null && _stackURL !== void 0 && _stackURL.startsWith("(")) {
                    stackURL = stackURL.slice(1);
                }
                if ((_stackURL2 = stackURL) !== null && _stackURL2 !== void 0 && _stackURL2.startsWith(INJECTED_SCRIPT_MARKER)) {
                    var _stackFunction;
                    stackURL = INJECTED_SCRIPT_STRING;
                    var stackFunction = getStackTraceValues[1] !== undefined ? getStackTraceValues[1].slice(0, -1) : line.slice(0, getStackTraceValues.index).trim();
                    if ((_stackFunction = stackFunction) !== null && _stackFunction !== void 0 && _stackFunction.startsWith("at")) {
                        stackFunction = stackFunction.slice(2).trim();
                    }
                    stack = `${stackFunction} ${stackURL}${stackLine}${stackCol}`.trim();
                } else if (stackURL === documentURL) {
                    stack = `${INLINE_SCRIPT_STRING}${stackLine}${stackCol}`.trim();
                } else {
                    stack = `${stackURL}${stackLine}${stackCol}`.trim();
                }
            } else {
                stack = line;
            }
            return stack;
        }));
        if (stackLines) {
            for (var index = 0; index < stackLines.length; index += 1) {
                if (isInlineScript(stackMatch) && stackLines[index].startsWith(INLINE_SCRIPT_STRING) && stackLines[index].match(toRegExp(stackMatch))) {
                    return true;
                }
                if (isInjectedScript(stackMatch) && stackLines[index].startsWith(INJECTED_SCRIPT_STRING) && stackLines[index].match(toRegExp(stackMatch))) {
                    return true;
                }
            }
        }
        return false;
    }
    function getNativeRegexpTest() {
        var descriptor = Object.getOwnPropertyDescriptor(RegExp.prototype, "test");
        var nativeRegexTest = descriptor === null || descriptor === void 0 ? void 0 : descriptor.value;
        if (descriptor && typeof descriptor.value === "function") {
            return nativeRegexTest;
        }
        throw new Error("RegExp.prototype.test is not a function");
    }
    function toRegExp(rawInput) {
        var input = rawInput || "";
        var DEFAULT_VALUE = ".?";
        var FORWARD_SLASH = "/";
        if (input === "") {
            return new RegExp(DEFAULT_VALUE);
        }
        var delimiterIndex = input.lastIndexOf(FORWARD_SLASH);
        var flagsPart = input.substring(delimiterIndex + 1);
        var regExpPart = input.substring(0, delimiterIndex + 1);
        var isValidRegExpFlag = function isValidRegExpFlag(flag) {
            if (!flag) {
                return false;
            }
            try {
                new RegExp("", flag);
                return true;
            } catch (ex) {
                return false;
            }
        };
        var getRegExpFlags = function getRegExpFlags(regExpStr, flagsStr) {
            if (regExpStr.startsWith(FORWARD_SLASH) && regExpStr.endsWith(FORWARD_SLASH) && !regExpStr.endsWith("\\/") && isValidRegExpFlag(flagsStr)) {
                return flagsStr;
            }
            return "";
        };
        var flags = getRegExpFlags(regExpPart, flagsPart);
        if (input.startsWith(FORWARD_SLASH) && input.endsWith(FORWARD_SLASH) || flags) {
            var regExpInput = flags ? regExpPart : input;
            return new RegExp(regExpInput.slice(1, -1), flags);
        }
        var escaped = input.replace(/\\'/g, "'").replace(/\\"/g, '"').replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
        return new RegExp(escaped);
    }
    function nativeIsNaN(num) {
        var native = Number.isNaN || window.isNaN;
        return native(num);
    }
    function randomId() {
        return Math.random().toString(36).slice(2, 9);
    }
    function createOnErrorHandler(rid) {
        var nativeOnError = window.onerror;
        return function onError(error) {
            if (typeof error === "string" && error.includes(rid)) {
                return true;
            }
            if (nativeOnError instanceof Function) {
                for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
                    args[_key - 1] = arguments[_key];
                }
                return nativeOnError.apply(window, [ error, ...args ]);
            }
            return false;
        };
    }
    function isEmptyObject(obj) {
        return Object.keys(obj).length === 0 && !obj.prototype;
    }
    function isArbitraryObject(value) {
        return value !== null && typeof value === "object" && !Array.isArray(value) && !(value instanceof RegExp);
    }
    function isStringMatched(str, matcher) {
        if (typeof matcher === "string") {
            if (matcher === "") {
                return str === matcher;
            }
            return str.includes(matcher);
        }
        if (matcher instanceof RegExp) {
            return matcher.test(str);
        }
        return false;
    }
    function isArrayMatched(array, matcher) {
        if (array.length === 0) {
            return matcher.length === 0;
        }
        if (matcher.length === 0) {
            return false;
        }
        var _loop = function _loop() {
            var matcherValue = matcher[i];
            var isMatching = array.some((function(arrItem) {
                return isValueMatched(arrItem, matcherValue);
            }));
            if (!isMatching) {
                return {
                    v: false
                };
            }
            return 0;
        }, _ret;
        for (var i = 0; i < matcher.length; i += 1) {
            _ret = _loop();
            if (_ret === 0) continue;
            if (_ret) return _ret.v;
        }
        return true;
    }
    function isObjectMatched(obj, matcher) {
        var matcherKeys = Object.keys(matcher);
        for (var i = 0; i < matcherKeys.length; i += 1) {
            var key = matcherKeys[i];
            var value = obj[key];
            if (!isValueMatched(value, matcher[key])) {
                return false;
            }
            continue;
        }
        return true;
    }
    function backupRegExpValues() {
        try {
            var arrayOfRegexpValues = [];
            for (var index = 1; index < 10; index += 1) {
                var value = `$${index}`;
                if (!RegExp[value]) {
                    break;
                }
                arrayOfRegexpValues.push(RegExp[value]);
            }
            return arrayOfRegexpValues;
        } catch (error) {
            return [];
        }
    }
    function restoreRegExpValues(array) {
        if (!array.length) {
            return;
        }
        try {
            var stringPattern = "";
            if (array.length === 1) {
                stringPattern = `(${array[0]})`;
            } else {
                stringPattern = array.reduce((function(accumulator, currentValue, currentIndex) {
                    if (currentIndex === 1) {
                        return `(${accumulator}),(${currentValue})`;
                    }
                    return `${accumulator},(${currentValue})`;
                }));
            }
            var regExpGroup = new RegExp(stringPattern);
            array.toString().replace(regExpGroup, "");
        } catch (error) {
            var message = `Failed to restore RegExp values: ${error}`;
            console.log(message);
        }
    }
    var updatedArgs = args ? [].concat(source).concat(args) : [ source ];
    try {
        trustedSuppressNativeMethod.apply(this, updatedArgs);
        if (source.uniqueId) {
            Object.defineProperty(Window.prototype.toString, uniqueIdentifier, {
                value: flag,
                enumerable: false,
                writable: false,
                configurable: false
            });
        }
    } catch (e) {
        console.log(e);
    }
}

function xmlPrune(source, args) {
    var flag = "done";
    var uniqueIdentifier = source.uniqueId + source.name + "_" + (Array.isArray(args) ? args.join("_") : "");
    if (source.uniqueId) {
        if (Window.prototype.toString[uniqueIdentifier] === flag) {
            return;
        }
    }
    function xmlPrune(source, propsToRemove) {
        var optionalProp = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : "";
        var urlToMatch = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : "";
        var verbose = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;
        if (typeof Reflect === "undefined" || typeof fetch === "undefined" || typeof Proxy === "undefined" || typeof Response === "undefined") {
            return;
        }
        var shouldPruneResponse = false;
        var shouldLogContent = verbose === "true";
        var urlMatchRegexp = toRegExp(urlToMatch);
        var XPATH_MARKER = "xpath(";
        var isXpath = propsToRemove && propsToRemove.startsWith(XPATH_MARKER);
        var getXPathElements = function getXPathElements(contextNode) {
            var matchedElements = [];
            try {
                var elementsToRemove = propsToRemove.slice(XPATH_MARKER.length, -1);
                var xpathResult = contextNode.evaluate(elementsToRemove, contextNode, null, XPathResult.UNORDERED_NODE_SNAPSHOT_TYPE, null);
                for (var i = 0; i < xpathResult.snapshotLength; i += 1) {
                    matchedElements.push(xpathResult.snapshotItem(i));
                }
            } catch (ex) {
                var message = `Invalid XPath parameter: ${propsToRemove}\n${ex}`;
                logMessage(source, message);
            }
            return matchedElements;
        };
        var xPathPruning = function xPathPruning(xPathElements) {
            xPathElements.forEach((function(element) {
                if (element.nodeType === 1) {
                    element.remove();
                } else if (element.nodeType === 2) {
                    element.ownerElement.removeAttribute(element.nodeName);
                }
            }));
        };
        var isXML = function isXML(text) {
            if (typeof text === "string") {
                var trimmedText = text.trim();
                if (trimmedText.startsWith("<") && trimmedText.endsWith(">")) {
                    return true;
                }
            }
            return false;
        };
        var createXMLDocument = function createXMLDocument(text) {
            var xmlParser = new DOMParser;
            var xmlDocument = xmlParser.parseFromString(text, "text/xml");
            return xmlDocument;
        };
        var isPruningNeeded = function isPruningNeeded(response, propsToRemove) {
            if (!isXML(response)) {
                return false;
            }
            var docXML = createXMLDocument(response);
            return isXpath ? getXPathElements(docXML) : !!docXML.querySelector(propsToRemove);
        };
        var pruneXML = function pruneXML(text) {
            if (!isXML(text)) {
                shouldPruneResponse = false;
                return text;
            }
            var xmlDoc = createXMLDocument(text);
            var errorNode = xmlDoc.querySelector("parsererror");
            if (errorNode) {
                return text;
            }
            if (optionalProp !== "" && xmlDoc.querySelector(optionalProp) === null) {
                shouldPruneResponse = false;
                return text;
            }
            var elements = isXpath ? getXPathElements(xmlDoc) : xmlDoc.querySelectorAll(propsToRemove);
            if (!elements.length) {
                shouldPruneResponse = false;
                return text;
            }
            if (shouldLogContent) {
                var cloneXmlDoc = xmlDoc.cloneNode(true);
                logMessage(source, "Original xml:");
                logMessage(source, cloneXmlDoc, true, false);
            }
            if (isXpath) {
                xPathPruning(elements);
            } else {
                elements.forEach((function(elem) {
                    elem.remove();
                }));
            }
            if (shouldLogContent) {
                logMessage(source, "Modified xml:");
                logMessage(source, xmlDoc, true, false);
            }
            var serializer = new XMLSerializer;
            text = serializer.serializeToString(xmlDoc);
            return text;
        };
        var nativeOpen = window.XMLHttpRequest.prototype.open;
        var nativeSend = window.XMLHttpRequest.prototype.send;
        var xhrData;
        var openWrapper = function openWrapper(target, thisArg, args) {
            xhrData = getXhrData.apply(null, args);
            if (matchRequestProps(source, urlToMatch, xhrData)) {
                thisArg.shouldBePruned = true;
            }
            if (thisArg.shouldBePruned) {
                thisArg.collectedHeaders = [];
                var setRequestHeaderWrapper = function setRequestHeaderWrapper(target, thisArg, args) {
                    thisArg.collectedHeaders.push(args);
                    return Reflect.apply(target, thisArg, args);
                };
                var setRequestHeaderHandler = {
                    apply: setRequestHeaderWrapper
                };
                thisArg.setRequestHeader = new Proxy(thisArg.setRequestHeader, setRequestHeaderHandler);
            }
            return Reflect.apply(target, thisArg, args);
        };
        var sendWrapper = function sendWrapper(target, thisArg, args) {
            var allowedResponseTypeValues = [ "", "text" ];
            if (!thisArg.shouldBePruned || !allowedResponseTypeValues.includes(thisArg.responseType)) {
                return Reflect.apply(target, thisArg, args);
            }
            var forgedRequest = new XMLHttpRequest;
            forgedRequest.addEventListener("readystatechange", (function() {
                if (forgedRequest.readyState !== 4) {
                    return;
                }
                var {readyState: readyState, response: response, responseText: responseText, responseURL: responseURL, responseXML: responseXML, status: status, statusText: statusText} = forgedRequest;
                var content = responseText || response;
                if (typeof content !== "string") {
                    return;
                }
                if (!propsToRemove) {
                    if (isXML(response)) {
                        var message = `XMLHttpRequest.open() URL: ${responseURL}\nresponse: ${response}`;
                        logMessage(source, message);
                        logMessage(source, createXMLDocument(response), true, false);
                    }
                } else {
                    shouldPruneResponse = isPruningNeeded(response, propsToRemove);
                }
                var responseContent = shouldPruneResponse ? pruneXML(response) : response;
                Object.defineProperties(thisArg, {
                    readyState: {
                        value: readyState,
                        writable: false
                    },
                    responseURL: {
                        value: responseURL,
                        writable: false
                    },
                    responseXML: {
                        value: responseXML,
                        writable: false
                    },
                    status: {
                        value: status,
                        writable: false
                    },
                    statusText: {
                        value: statusText,
                        writable: false
                    },
                    response: {
                        value: responseContent,
                        writable: false
                    },
                    responseText: {
                        value: responseContent,
                        writable: false
                    }
                });
                setTimeout((function() {
                    var stateEvent = new Event("readystatechange");
                    thisArg.dispatchEvent(stateEvent);
                    var loadEvent = new Event("load");
                    thisArg.dispatchEvent(loadEvent);
                    var loadEndEvent = new Event("loadend");
                    thisArg.dispatchEvent(loadEndEvent);
                }), 1);
                hit(source);
            }));
            nativeOpen.apply(forgedRequest, [ xhrData.method, xhrData.url ]);
            thisArg.collectedHeaders.forEach((function(header) {
                var name = header[0];
                var value = header[1];
                forgedRequest.setRequestHeader(name, value);
            }));
            thisArg.collectedHeaders = [];
            try {
                nativeSend.call(forgedRequest, args);
            } catch (_unused) {
                return Reflect.apply(target, thisArg, args);
            }
            return undefined;
        };
        var openHandler = {
            apply: openWrapper
        };
        var sendHandler = {
            apply: sendWrapper
        };
        XMLHttpRequest.prototype.open = new Proxy(XMLHttpRequest.prototype.open, openHandler);
        XMLHttpRequest.prototype.send = new Proxy(XMLHttpRequest.prototype.send, sendHandler);
        var nativeFetch = window.fetch;
        var fetchWrapper = async function fetchWrapper(target, thisArg, args) {
            var fetchURL = args[0] instanceof Request ? args[0].url : args[0];
            if (typeof fetchURL !== "string" || fetchURL.length === 0) {
                return Reflect.apply(target, thisArg, args);
            }
            if (urlMatchRegexp.test(fetchURL)) {
                var response = await nativeFetch(...args);
                var clonedResponse = response.clone();
                var responseText = await response.text();
                shouldPruneResponse = isPruningNeeded(responseText, propsToRemove);
                if (!shouldPruneResponse) {
                    var message = `fetch URL: ${fetchURL}\nresponse text: ${responseText}`;
                    logMessage(source, message);
                    logMessage(source, createXMLDocument(responseText), true, false);
                    return clonedResponse;
                }
                var prunedText = pruneXML(responseText);
                if (shouldPruneResponse) {
                    hit(source);
                    return new Response(prunedText, {
                        status: response.status,
                        statusText: response.statusText,
                        headers: response.headers
                    });
                }
                return clonedResponse;
            }
            return Reflect.apply(target, thisArg, args);
        };
        var fetchHandler = {
            apply: fetchWrapper
        };
        window.fetch = new Proxy(window.fetch, fetchHandler);
    }
    function hit(source) {
        var ADGUARD_PREFIX = "[AdGuard]";
        if (!source.verbose) {
            return;
        }
        try {
            var trace = console.trace.bind(console);
            var label = `${ADGUARD_PREFIX} `;
            if (source.engine === "corelibs") {
                label += source.ruleText;
            } else {
                if (source.domainName) {
                    label += `${source.domainName}`;
                }
                if (source.args) {
                    label += `#%#//scriptlet('${source.name}', '${source.args.join("', '")}')`;
                } else {
                    label += `#%#//scriptlet('${source.name}')`;
                }
            }
            if (trace) {
                trace(label);
            }
        } catch (e) {}
        if (typeof window.__debug === "function") {
            window.__debug(source);
        }
    }
    function logMessage(source, message) {
        var forced = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
        var convertMessageToString = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
        var {name: name, verbose: verbose} = source;
        if (!forced && !verbose) {
            return;
        }
        var nativeConsole = console.log;
        if (!convertMessageToString) {
            nativeConsole(`${name}:`, message);
            return;
        }
        nativeConsole(`${name}: ${message}`);
    }
    function toRegExp(rawInput) {
        var input = rawInput || "";
        var DEFAULT_VALUE = ".?";
        var FORWARD_SLASH = "/";
        if (input === "") {
            return new RegExp(DEFAULT_VALUE);
        }
        var delimiterIndex = input.lastIndexOf(FORWARD_SLASH);
        var flagsPart = input.substring(delimiterIndex + 1);
        var regExpPart = input.substring(0, delimiterIndex + 1);
        var isValidRegExpFlag = function isValidRegExpFlag(flag) {
            if (!flag) {
                return false;
            }
            try {
                new RegExp("", flag);
                return true;
            } catch (ex) {
                return false;
            }
        };
        var getRegExpFlags = function getRegExpFlags(regExpStr, flagsStr) {
            if (regExpStr.startsWith(FORWARD_SLASH) && regExpStr.endsWith(FORWARD_SLASH) && !regExpStr.endsWith("\\/") && isValidRegExpFlag(flagsStr)) {
                return flagsStr;
            }
            return "";
        };
        var flags = getRegExpFlags(regExpPart, flagsPart);
        if (input.startsWith(FORWARD_SLASH) && input.endsWith(FORWARD_SLASH) || flags) {
            var regExpInput = flags ? regExpPart : input;
            return new RegExp(regExpInput.slice(1, -1), flags);
        }
        var escaped = input.replace(/\\'/g, "'").replace(/\\"/g, '"').replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
        return new RegExp(escaped);
    }
    function getXhrData(method, url, async, user, password) {
        return {
            method: method,
            url: url,
            async: async,
            user: user,
            password: password
        };
    }
    function matchRequestProps(source, propsToMatch, requestData) {
        if (propsToMatch === "" || propsToMatch === "*") {
            return true;
        }
        var isMatched;
        var parsedData = parseMatchProps(propsToMatch);
        if (!isValidParsedData(parsedData)) {
            logMessage(source, `Invalid parameter: ${propsToMatch}`);
            isMatched = false;
        } else {
            var matchData = getMatchPropsData(parsedData);
            var matchKeys = Object.keys(matchData);
            isMatched = matchKeys.every((function(matchKey) {
                var matchValue = matchData[matchKey];
                var dataValue = requestData[matchKey];
                return Object.prototype.hasOwnProperty.call(requestData, matchKey) && typeof dataValue === "string" && (matchValue === null || matchValue === void 0 ? void 0 : matchValue.test(dataValue));
            }));
        }
        return isMatched;
    }
    function getMatchPropsData(data) {
        var matchData = {};
        var dataKeys = Object.keys(data);
        dataKeys.forEach((function(key) {
            matchData[key] = toRegExp(data[key]);
        }));
        return matchData;
    }
    function getRequestProps() {
        return [ "url", "method", "headers", "body", "credentials", "cache", "redirect", "referrer", "referrerPolicy", "integrity", "keepalive", "signal", "mode" ];
    }
    function isValidParsedData(data) {
        return Object.values(data).every((function(value) {
            return isValidStrPattern(value);
        }));
    }
    function parseMatchProps(propsToMatchStr) {
        var PROPS_DIVIDER = " ";
        var PAIRS_MARKER = ":";
        var isRequestProp = function isRequestProp(prop) {
            return getRequestProps().includes(prop);
        };
        var propsObj = {};
        var props = propsToMatchStr.split(PROPS_DIVIDER);
        props.forEach((function(prop) {
            var dividerInd = prop.indexOf(PAIRS_MARKER);
            var key = prop.slice(0, dividerInd);
            if (isRequestProp(key)) {
                var value = prop.slice(dividerInd + 1);
                propsObj[key] = value;
            } else {
                propsObj.url = prop;
            }
        }));
        return propsObj;
    }
    function isValidStrPattern(input) {
        var FORWARD_SLASH = "/";
        var str = escapeRegExp(input);
        if (input[0] === FORWARD_SLASH && input[input.length - 1] === FORWARD_SLASH) {
            str = input.slice(1, -1);
        }
        var isValid;
        try {
            isValid = new RegExp(str);
            isValid = true;
        } catch (e) {
            isValid = false;
        }
        return isValid;
    }
    function escapeRegExp(str) {
        return str.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
    }
    var updatedArgs = args ? [].concat(source).concat(args) : [ source ];
    try {
        xmlPrune.apply(this, updatedArgs);
        if (source.uniqueId) {
            Object.defineProperty(Window.prototype.toString, uniqueIdentifier, {
                value: flag,
                enumerable: false,
                writable: false,
                configurable: false
            });
        }
    } catch (e) {
        console.log(e);
    }
}

var scriptletsMap = {
    "amazon-apstag": AmazonApstag,
    "ubo-amazon_apstag.js": AmazonApstag,
    "amazon_apstag.js": AmazonApstag,
    "didomi-loader": DidomiLoader,
    fingerprintjs2: Fingerprintjs2,
    "ubo-fingerprint2.js": Fingerprintjs2,
    "fingerprint2.js": Fingerprintjs2,
    fingerprintjs3: Fingerprintjs3,
    "ubo-fingerprint3.js": Fingerprintjs3,
    "fingerprint3.js": Fingerprintjs3,
    gemius: Gemius,
    "google-analytics-ga": GoogleAnalyticsGa,
    "ubo-google-analytics_ga.js": GoogleAnalyticsGa,
    "google-analytics_ga.js": GoogleAnalyticsGa,
    "google-analytics": GoogleAnalytics,
    "ubo-google-analytics_analytics.js": GoogleAnalytics,
    "google-analytics_analytics.js": GoogleAnalytics,
    "googletagmanager-gtm": GoogleAnalytics,
    "ubo-googletagmanager_gtm.js": GoogleAnalytics,
    "googletagmanager_gtm.js": GoogleAnalytics,
    "google-ima3": GoogleIma3,
    "ubo-google-ima.js": GoogleIma3,
    "google-ima.js": GoogleIma3,
    "googlesyndication-adsbygoogle": GoogleSyndicationAdsByGoogle,
    "ubo-googlesyndication_adsbygoogle.js": GoogleSyndicationAdsByGoogle,
    "googlesyndication_adsbygoogle.js": GoogleSyndicationAdsByGoogle,
    "googletagservices-gpt": GoogleTagServicesGpt,
    "ubo-googletagservices_gpt.js": GoogleTagServicesGpt,
    "googletagservices_gpt.js": GoogleTagServicesGpt,
    matomo: Matomo,
    "naver-wcslog": NaverWcslog,
    "pardot-1.0": Pardot,
    prebid: Prebid,
    "scorecardresearch-beacon": ScoreCardResearchBeacon,
    "ubo-scorecardresearch_beacon.js": ScoreCardResearchBeacon,
    "scorecardresearch_beacon.js": ScoreCardResearchBeacon,
    "abort-current-inline-script": abortCurrentInlineScript,
    "abort-current-script.js": abortCurrentInlineScript,
    "ubo-abort-current-script.js": abortCurrentInlineScript,
    "acs.js": abortCurrentInlineScript,
    "ubo-acs.js": abortCurrentInlineScript,
    "ubo-abort-current-script": abortCurrentInlineScript,
    "ubo-acs": abortCurrentInlineScript,
    "abort-current-inline-script.js": abortCurrentInlineScript,
    "ubo-abort-current-inline-script.js": abortCurrentInlineScript,
    "acis.js": abortCurrentInlineScript,
    "ubo-acis.js": abortCurrentInlineScript,
    "ubo-abort-current-inline-script": abortCurrentInlineScript,
    "ubo-acis": abortCurrentInlineScript,
    "abp-abort-current-inline-script": abortCurrentInlineScript,
    "abort-on-property-read": abortOnPropertyRead,
    "abort-on-property-read.js": abortOnPropertyRead,
    "ubo-abort-on-property-read.js": abortOnPropertyRead,
    "aopr.js": abortOnPropertyRead,
    "ubo-aopr.js": abortOnPropertyRead,
    "ubo-abort-on-property-read": abortOnPropertyRead,
    "ubo-aopr": abortOnPropertyRead,
    "abp-abort-on-property-read": abortOnPropertyRead,
    "abort-on-property-write": abortOnPropertyWrite,
    "abort-on-property-write.js": abortOnPropertyWrite,
    "ubo-abort-on-property-write.js": abortOnPropertyWrite,
    "aopw.js": abortOnPropertyWrite,
    "ubo-aopw.js": abortOnPropertyWrite,
    "ubo-abort-on-property-write": abortOnPropertyWrite,
    "ubo-aopw": abortOnPropertyWrite,
    "abp-abort-on-property-write": abortOnPropertyWrite,
    "abort-on-stack-trace": abortOnStackTrace,
    "abort-on-stack-trace.js": abortOnStackTrace,
    "ubo-abort-on-stack-trace.js": abortOnStackTrace,
    "aost.js": abortOnStackTrace,
    "ubo-aost.js": abortOnStackTrace,
    "ubo-abort-on-stack-trace": abortOnStackTrace,
    "ubo-aost": abortOnStackTrace,
    "abp-abort-on-stack-trace": abortOnStackTrace,
    "adjust-setInterval": adjustSetInterval,
    "nano-setInterval-booster.js": adjustSetInterval,
    "ubo-nano-setInterval-booster.js": adjustSetInterval,
    "nano-sib.js": adjustSetInterval,
    "ubo-nano-sib.js": adjustSetInterval,
    "adjust-setInterval.js": adjustSetInterval,
    "ubo-adjust-setInterval.js": adjustSetInterval,
    "ubo-nano-setInterval-booster": adjustSetInterval,
    "ubo-nano-sib": adjustSetInterval,
    "ubo-adjust-setInterval": adjustSetInterval,
    "adjust-setTimeout": adjustSetTimeout,
    "adjust-setTimeout.js": adjustSetTimeout,
    "ubo-adjust-setTimeout.js": adjustSetTimeout,
    "nano-setTimeout-booster.js": adjustSetTimeout,
    "ubo-nano-setTimeout-booster.js": adjustSetTimeout,
    "nano-stb.js": adjustSetTimeout,
    "ubo-nano-stb.js": adjustSetTimeout,
    "ubo-adjust-setTimeout": adjustSetTimeout,
    "ubo-nano-setTimeout-booster": adjustSetTimeout,
    "ubo-nano-stb": adjustSetTimeout,
    "call-nothrow": callNoThrow,
    "call-nothrow.js": callNoThrow,
    "ubo-call-nothrow.js": callNoThrow,
    "ubo-call-nothrow": callNoThrow,
    "debug-current-inline-script": debugCurrentInlineScript,
    "debug-on-property-read": debugOnPropertyRead,
    "debug-on-property-write": debugOnPropertyWrite,
    "dir-string": dirString,
    "disable-newtab-links": disableNewtabLinks,
    "disable-newtab-links.js": disableNewtabLinks,
    "ubo-disable-newtab-links.js": disableNewtabLinks,
    "ubo-disable-newtab-links": disableNewtabLinks,
    "evaldata-prune": evalDataPrune,
    "evaldata-prune.js": evalDataPrune,
    "ubo-evaldata-prune.js": evalDataPrune,
    "ubo-evaldata-prune": evalDataPrune,
    "close-window": forceWindowClose,
    "window-close-if.js": forceWindowClose,
    "ubo-window-close-if.js": forceWindowClose,
    "ubo-window-close-if": forceWindowClose,
    "close-window.js": forceWindowClose,
    "ubo-close-window.js": forceWindowClose,
    "ubo-close-window": forceWindowClose,
    "hide-in-shadow-dom": hideInShadowDom,
    "href-sanitizer": hrefSanitizer,
    "href-sanitizer.js": hrefSanitizer,
    "ubo-href-sanitizer.js": hrefSanitizer,
    "ubo-href-sanitizer": hrefSanitizer,
    "inject-css-in-shadow-dom": injectCssInShadowDom,
    "json-prune-fetch-response": jsonPruneFetchResponse,
    "json-prune-fetch-response.js": jsonPruneFetchResponse,
    "ubo-json-prune-fetch-response.js": jsonPruneFetchResponse,
    "ubo-json-prune-fetch-response": jsonPruneFetchResponse,
    "json-prune": jsonPrune,
    "json-prune.js": jsonPrune,
    "ubo-json-prune.js": jsonPrune,
    "ubo-json-prune": jsonPrune,
    "abp-json-prune": jsonPrune,
    "json-prune-xhr-response": jsonPruneXhrResponse,
    "json-prune-xhr-response.js": jsonPruneXhrResponse,
    "ubo-json-prune-xhr-response.js": jsonPruneXhrResponse,
    "ubo-json-prune-xhr-response": jsonPruneXhrResponse,
    "log-addEventListener": logAddEventListener,
    "addEventListener-logger.js": logAddEventListener,
    "ubo-addEventListener-logger.js": logAddEventListener,
    "aell.js": logAddEventListener,
    "ubo-aell.js": logAddEventListener,
    "ubo-addEventListener-logger": logAddEventListener,
    "ubo-aell": logAddEventListener,
    "log-eval": logEval,
    log: log,
    "abp-log": log,
    "log-on-stack-trace": logOnStackTrace,
    "m3u-prune": m3uPrune,
    "m3u-prune.js": m3uPrune,
    "ubo-m3u-prune.js": m3uPrune,
    "ubo-m3u-prune": m3uPrune,
    "metrika-yandex-tag": metrikaYandexTag,
    "metrika-yandex-watch": metrikaYandexWatch,
    "no-protected-audience": noProtectedAudience,
    "no-topics": noTopics,
    noeval: noeval,
    "noeval.js": noeval,
    "silent-noeval.js": noeval,
    "ubo-noeval.js": noeval,
    "ubo-silent-noeval.js": noeval,
    "ubo-noeval": noeval,
    "ubo-silent-noeval": noeval,
    nowebrtc: nowebrtc,
    "nowebrtc.js": nowebrtc,
    "ubo-nowebrtc.js": nowebrtc,
    "ubo-nowebrtc": nowebrtc,
    "prevent-addEventListener": preventAddEventListener,
    "addEventListener-defuser.js": preventAddEventListener,
    "ubo-addEventListener-defuser.js": preventAddEventListener,
    "aeld.js": preventAddEventListener,
    "ubo-aeld.js": preventAddEventListener,
    "ubo-addEventListener-defuser": preventAddEventListener,
    "ubo-aeld": preventAddEventListener,
    "abp-prevent-listener": preventAddEventListener,
    "prevent-adfly": preventAdfly,
    "prevent-bab": preventBab,
    "prevent-canvas": preventCanvas,
    "prevent-canvas.js": preventCanvas,
    "ubo-prevent-canvas.js": preventCanvas,
    "ubo-prevent-canvas": preventCanvas,
    "prevent-element-src-loading": preventElementSrcLoading,
    "prevent-eval-if": preventEvalIf,
    "noeval-if.js": preventEvalIf,
    "ubo-noeval-if.js": preventEvalIf,
    "ubo-noeval-if": preventEvalIf,
    "prevent-fab-3.2.0": preventFab,
    "nofab.js": preventFab,
    "ubo-nofab.js": preventFab,
    "fuckadblock.js-3.2.0": preventFab,
    "ubo-fuckadblock.js-3.2.0": preventFab,
    "ubo-nofab": preventFab,
    "prevent-fetch": preventFetch,
    "prevent-fetch.js": preventFetch,
    "ubo-prevent-fetch.js": preventFetch,
    "ubo-prevent-fetch": preventFetch,
    "no-fetch-if.js": preventFetch,
    "ubo-no-fetch-if.js": preventFetch,
    "ubo-no-fetch-if": preventFetch,
    "prevent-popads-net": preventPopadsNet,
    "popads.net.js": preventPopadsNet,
    "ubo-popads.net.js": preventPopadsNet,
    "ubo-popads.net": preventPopadsNet,
    "prevent-refresh": preventRefresh,
    "prevent-refresh.js": preventRefresh,
    "refresh-defuser.js": preventRefresh,
    "refresh-defuser": preventRefresh,
    "ubo-prevent-refresh.js": preventRefresh,
    "ubo-prevent-refresh": preventRefresh,
    "ubo-refresh-defuser.js": preventRefresh,
    "ubo-refresh-defuser": preventRefresh,
    "prevent-requestAnimationFrame": preventRequestAnimationFrame,
    "no-requestAnimationFrame-if.js": preventRequestAnimationFrame,
    "ubo-no-requestAnimationFrame-if.js": preventRequestAnimationFrame,
    "norafif.js": preventRequestAnimationFrame,
    "ubo-norafif.js": preventRequestAnimationFrame,
    "ubo-no-requestAnimationFrame-if": preventRequestAnimationFrame,
    "ubo-norafif": preventRequestAnimationFrame,
    "prevent-setInterval": preventSetInterval,
    "no-setInterval-if.js": preventSetInterval,
    "ubo-no-setInterval-if.js": preventSetInterval,
    "setInterval-defuser.js": preventSetInterval,
    "ubo-setInterval-defuser.js": preventSetInterval,
    "nosiif.js": preventSetInterval,
    "ubo-nosiif.js": preventSetInterval,
    "sid.js": preventSetInterval,
    "ubo-sid.js": preventSetInterval,
    "ubo-no-setInterval-if": preventSetInterval,
    "ubo-setInterval-defuser": preventSetInterval,
    "ubo-nosiif": preventSetInterval,
    "ubo-sid": preventSetInterval,
    "prevent-setTimeout": preventSetTimeout,
    "no-setTimeout-if.js": preventSetTimeout,
    "ubo-no-setTimeout-if.js": preventSetTimeout,
    "nostif.js": preventSetTimeout,
    "ubo-nostif.js": preventSetTimeout,
    "ubo-no-setTimeout-if": preventSetTimeout,
    "ubo-nostif": preventSetTimeout,
    "setTimeout-defuser.js": preventSetTimeout,
    "ubo-setTimeout-defuser.js": preventSetTimeout,
    "ubo-setTimeout-defuser": preventSetTimeout,
    "std.js": preventSetTimeout,
    "ubo-std.js": preventSetTimeout,
    "ubo-std": preventSetTimeout,
    "prevent-window-open": preventWindowOpen,
    "window.open-defuser.js": preventWindowOpen,
    "ubo-window.open-defuser.js": preventWindowOpen,
    "ubo-window.open-defuser": preventWindowOpen,
    "nowoif.js": preventWindowOpen,
    "ubo-nowoif.js": preventWindowOpen,
    "ubo-nowoif": preventWindowOpen,
    "no-window-open-if.js": preventWindowOpen,
    "ubo-no-window-open-if.js": preventWindowOpen,
    "ubo-no-window-open-if": preventWindowOpen,
    "prevent-xhr": preventXHR,
    "no-xhr-if.js": preventXHR,
    "ubo-no-xhr-if.js": preventXHR,
    "ubo-no-xhr-if": preventXHR,
    "remove-attr": removeAttr,
    "remove-attr.js": removeAttr,
    "ubo-remove-attr.js": removeAttr,
    "ra.js": removeAttr,
    "ubo-ra.js": removeAttr,
    "ubo-remove-attr": removeAttr,
    "ubo-ra": removeAttr,
    "remove-class": removeClass,
    "remove-class.js": removeClass,
    "ubo-remove-class.js": removeClass,
    "rc.js": removeClass,
    "ubo-rc.js": removeClass,
    "ubo-remove-class": removeClass,
    "ubo-rc": removeClass,
    "remove-cookie": removeCookie,
    "cookie-remover.js": removeCookie,
    "ubo-cookie-remover.js": removeCookie,
    "ubo-cookie-remover": removeCookie,
    "remove-cookie.js": removeCookie,
    "ubo-remove-cookie.js": removeCookie,
    "ubo-remove-cookie": removeCookie,
    "abp-cookie-remover": removeCookie,
    "remove-in-shadow-dom": removeInShadowDom,
    "remove-node-text": removeNodeText,
    "remove-node-text.js": removeNodeText,
    "ubo-remove-node-text.js": removeNodeText,
    "rmnt.js": removeNodeText,
    "ubo-rmnt.js": removeNodeText,
    "ubo-remove-node-text": removeNodeText,
    "ubo-rmnt": removeNodeText,
    "set-attr": setAttr,
    "set-attr.js": setAttr,
    "ubo-set-attr.js": setAttr,
    "ubo-set-attr": setAttr,
    "set-constant": setConstant,
    "set-constant.js": setConstant,
    "ubo-set-constant.js": setConstant,
    "set.js": setConstant,
    "ubo-set.js": setConstant,
    "ubo-set-constant": setConstant,
    "ubo-set": setConstant,
    "abp-override-property-read": setConstant,
    "set-cookie": setCookie,
    "set-cookie.js": setCookie,
    "ubo-set-cookie.js": setCookie,
    "ubo-set-cookie": setCookie,
    "set-cookie-reload": setCookieReload,
    "set-cookie-reload.js": setCookieReload,
    "ubo-set-cookie-reload.js": setCookieReload,
    "ubo-set-cookie-reload": setCookieReload,
    "set-local-storage-item": setLocalStorageItem,
    "set-local-storage-item.js": setLocalStorageItem,
    "ubo-set-local-storage-item.js": setLocalStorageItem,
    "ubo-set-local-storage-item": setLocalStorageItem,
    "set-popads-dummy": setPopadsDummy,
    "popads-dummy.js": setPopadsDummy,
    "ubo-popads-dummy.js": setPopadsDummy,
    "ubo-popads-dummy": setPopadsDummy,
    "set-session-storage-item": setSessionStorageItem,
    "set-session-storage-item.js": setSessionStorageItem,
    "ubo-set-session-storage-item.js": setSessionStorageItem,
    "ubo-set-session-storage-item": setSessionStorageItem,
    "spoof-css": spoofCSS,
    "spoof-css.js": spoofCSS,
    "ubo-spoof-css.js": spoofCSS,
    "ubo-spoof-css": spoofCSS,
    "trusted-click-element": trustedClickElement,
    "trusted-create-element": trustedCreateElement,
    "trusted-dispatch-event": trustedDispatchEvent,
    "trusted-prune-inbound-object": trustedPruneInboundObject,
    "trusted-replace-fetch-response": trustedReplaceFetchResponse,
    "trusted-replace-node-text": trustedReplaceNodeText,
    "trusted-replace-outbound-text": trustedReplaceOutboundText,
    "trusted-replace-xhr-response": trustedReplaceXhrResponse,
    "trusted-set-attr": trustedSetAttr,
    "trusted-set-constant": trustedSetConstant,
    "trusted-set-cookie": trustedSetCookie,
    "trusted-set-cookie-reload": trustedSetCookieReload,
    "trusted-set-local-storage-item": trustedSetLocalStorageItem,
    "trusted-set-session-storage-item": trustedSetSessionStorageItem,
    "trusted-suppress-native-method": trustedSuppressNativeMethod,
    "xml-prune": xmlPrune,
    "xml-prune.js": xmlPrune,
    "ubo-xml-prune.js": xmlPrune,
    "ubo-xml-prune": xmlPrune
};

var getScriptletFunction = function getScriptletFunction(name) {
    return scriptletsMap[name];
};

function passSourceAndProps(source, code) {
    var redirect = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
    var sourceString = JSON.stringify(source);
    var argsString = source.args ? `[${source.args.map((function(arg) {
        return JSON.stringify(arg);
    }))}]` : undefined;
    var params = argsString ? `${sourceString}, ${argsString}` : sourceString;
    if (redirect) {
        return `(function(source, args){\n${code}\n})(${params});`;
    }
    return `(${code})(${params});`;
}

function wrapInNonameFunc(code) {
    return `function(source, args){\n${code}\n}`;
}

function getScriptletCode(source) {
    var scriptletFunction = getScriptletFunction(source.name);
    if (typeof scriptletFunction !== "function") {
        throw new Error(`Error: cannot invoke scriptlet with name: '${source.name}'`);
    }
    var scriptletFunctionString = scriptletFunction.toString();
    var result = source.engine === "corelibs" || source.engine === "test" ? wrapInNonameFunc(scriptletFunctionString) : passSourceAndProps(source, scriptletFunctionString);
    return result;
}

var scriptlets = {
    invoke: getScriptletCode,
    getScriptletFunction: getScriptletFunction
};




/***/ }),

/***/ 66448:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  td: () => (/* binding */ isRedirectResourceCompatibleWithAdg),
  GY: () => (/* binding */ isValidScriptletName)
});

// UNUSED EXPORTS: isAbpSnippetRule, isAdgScriptletRule, isUboScriptletRule, isValidAdgRedirectRule, isValidScriptletRule

;// ./node_modules/.pnpm/@adguard+agtree@3.0.1/node_modules/@adguard/agtree/dist/compatibility-tables/platforms.js
/*
 * AGTree v3.0.1 (build date: Fri, 28 Feb 2025 15:31:12 GMT)
 * (c) 2025 Adguard Software Ltd.
 * Released under the MIT license
 * https://github.com/AdguardTeam/tsurlfilter/tree/master/packages/agtree#readme
 */
/* eslint-disable no-bitwise */
/**
 * @file Provides platform enums.
 * The difference between specific and generic platforms is that specific platforms are individual platforms
 * (e.g. AdGuard for Windows, AdGuard for Android, etc.),
 * while generic platforms are groups of specific platforms
 * (e.g. AdGuard for any OS, AdGuard for any Chromium-based extension, etc.).
 */
/**
 * List of specific platforms.
 */
const SpecificPlatform = {
    AdgOsWindows: 1,
    AdgOsMac: 1 << 1,
    AdgOsAndroid: 1 << 2,
    AdgExtChrome: 1 << 3,
    AdgExtOpera: 1 << 4,
    AdgExtEdge: 1 << 5,
    AdgExtFirefox: 1 << 6,
    AdgCbAndroid: 1 << 7,
    AdgCbIos: 1 << 8,
    AdgCbSafari: 1 << 9,
    UboExtChrome: 1 << 10,
    UboExtOpera: 1 << 11,
    UboExtEdge: 1 << 12,
    UboExtFirefox: 1 << 13,
    AbpExtChrome: 1 << 14,
    AbpExtOpera: 1 << 15,
    AbpExtEdge: 1 << 16,
    AbpExtFirefox: 1 << 17,
};
const AdgOsAny = SpecificPlatform.AdgOsWindows
    | SpecificPlatform.AdgOsMac
    | SpecificPlatform.AdgOsAndroid;
const AdgSafariAny = SpecificPlatform.AdgCbSafari | SpecificPlatform.AdgCbIos;
const AdgExtChromium = SpecificPlatform.AdgExtChrome
    | SpecificPlatform.AdgExtOpera
    | SpecificPlatform.AdgExtEdge;
const AdgExtAny = AdgExtChromium | SpecificPlatform.AdgExtFirefox;
const AdgAny = AdgExtAny | AdgOsAny | AdgSafariAny | SpecificPlatform.AdgCbAndroid;
const UboExtChromium = SpecificPlatform.UboExtChrome
    | SpecificPlatform.UboExtOpera
    | SpecificPlatform.UboExtEdge;
const UboExtAny = UboExtChromium | SpecificPlatform.UboExtFirefox;
const UboAny = UboExtAny;
const AbpExtChromium = SpecificPlatform.AbpExtChrome
    | SpecificPlatform.AbpExtOpera
    | SpecificPlatform.AbpExtEdge;
const AbpExtAny = AbpExtChromium | SpecificPlatform.AbpExtFirefox;
const AbpAny = AbpExtAny;
const Any = AdgAny | UboAny | AbpAny;
/**
 * List of generic platforms (combinations of specific platforms).
 */
const platforms_GenericPlatform = {
    AdgOsAny,
    AdgSafariAny,
    AdgExtChromium,
    AdgExtAny,
    AdgAny,
    UboExtChromium,
    UboExtAny,
    UboAny,
    AbpExtChromium,
    AbpExtAny,
    AbpAny,
    Any,
};



;// ./node_modules/.pnpm/@adguard+agtree@3.0.1/node_modules/@adguard/agtree/dist/utils/type-guards.js
/*
 * AGTree v3.0.1 (build date: Fri, 28 Feb 2025 15:31:12 GMT)
 * (c) 2025 Adguard Software Ltd.
 * Released under the MIT license
 * https://github.com/AdguardTeam/tsurlfilter/tree/master/packages/agtree#readme
 */
/**
 * Checks whether the given value is undefined.
 *
 * @param value Value to check.
 *
 * @returns `true` if the value is 'undefined', `false` otherwise.
 */
const isUndefined = (value) => {
    return typeof value === 'undefined';
};
/**
 * Checks whether the given value is null.
 *
 * @param value Value to check.
 *
 * @returns `true` if the value is 'null', `false` otherwise.
 */
const isNull = (value) => {
    return value === null;
};
/**
 * Checks whether the given value is a string.
 *
 * @param value Value to check.
 * @returns `true` if the value is a string, `false` otherwise.
 */
const isString = (value) => {
    return typeof value === 'string';
};
/**
 * Checks whether the given value is an array of Uint8Arrays.
 *
 * @param value Value to check.
 *
 * @returns True if the value type is an array of Uint8Arrays.
 */
const isArrayOfUint8Arrays = (value) => {
    return Array.isArray(value) && value.every((chunk) => chunk instanceof Uint8Array);
};



;// ./node_modules/.pnpm/@adguard+agtree@3.0.1/node_modules/@adguard/agtree/dist/compatibility-tables/utils/platform-helpers.js
/*
 * AGTree v3.0.1 (build date: Fri, 28 Feb 2025 15:31:12 GMT)
 * (c) 2025 Adguard Software Ltd.
 * Released under the MIT license
 * https://github.com/AdguardTeam/tsurlfilter/tree/master/packages/agtree#readme
 */


/* eslint-disable no-bitwise */
/**
 * @file Provides platform mapping and helper functions.
 */
/**
 * Map of specific platforms string names to their corresponding enum values.
 */
const SPECIFIC_PLATFORM_MAP = new Map([
    ['adg_os_windows', SpecificPlatform.AdgOsWindows],
    ['adg_os_mac', SpecificPlatform.AdgOsMac],
    ['adg_os_android', SpecificPlatform.AdgOsAndroid],
    ['adg_ext_chrome', SpecificPlatform.AdgExtChrome],
    ['adg_ext_opera', SpecificPlatform.AdgExtOpera],
    ['adg_ext_edge', SpecificPlatform.AdgExtEdge],
    ['adg_ext_firefox', SpecificPlatform.AdgExtFirefox],
    ['adg_cb_android', SpecificPlatform.AdgCbAndroid],
    ['adg_cb_ios', SpecificPlatform.AdgCbIos],
    ['adg_cb_safari', SpecificPlatform.AdgCbSafari],
    ['ubo_ext_chrome', SpecificPlatform.UboExtChrome],
    ['ubo_ext_opera', SpecificPlatform.UboExtOpera],
    ['ubo_ext_edge', SpecificPlatform.UboExtEdge],
    ['ubo_ext_firefox', SpecificPlatform.UboExtFirefox],
    ['abp_ext_chrome', SpecificPlatform.AbpExtChrome],
    ['abp_ext_opera', SpecificPlatform.AbpExtOpera],
    ['abp_ext_edge', SpecificPlatform.AbpExtEdge],
    ['abp_ext_firefox', SpecificPlatform.AbpExtFirefox],
]);
/**
 * Map of specific platforms enum values to their corresponding string names.
 *
 * @note Reverse of {@link SPECIFIC_PLATFORM_MAP}.
 */
const SPECIFIC_PLATFORM_MAP_REVERSE = new Map([...SPECIFIC_PLATFORM_MAP].map(([key, value]) => [value, key]));
/**
 * Map of generic platforms string names to their corresponding enum values.
 */
const GENERIC_PLATFORM_MAP = new Map([
    ['adg_os_any', platforms_GenericPlatform.AdgOsAny],
    ['adg_safari_any', platforms_GenericPlatform.AdgSafariAny],
    ['adg_ext_chromium', platforms_GenericPlatform.AdgExtChromium],
    ['adg_ext_any', platforms_GenericPlatform.AdgExtAny],
    ['adg_any', platforms_GenericPlatform.AdgAny],
    ['ubo_ext_chromium', platforms_GenericPlatform.UboExtChromium],
    ['ubo_ext_any', platforms_GenericPlatform.UboExtAny],
    ['ubo_any', platforms_GenericPlatform.UboAny],
    ['abp_ext_chromium', platforms_GenericPlatform.AbpExtChromium],
    ['abp_ext_any', platforms_GenericPlatform.AbpExtAny],
    ['abp_any', platforms_GenericPlatform.AbpAny],
    ['any', platforms_GenericPlatform.Any],
]);
/**
 * Check if the platform is a generic platform.
 *
 * @param platform Platform to check.
 *
 * @returns True if the platform is a generic platform, false otherwise.
 */
const isGenericPlatform = (platform) => {
    // if more than one bit is set, it's a generic platform
    return !!(platform & (platform - 1));
};
/**
 * Returns the platform enum value for the given platform string name.
 *
 * @param platform Platform string name, e.g., 'adg_os_windows'.
 *
 * @returns Specific or generic platform enum value.
 * @throws Error if the platform is unknown.
 */
const getPlatformId = (platform) => {
    const specificPlatform = SPECIFIC_PLATFORM_MAP.get(platform);
    if (specificPlatform) {
        return specificPlatform;
    }
    const genericPlatform = GENERIC_PLATFORM_MAP.get(platform);
    if (genericPlatform) {
        return genericPlatform;
    }
    throw new Error(`Unknown platform: ${platform}`);
};
/**
 * Returns the specific platform string name for the given platform enum value.
 *
 * @param platform Specific platform enum value.
 *
 * @returns Specific platform string name, e.g., 'adg_os_windows'.
 * @throws Error if the platform is unknown.
 */
const getSpecificPlatformName = (platform) => {
    const specificPlatform = SPECIFIC_PLATFORM_MAP_REVERSE.get(platform);
    if (!specificPlatform) {
        throw new Error(`Unknown platform: ${platform}`);
    }
    return specificPlatform;
};



;// ./node_modules/.pnpm/@adguard+agtree@3.0.1/node_modules/@adguard/agtree/dist/utils/adblockers.js
/*
 * AGTree v3.0.1 (build date: Fri, 28 Feb 2025 15:31:12 GMT)
 * (c) 2025 Adguard Software Ltd.
 * Released under the MIT license
 * https://github.com/AdguardTeam/tsurlfilter/tree/master/packages/agtree#readme
 */
/**
 * @file Possible adblock syntaxes are listed here.
 */
/**
 * Possible adblock syntaxes (supported by this library)
 */
const adblockers_AdblockSyntax = {
    /**
     * Common syntax, which is supported by more than one adblocker (or by all adblockers).
     *
     * We typically use this syntax when we cannot determine the concrete syntax of the rule,
     * because the syntax is used by more than one adblocker natively.
     *
     * @example
     * - `||example.org^$important` is a common syntax, since it is used by all adblockers natively, and
     * we cannot determine at parsing level whether `important` is a valid option or not, and if it is valid,
     * then which adblocker supports it.
     */
    Common: 'Common',
    /**
     * Adblock Plus syntax.
     *
     * @example
     * - `example.org#$#abort-on-property-read alert` is an Adblock Plus syntax, since it is not used by any other
     * adblockers directly (probably supported by some on-the-fly conversion, but this is not the native syntax).
     * @see {@link https://adblockplus.org/}
     */
    Abp: 'AdblockPlus',
    /**
     * uBlock Origin syntax.
     *
     * @example
     * - `example.com##+js(set, atob, noopFunc)` is an uBlock Origin syntax, since it is not used by any other
     * adblockers directly (probably supported by some on-the-fly conversion, but this is not the native syntax).
     * @see {@link https://github.com/gorhill/uBlock}
     */
    Ubo: 'UblockOrigin',
    /**
     * AdGuard syntax.
     *
     * @example
     * - `example.org#%#//scriptlet("abort-on-property-read", "alert")` is an AdGuard syntax, since it is not used
     * by any other adblockers directly (probably supported by some on-the-fly conversion, but this is not the native
     * syntax).
     * @see {@link https://adguard.com/}
     */
    Adg: 'AdGuard',
};



;// ./node_modules/.pnpm/@adguard+agtree@3.0.1/node_modules/@adguard/agtree/dist/compatibility-tables/base.js
/*
 * AGTree v3.0.1 (build date: Fri, 28 Feb 2025 15:31:12 GMT)
 * (c) 2025 Adguard Software Ltd.
 * Released under the MIT license
 * https://github.com/AdguardTeam/tsurlfilter/tree/master/packages/agtree#readme
 */





/* eslint-disable no-bitwise */
/**
 * @file Provides common compatibility table methods.
 */
/**
 * Base compatibility table class which provides common methods to work with compatibility data.
 *
 * @template T Compatibility data schema.
 */
class CompatibilityTableBase {
    /**
     * Compatibility table data.
     */
    data;
    /**
     * Optional name transformer function. If provided,
     * it will be called in all methods before processing compatibility data names.
     */
    nameTransformer;
    /**
     * Creates a new instance of the common compatibility table.
     *
     * @param data Compatibility table data.
     * @param nameTransformer Optional name transformer function.
     */
    constructor(data, nameTransformer = null) {
        this.data = data;
        this.nameTransformer = nameTransformer;
    }
    /**
     * Helper method to get a 'row' from the compatibility table data by name.
     *
     * @param name Compatibility data name.
     * @returns Compatibility table row storage or `null` if not found.
     */
    getRowStorage(name) {
        const idx = this.data.map[name];
        if (isUndefined(idx)) {
            return null;
        }
        return this.data.shared[idx];
    }
    /**
     * Checks whether a compatibility data `name` exists for any platform.
     *
     * @note Technically, do the same as `exists()` method with generic platform _any_
     * but it is faster because it does not apply complex logic.
     *
     * @param name Compatibility data name.
     *
     * @returns True if the compatibility data exists, false otherwise.
     */
    existsAny(name) {
        const normalizedName = this.nameTransformer ? this.nameTransformer(name) : name;
        return !isUndefined(this.data.map[normalizedName]);
    }
    /**
     * Checks whether a compatibility data `name` exists for a specified platform.
     *
     * @param name Compatibility data name.
     * @param platform Specific or generic platform.
     *
     * @returns True if the compatibility data exists, false otherwise.
     */
    exists(name, platform) {
        const normalizedName = this.nameTransformer ? this.nameTransformer(name) : name;
        const data = this.getRowStorage(normalizedName);
        if (!data) {
            return false;
        }
        const isMatch = (idx) => {
            const el = data.shared[idx];
            return !isUndefined(el) && (el.name === normalizedName || !!el.aliases?.includes(normalizedName));
        };
        if (isGenericPlatform(platform)) {
            // Since indexes are specific platforms in the compatibility table data,
            // we can't index them directly if the platform is generic (union of specific platforms).
            // In this case, we need to iterate over the keys and return true on the first match.
            const keys = Object.keys(data.map);
            for (let i = 0; i < keys.length; i += 1) {
                const key = Number(keys[i]);
                if (platform & key) {
                    const idx = data.map[key];
                    if (isMatch(idx)) {
                        return true;
                    }
                }
            }
            return false;
        }
        const idx = data.map[platform];
        return isMatch(idx);
    }
    /**
     * Returns a compatibility data by name and specific platform.
     *
     * @param name The name of the compatibility data.
     * @param platform The specific platform.
     *
     * @returns A single compatibility data or `null` if not found.
     */
    getSingle(name, platform) {
        const normalizedName = this.nameTransformer ? this.nameTransformer(name) : name;
        const data = this.getRowStorage(normalizedName);
        if (!data) {
            return null;
        }
        const idx = data.map[platform];
        return isUndefined(idx) ? null : data.shared[idx];
    }
    /**
     * Returns all compatibility data records for name and specified platform.
     *
     * @param name Compatibility data name.
     * @param platform Specific or generic platform.
     *
     * @returns Multiple records grouped by platforms.
     * Technically, it is an object where keys are platform enums values and values are compatibility data records.
     *
     * @note Platform enum values can be converted to string names using {@link getSpecificPlatformName} on demand.
     */
    getMultiple(name, platform) {
        const normalizedName = this.nameTransformer ? this.nameTransformer(name) : name;
        const data = this.getRowStorage(normalizedName);
        if (!data) {
            return null;
        }
        if (isGenericPlatform(platform)) {
            const result = {};
            const keys = Object.keys(data.map);
            for (let i = 0; i < keys.length; i += 1) {
                const key = Number(keys[i]);
                if (platform & key) {
                    const idx = data.map[key];
                    if (!isUndefined(idx)) {
                        result[key] = data.shared[idx];
                    }
                }
            }
            return result;
        }
        const idx = data.map[platform];
        if (isUndefined(idx)) {
            return null;
        }
        return { key: data.shared[idx] };
    }
    /**
     * Returns all compatibility data records for the specified platform.
     *
     * @param platform Specific or generic platform.
     *
     * @returns Array of multiple records grouped by platforms.
     */
    getAllMultiple(platform) {
        const result = [];
        for (let i = 0; i < this.data.shared.length; i += 1) {
            const data = this.data.shared[i];
            const names = new Set(data.shared.map(({ name }) => name));
            names.forEach((name) => {
                const multipleRecords = this.getMultiple(name, platform);
                if (multipleRecords) {
                    result.push(multipleRecords);
                }
            });
        }
        return result;
    }
    /**
     * Returns the first compatibility data record for name and specified platform.
     *
     * @param name Compatibility data name.
     * @param platform Specific or generic platform.
     *
     * @returns First found compatibility data record or `null` if not found.
     */
    getFirst(name, platform) {
        const normalizedName = this.nameTransformer ? this.nameTransformer(name) : name;
        const data = this.getRowStorage(normalizedName);
        if (!data) {
            return null;
        }
        if (isGenericPlatform(platform)) {
            const keys = Object.keys(data.map);
            for (let i = 0; i < keys.length; i += 1) {
                const key = Number(keys[i]);
                if (platform & key) {
                    const idx = data.map[key];
                    if (!isUndefined(idx)) {
                        // return the first found record
                        return data.shared[idx];
                    }
                }
            }
            return null;
        }
        const idx = data.map[platform];
        if (isUndefined(idx)) {
            return null;
        }
        return data.shared[idx];
    }
    /**
     * Returns all compatibility data records for the specified name.
     *
     * @param name Compatibility data name.
     *
     * @returns Array of multiple records grouped by platforms.
     */
    getRow(name) {
        const normalizedName = this.nameTransformer ? this.nameTransformer(name) : name;
        const data = this.getRowStorage(normalizedName);
        if (!data) {
            return [];
        }
        return data.shared;
    }
    /**
     * Returns all compatibility data grouped by products.
     *
     * @returns Array of multiple records grouped by products.
     */
    getRowsByProduct() {
        const result = [];
        for (let i = 0; i < this.data.shared.length; i += 1) {
            const data = this.data.shared[i];
            const keys = Object.keys(data.map);
            const row = {
                [adblockers_AdblockSyntax.Adg]: {},
                [adblockers_AdblockSyntax.Ubo]: {},
                [adblockers_AdblockSyntax.Abp]: {},
            };
            for (let j = 0; j < keys.length; j += 1) {
                const key = Number(keys[j]);
                if (key & platforms_GenericPlatform.AdgAny) {
                    row[adblockers_AdblockSyntax.Adg][key] = data.shared[data.map[key]];
                }
                else if (key & platforms_GenericPlatform.UboAny) {
                    row[adblockers_AdblockSyntax.Ubo][key] = data.shared[data.map[key]];
                }
                else if (key & platforms_GenericPlatform.AbpAny) {
                    row[adblockers_AdblockSyntax.Abp][key] = data.shared[data.map[key]];
                }
            }
            result.push(row);
        }
        return result;
    }
}



;// ./node_modules/.pnpm/@adguard+agtree@3.0.1/node_modules/@adguard/agtree/dist/compatibility-tables/compatibility-table-data.js
/*
 * AGTree v3.0.1 (build date: Fri, 28 Feb 2025 15:31:12 GMT)
 * (c) 2025 Adguard Software Ltd.
 * Released under the MIT license
 * https://github.com/AdguardTeam/tsurlfilter/tree/master/packages/agtree#readme
 */
const modifiersCompatibilityTableData = {shared:[{shared:[{name:'all',aliases:null,description:'$all modifier is made of $document, $popup, and all content-type modifiers combined.',docs:'https://adguard.app/kb/general/ad-filtering/create-own-filters/#all-modifier',versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,conflicts:null,inverseConflicts:false,assignable:false,negatable:false,blockOnly:true,exceptionOnly:false,valueOptional:false,valueFormat:null,valueFormatFlags:null},{name:'all',aliases:null,description:'The `all` option is equivalent to specifying all network-based types\n+ `popup`, `document`, `inline-font` and `inline-script`.',docs:'https://github.com/gorhill/uBlock/wiki/Static-filter-syntax#all',versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,conflicts:null,inverseConflicts:false,assignable:false,negatable:false,blockOnly:false,exceptionOnly:false,valueOptional:false,valueFormat:null,valueFormatFlags:null}],map:{'1':0,'2':0,'4':0,'8':0,'16':0,'32':0,'64':0,'256':0,'512':0,'1024':1,'2048':1,'4096':1,'8192':1}},{shared:[{name:'app',aliases:null,description:'The `$app` modifier lets you narrow the rule coverage down to a specific application or a list of applications.\nThe modifier\'s behavior and syntax perfectly match the corresponding basic rules `$app` modifier.',docs:'https://adguard.app/kb/general/ad-filtering/create-own-filters/#app-modifier',versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,conflicts:null,inverseConflicts:false,assignable:true,negatable:false,blockOnly:false,exceptionOnly:false,valueOptional:false,valueFormat:'pipe_separated_apps',valueFormatFlags:null}],map:{'1':0,'2':0,'4':0}},{shared:[{name:'badfilter',aliases:null,description:'The rules with the `$badfilter` modifier disable other basic rules to which they refer. It means that\nthe text of the disabled rule should match the text of the `$badfilter` rule (without the `$badfilter` modifier).',docs:'https://adguard.app/kb/general/ad-filtering/create-own-filters/#badfilter-modifier',versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,conflicts:null,inverseConflicts:false,assignable:false,negatable:false,blockOnly:false,exceptionOnly:false,valueOptional:false,valueFormat:null,valueFormatFlags:null},{name:'badfilter',aliases:null,description:'The rules with the `$badfilter` modifier disable other basic rules to which they refer. It means that\nthe text of the disabled rule should match the text of the `$badfilter` rule (without the `$badfilter` modifier).',docs:'https://github.com/gorhill/uBlock/wiki/Static-filter-syntax#badfilter',versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,conflicts:null,inverseConflicts:false,assignable:false,negatable:false,blockOnly:false,exceptionOnly:false,valueOptional:false,valueFormat:null,valueFormatFlags:null}],map:{'1':0,'2':0,'4':0,'8':0,'16':0,'32':0,'64':0,'256':0,'512':0,'1024':1,'2048':1,'4096':1,'8192':1}},{shared:[{name:'cname',aliases:null,description:'When used in an exception filter,\nit will bypass blocking CNAME uncloaked requests for the current (specified) document.',docs:'https://github.com/gorhill/uBlock/wiki/Static-filter-syntax#cname',versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,conflicts:null,inverseConflicts:false,assignable:false,negatable:false,blockOnly:false,exceptionOnly:true,valueOptional:false,valueFormat:null,valueFormatFlags:null}],map:{'1024':0,'2048':0,'4096':0,'8192':0}},{shared:[{name:'content',aliases:null,description:'Disables HTML filtering and `$replace` rules on the pages that match the rule.',docs:'https://adguard.app/kb/general/ad-filtering/create-own-filters/#content-modifier',versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,conflicts:null,inverseConflicts:false,assignable:false,negatable:false,blockOnly:false,exceptionOnly:true,valueOptional:false,valueFormat:null,valueFormatFlags:null}],map:{'1':0,'2':0,'4':0}},{shared:[{name:'cookie',aliases:null,description:'The `$cookie` modifier completely changes rule behavior.\nInstead of blocking a request, this modifier makes us suppress or modify the Cookie and Set-Cookie headers.',docs:'https://adguard.app/kb/general/ad-filtering/create-own-filters/#cookie-modifier',versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,conflicts:null,inverseConflicts:false,assignable:true,negatable:false,blockOnly:false,exceptionOnly:false,valueOptional:true,valueFormat:'^([^;=\\s]*?)((?:;(maxAge=\\d+;?)?|(sameSite=(lax|none|strict);?)?){1,3})(?<!;)$',valueFormatFlags:null}],map:{'1':0,'2':0,'4':0,'8':0,'16':0,'32':0,'64':0}},{shared:[{name:'csp',aliases:null,description:'This modifier completely changes the rule behavior.\nIf it is applied to a rule, it will not block the matching request.\nThe response headers are going to be modified instead.',docs:'https://adguard.app/kb/general/ad-filtering/create-own-filters/#csp-modifier',versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,conflicts:['domain','important','subdocument','badfilter'],inverseConflicts:true,assignable:true,negatable:false,blockOnly:false,exceptionOnly:false,valueOptional:true,valueFormat:'csp_value',valueFormatFlags:null},{name:'csp',aliases:null,description:'This modifier completely changes the rule behavior.\nIf it is applied to a rule, it will not block the matching request.\nThe response headers are going to be modified instead.',docs:'https://github.com/gorhill/uBlock/wiki/Static-filter-syntax#csp',versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,conflicts:['1p','3p','domain','badfilter'],inverseConflicts:true,assignable:true,negatable:false,blockOnly:false,exceptionOnly:false,valueOptional:true,valueFormat:'csp_value',valueFormatFlags:null},{name:'csp',aliases:null,description:'This modifier completely changes the rule behavior.\nIf it is applied to a rule, it will not block the matching request.\nThe response headers are going to be modified instead.',docs:'https://help.adblockplus.org/hc/en-us/articles/360062733293-How-to-write-filters#content-security-policies',versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,conflicts:['domain','subdocument'],inverseConflicts:true,assignable:true,negatable:false,blockOnly:false,exceptionOnly:false,valueOptional:true,valueFormat:'csp_value',valueFormatFlags:null}],map:{'1':0,'2':0,'4':0,'8':0,'16':0,'32':0,'64':0,'1024':1,'2048':1,'4096':1,'8192':1,'16384':2,'32768':2,'65536':2,'131072':2}},{shared:[{name:'denyallow',aliases:null,description:'The `$denyallow` modifier allows to avoid creating additional rules\nwhen it is needed to disable a certain rule for specific domains.\n`$denyallow` matches only target domains and not referrer domains.',docs:'https://adguard.app/kb/general/ad-filtering/create-own-filters/#denyallow-modifier',versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,conflicts:['to'],inverseConflicts:false,assignable:true,negatable:false,blockOnly:false,exceptionOnly:false,valueOptional:false,valueFormat:'pipe_separated_denyallow_domains',valueFormatFlags:null},{name:'denyallow',aliases:null,description:'The `$denyallow` modifier allows to avoid creating additional rules\nwhen it is needed to disable a certain rule for specific domains.\n`$denyallow` matches only target domains and not referrer domains.',docs:'https://github.com/gorhill/uBlock/wiki/Static-filter-syntax#denyallow',versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,conflicts:['to'],inverseConflicts:false,assignable:true,negatable:false,blockOnly:false,exceptionOnly:false,valueOptional:false,valueFormat:'pipe_separated_denyallow_domains',valueFormatFlags:null}],map:{'1':0,'2':0,'4':0,'8':0,'16':0,'32':0,'64':0,'256':0,'512':0,'1024':1,'2048':1,'4096':1,'8192':1}},{shared:[{name:'document',aliases:null,description:'The rule corresponds to the main frame document requests,\ni.e. HTML documents that are loaded in the browser tab.',docs:'https://adguard.app/kb/general/ad-filtering/create-own-filters/#document-modifier',versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,conflicts:null,inverseConflicts:false,assignable:false,negatable:false,blockOnly:false,exceptionOnly:false,valueOptional:false,valueFormat:null,valueFormatFlags:null},{name:'document',aliases:null,description:'The rule corresponds to the main frame document requests,\ni.e. HTML documents that are loaded in the browser tab.',docs:'https://adguard.app/kb/general/ad-filtering/create-own-filters/#document-modifier',versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,conflicts:null,inverseConflicts:false,assignable:false,negatable:false,blockOnly:false,exceptionOnly:false,valueOptional:false,valueFormat:null,valueFormatFlags:null},{name:'document',aliases:null,description:'The rule corresponds to the main frame document requests,\ni.e. HTML documents that are loaded in the browser tab.',docs:'https://adguard.app/kb/general/ad-filtering/create-own-filters/#document-modifier',versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,conflicts:null,inverseConflicts:false,assignable:false,negatable:false,blockOnly:false,exceptionOnly:false,valueOptional:false,valueFormat:null,valueFormatFlags:null},{name:'document',aliases:null,description:'The rule corresponds to the main frame document requests,\ni.e. HTML documents that are loaded in the browser tab.',docs:'https://adguard.app/kb/general/ad-filtering/create-own-filters/#document-modifier',versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,conflicts:null,inverseConflicts:false,assignable:false,negatable:false,blockOnly:false,exceptionOnly:false,valueOptional:false,valueFormat:null,valueFormatFlags:null},{name:'document',aliases:['doc'],description:'The rule corresponds to the main frame document requests,\ni.e. HTML documents that are loaded in the browser tab.',docs:'https://github.com/gorhill/uBlock/wiki/Static-filter-syntax#document',versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,conflicts:null,inverseConflicts:false,assignable:false,negatable:false,blockOnly:false,exceptionOnly:false,valueOptional:false,valueFormat:null,valueFormatFlags:null},{name:'document',aliases:null,description:'The rule corresponds to the main frame document requests,\ni.e. HTML documents that are loaded in the browser tab.',docs:'https://help.adblockplus.org/hc/en-us/articles/360062733293-How-to-write-filters#allowlist',versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,conflicts:null,inverseConflicts:false,assignable:false,negatable:false,blockOnly:false,exceptionOnly:false,valueOptional:false,valueFormat:null,valueFormatFlags:null}],map:{'1':0,'2':0,'4':0,'8':1,'16':1,'32':1,'64':1,'256':2,'512':3,'1024':4,'2048':4,'4096':4,'8192':4,'16384':5,'32768':5,'65536':5,'131072':5}},{shared:[{name:'domain',aliases:['from'],description:'The `$domain` modifier limits the rule application area to a list of domains and their subdomains.',docs:'https://adguard.app/kb/general/ad-filtering/create-own-filters/#domain-modifier',versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,conflicts:null,inverseConflicts:false,assignable:true,negatable:false,blockOnly:false,exceptionOnly:false,valueOptional:false,valueFormat:'pipe_separated_domains',valueFormatFlags:null},{name:'domain',aliases:['from'],description:'The `$domain` modifier limits the rule application area to a list of domains and their subdomains.',docs:'https://github.com/gorhill/uBlock/wiki/Static-filter-syntax#from',versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,conflicts:null,inverseConflicts:false,assignable:true,negatable:false,blockOnly:false,exceptionOnly:false,valueOptional:false,valueFormat:'pipe_separated_domains',valueFormatFlags:null},{name:'domain',aliases:null,description:'The `$domain` modifier limits the rule application area to a list of domains and their subdomains.',docs:'https://help.adblockplus.org/hc/en-us/articles/360062733293-How-to-write-filters#domain-restrictions',versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,conflicts:null,inverseConflicts:false,assignable:true,negatable:false,blockOnly:false,exceptionOnly:false,valueOptional:false,valueFormat:'pipe_separated_domains',valueFormatFlags:null}],map:{'1':0,'2':0,'4':0,'8':0,'16':0,'32':0,'64':0,'128':0,'256':0,'512':0,'1024':1,'2048':1,'4096':1,'8192':1,'16384':2,'32768':2,'65536':2,'131072':2}},{shared:[{name:'elemhide',aliases:['ehide'],description:'Disables any cosmetic rules on the pages matching the rule.',docs:'https://adguard.app/kb/general/ad-filtering/create-own-filters/#elemhide-modifier',versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,conflicts:null,inverseConflicts:false,assignable:false,negatable:false,blockOnly:false,exceptionOnly:true,valueOptional:false,valueFormat:null,valueFormatFlags:null},{name:'elemhide',aliases:['ehide'],description:'Disables any cosmetic rules on the pages matching the rule.',docs:'https://github.com/gorhill/uBlock/wiki/Static-filter-syntax#elemhide-1',versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,conflicts:null,inverseConflicts:false,assignable:false,negatable:false,blockOnly:false,exceptionOnly:true,valueOptional:false,valueFormat:null,valueFormatFlags:null},{name:'elemhide',aliases:['ehide'],description:'Disables any cosmetic rules on the pages matching the rule.',docs:'https://help.adblockplus.org/hc/en-us/articles/360062733293-How-to-write-filters#type-options',versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,conflicts:null,inverseConflicts:false,assignable:false,negatable:false,blockOnly:false,exceptionOnly:true,valueOptional:false,valueFormat:null,valueFormatFlags:null}],map:{'1':0,'2':0,'4':0,'8':0,'16':0,'32':0,'64':0,'128':0,'256':0,'512':0,'1024':1,'2048':1,'4096':1,'8192':1,'16384':2,'32768':2,'65536':2,'131072':2}},{shared:[{name:'empty',aliases:null,description:'This modifier is deprecated in favor of the $redirect modifier.\nRules with `$empty` are still supported and being converted into `$redirect=nooptext` now\nbut the support shall be removed in the future.',docs:'https://adguard.app/kb/general/ad-filtering/create-own-filters/#empty-modifier',versionAdded:null,versionRemoved:null,deprecated:true,deprecationMessage:'Rules with `$empty` are still supported and being converted into `$redirect=nooptext` now\nbut the support shall be removed in the future.',removed:false,removalMessage:null,conflicts:null,inverseConflicts:false,assignable:false,negatable:false,blockOnly:false,exceptionOnly:false,valueOptional:false,valueFormat:null,valueFormatFlags:null},{name:'empty',aliases:null,description:'This modifier is deprecated in favor of the $redirect modifier.\nRules with `$empty` are still supported and being converted into `$redirect=nooptext` now\nbut the support shall be removed in the future.',docs:'https://adguard.app/kb/general/ad-filtering/create-own-filters/#empty-modifier',versionAdded:null,versionRemoved:null,deprecated:true,deprecationMessage:'Rules with `$empty` are still supported and being converted into `$redirect=nooptext` now\nbut the support shall be removed in the future.',removed:false,removalMessage:null,conflicts:null,inverseConflicts:false,assignable:false,negatable:false,blockOnly:false,exceptionOnly:false,valueOptional:false,valueFormat:null,valueFormatFlags:null},{name:'empty',aliases:null,description:'This modifier is deprecated in favor of the $redirect modifier.\nRules with `$empty` are supported and being converted into `$redirect=nooptext`.',docs:'https://github.com/gorhill/uBlock/wiki/Static-filter-syntax#empty',versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,conflicts:null,inverseConflicts:false,assignable:false,negatable:false,blockOnly:false,exceptionOnly:false,valueOptional:false,valueFormat:null,valueFormatFlags:null}],map:{'1':0,'2':0,'4':0,'8':1,'16':1,'32':1,'64':1,'1024':2,'2048':2,'4096':2,'8192':2}},{shared:[{name:'extension',aliases:null,description:'Disables all userscripts on the pages matching this rule.',docs:'https://adguard.app/kb/general/ad-filtering/create-own-filters/#extension-modifier',versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,conflicts:['domain','specifichide','generichide','elemhide','genericblock','urlblock','jsinject','content','xmlhttprequest','badfilter'],inverseConflicts:true,assignable:false,negatable:true,blockOnly:false,exceptionOnly:true,valueOptional:false,valueFormat:null,valueFormatFlags:null}],map:{'1':0,'2':0,'4':0}},{shared:[{name:'first-party',aliases:['1p','~third-party'],description:'A restriction of first-party requests. Equal to `~third-party`.',docs:'https://adguard.app/kb/general/ad-filtering/create-own-filters/#third-party-modifier',versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,conflicts:null,inverseConflicts:false,assignable:false,negatable:false,blockOnly:false,exceptionOnly:false,valueOptional:false,valueFormat:null,valueFormatFlags:null},{name:'first-party',aliases:['1p','~third-party'],description:'A restriction of first-party requests. Equal to `~third-party`.',docs:'https://github.com/gorhill/uBlock/wiki/Static-filter-syntax#1p',versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,conflicts:null,inverseConflicts:false,assignable:false,negatable:false,blockOnly:false,exceptionOnly:false,valueOptional:false,valueFormat:null,valueFormatFlags:null}],map:{'1':0,'2':0,'4':0,'8':0,'16':0,'32':0,'64':0,'128':0,'256':0,'512':0,'1024':1,'2048':1,'4096':1,'8192':1}},{shared:[{name:'font',aliases:null,description:'The rule corresponds to requests for fonts, e.g. `.woff` filename extension.',docs:'https://adguard.app/kb/general/ad-filtering/create-own-filters/#font-modifier',versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,conflicts:null,inverseConflicts:false,assignable:false,negatable:true,blockOnly:false,exceptionOnly:false,valueOptional:false,valueFormat:null,valueFormatFlags:null},{name:'font',aliases:null,description:'The rule corresponds to requests for fonts, e.g. `.woff` filename extension.',docs:'https://help.adblockplus.org/hc/en-us/articles/360062733293#options',versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,conflicts:null,inverseConflicts:false,assignable:false,negatable:true,blockOnly:false,exceptionOnly:false,valueOptional:false,valueFormat:null,valueFormatFlags:null},{name:'font',aliases:null,description:'The rule corresponds to requests for fonts, e.g. `.woff` filename extension.',docs:'https://help.adblockplus.org/hc/en-us/articles/360062733293#options',versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,conflicts:null,inverseConflicts:false,assignable:false,negatable:true,blockOnly:false,exceptionOnly:false,valueOptional:false,valueFormat:null,valueFormatFlags:null}],map:{'1':0,'2':0,'4':0,'8':0,'16':0,'32':0,'64':0,'128':0,'256':0,'512':0,'1024':1,'2048':1,'4096':1,'8192':1,'16384':2,'32768':2,'65536':2,'131072':2}},{shared:[{name:'genericblock',aliases:null,description:'Disables generic basic rules on pages that correspond to exception rule.',docs:'https://adguard.app/kb/general/ad-filtering/create-own-filters/#genericblock-modifier',versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,conflicts:['domain','specifichide','generichide','elemhide','extension','jsinject','content','badfilter'],inverseConflicts:true,assignable:false,negatable:false,blockOnly:false,exceptionOnly:true,valueOptional:false,valueFormat:null,valueFormatFlags:null},{name:'genericblock',aliases:null,description:'Disables generic basic rules on pages that correspond to exception rule.',docs:'https://adguard.app/kb/general/ad-filtering/create-own-filters/#genericblock-modifier',versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,conflicts:['domain','specifichide','generichide','elemhide','jsinject','badfilter'],inverseConflicts:true,assignable:false,negatable:false,blockOnly:false,exceptionOnly:true,valueOptional:false,valueFormat:null,valueFormatFlags:null},{name:'genericblock',aliases:null,description:'Disables generic basic rules on pages that correspond to exception rule.',docs:'https://adguard.app/kb/general/ad-filtering/create-own-filters/#genericblock-modifier',versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,conflicts:['domain','specifichide','generichide','elemhide','jsinject','badfilter'],inverseConflicts:true,assignable:false,negatable:false,blockOnly:false,exceptionOnly:true,valueOptional:false,valueFormat:null,valueFormatFlags:null},{name:'genericblock',aliases:null,description:'Disables generic basic rules on pages that correspond to exception rule.',docs:'https://adguard.app/kb/general/ad-filtering/create-own-filters/#genericblock-modifier',versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,conflicts:['domain','specifichide','generichide','elemhide','jsinject','badfilter'],inverseConflicts:true,assignable:false,negatable:false,blockOnly:false,exceptionOnly:true,valueOptional:false,valueFormat:null,valueFormatFlags:null},{name:'genericblock',aliases:null,description:'Disables generic basic rules on pages that correspond to exception rule.',docs:'https://help.adblockplus.org/hc/en-us/articles/360062733293-How-to-write-filters#type-options',versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,conflicts:null,inverseConflicts:false,assignable:false,negatable:false,blockOnly:false,exceptionOnly:true,valueOptional:false,valueFormat:null,valueFormatFlags:null}],map:{'1':0,'2':0,'4':0,'8':1,'16':1,'32':1,'64':1,'256':2,'512':3,'16384':4,'32768':4,'65536':4,'131072':4}},{shared:[{name:'generichide',aliases:['ghide'],description:'Disables all generic cosmetic rules.',docs:'https://adguard.app/kb/general/ad-filtering/create-own-filters/#generichide-modifier',versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,conflicts:['domain','genericblock','urlblock','extension','jsinject','content','xmlhttprequest','badfilter'],inverseConflicts:true,assignable:false,negatable:false,blockOnly:false,exceptionOnly:true,valueOptional:false,valueFormat:null,valueFormatFlags:null},{name:'generichide',aliases:['ghide'],description:'Disables all generic cosmetic rules.',docs:'https://github.com/gorhill/uBlock/wiki/Static-filter-syntax#generichide',versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,conflicts:['domain','badfilter'],inverseConflicts:true,assignable:false,negatable:false,blockOnly:false,exceptionOnly:true,valueOptional:false,valueFormat:null,valueFormatFlags:null},{name:'generichide',aliases:null,description:'Disables all generic cosmetic rules.',docs:'https://help.adblockplus.org/hc/en-us/articles/360062733293-How-to-write-filters#type-options',versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,conflicts:['domain'],inverseConflicts:true,assignable:false,negatable:false,blockOnly:false,exceptionOnly:true,valueOptional:false,valueFormat:null,valueFormatFlags:null}],map:{'1':0,'2':0,'4':0,'8':0,'16':0,'32':0,'64':0,'128':0,'256':0,'512':0,'1024':1,'2048':1,'4096':1,'8192':1,'16384':2,'32768':2,'65536':2,'131072':2}},{shared:[{name:'header',aliases:null,description:'The `$header` modifier allows matching the HTTP response\nhaving a specific header with (optionally) a specific value.',docs:'https://adguard.app/kb/general/ad-filtering/create-own-filters/#header-modifier',versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,conflicts:null,inverseConflicts:false,assignable:true,negatable:true,blockOnly:false,exceptionOnly:false,valueOptional:false,valueFormat:'^(?:)[\\w-]+(:(?:)(\\w+|\\/.+\\/))?',valueFormatFlags:'i'},{name:'header',aliases:null,description:'The `$header` modifier allows matching the HTTP response\nhaving a specific header with (optionally) a specific value.',docs:'https://adguard.app/kb/general/ad-filtering/create-own-filters/#header-modifier',versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,conflicts:null,inverseConflicts:false,assignable:true,negatable:true,blockOnly:false,exceptionOnly:false,valueOptional:false,valueFormat:'^(?:)[\\w-]+(:(?:)(\\w+|\\/.+\\/))?',valueFormatFlags:'i'},{name:'header',aliases:null,description:'The `$header` modifier allows matching the HTTP response\nhaving a specific header with (optionally) a specific value.',docs:'https://github.com/gorhill/uBlock/wiki/Static-filter-syntax#header',versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,conflicts:null,inverseConflicts:false,assignable:true,negatable:true,blockOnly:false,exceptionOnly:false,valueOptional:false,valueFormat:'^(?:)[\\w-]+(:(?:)(\\w+|\\/.+\\/))?',valueFormatFlags:'i'}],map:{'1':0,'2':0,'4':0,'8':1,'16':1,'32':1,'64':1,'1024':2,'2048':2,'4096':2,'8192':2}},{shared:[{name:'hls',aliases:null,description:'The `$hls` rules modify the response of a matching request.\nThey are intended as a convenient way to remove segments from HLS playlists (RFC 8216).',docs:'https://adguard.app/kb/general/ad-filtering/create-own-filters/#hls-modifier',versionAdded:'CoreLibs 1.10',versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,conflicts:['domain','third-party','app','important','match-case','xmlhttprequest'],inverseConflicts:true,assignable:true,negatable:false,blockOnly:false,exceptionOnly:false,valueOptional:true,valueFormat:'((?:)\\w+(?:)|(?:)\\/.+\\/(?:)([ti]*)?)',valueFormatFlags:'i'}],map:{'1':0,'2':0,'4':0}},{shared:[{name:'image',aliases:null,description:'The rule corresponds to images requests.',docs:'https://adguard.app/kb/general/ad-filtering/create-own-filters/#image-modifier',versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,conflicts:null,inverseConflicts:false,assignable:false,negatable:true,blockOnly:false,exceptionOnly:false,valueOptional:false,valueFormat:null,valueFormatFlags:null},{name:'image',aliases:null,description:'The rule corresponds to images requests.',docs:'https://help.adblockplus.org/hc/en-us/articles/360062733293#options',versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,conflicts:null,inverseConflicts:false,assignable:false,negatable:true,blockOnly:false,exceptionOnly:false,valueOptional:false,valueFormat:null,valueFormatFlags:null},{name:'image',aliases:null,description:'The rule corresponds to images requests.',docs:'https://help.adblockplus.org/hc/en-us/articles/360062733293#options',versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,conflicts:null,inverseConflicts:false,assignable:false,negatable:true,blockOnly:false,exceptionOnly:false,valueOptional:false,valueFormat:null,valueFormatFlags:null}],map:{'1':0,'2':0,'4':0,'8':0,'16':0,'32':0,'64':0,'128':0,'256':0,'512':0,'1024':1,'2048':1,'4096':1,'8192':1,'16384':2,'32768':2,'65536':2,'131072':2}},{shared:[{name:'important',aliases:null,description:'The `$important` modifier applied to a rule increases its priority\nover any other rule without `$important` modifier. Even over basic exception rules.',docs:'https://adguard.app/kb/general/ad-filtering/create-own-filters/#important-modifier',versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,conflicts:null,inverseConflicts:false,assignable:false,negatable:false,blockOnly:false,exceptionOnly:false,valueOptional:false,valueFormat:null,valueFormatFlags:null},{name:'important',aliases:null,description:'The `$important` modifier applied to a rule increases its priority\nover any other rule without `$important` modifier. Even over basic exception rules.',docs:'https://github.com/gorhill/uBlock/wiki/Static-filter-syntax#important',versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,conflicts:null,inverseConflicts:false,assignable:false,negatable:false,blockOnly:false,exceptionOnly:false,valueOptional:false,valueFormat:null,valueFormatFlags:null}],map:{'1':0,'2':0,'4':0,'8':0,'16':0,'32':0,'64':0,'128':0,'256':0,'512':0,'1024':1,'2048':1,'4096':1,'8192':1}},{shared:[{name:'inline-font',aliases:null,description:'The `$inline-font` modifier is a sort of a shortcut for $csp modifier with specific value.\nE.g. `||example.org^$inline-font` is converting into:\n```adblock\n||example.org^$csp=font-src \'self\' \'unsafe-eval\' http: https: data: blob: mediastream: filesystem:\n```',docs:'https://adguard.app/kb/general/ad-filtering/create-own-filters/#inline-font-modifier',versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,conflicts:null,inverseConflicts:false,assignable:false,negatable:true,blockOnly:false,exceptionOnly:false,valueOptional:false,valueFormat:null,valueFormatFlags:null},{name:'inline-font',aliases:null,description:'The `$inline-font` modifier is a sort of a shortcut for $csp modifier with specific value.\nE.g. `||example.org^$inline-font` is converting into:\n```adblock\n||example.org^$csp=font-src \'self\' \'unsafe-eval\' http: https: data: blob: mediastream: filesystem:\n```',docs:'https://adguard.app/kb/general/ad-filtering/create-own-filters/#inline-font-modifier',versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,conflicts:null,inverseConflicts:false,assignable:false,negatable:true,blockOnly:false,exceptionOnly:false,valueOptional:false,valueFormat:null,valueFormatFlags:null},{name:'inline-font',aliases:null,description:'The `$inline-font` modifier is a sort of a shortcut for $csp modifier with specific value.\nE.g. `||example.org^$inline-font` is converting into:\n```adblock\n||example.org^$csp=font-src \'self\' \'unsafe-eval\' http: https: data: blob: mediastream: filesystem:\n```',docs:'https://github.com/gorhill/uBlock/wiki/Static-filter-syntax#inline-font',versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,conflicts:null,inverseConflicts:false,assignable:false,negatable:true,blockOnly:false,exceptionOnly:false,valueOptional:false,valueFormat:null,valueFormatFlags:null}],map:{'1':0,'2':0,'4':0,'8':1,'16':1,'32':1,'64':1,'1024':2,'2048':2,'4096':2,'8192':2}},{shared:[{name:'inline-script',aliases:null,description:'The `$inline-script` modifier is a sort of a shortcut for $csp modifier with specific value.\nE.g. `||example.org^$inline-script` is converting into:\n```adblock\n||example.org^$csp=script-src \'self\' \'unsafe-eval\' http: https: data: blob: mediastream: filesystem:\n```',docs:'https://adguard.app/kb/general/ad-filtering/create-own-filters/#inline-script-modifier',versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,conflicts:null,inverseConflicts:false,assignable:false,negatable:true,blockOnly:false,exceptionOnly:false,valueOptional:false,valueFormat:null,valueFormatFlags:null},{name:'inline-script',aliases:null,description:'The `$inline-script` modifier is a sort of a shortcut for $csp modifier with specific value.\nE.g. `||example.org^$inline-script` is converting into:\n```adblock\n||example.org^$csp=script-src \'self\' \'unsafe-eval\' http: https: data: blob: mediastream: filesystem:\n```',docs:'https://adguard.app/kb/general/ad-filtering/create-own-filters/#inline-script-modifier',versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,conflicts:null,inverseConflicts:false,assignable:false,negatable:true,blockOnly:false,exceptionOnly:false,valueOptional:false,valueFormat:null,valueFormatFlags:null},{name:'inline-script',aliases:null,description:'The `$inline-script` modifier is a sort of a shortcut for $csp modifier with specific value.\nE.g. `||example.org^$inline-script` is converting into:\n```adblock\n||example.org^$csp=script-src \'self\' \'unsafe-eval\' http: https: data: blob: mediastream: filesystem:\n```',docs:'https://github.com/gorhill/uBlock/wiki/Static-filter-syntax#inline-script',versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,conflicts:null,inverseConflicts:false,assignable:false,negatable:true,blockOnly:false,exceptionOnly:false,valueOptional:false,valueFormat:null,valueFormatFlags:null}],map:{'1':0,'2':0,'4':0,'8':1,'16':1,'32':1,'64':1,'1024':2,'2048':2,'4096':2,'8192':2}},{shared:[{name:'jsinject',aliases:null,description:'Forbids adding of javascript code to the page.',docs:'https://adguard.app/kb/general/ad-filtering/create-own-filters/#jsinject-modifier',versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,conflicts:['domain','specifichide','generichide','elemhide','genericblock','urlblock','extension','content','xmlhttprequest','badfilter'],inverseConflicts:true,assignable:false,negatable:false,blockOnly:false,exceptionOnly:true,valueOptional:false,valueFormat:null,valueFormatFlags:null},{name:'jsinject',aliases:null,description:'Forbids adding of javascript code to the page.',docs:'https://adguard.app/kb/general/ad-filtering/create-own-filters/#jsinject-modifier',versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,conflicts:['domain','specifichide','generichide','elemhide','genericblock','urlblock','xmlhttprequest','badfilter'],inverseConflicts:true,assignable:false,negatable:false,blockOnly:false,exceptionOnly:true,valueOptional:false,valueFormat:null,valueFormatFlags:null},{name:'jsinject',aliases:null,description:'Forbids adding of javascript code to the page.',docs:'https://adguard.app/kb/general/ad-filtering/create-own-filters/#jsinject-modifier',versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,conflicts:['domain','specifichide','generichide','elemhide','genericblock','urlblock','xmlhttprequest','badfilter'],inverseConflicts:true,assignable:false,negatable:false,blockOnly:false,exceptionOnly:true,valueOptional:false,valueFormat:null,valueFormatFlags:null},{name:'jsinject',aliases:null,description:'Forbids adding of javascript code to the page.',docs:'https://adguard.app/kb/general/ad-filtering/create-own-filters/#jsinject-modifier',versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,conflicts:['domain','specifichide','generichide','elemhide','genericblock','urlblock','xmlhttprequest','badfilter'],inverseConflicts:true,assignable:false,negatable:false,blockOnly:false,exceptionOnly:true,valueOptional:false,valueFormat:null,valueFormatFlags:null}],map:{'1':0,'2':0,'4':0,'8':1,'16':1,'32':1,'64':1,'256':2,'512':3}},{shared:[{name:'jsonprune',aliases:null,description:'The `$jsonprune` rules modify the response to a matching request\nby removing JSON items that match a modified JSONPath expression.\nThey do not modify responses which are not valid JSON documents.',docs:'https://adguard.app/kb/general/ad-filtering/create-own-filters/#jsonprune-modifier',versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,conflicts:null,inverseConflicts:false,assignable:true,negatable:false,blockOnly:false,exceptionOnly:false,valueOptional:true,valueFormat:'^(?:)\\\\(?:)\\$(?:)\\.?(?:).+(?:)$',valueFormatFlags:'i'}],map:{'1':0,'2':0,'4':0}},{shared:[{name:'match-case',aliases:null,description:'This modifier defines a rule which applies only to addresses that match the case.\nDefault rules are case-insensitive.',docs:'https://adguard.app/kb/general/ad-filtering/create-own-filters/#match-case-modifier',versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,conflicts:null,inverseConflicts:false,assignable:false,negatable:true,blockOnly:false,exceptionOnly:false,valueOptional:false,valueFormat:null,valueFormatFlags:null},{name:'match-case',aliases:null,description:'This modifier defines a rule which applies only to addresses that match the case.\nDefault rules are case-insensitive.',docs:'https://github.com/gorhill/uBlock/wiki/Static-filter-syntax#match-case',versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,conflicts:null,inverseConflicts:false,assignable:false,negatable:true,blockOnly:false,exceptionOnly:false,valueOptional:false,valueFormat:null,valueFormatFlags:null},{name:'match-case',aliases:null,description:'This modifier defines a rule which applies only to addresses that match the case.\nDefault rules are case-insensitive.',docs:'https://help.adblockplus.org/hc/en-us/articles/360062733293-How-to-write-filters#type-options',versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,conflicts:null,inverseConflicts:false,assignable:false,negatable:true,blockOnly:false,exceptionOnly:false,valueOptional:false,valueFormat:null,valueFormatFlags:null}],map:{'1':0,'2':0,'4':0,'8':0,'16':0,'32':0,'64':0,'128':0,'256':0,'512':0,'1024':1,'2048':1,'4096':1,'8192':1,'16384':2,'32768':2,'65536':2,'131072':2}},{shared:[{name:'media',aliases:null,description:'A restriction of third-party and own requests.\nA third-party request is a request from a different domain.\nFor example, a request to `example.org` from `domain.com` is a third-party request.',docs:'https://adguard.app/kb/general/ad-filtering/create-own-filters/#media-modifier',versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,conflicts:null,inverseConflicts:false,assignable:false,negatable:true,blockOnly:false,exceptionOnly:false,valueOptional:false,valueFormat:null,valueFormatFlags:null},{name:'media',aliases:null,description:'A restriction of third-party and own requests.\nA third-party request is a request from a different domain.\nFor example, a request to `example.org` from `domain.com` is a third-party request.',docs:'https://help.adblockplus.org/hc/en-us/articles/360062733293#options',versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,conflicts:null,inverseConflicts:false,assignable:false,negatable:true,blockOnly:false,exceptionOnly:false,valueOptional:false,valueFormat:null,valueFormatFlags:null},{name:'media',aliases:null,description:'A restriction of third-party and own requests.\nA third-party request is a request from a different domain.\nFor example, a request to `example.org` from `domain.com` is a third-party request.',docs:'https://help.adblockplus.org/hc/en-us/articles/360062733293#options',versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,conflicts:null,inverseConflicts:false,assignable:false,negatable:true,blockOnly:false,exceptionOnly:false,valueOptional:false,valueFormat:null,valueFormatFlags:null}],map:{'1':0,'2':0,'4':0,'8':0,'16':0,'32':0,'64':0,'128':0,'256':0,'512':0,'1024':1,'2048':1,'4096':1,'8192':1,'16384':2,'32768':2,'65536':2,'131072':2}},{shared:[{name:'method',aliases:null,description:'This modifier limits the rule scope to requests that use the specified set of HTTP methods.\nNegated methods are allowed.',docs:'https://adguard.app/kb/general/ad-filtering/create-own-filters/#method-modifier',versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,conflicts:null,inverseConflicts:false,assignable:true,negatable:false,blockOnly:false,exceptionOnly:false,valueOptional:false,valueFormat:'pipe_separated_methods',valueFormatFlags:null},{name:'method',aliases:null,description:'This modifier limits the rule scope to requests that use the specified set of HTTP methods.\nNegated methods are allowed.',docs:'https://adguard.app/kb/general/ad-filtering/create-own-filters/#method-modifier',versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,conflicts:null,inverseConflicts:false,assignable:true,negatable:false,blockOnly:false,exceptionOnly:false,valueOptional:false,valueFormat:'pipe_separated_methods',valueFormatFlags:null},{name:'method',aliases:null,description:'This modifier limits the rule scope to requests that use the specified set of HTTP methods.\nNegated methods are allowed.',docs:'https://github.com/gorhill/uBlock/wiki/Static-filter-syntax#method',versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,conflicts:null,inverseConflicts:false,assignable:true,negatable:false,blockOnly:false,exceptionOnly:false,valueOptional:false,valueFormat:'pipe_separated_methods',valueFormatFlags:null}],map:{'1':0,'2':0,'4':0,'8':1,'16':1,'32':1,'64':1,'1024':2,'2048':2,'4096':2,'8192':2}},{shared:[{name:'mp4',aliases:null,description:'As a response to blocked request AdGuard returns a short video placeholder.\nRules with `$mp4` are still supported and being converted into `$redirect=noopmp4-1s` now\nbut the support shall be removed in the future.',docs:'https://adguard.app/kb/general/ad-filtering/create-own-filters/#mp4-modifier',versionAdded:null,versionRemoved:null,deprecated:true,deprecationMessage:'Rules with `$mp4` are still supported and being converted into `$redirect=noopmp4-1s` now\nbut the support shall be removed in the future.',removed:false,removalMessage:null,conflicts:null,inverseConflicts:false,assignable:false,negatable:false,blockOnly:false,exceptionOnly:false,valueOptional:false,valueFormat:null,valueFormatFlags:null},{name:'mp4',aliases:null,description:'As a response to blocked request AdGuard returns a short video placeholder.\nRules with `$mp4` are still supported and being converted into `$redirect=noopmp4-1s` now\nbut the support shall be removed in the future.',docs:'https://adguard.app/kb/general/ad-filtering/create-own-filters/#mp4-modifier',versionAdded:null,versionRemoved:null,deprecated:true,deprecationMessage:'Rules with `$mp4` are still supported and being converted into `$redirect=noopmp4-1s` now\nbut the support shall be removed in the future.',removed:false,removalMessage:null,conflicts:null,inverseConflicts:false,assignable:false,negatable:false,blockOnly:false,exceptionOnly:false,valueOptional:false,valueFormat:null,valueFormatFlags:null},{name:'mp4',aliases:null,description:'As a response to blocked request a short video placeholder is returned.\nRules with `$mp4` are supported and being converted into `$redirect=noopmp4-1s`.',docs:'https://github.com/gorhill/uBlock/wiki/Static-filter-syntax#mp4',versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,conflicts:null,inverseConflicts:false,assignable:false,negatable:false,blockOnly:false,exceptionOnly:false,valueOptional:false,valueFormat:null,valueFormatFlags:null}],map:{'1':0,'2':0,'4':0,'8':1,'16':1,'32':1,'64':1,'1024':2,'2048':2,'4096':2,'8192':2}},{shared:[{name:'network',aliases:null,description:'This is basically a Firewall-kind of rules allowing to fully block\nor unblock access to a specified remote address.',docs:'https://adguard.app/kb/general/ad-filtering/create-own-filters/#network-modifier',versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,conflicts:['app','important'],inverseConflicts:true,assignable:false,negatable:false,blockOnly:false,exceptionOnly:false,valueOptional:false,valueFormat:null,valueFormatFlags:null}],map:{'1':0,'2':0,'4':0}},{shared:[{name:'_',aliases:null,description:'The noop modifier does nothing and can be used solely to increase rules\' readability.\nIt consists of a sequence of underscore characters (_) of any length\nand can appear in a rule as many times as needed.',docs:'https://adguard.app/kb/general/ad-filtering/create-own-filters/#noop-modifier',versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,conflicts:null,inverseConflicts:false,assignable:false,negatable:false,blockOnly:false,exceptionOnly:false,valueOptional:false,valueFormat:null,valueFormatFlags:null},{name:'_',aliases:null,description:'The noop modifier does nothing and can be used solely to increase rules\' readability.\nIt consists of a sequence of underscore characters (_) of any length\nand can appear in a rule as many times as needed.',docs:'https://adguard.app/kb/general/ad-filtering/create-own-filters/#noop-modifier',versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,conflicts:null,inverseConflicts:false,assignable:false,negatable:false,blockOnly:false,exceptionOnly:false,valueOptional:false,valueFormat:null,valueFormatFlags:null},{name:'_',aliases:null,description:'The noop modifier does nothing and can be used solely to increase rules\' readability.\nIt consists of a sequence of underscore characters (_) of any length\nand can appear in a rule as many times as needed.',docs:'https://adguard.app/kb/general/ad-filtering/create-own-filters/#noop-modifier',versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,conflicts:null,inverseConflicts:false,assignable:false,negatable:false,blockOnly:false,exceptionOnly:false,valueOptional:false,valueFormat:null,valueFormatFlags:null},{name:'_',aliases:null,description:'The noop modifier does nothing and can be used solely to increase rules\' readability.\nIt consists of a sequence of underscore characters (_) of any length\nand can appear in a rule as many times as needed.',docs:'https://adguard.app/kb/general/ad-filtering/create-own-filters/#noop-modifier',versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,conflicts:null,inverseConflicts:false,assignable:false,negatable:false,blockOnly:false,exceptionOnly:false,valueOptional:false,valueFormat:null,valueFormatFlags:null},{name:'_',aliases:null,description:'The noop modifier does nothing and can be used solely to increase rules\' readability.\nIt consists of a sequence of underscore characters (_) of any length\nand can appear in a rule as many times as needed.',docs:'https://github.com/gorhill/uBlock/wiki/Static-filter-syntax#_-aka-noop',versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,conflicts:null,inverseConflicts:false,assignable:false,negatable:false,blockOnly:false,exceptionOnly:false,valueOptional:false,valueFormat:null,valueFormatFlags:null}],map:{'1':0,'2':0,'4':0,'8':1,'16':1,'32':1,'64':1,'256':2,'512':3,'1024':4,'2048':4,'4096':4,'8192':4}},{shared:[{name:'object-subrequest',aliases:null,description:'The `$object-subrequest` modifier is removed and is no longer supported.\nRules with it are considered as invalid.\nThe rule corresponds to requests by browser plugins (it is usually Flash).',docs:'https://adguard.app/kb/general/ad-filtering/create-own-filters/#object-subrequest-modifier',versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:true,removalMessage:'The `$object-subrequest` modifier is removed and is no longer supported.\nRules with it are considered as invalid.',conflicts:null,inverseConflicts:false,assignable:false,negatable:true,blockOnly:false,exceptionOnly:false,valueOptional:false,valueFormat:null,valueFormatFlags:null}],map:{'1':0,'2':0,'4':0,'8':0,'16':0,'32':0,'64':0,'128':0,'256':0,'512':0}},{shared:[{name:'object',aliases:null,description:'The rule corresponds to browser plugins resources, e.g. Java or Flash',docs:'https://adguard.app/kb/general/ad-filtering/create-own-filters/#object-modifier',versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,conflicts:null,inverseConflicts:false,assignable:false,negatable:true,blockOnly:false,exceptionOnly:false,valueOptional:false,valueFormat:null,valueFormatFlags:null},{name:'object',aliases:null,description:'The rule corresponds to browser plugins resources, e.g. Java or Flash.',docs:'https://help.adblockplus.org/hc/en-us/articles/360062733293-How-to-write-filters#type-options',versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,conflicts:null,inverseConflicts:false,assignable:false,negatable:true,blockOnly:false,exceptionOnly:false,valueOptional:false,valueFormat:null,valueFormatFlags:null},{name:'object',aliases:null,description:'The rule corresponds to browser plugins resources, e.g. Java or Flash.',docs:'https://help.adblockplus.org/hc/en-us/articles/360062733293-How-to-write-filters#type-options',versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,conflicts:null,inverseConflicts:false,assignable:false,negatable:true,blockOnly:false,exceptionOnly:false,valueOptional:false,valueFormat:null,valueFormatFlags:null}],map:{'1':0,'2':0,'4':0,'8':0,'16':0,'32':0,'64':0,'128':0,'256':0,'512':0,'1024':1,'2048':1,'4096':1,'8192':1,'16384':2,'32768':2,'65536':2,'131072':2}},{shared:[{name:'other',aliases:null,description:'The rule applies to requests for which the type has not been determined\nor does not match the types listed above.',docs:'https://adguard.app/kb/general/ad-filtering/create-own-filters/#other-modifier',versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,conflicts:null,inverseConflicts:false,assignable:false,negatable:true,blockOnly:false,exceptionOnly:false,valueOptional:false,valueFormat:null,valueFormatFlags:null},{name:'other',aliases:null,description:'The rule applies to requests for which the type has not been determined\nor does not match the types listed above.',docs:'https://help.adblockplus.org/hc/en-us/articles/360062733293-How-to-write-filters#type-options',versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,conflicts:null,inverseConflicts:false,assignable:false,negatable:true,blockOnly:false,exceptionOnly:false,valueOptional:false,valueFormat:null,valueFormatFlags:null},{name:'other',aliases:null,description:'The rule applies to requests for which the type has not been determined\nor does not match the types listed above.',docs:'https://help.adblockplus.org/hc/en-us/articles/360062733293-How-to-write-filters#type-options',versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,conflicts:null,inverseConflicts:false,assignable:false,negatable:true,blockOnly:false,exceptionOnly:false,valueOptional:false,valueFormat:null,valueFormatFlags:null}],map:{'1':0,'2':0,'4':0,'8':0,'16':0,'32':0,'64':0,'128':0,'256':0,'512':0,'1024':1,'2048':1,'4096':1,'8192':1,'16384':2,'32768':2,'65536':2,'131072':2}},{shared:[{name:'permissions',aliases:null,description:'For the requests matching a `$permissions` rule, ad blocker strengthens response\'s feature policy\nby adding additional feature policy equal to the `$permissions` modifier contents.\n`$permissions` rules are applied independently from any other rule type.',docs:'https://adguard.app/kb/general/ad-filtering/create-own-filters/#permissions-modifier',versionAdded:'CoreLibs 1.11',versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,conflicts:['domain','important','subdocument'],inverseConflicts:true,assignable:true,negatable:false,blockOnly:false,exceptionOnly:false,valueOptional:true,valueFormat:'permissions_value',valueFormatFlags:null}],map:{'1':0,'2':0,'4':0}},{shared:[{name:'ping',aliases:null,description:'The rule corresponds to requests caused by either navigator.sendBeacon() or the ping attribute on links.',docs:'https://adguard.app/kb/general/ad-filtering/create-own-filters/#ping-modifier',versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,conflicts:null,inverseConflicts:false,assignable:false,negatable:true,blockOnly:false,exceptionOnly:false,valueOptional:false,valueFormat:null,valueFormatFlags:null},{name:'ping',aliases:null,description:'The rule corresponds to requests caused by either navigator.sendBeacon() or the ping attribute on links.',docs:'https://help.adblockplus.org/hc/en-us/articles/360062733293-How-to-write-filters#type-options',versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,conflicts:null,inverseConflicts:false,assignable:false,negatable:true,blockOnly:false,exceptionOnly:false,valueOptional:false,valueFormat:null,valueFormatFlags:null},{name:'ping',aliases:null,description:'The rule corresponds to requests caused by either navigator.sendBeacon() or the ping attribute on links.',docs:'https://help.adblockplus.org/hc/en-us/articles/360062733293-How-to-write-filters#type-options',versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,conflicts:null,inverseConflicts:false,assignable:false,negatable:true,blockOnly:false,exceptionOnly:false,valueOptional:false,valueFormat:null,valueFormatFlags:null}],map:{'1':0,'2':0,'4':0,'8':0,'16':0,'32':0,'64':0,'128':0,'256':0,'512':0,'1024':1,'2048':1,'4096':1,'8192':1,'16384':2,'32768':2,'65536':2,'131072':2}},{shared:[{name:'popunder',aliases:null,description:'To block "popunders" windows/tabs where the original page redirects to an advertisement\nand the desired content loads in the newly created one.\nTo be used in the same manner as the popup filter option, except that it will block popunders.',docs:'https://github.com/gorhill/uBlock/wiki/Static-filter-syntax#popunder',versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,conflicts:null,inverseConflicts:false,assignable:false,negatable:false,blockOnly:true,exceptionOnly:false,valueOptional:false,valueFormat:null,valueFormatFlags:null}],map:{'1024':0,'2048':0,'4096':0,'8192':0}},{shared:[{name:'popup',aliases:null,description:'Pages opened in a new tab or window.\nNote: Filters will not block pop-ups by default, only if the `$popup`  type option is specified.',docs:'https://adguard.app/kb/general/ad-filtering/create-own-filters/#popup-modifier',versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,conflicts:null,inverseConflicts:false,assignable:false,negatable:false,blockOnly:false,exceptionOnly:false,valueOptional:false,valueFormat:null,valueFormatFlags:null},{name:'popup',aliases:null,description:'Pages opened in a new tab or window.\nNote: Filters will not block pop-ups by default, only if the `$popup`  type option is specified.',docs:'https://help.adblockplus.org/hc/en-us/articles/360062733293-How-to-write-filters#type-options',versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,conflicts:null,inverseConflicts:false,assignable:false,negatable:false,blockOnly:false,exceptionOnly:false,valueOptional:false,valueFormat:null,valueFormatFlags:null},{name:'popup',aliases:null,description:'Pages opened in a new tab or window.\nNote: Filters will not block pop-ups by default, only if the `$popup`  type option is specified.',docs:'https://help.adblockplus.org/hc/en-us/articles/360062733293-How-to-write-filters#type-options',versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,conflicts:null,inverseConflicts:false,assignable:false,negatable:false,blockOnly:false,exceptionOnly:false,valueOptional:false,valueFormat:null,valueFormatFlags:null}],map:{'1':0,'2':0,'4':0,'8':0,'16':0,'32':0,'64':0,'128':0,'256':0,'512':0,'1024':1,'2048':1,'4096':1,'8192':1,'16384':2,'32768':2,'65536':2,'131072':2}},{shared:[{name:'redirect-rule',aliases:null,description:'This is basically an alias to `$redirect`\nsince it has the same "redirection" values and the logic is almost similar.\nThe difference is that `$redirect-rule` is applied only in the case\nwhen the target request is blocked by a different basic rule.',docs:'https://adguard.app/kb/general/ad-filtering/create-own-filters/#redirect-rule-modifier',versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,conflicts:['domain','to','third-party','popup','match-case','header','first-party','document','image','stylesheet','script','object','font','media','subdocument','ping','xmlhttprequest','websocket','other','webrtc','important','badfilter','app'],inverseConflicts:true,assignable:true,negatable:false,blockOnly:false,exceptionOnly:false,valueOptional:true,valueFormat:'^(1x1-transparent\\.gif|2x2-transparent\\.png|3x2-transparent\\.png|32x32-transparent\\.png|noopframe|noopcss|noopjs|noopjson|nooptext|empty|noopvmap-1\\.0|noopvast-2\\.0|noopvast-3\\.0|noopvast-4\\.0|noopmp3-0\\.1s|noopmp4-1s|amazon-apstag|ati-smarttag|didomi-loader|fingerprintjs2|fingerprintjs3|gemius|google-analytics-ga|google-analytics|google-ima3|googlesyndication-adsbygoogle|googletagservices-gpt|matomo|metrika-yandex-tag|metrika-yandex-watch|naver-wcslog|noeval|pardot-1\\.0|prebid-ads|prebid|prevent-bab|prevent-bab2|prevent-fab-3\\.2\\.0|prevent-popads-net|scorecardresearch-beacon|set-popads-dummy|click2load\\.html|)?$',valueFormatFlags:null},{name:'redirect-rule',aliases:null,description:'This is basically an alias to `$redirect`\nsince it has the same "redirection" values and the logic is almost similar.\nThe difference is that `$redirect-rule` is applied only in the case\nwhen the target request is blocked by a different basic rule.',docs:'https://adguard.app/kb/general/ad-filtering/create-own-filters/#redirect-rule-modifier',versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,conflicts:['domain','to','third-party','popup','match-case','header','first-party','document','image','stylesheet','script','object','font','media','subdocument','ping','xmlhttprequest','websocket','other','webrtc','important','badfilter'],inverseConflicts:true,assignable:true,negatable:false,blockOnly:false,exceptionOnly:false,valueOptional:true,valueFormat:'^(1x1-transparent\\.gif|2x2-transparent\\.png|3x2-transparent\\.png|32x32-transparent\\.png|noopframe|noopcss|noopjs|noopjson|nooptext|empty|noopvmap-1\\.0|noopvast-2\\.0|noopvast-3\\.0|noopvast-4\\.0|noopmp3-0\\.1s|noopmp4-1s|amazon-apstag|ati-smarttag|didomi-loader|fingerprintjs2|fingerprintjs3|gemius|google-analytics-ga|google-analytics|google-ima3|googlesyndication-adsbygoogle|googletagservices-gpt|matomo|metrika-yandex-tag|metrika-yandex-watch|naver-wcslog|noeval|pardot-1\\.0|prebid-ads|prebid|prevent-bab|prevent-bab2|prevent-fab-3\\.2\\.0|prevent-popads-net|scorecardresearch-beacon|set-popads-dummy|click2load\\.html|)?$',valueFormatFlags:null},{name:'redirect-rule',aliases:null,description:'This is basically an alias to `$redirect`\nsince it has the same "redirection" values and the logic is almost similar.\nThe difference is that `$redirect-rule` is applied only in the case\nwhen the target request is blocked by a different basic rule.',docs:'https://github.com/gorhill/uBlock/wiki/Static-filter-syntax#redirect-rule',versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,conflicts:['domain','to','third-party','popup','match-case','header','first-party','document','image','stylesheet','script','object','font','media','subdocument','ping','xmlhttprequest','websocket','other','webrtc','important','badfilter'],inverseConflicts:true,assignable:true,negatable:false,blockOnly:false,exceptionOnly:false,valueOptional:false,valueFormat:'^(1x1\\.gif|2x2\\.png|3x2\\.png|32x32\\.png|noop\\.css|noop\\.html|noopframe|noop\\.js|noop\\.txt|noop-0\\.1s\\.mp3|noop-0\\.5s\\.mp3|noop-1s\\.mp4|none|click2load\\.html|addthis_widget\\.js|amazon_ads\\.js|amazon_apstag\\.js|monkeybroker\\.js|doubleclick_instream_ad_status|google-analytics_ga\\.js|google-analytics_analytics\\.js|google-analytics_inpage_linkid\\.js|google-analytics_cx_api\\.js|google-ima\\.js|googletagservices_gpt\\.js|googletagmanager_gtm\\.js|googlesyndication_adsbygoogle\\.js|scorecardresearch_beacon\\.js|outbrain-widget\\.js|hd-main\\.js)(:[0-9]+)?$',valueFormatFlags:null}],map:{'1':0,'2':0,'4':0,'8':1,'16':1,'32':1,'64':1,'1024':2,'2048':2,'4096':2,'8192':2}},{shared:[{name:'redirect',aliases:null,description:'Used to redirect web requests to a local "resource".',docs:'https://adguard.app/kb/general/ad-filtering/create-own-filters/#redirect-modifier',versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,conflicts:null,inverseConflicts:false,assignable:true,negatable:false,blockOnly:false,exceptionOnly:false,valueOptional:true,valueFormat:'^(1x1-transparent\\.gif|2x2-transparent\\.png|3x2-transparent\\.png|32x32-transparent\\.png|noopframe|noopcss|noopjs|noopjson|nooptext|empty|noopvmap-1\\.0|noopvast-2\\.0|noopvast-3\\.0|noopvast-4\\.0|noopmp3-0\\.1s|noopmp4-1s|amazon-apstag|ati-smarttag|didomi-loader|fingerprintjs2|fingerprintjs3|gemius|google-analytics-ga|google-analytics|googletagmanager-gtm|google-ima3|googlesyndication-adsbygoogle|googletagservices-gpt|matomo|metrika-yandex-tag|metrika-yandex-watch|naver-wcslog|noeval|pardot-1\\.0|prebid-ads|prebid|prevent-bab|prevent-bab2|prevent-fab-3\\.2\\.0|prevent-popads-net|scorecardresearch-beacon|set-popads-dummy|click2load\\.html)?$',valueFormatFlags:null},{name:'redirect',aliases:null,description:'Used to redirect web requests to a local "resource".',docs:'https://adguard.app/kb/general/ad-filtering/create-own-filters/#redirect-modifier',versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,conflicts:null,inverseConflicts:false,assignable:true,negatable:false,blockOnly:false,exceptionOnly:false,valueOptional:true,valueFormat:'^(1x1-transparent\\.gif|2x2-transparent\\.png|3x2-transparent\\.png|32x32-transparent\\.png|noopframe|noopcss|noopjs|noopjson|nooptext|empty|noopvmap-1\\.0|noopvast-2\\.0|noopvast-3\\.0|noopvast-4\\.0|noopmp3-0\\.1s|noopmp4-1s|amazon-apstag|ati-smarttag|didomi-loader|fingerprintjs2|fingerprintjs3|gemius|google-analytics-ga|google-analytics|googletagmanager-gtm|google-ima3|googlesyndication-adsbygoogle|googletagservices-gpt|matomo|metrika-yandex-tag|metrika-yandex-watch|naver-wcslog|noeval|pardot-1\\.0|prebid-ads|prebid|prevent-bab|prevent-bab2|prevent-fab-3\\.2\\.0|prevent-popads-net|scorecardresearch-beacon|set-popads-dummy|click2load\\.html)?$',valueFormatFlags:null},{name:'redirect',aliases:null,description:'Used to redirect web requests to a local "resource".',docs:'https://github.com/gorhill/uBlock/wiki/Static-filter-syntax#redirect',versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,conflicts:null,inverseConflicts:false,assignable:true,negatable:false,blockOnly:false,exceptionOnly:false,valueOptional:true,valueFormat:'^(1x1\\.gif|2x2\\.png|3x2\\.png|32x32\\.png|noop\\.css|noop\\.html|noopframe|noop\\.js|noop\\.txt|noop-0\\.1s\\.mp3|noop-0\\.5s\\.mp3|noop-1s\\.mp4|none|click2load\\.html|addthis_widget\\.js|amazon_ads\\.js|amazon_apstag\\.js|monkeybroker\\.js|doubleclick_instream_ad_status|google-analytics_ga\\.js|google-analytics_analytics\\.js|google-analytics_inpage_linkid\\.js|google-analytics_cx_api\\.js|google-ima\\.js|googletagservices_gpt\\.js|googletagmanager_gtm\\.js|googlesyndication_adsbygoogle\\.js|scorecardresearch_beacon\\.js|outbrain-widget\\.js|hd-main\\.js)(:[0-9]+)?$',valueFormatFlags:null},{name:'rewrite',aliases:null,description:'The `rewrite=` option allows the rewriting of URLs (or redirecting requests) to an internal\nresource in order to deactivate it without causing an error. Indicate the internal resource\nby name and prefix `abp-resource:` in order to be recognized. For example\n`$rewrite=abp-resource:blank-js` sends an empty JavaScript.',docs:'https://help.adblockplus.org/hc/en-us/articles/360062733293#rewrite',versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,conflicts:null,inverseConflicts:false,assignable:true,negatable:false,blockOnly:false,exceptionOnly:false,valueOptional:false,valueFormat:'(?:)^abp-resource:(?:)(blank-text|blank-css|blank-js|blank-html|blank-mp3|1x1-transparent-gif|2x2-transparent-png|3x2-transparent-png|32x32-transparent-png)$',valueFormatFlags:null}],map:{'1':0,'2':0,'4':0,'8':1,'16':1,'32':1,'64':1,'1024':2,'2048':2,'4096':2,'8192':2,'16384':3,'32768':3,'65536':3,'131072':3}},{shared:[{name:'referrerpolicy',aliases:null,description:'This modifier allows overriding of a page\'s referrer policy.',docs:'https://adguard.app/kb/general/ad-filtering/create-own-filters/#referrerpolicy-modifier',versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,conflicts:['document','subdocument'],inverseConflicts:true,assignable:true,negatable:false,blockOnly:false,exceptionOnly:false,valueOptional:true,valueFormat:'referrerpolicy_value',valueFormatFlags:null}],map:{'1':0,'2':0,'4':0}},{shared:[{name:'removeheader',aliases:null,description:'Rules with the `$removeheader` modifier are intended to remove headers from HTTP requests and responses.',docs:'https://adguard.app/kb/general/ad-filtering/create-own-filters/#removeheader-modifier',versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,conflicts:['domain','third-party','first-party','app','important','match-case','document','image','stylesheet','script','object','font','media','subdocument','ping','xmlhttpreqeust','websocket','other','webrtc'],inverseConflicts:true,assignable:true,negatable:false,blockOnly:false,exceptionOnly:false,valueOptional:true,valueFormat:'^(?:)(request:)?(?:)(?!(access-control-allow-origin|access-control-allow-credentials|access-control-allow-headers|access-control-allow-methods|access-control-expose-headers|access-control-max-age|access-control-request-headers|access-control-request-method|origin|timing-allow-origin|allow|cross-origin-embedder-policy|cross-origin-opener-policy|cross-origin-resource-policy|content-security-policy|content-security-policy-report-only|expect-ct|feature-policy|origin-isolation|strict-transport-security|upgrade-insecure-requests|x-content-type-options|x-download-options|x-frame-options|x-permitted-cross-domain-policies|x-powered-by|x-xss-protection|public-key-pins|public-key-pins-report-only|sec-websocket-key|sec-websocket-extensions|sec-websocket-accept|sec-websocket-protocol|sec-websocket-version|p3p|sec-fetch-mode|sec-fetch-dest|sec-fetch-site|sec-fetch-user|referrer-policy|content-type|content-length|accept|accept-encoding|host|connection|transfer-encoding|upgrade)$)(?:)[A-z0-9-]+(?:)$',valueFormatFlags:'i'},{name:'removeheader',aliases:null,description:'Rules with the `$removeheader` modifier are intended to remove headers from HTTP requests and responses.',docs:'https://adguard.app/kb/general/ad-filtering/create-own-filters/#removeheader-modifier',versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,conflicts:['domain','third-party','first-party','app','important','match-case','document','image','stylesheet','script','object','font','media','subdocument','ping','xmlhttpreqeust','websocket','other','webrtc'],inverseConflicts:true,assignable:true,negatable:false,blockOnly:false,exceptionOnly:false,valueOptional:true,valueFormat:'^(?:)(request:)?(?:)(?!(access-control-allow-origin|access-control-allow-credentials|access-control-allow-headers|access-control-allow-methods|access-control-expose-headers|access-control-max-age|access-control-request-headers|access-control-request-method|origin|timing-allow-origin|allow|cross-origin-embedder-policy|cross-origin-opener-policy|cross-origin-resource-policy|content-security-policy|content-security-policy-report-only|expect-ct|feature-policy|origin-isolation|strict-transport-security|upgrade-insecure-requests|x-content-type-options|x-download-options|x-frame-options|x-permitted-cross-domain-policies|x-powered-by|x-xss-protection|public-key-pins|public-key-pins-report-only|sec-websocket-key|sec-websocket-extensions|sec-websocket-accept|sec-websocket-protocol|sec-websocket-version|p3p|sec-fetch-mode|sec-fetch-dest|sec-fetch-site|sec-fetch-user|referrer-policy|content-type|content-length|accept|accept-encoding|host|connection|transfer-encoding|upgrade)$)(?:)[A-z0-9-]+(?:)$',valueFormatFlags:'i'}],map:{'1':0,'2':0,'4':0,'8':1,'16':1,'32':1,'64':1}},{shared:[{name:'removeparam',aliases:null,description:'Rules with the `$removeparam` modifier are intended to strip query parameters from requests\' URLs.',docs:'https://adguard.app/kb/general/ad-filtering/create-own-filters/#removeparam-modifier',versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,conflicts:null,inverseConflicts:false,assignable:true,negatable:false,blockOnly:false,exceptionOnly:false,valueOptional:true,valueFormat:'((?:)\\w+(?:)|\\/.+\\/(?:)([gimuy]+)?)',valueFormatFlags:'i'},{name:'removeparam',aliases:null,description:'Rules with the `$removeparam` modifier are intended to strip query parameters from requests\' URLs.',docs:'https://adguard.app/kb/general/ad-filtering/create-own-filters/#removeparam-modifier',versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,conflicts:null,inverseConflicts:false,assignable:true,negatable:false,blockOnly:false,exceptionOnly:false,valueOptional:true,valueFormat:'((?:)\\w+(?:)|\\/.+\\/(?:)([gimuy]+)?)',valueFormatFlags:'i'},{name:'removeparam',aliases:null,description:'Rules with the `$removeparam` modifier are intended to strip query parameters from requests\' URLs.',docs:'https://github.com/gorhill/uBlock/wiki/Static-filter-syntax#removeparam',versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,conflicts:null,inverseConflicts:false,assignable:true,negatable:false,blockOnly:false,exceptionOnly:false,valueOptional:false,valueFormat:'((?:)\\w+(?:)|\\/.+\\/(?:)([gimuy]+)?)',valueFormatFlags:'i'}],map:{'1':0,'2':0,'4':0,'8':1,'16':1,'32':1,'64':1,'1024':2,'2048':2,'4096':2,'8192':2}},{shared:[{name:'replace',aliases:null,description:'This modifier completely changes the rule behavior.\nIf it is applied, the rule will not block the request. The response is going to be modified instead.',docs:'https://adguard.app/kb/general/ad-filtering/create-own-filters/#replace-modifier',versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,conflicts:['app','domain','document','subdocument','script','stylesheet','other','xmlhttprequest','first-party','third-party','important','badfilter'],inverseConflicts:true,assignable:true,negatable:false,blockOnly:false,exceptionOnly:false,valueOptional:false,valueFormat:'^(?:)\\/(?:)(.+)(?:)\\/(?:)(.+)?(?:)\\/(?:)([gimuy]*)?(?:)$',valueFormatFlags:'i'},{name:'replace',aliases:null,description:'This modifier completely changes the rule behavior.\nIf it is applied, the rule will not block the request. The response is going to be modified instead.',docs:'https://adguard.app/kb/general/ad-filtering/create-own-filters/#replace-modifier',versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,conflicts:['app','domain','document','subdocument','script','stylesheet','other','xmlhttprequest','first-party','third-party','important','badfilter'],inverseConflicts:true,assignable:true,negatable:false,blockOnly:false,exceptionOnly:false,valueOptional:false,valueFormat:'^(?:)\\/(?:)(.+)(?:)\\/(?:)(.+)?(?:)\\/(?:)([gimuy]*)?(?:)$',valueFormatFlags:'i'},{name:'replace',aliases:null,description:'This modifier completely changes the rule behavior.\nIf it is applied, the rule will not block the request. The response is going to be modified instead.',docs:'https://github.com/gorhill/uBlock/wiki/Static-filter-syntax#replace',versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,conflicts:['app','domain','document','subdocument','script','stylesheet','other','xmlhttprequest','first-party','third-party','important','badfilter'],inverseConflicts:true,assignable:true,negatable:false,blockOnly:false,exceptionOnly:false,valueOptional:false,valueFormat:'^(?:)\\/(?:)(.+)(?:)\\/(?:)(.+)?(?:)\\/(?:)([gimuy]*)?(?:)$',valueFormatFlags:'i'}],map:{'1':0,'2':0,'4':0,'64':1,'8192':2}},{shared:[{name:'script',aliases:null,description:'The rule corresponds to script requests, e.g. javascript, vbscript.',docs:'https://adguard.app/kb/general/ad-filtering/create-own-filters/#script-modifier',versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,conflicts:null,inverseConflicts:false,assignable:false,negatable:true,blockOnly:false,exceptionOnly:false,valueOptional:false,valueFormat:null,valueFormatFlags:null},{name:'script',aliases:null,description:'The rule corresponds to script requests, e.g. javascript, vbscript.',docs:'https://help.adblockplus.org/hc/en-us/articles/360062733293#options',versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,conflicts:null,inverseConflicts:false,assignable:false,negatable:true,blockOnly:false,exceptionOnly:false,valueOptional:false,valueFormat:null,valueFormatFlags:null},{name:'script',aliases:null,description:'The rule corresponds to script requests, e.g. javascript, vbscript.',docs:'https://help.adblockplus.org/hc/en-us/articles/360062733293-How-to-write-filters#type-options',versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,conflicts:null,inverseConflicts:false,assignable:false,negatable:true,blockOnly:false,exceptionOnly:false,valueOptional:false,valueFormat:null,valueFormatFlags:null}],map:{'1':0,'2':0,'4':0,'8':0,'16':0,'32':0,'64':0,'128':0,'256':0,'512':0,'1024':1,'2048':1,'4096':1,'8192':1,'16384':2,'32768':2,'65536':2,'131072':2}},{shared:[{name:'specifichide',aliases:['shide'],description:'Disables all specific element hiding and CSS rules, but not general ones.\nHas an opposite effect to `$generichide`.',docs:'https://adguard.app/kb/general/ad-filtering/create-own-filters/#specifichide-modifier',versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,conflicts:['domain','genericblock','urlblock','extension','jsinject','content','xmlhttprequest','badfilter'],inverseConflicts:true,assignable:false,negatable:false,blockOnly:false,exceptionOnly:true,valueOptional:false,valueFormat:null,valueFormatFlags:null},{name:'specifichide',aliases:['shide'],description:'Disables all specific element hiding and CSS rules, but not general ones.\nHas an opposite effect to `$generichide`.',docs:'https://github.com/gorhill/uBlock/wiki/Static-filter-syntax#specifichide',versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,conflicts:['domain','badfilter'],inverseConflicts:true,assignable:false,negatable:false,blockOnly:false,exceptionOnly:true,valueOptional:false,valueFormat:null,valueFormatFlags:null}],map:{'1':0,'2':0,'4':0,'8':0,'16':0,'32':0,'64':0,'128':0,'256':0,'512':0,'1024':1,'2048':1,'4096':1,'8192':1}},{shared:[{name:'stealth',aliases:null,description:'Disables the Stealth Mode module for all corresponding pages and requests.',docs:'https://adguard.app/kb/general/ad-filtering/create-own-filters/#stealth-modifier',versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,conflicts:null,inverseConflicts:false,assignable:true,negatable:false,blockOnly:false,exceptionOnly:true,valueOptional:true,valueFormat:'pipe_separated_stealth_options',valueFormatFlags:null},{name:'stealth',aliases:null,description:'Disables the Stealth Mode module for all corresponding pages and requests.',docs:'https://adguard.app/kb/general/ad-filtering/create-own-filters/#stealth-modifier',versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,conflicts:null,inverseConflicts:false,assignable:true,negatable:false,blockOnly:false,exceptionOnly:true,valueOptional:true,valueFormat:'pipe_separated_stealth_options',valueFormatFlags:null},{name:'stealth',aliases:null,description:'Disables the Stealth Mode module for all corresponding pages and requests.',docs:'https://adguard.app/kb/general/ad-filtering/create-own-filters/#stealth-modifier',versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,conflicts:null,inverseConflicts:false,assignable:true,negatable:false,blockOnly:false,exceptionOnly:true,valueOptional:true,valueFormat:'pipe_separated_stealth_options',valueFormatFlags:null},{name:'stealth',aliases:null,description:'Disables the Stealth Mode module for all corresponding pages and requests.',docs:'https://adguard.app/kb/general/ad-filtering/create-own-filters/#stealth-modifier',versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,conflicts:null,inverseConflicts:false,assignable:true,negatable:false,blockOnly:false,exceptionOnly:true,valueOptional:true,valueFormat:'pipe_separated_stealth_options',valueFormatFlags:null},{name:'stealth',aliases:null,description:'Disables the Stealth Mode module for all corresponding pages and requests.',docs:'https://adguard.app/kb/general/ad-filtering/create-own-filters/#stealth-modifier',versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,conflicts:null,inverseConflicts:false,assignable:true,negatable:false,blockOnly:false,exceptionOnly:true,valueOptional:true,valueFormat:'pipe_separated_stealth_options',valueFormatFlags:null}],map:{'1':0,'2':0,'4':0,'8':1,'16':2,'32':3,'64':4}},{shared:[{name:'strict1p',aliases:null,description:'This new `strict1p` option can check for strict partyness.\nFor example, a network request qualifies as 1st-party if both the context and the request share the same hostname.',docs:'https://github.com/gorhill/uBlock/wiki/Static-filter-syntax#strict1p',versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,conflicts:null,inverseConflicts:false,assignable:false,negatable:true,blockOnly:false,exceptionOnly:false,valueOptional:false,valueFormat:null,valueFormatFlags:null}],map:{'1024':0,'2048':0,'4096':0,'8192':0}},{shared:[{name:'strict3p',aliases:null,description:'This new `strict3p` option can check for strict partyness.\nFor example, a network request qualifies as 3rd-party if the context and the request hostnames are different.',docs:'https://github.com/gorhill/uBlock/wiki/Static-filter-syntax#strict3p',versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,conflicts:null,inverseConflicts:false,assignable:false,negatable:true,blockOnly:false,exceptionOnly:false,valueOptional:false,valueFormat:null,valueFormatFlags:null}],map:{'1024':0,'2048':0,'4096':0,'8192':0}},{shared:[{name:'stylesheet',aliases:null,description:'The rule corresponds to CSS files requests.',docs:'https://adguard.app/kb/general/ad-filtering/create-own-filters/#stylesheet-modifier',versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,conflicts:null,inverseConflicts:false,assignable:false,negatable:true,blockOnly:false,exceptionOnly:false,valueOptional:false,valueFormat:null,valueFormatFlags:null},{name:'stylesheet',aliases:['css'],description:'The rule corresponds to CSS files requests.',docs:'https://github.com/gorhill/uBlock/wiki/Static-filter-syntax#css',versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,conflicts:null,inverseConflicts:false,assignable:false,negatable:true,blockOnly:false,exceptionOnly:false,valueOptional:false,valueFormat:null,valueFormatFlags:null},{name:'stylesheet',aliases:null,description:'The rule corresponds to CSS files requests.',docs:'https://help.adblockplus.org/hc/en-us/articles/360062733293-How-to-write-filters#type-options',versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,conflicts:null,inverseConflicts:false,assignable:false,negatable:true,blockOnly:false,exceptionOnly:false,valueOptional:false,valueFormat:null,valueFormatFlags:null}],map:{'1':0,'2':0,'4':0,'8':0,'16':0,'32':0,'64':0,'128':0,'256':0,'512':0,'1024':1,'2048':1,'4096':1,'8192':1,'16384':2,'32768':2,'65536':2,'131072':2}},{shared:[{name:'subdocument',aliases:null,description:'The rule corresponds to requests for built-in pages — HTML tags frame and iframe.',docs:'https://adguard.app/kb/general/ad-filtering/create-own-filters/#subdocument-modifier',versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,conflicts:null,inverseConflicts:false,assignable:false,negatable:true,blockOnly:false,exceptionOnly:false,valueOptional:false,valueFormat:null,valueFormatFlags:null},{name:'subdocument',aliases:['frame'],description:'The rule corresponds to requests for built-in pages — HTML tags frame and iframe.',docs:'https://github.com/gorhill/uBlock/wiki/Static-filter-syntax#frame',versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,conflicts:null,inverseConflicts:false,assignable:false,negatable:true,blockOnly:false,exceptionOnly:false,valueOptional:false,valueFormat:null,valueFormatFlags:null},{name:'subdocument',aliases:null,description:'The rule corresponds to requests for built-in pages — HTML tags frame and iframe.',docs:'https://help.adblockplus.org/hc/en-us/articles/360062733293-How-to-write-filters#type-options',versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,conflicts:null,inverseConflicts:false,assignable:false,negatable:true,blockOnly:false,exceptionOnly:false,valueOptional:false,valueFormat:null,valueFormatFlags:null}],map:{'1':0,'2':0,'4':0,'8':0,'16':0,'32':0,'64':0,'128':0,'256':0,'512':0,'1024':1,'2048':1,'4096':1,'8192':1,'16384':2,'32768':2,'65536':2,'131072':2}},{shared:[{name:'third-party',aliases:['3p'],description:'A restriction of third-party and own requests.\nA third-party request is a request from a different domain.\nFor example, a request to `example.org` from `domain.com` is a third-party request.',docs:'https://adguard.app/kb/general/ad-filtering/create-own-filters/#third-party-modifier',versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,conflicts:null,inverseConflicts:false,assignable:false,negatable:true,blockOnly:false,exceptionOnly:false,valueOptional:false,valueFormat:null,valueFormatFlags:null},{name:'3p',aliases:['third-party'],description:'A restriction of third-party and own requests.\nA third-party request is a request from a different domain.\nFor example, a request to `example.org` from `domain.com` is a third-party request.',docs:'https://github.com/gorhill/uBlock/wiki/Static-filter-syntax#3p',versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,conflicts:null,inverseConflicts:false,assignable:false,negatable:true,blockOnly:false,exceptionOnly:false,valueOptional:false,valueFormat:null,valueFormatFlags:null},{name:'third-party',aliases:null,description:'A restriction of third-party and own requests.\nA third-party request is a request from a different domain.\nFor example, a request to `example.org` from `domain.com` is a third-party request.',docs:'https://help.adblockplus.org/hc/en-us/articles/360062733293#party-requests',versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,conflicts:null,inverseConflicts:false,assignable:false,negatable:true,blockOnly:false,exceptionOnly:false,valueOptional:false,valueFormat:null,valueFormatFlags:null}],map:{'1':0,'2':0,'4':0,'8':0,'16':0,'32':0,'64':0,'128':0,'256':0,'512':0,'1024':1,'2048':1,'4096':1,'8192':1,'16384':2,'32768':2,'65536':2,'131072':2}},{shared:[{name:'to',aliases:null,description:'`$to` limits the rule scope to requests made to the specified domains and their subdomains.\nTo add multiple domains to one rule, use the `|` character as a separator.',docs:'https://adguard.com/kb/general/ad-filtering/create-own-filters/#to-modifier',versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,conflicts:['denyallow'],inverseConflicts:false,assignable:true,negatable:false,blockOnly:false,exceptionOnly:false,valueOptional:false,valueFormat:'pipe_separated_domains',valueFormatFlags:null},{name:'to',aliases:null,description:'`$to` limits the rule scope to requests made to the specified domains and their subdomains.\nTo add multiple domains to one rule, use the `|` character as a separator.',docs:'https://adguard.com/kb/general/ad-filtering/create-own-filters/#to-modifier',versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,conflicts:['denyallow'],inverseConflicts:false,assignable:true,negatable:false,blockOnly:false,exceptionOnly:false,valueOptional:false,valueFormat:'pipe_separated_domains',valueFormatFlags:null},{name:'to',aliases:null,description:'The main motivation of this option is\nto give static network filtering engine an equivalent of DNR\'s `requestDomains` and `excludedRequestDomains`.',docs:'https://github.com/gorhill/uBlock/wiki/Static-filter-syntax#to',versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,conflicts:['denyallow'],inverseConflicts:false,assignable:true,negatable:false,blockOnly:false,exceptionOnly:false,valueOptional:false,valueFormat:'pipe_separated_domains',valueFormatFlags:null}],map:{'1':0,'2':0,'4':0,'8':1,'16':1,'32':1,'64':1,'1024':2,'2048':2,'4096':2,'8192':2}},{shared:[{name:'urlblock',aliases:null,description:'Disables blocking of all requests sent from the pages matching the rule.',docs:'https://adguard.app/kb/general/ad-filtering/create-own-filters/#urlblock-modifier',versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,conflicts:['domain','specifichide','generichide','elemhide','extension','jsinject','content','badfilter'],inverseConflicts:true,assignable:false,negatable:false,blockOnly:false,exceptionOnly:true,valueOptional:false,valueFormat:null,valueFormatFlags:null}],map:{'1':0,'2':0,'4':0,'8':0,'16':0,'32':0,'64':0,'128':0,'256':0,'512':0}},{shared:[{name:'webrtc',aliases:null,description:'The rule applies only to WebRTC connections.',docs:'https://adguard.app/kb/general/ad-filtering/create-own-filters/#webrtc-modifier',versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:true,removalMessage:'This modifier is removed and is no longer supported.\nRules with it are considered as invalid. If you need to suppress WebRTC, consider using\nthe [nowebrtc scriptlet](https://github.com/AdguardTeam/Scriptlets/blob/master/wiki/about-scriptlets.md#nowebrtc).',conflicts:null,inverseConflicts:false,assignable:false,negatable:true,blockOnly:false,exceptionOnly:false,valueOptional:false,valueFormat:null,valueFormatFlags:null},{name:'webrtc',aliases:null,description:'The rule applies only to WebRTC connections.',docs:'https://github.com/gorhill/uBlock/wiki/Static-filter-syntax',versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:true,removalMessage:'This modifier is removed and is no longer supported.\nIf you need to suppress WebRTC, consider using\nthe [nowebrtc scriptlet](https://github.com/gorhill/uBlock/wiki/Resources-Library#nowebrtcjs-).',conflicts:null,inverseConflicts:false,assignable:false,negatable:true,blockOnly:false,exceptionOnly:false,valueOptional:false,valueFormat:null,valueFormatFlags:null},{name:'webrtc',aliases:null,description:'The rule applies only to WebRTC connections.',docs:'https://help.adblockplus.org/hc/en-us/articles/360062733293-How-to-write-filters#type-options',versionAdded:'1.13.3',versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,conflicts:null,inverseConflicts:false,assignable:false,negatable:true,blockOnly:false,exceptionOnly:false,valueOptional:false,valueFormat:null,valueFormatFlags:null}],map:{'1':0,'2':0,'4':0,'8':0,'16':0,'32':0,'64':0,'128':0,'256':0,'512':0,'1024':1,'2048':1,'4096':1,'8192':1,'16384':2,'32768':2,'65536':2,'131072':2}},{shared:[{name:'websocket',aliases:null,description:'The rule applies only to WebSocket connections.',docs:'https://adguard.app/kb/general/ad-filtering/create-own-filters/#websocket-modifier',versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,conflicts:null,inverseConflicts:false,assignable:false,negatable:true,blockOnly:false,exceptionOnly:false,valueOptional:false,valueFormat:null,valueFormatFlags:null},{name:'websocket',aliases:null,description:'The rule applies only to WebSocket connections.',docs:'https://adguard.app/kb/general/ad-filtering/create-own-filters/#websocket-modifier',versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,conflicts:null,inverseConflicts:false,assignable:false,negatable:true,blockOnly:false,exceptionOnly:false,valueOptional:false,valueFormat:null,valueFormatFlags:null},{name:'websocket',aliases:null,description:'The rule applies only to WebSocket connections.',docs:'https://adguard.app/kb/general/ad-filtering/create-own-filters/#websocket-modifier',versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,conflicts:null,inverseConflicts:false,assignable:false,negatable:true,blockOnly:false,exceptionOnly:false,valueOptional:false,valueFormat:null,valueFormatFlags:null},{name:'websocket',aliases:null,description:'The rule applies only to WebSocket connections.',docs:'https://adguard.app/kb/general/ad-filtering/create-own-filters/#websocket-modifier',versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,conflicts:null,inverseConflicts:false,assignable:false,negatable:true,blockOnly:false,exceptionOnly:false,valueOptional:false,valueFormat:null,valueFormatFlags:null},{name:'websocket',aliases:null,description:'The rule applies only to WebSocket connections.',docs:'https://help.adblockplus.org/hc/en-us/articles/360062733293-How-to-write-filters#type-options',versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,conflicts:null,inverseConflicts:false,assignable:false,negatable:true,blockOnly:false,exceptionOnly:false,valueOptional:false,valueFormat:null,valueFormatFlags:null},{name:'websocket',aliases:null,description:'The rule applies only to WebSocket connections.',docs:'https://help.adblockplus.org/hc/en-us/articles/360062733293-How-to-write-filters#type-options',versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,conflicts:null,inverseConflicts:false,assignable:false,negatable:true,blockOnly:false,exceptionOnly:false,valueOptional:false,valueFormat:null,valueFormatFlags:null}],map:{'1':0,'2':0,'4':0,'8':1,'16':1,'32':1,'64':1,'256':2,'512':3,'1024':4,'2048':4,'4096':4,'8192':4,'16384':5,'32768':5,'65536':5,'131072':5}},{shared:[{name:'xmlhttprequest',aliases:['xhr'],description:'The rule applies only to ajax requests (requests sent via javascript object XMLHttpRequest).',docs:'https://adguard.app/kb/general/ad-filtering/create-own-filters/#xmlhttprequest-modifier',versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,conflicts:null,inverseConflicts:false,assignable:false,negatable:true,blockOnly:false,exceptionOnly:false,valueOptional:false,valueFormat:null,valueFormatFlags:null},{name:'xhr',aliases:['xmlhttprequest'],description:'The rule applies only to ajax requests (requests sent via javascript object XMLHttpRequest).',docs:'https://github.com/gorhill/uBlock/wiki/Static-filter-syntax#xhr',versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,conflicts:null,inverseConflicts:false,assignable:false,negatable:true,blockOnly:false,exceptionOnly:false,valueOptional:false,valueFormat:null,valueFormatFlags:null},{name:'xmlhttprequest',aliases:null,description:'The rule applies only to ajax requests (requests sent via javascript object XMLHttpRequest).',docs:'https://help.adblockplus.org/hc/en-us/articles/360062733293-How-to-write-filters#type-options',versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,conflicts:null,inverseConflicts:false,assignable:false,negatable:true,blockOnly:false,exceptionOnly:false,valueOptional:false,valueFormat:null,valueFormatFlags:null}],map:{'1':0,'2':0,'4':0,'8':0,'16':0,'32':0,'64':0,'128':0,'256':0,'512':0,'1024':1,'2048':1,'4096':1,'8192':1,'16384':2,'32768':2,'65536':2,'131072':2}}],map:{all:0,app:1,badfilter:2,cname:3,content:4,cookie:5,csp:6,denyallow:7,document:8,doc:8,domain:9,from:9,elemhide:10,ehide:10,empty:11,extension:12,'first-party':13,'1p':13,'~third-party':13,font:14,genericblock:15,generichide:16,ghide:16,header:17,hls:18,image:19,important:20,'inline-font':21,'inline-script':22,jsinject:23,jsonprune:24,'match-case':25,media:26,method:27,mp4:28,network:29,_:30,'object-subrequest':31,object:32,other:33,permissions:34,ping:35,popunder:36,popup:37,'redirect-rule':38,redirect:39,rewrite:39,referrerpolicy:40,removeheader:41,removeparam:42,replace:43,script:44,specifichide:45,shide:45,stealth:46,strict1p:47,strict3p:48,stylesheet:49,css:49,subdocument:50,frame:50,'third-party':51,'3p':51,to:52,urlblock:53,webrtc:54,websocket:55,xmlhttprequest:56,xhr:56}};
const redirectsCompatibilityTableData = {shared:[{shared:[{name:'1x1-transparent.gif',aliases:['1x1.gif','1x1-transparent-gif'],description:'Redirects to a 1x1 transparent GIF.',docs:'https://github.com/AdguardTeam/Scriptlets/blob/master/wiki/about-redirects.md#1x1-transparent.gif',versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,isBlocking:false,resourceTypes:[]},{name:'1x1.gif',aliases:null,description:'Redirects to a 1x1 transparent GIF.',docs:'https://github.com/gorhill/uBlock/wiki/Resources-Library#available-empty-redirect-resources',versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,isBlocking:false,resourceTypes:['image']},{name:'1x1-transparent-gif',aliases:null,description:'Redirects to a 1x1 transparent GIF.',docs:'https://help.adblockplus.org/hc/en-us/articles/360062733293#rewrite',versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,isBlocking:false,resourceTypes:[]}],map:{'1':0,'2':0,'4':0,'8':0,'16':0,'32':0,'64':0,'1024':1,'2048':1,'4096':1,'8192':1,'16384':2,'32768':2,'65536':2,'131072':2}},{shared:[{name:'2x2-transparent.png',aliases:['2x2.png','2x2-transparent-png'],description:'Redirects to a 2x2 transparent PNG.',docs:'https://github.com/AdguardTeam/Scriptlets/blob/master/wiki/about-redirects.md#2x2-transparent.png',versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,isBlocking:false,resourceTypes:[]},{name:'2x2.png',aliases:null,description:'Redirects to a 2x2 transparent PNG.',docs:'https://github.com/gorhill/uBlock/wiki/Resources-Library#available-empty-redirect-resources',versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,isBlocking:false,resourceTypes:['image']},{name:'2x2-transparent-png',aliases:null,description:'Redirects to a 2x2 transparent PNG.',docs:'https://help.adblockplus.org/hc/en-us/articles/360062733293#rewrite',versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,isBlocking:false,resourceTypes:[]}],map:{'1':0,'2':0,'4':0,'8':0,'16':0,'32':0,'64':0,'1024':1,'2048':1,'4096':1,'8192':1,'16384':2,'32768':2,'65536':2,'131072':2}},{shared:[{name:'32x32-transparent.png',aliases:['32x32.png','32x32-transparent-png'],description:'Redirects to a 32x32 transparent PNG.',docs:'https://github.com/AdguardTeam/Scriptlets/blob/master/wiki/about-redirects.md#32x32-transparent.png',versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,isBlocking:false,resourceTypes:[]},{name:'32x32.png',aliases:null,description:'Redirects to a 32x32 transparent PNG.',docs:'https://github.com/gorhill/uBlock/wiki/Resources-Library#available-empty-redirect-resources',versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,isBlocking:false,resourceTypes:['image']},{name:'32x32-transparent-png',aliases:null,description:'Redirects to a 32x32 transparent PNG.',docs:'https://help.adblockplus.org/hc/en-us/articles/360062733293#rewrite',versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,isBlocking:false,resourceTypes:[]}],map:{'1':0,'2':0,'4':0,'8':0,'16':0,'32':0,'64':0,'1024':1,'2048':1,'4096':1,'8192':1,'16384':2,'32768':2,'65536':2,'131072':2}},{shared:[{name:'3x2-transparent.png',aliases:['3x2.png','3x2-transparent-png'],description:'Redirects to a 3x2 transparent PNG.',docs:'https://github.com/AdguardTeam/Scriptlets/blob/master/wiki/about-redirects.md#3x2-transparent.png',versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,isBlocking:false,resourceTypes:[]},{name:'3x2.png',aliases:null,description:'Redirects to a 3x2 transparent PNG.',docs:'https://github.com/gorhill/uBlock/wiki/Resources-Library#available-empty-redirect-resources',versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,isBlocking:false,resourceTypes:['image']},{name:'3x2-transparent-png',aliases:null,description:'Redirects to a 3x2 transparent PNG.',docs:'https://help.adblockplus.org/hc/en-us/articles/360062733293#rewrite',versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,isBlocking:false,resourceTypes:[]}],map:{'1':0,'2':0,'4':0,'8':0,'16':0,'32':0,'64':0,'1024':1,'2048':1,'4096':1,'8192':1,'16384':2,'32768':2,'65536':2,'131072':2}},{shared:[{name:'amazon-apstag',aliases:['ubo-amazon_apstag.js','amazon_apstag.js'],description:'Mocks Amazon\'s apstag.js',docs:'https://github.com/AdguardTeam/Scriptlets/blob/master/wiki/about-redirects.md#amazon-apstag',versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,isBlocking:false,resourceTypes:[]},{name:'amazon_apstag.js',aliases:null,description:'Mocks Amazon\'s apstag.js',docs:'https://github.com/gorhill/uBlock/wiki/Resources-Library#amazon_apstagjs-',versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,isBlocking:false,resourceTypes:['script']}],map:{'1':0,'2':0,'4':0,'8':0,'16':0,'32':0,'64':0,'1024':1,'2048':1,'4096':1,'8192':1}},{shared:[{name:'amazon_ads.js',aliases:null,description:null,docs:null,versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,isBlocking:false,resourceTypes:['script']}],map:{'1024':0,'2048':0,'4096':0,'8192':0}},{shared:[{name:'ampproject_v0.js',aliases:null,description:null,docs:null,versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,isBlocking:false,resourceTypes:['script']}],map:{'1024':0,'2048':0,'4096':0,'8192':0}},{shared:[{name:'ati-smarttag',aliases:null,description:null,docs:null,versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,isBlocking:false,resourceTypes:[]}],map:{'1':0,'2':0,'4':0,'8':0,'16':0,'32':0,'64':0}},{shared:[{name:'chartbeat.js',aliases:null,description:null,docs:null,versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,isBlocking:false,resourceTypes:['script']}],map:{'1024':0,'2048':0,'4096':0,'8192':0}},{shared:[{name:'click2load.html',aliases:['click2load.html','ubo-click2load.html'],description:'Redirects resource and replaces supposed content by decoy frame with button for original content recovering.',docs:null,versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,isBlocking:true,resourceTypes:[]},{name:'click2load.html',aliases:null,description:'Redirects resource and replaces supposed content by decoy frame with button for original content recovering.',docs:null,versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,isBlocking:true,resourceTypes:[]}],map:{'1':0,'2':0,'4':0,'8':0,'16':0,'32':0,'64':0,'1024':1,'2048':1,'4096':1,'8192':1}},{shared:[{name:'didomi-loader',aliases:null,description:'Mocks Didomi\'s CMP loader script.',docs:null,versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,isBlocking:false,resourceTypes:[]}],map:{'1':0,'2':0,'4':0,'8':0,'16':0,'32':0,'64':0}},{shared:[{name:'empty',aliases:null,description:'Redirects to an empty file.',docs:null,versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,isBlocking:false,resourceTypes:[]},{name:'empty',aliases:null,description:'Redirects to an empty file.',docs:null,versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,isBlocking:false,resourceTypes:[]}],map:{'1':0,'2':0,'4':0,'8':0,'16':0,'32':0,'64':0,'1024':1,'2048':1,'4096':1,'8192':1}},{shared:[{name:'fingerprintjs2',aliases:['fingerprint2.js'],description:'Mocks FingerprintJS2 script.',docs:null,versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,isBlocking:false,resourceTypes:[]},{name:'fingerprint2.js',aliases:null,description:'Mocks FingerprintJS2 script.',docs:null,versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,isBlocking:false,resourceTypes:['script']}],map:{'1':0,'2':0,'4':0,'8':0,'16':0,'32':0,'64':0,'1024':1,'2048':1,'4096':1,'8192':1}},{shared:[{name:'fingerprintjs3',aliases:['fingerprint3.js'],description:'Mocks FingerprintJS v3.',docs:null,versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,isBlocking:false,resourceTypes:[]},{name:'fingerprint3.js',aliases:null,description:'Mocks FingerprintJS v3.',docs:null,versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,isBlocking:false,resourceTypes:['script']}],map:{'1':0,'2':0,'4':0,'8':0,'16':0,'32':0,'64':0,'1024':1,'2048':1,'4096':1,'8192':1}},{shared:[{name:'gemius',aliases:null,description:'Mocks Gemius Analytics.',docs:null,versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,isBlocking:false,resourceTypes:[]}],map:{'1':0,'2':0,'4':0,'8':0,'16':0,'32':0,'64':0}},{shared:[{name:'google-analytics-ga',aliases:['ubo-google-analytics_ga.js','google-analytics_ga.js'],description:'Mocks old Google Analytics API.',docs:null,versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,isBlocking:false,resourceTypes:[]},{name:'google-analytics_ga.js',aliases:null,description:'Mocks old Google Analytics API.',docs:null,versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,isBlocking:false,resourceTypes:['script']}],map:{'1':0,'2':0,'4':0,'8':0,'16':0,'32':0,'64':0,'1024':1,'2048':1,'4096':1,'8192':1}},{shared:[{name:'google-analytics',aliases:['ubo-google-analytics_analytics.js','google-analytics_analytics.js','googletagmanager-gtm','ubo-googletagmanager_gtm.js','googletagmanager_gtm.js'],description:'Mocks Google\'s Analytics and Tag Manager APIs.',docs:null,versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,isBlocking:false,resourceTypes:[]},{name:'google-analytics_analytics.js',aliases:null,description:'Mocks Google\'s Analytics and Tag Manager APIs.',docs:null,versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,isBlocking:false,resourceTypes:['script']}],map:{'1':0,'2':0,'4':0,'8':0,'16':0,'32':0,'64':0,'1024':1,'2048':1,'4096':1,'8192':1}},{shared:[{name:'google-analytics_cx_api.js',aliases:null,description:null,docs:null,versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,isBlocking:false,resourceTypes:['script']}],map:{'1024':0,'2048':0,'4096':0,'8192':0}},{shared:[{name:'google-analytics_inpage_linkid.js',aliases:null,description:null,docs:null,versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,isBlocking:false,resourceTypes:['script']}],map:{'1024':0,'2048':0,'4096':0,'8192':0}},{shared:[{name:'google-ima3',aliases:['ubo-google-ima.js','google-ima.js'],description:'Mocks the IMA SDK of Google.',docs:null,versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,isBlocking:false,resourceTypes:[]},{name:'google-ima.js',aliases:null,description:'Mocks the IMA SDK of Google.',docs:null,versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,isBlocking:false,resourceTypes:['script']}],map:{'1':0,'2':0,'4':0,'8':0,'16':0,'32':0,'64':0,'1024':1,'2048':1,'4096':1,'8192':1}},{shared:[{name:'googlesyndication-adsbygoogle',aliases:['ubo-googlesyndication_adsbygoogle.js','ubo-googlesyndication.com/adsbygoogle.js','googlesyndication_adsbygoogle.js'],description:'Mocks Google AdSense API.',docs:null,versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,isBlocking:false,resourceTypes:[]},{name:'googlesyndication_adsbygoogle.js',aliases:['googlesyndication.com/adsbygoogle.js'],description:'Mocks Google AdSense API.',docs:null,versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,isBlocking:false,resourceTypes:['script']}],map:{'1':0,'2':0,'4':0,'8':0,'16':0,'32':0,'64':0,'1024':1,'2048':1,'4096':1,'8192':1}},{shared:[{name:'googletagservices-gpt',aliases:['ubo-googletagservices_gpt.js','googletagservices_gpt.js'],description:'Mocks Google Publisher Tag API.',docs:null,versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,isBlocking:false,resourceTypes:[]},{name:'googletagservices_gpt.js',aliases:null,description:'Mocks Google Publisher Tag API.',docs:null,versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,isBlocking:false,resourceTypes:['script']}],map:{'1':0,'2':0,'4':0,'8':0,'16':0,'32':0,'64':0,'1024':1,'2048':1,'4096':1,'8192':1}},{shared:[{name:'hd-main.js',aliases:null,description:null,docs:null,versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,isBlocking:false,resourceTypes:['script']}],map:{'1024':0,'2048':0,'4096':0,'8192':0}},{shared:[{name:'matomo',aliases:null,description:'Mocks the piwik.js file of Matomo (formerly Piwik).',docs:null,versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,isBlocking:false,resourceTypes:[]}],map:{'1':0,'2':0,'4':0,'8':0,'16':0,'32':0,'64':0}},{shared:[{name:'metrika-yandex-tag',aliases:null,description:'Mocks Yandex Metrika API.',docs:null,versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,isBlocking:false,resourceTypes:[]}],map:{'1':0,'2':0,'4':0,'8':0,'16':0,'32':0,'64':0}},{shared:[{name:'metrika-yandex-watch',aliases:null,description:'Mocks the old Yandex Metrika API.',docs:null,versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,isBlocking:false,resourceTypes:[]}],map:{'1':0,'2':0,'4':0,'8':0,'16':0,'32':0,'64':0}},{shared:[{name:'naver-wcslog',aliases:null,description:'Mocks wcslog.js of Naver Analytics.',docs:null,versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,isBlocking:false,resourceTypes:[]}],map:{'1':0,'2':0,'4':0,'8':0,'16':0,'32':0,'64':0}},{shared:[{name:'no-protected-audience',aliases:null,description:'Prevents using the Protected Audience API.',docs:null,versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,isBlocking:false,resourceTypes:[]}],map:{'1':0,'2':0,'4':0,'8':0,'16':0,'32':0,'64':0}},{shared:[{name:'no-topics',aliases:null,description:'Prevents using the Topics API.',docs:null,versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,isBlocking:false,resourceTypes:[]}],map:{'1':0,'2':0,'4':0,'8':0,'16':0,'32':0,'64':0}},{shared:[{name:'noeval',aliases:['noeval.js','silent-noeval.js','ubo-noeval.js','ubo-silent-noeval.js','ubo-noeval','ubo-silent-noeval'],description:'Prevents page to use eval.',docs:null,versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,isBlocking:false,resourceTypes:[]},{name:'noeval.js',aliases:null,description:'Prevents page to use eval.',docs:null,versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,isBlocking:false,resourceTypes:['script']}],map:{'1':0,'2':0,'4':0,'8':0,'16':0,'32':0,'64':0,'1024':1,'2048':1,'4096':1,'8192':1}},{shared:[{name:'noop-0.5s.mp3',aliases:null,description:'Redirects to an empty MP3 file with a duration of 0.5 seconds.',docs:null,versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,isBlocking:false,resourceTypes:['media']}],map:{'1024':0,'2048':0,'4096':0,'8192':0}},{shared:[{name:'noopcss',aliases:['noop.css','blank-css'],description:'Redirects to an empty CSS file.',docs:null,versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,isBlocking:false,resourceTypes:[]},{name:'noop.css',aliases:null,description:'Redirects to an empty CSS file.',docs:null,versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,isBlocking:false,resourceTypes:['stylesheet']},{name:'blank-css',aliases:null,description:'Redirects to an empty CSS file.',docs:null,versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,isBlocking:false,resourceTypes:[]}],map:{'1':0,'2':0,'4':0,'8':0,'16':0,'32':0,'64':0,'1024':1,'2048':1,'4096':1,'8192':1,'16384':2,'32768':2,'65536':2,'131072':2}},{shared:[{name:'noopframe',aliases:['noop.html','blank-html'],description:'Redirects to an empty HTML file.',docs:null,versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,isBlocking:false,resourceTypes:[]},{name:'noop.html',aliases:null,description:'Redirects to an empty HTML file.',docs:null,versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,isBlocking:false,resourceTypes:['sub_frame']},{name:'blank-html',aliases:null,description:'Redirects to an empty HTML file.',docs:null,versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,isBlocking:false,resourceTypes:[]}],map:{'1':0,'2':0,'4':0,'8':0,'16':0,'32':0,'64':0,'1024':1,'2048':1,'4096':1,'8192':1,'16384':2,'32768':2,'65536':2,'131072':2}},{shared:[{name:'noopjs',aliases:['noop.js','blank-js'],description:'Redirects to an empty JavaScript file.',docs:null,versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,isBlocking:false,resourceTypes:[]},{name:'noop.js',aliases:null,description:'Redirects to an empty JavaScript file.',docs:null,versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,isBlocking:false,resourceTypes:['script']},{name:'blank-js',aliases:null,description:'Redirects to an empty JavaScript file.',docs:null,versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,isBlocking:false,resourceTypes:[]}],map:{'1':0,'2':0,'4':0,'8':0,'16':0,'32':0,'64':0,'1024':1,'2048':1,'4096':1,'8192':1,'16384':2,'32768':2,'65536':2,'131072':2}},{shared:[{name:'noopjson',aliases:['noop.json'],description:'Redirects to an empty JSON file.',docs:null,versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,isBlocking:false,resourceTypes:[]},{name:'noop.json',aliases:null,description:'Redirects to an empty JSON file.',docs:null,versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,isBlocking:false,resourceTypes:[]}],map:{'1':0,'2':0,'4':0,'8':0,'16':0,'32':0,'64':0,'1024':1,'2048':1,'4096':1,'8192':1}},{shared:[{name:'noopmp3-0.1s',aliases:['noop-0.1s.mp3','blank-mp3'],description:'Redirects to an empty MP3 file with a duration of 0.1 seconds.',docs:null,versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,isBlocking:false,resourceTypes:[]},{name:'noop-0.1s.mp3',aliases:null,description:'Redirects to an empty MP3 file with a duration of 0.1 seconds.',docs:null,versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,isBlocking:false,resourceTypes:['media']},{name:'blank-mp3',aliases:null,description:'Redirects to an empty MP3 file with a duration of 0.1 seconds.',docs:null,versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,isBlocking:false,resourceTypes:[]}],map:{'1':0,'2':0,'4':0,'8':0,'16':0,'32':0,'64':0,'1024':1,'2048':1,'4096':1,'8192':1,'16384':2,'32768':2,'65536':2,'131072':2}},{shared:[{name:'noopmp4-1s',aliases:['noop-1s.mp4','blank-mp4'],description:'Redirects to an empty MP4 file with a duration of 1 second.',docs:null,versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,isBlocking:false,resourceTypes:[]},{name:'noop-1s.mp4',aliases:null,description:'Redirects to an empty MP4 file with a duration of 1 second.',docs:null,versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,isBlocking:false,resourceTypes:['media']},{name:'blank-mp4',aliases:null,description:'Redirects to an empty MP4 file with a duration of 1 second.',docs:null,versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,isBlocking:false,resourceTypes:[]}],map:{'1':0,'2':0,'4':0,'8':0,'16':0,'32':0,'64':0,'1024':1,'2048':1,'4096':1,'8192':1,'16384':2,'32768':2,'65536':2,'131072':2}},{shared:[{name:'nooptext',aliases:['noop.txt','blank-text'],description:'Redirects to an empty text file.',docs:null,versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,isBlocking:false,resourceTypes:[]},{name:'noop.txt',aliases:null,description:'Redirects to an empty text file.',docs:null,versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,isBlocking:false,resourceTypes:['image','media','sub_frame','stylesheet','script','xmlhttprequest','other']},{name:'blank-text',aliases:null,description:'Redirects to an empty text file.',docs:null,versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,isBlocking:false,resourceTypes:[]}],map:{'1':0,'2':0,'4':0,'8':0,'16':0,'32':0,'64':0,'1024':1,'2048':1,'4096':1,'8192':1,'16384':2,'32768':2,'65536':2,'131072':2}},{shared:[{name:'noopvast-2.0',aliases:null,description:'Redirects to an empty VAST 2.0 XML file.',docs:null,versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,isBlocking:false,resourceTypes:[]}],map:{'1':0,'2':0,'4':0,'8':0,'16':0,'32':0,'64':0}},{shared:[{name:'noopvast-3.0',aliases:null,description:'Redirects to an empty VAST 3.0 XML file.',docs:null,versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,isBlocking:false,resourceTypes:[]}],map:{'1':0,'2':0,'4':0,'8':0,'16':0,'32':0,'64':0}},{shared:[{name:'noopvast-4.0',aliases:null,description:'Redirects to an empty VAST 4.0 XML file.',docs:null,versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,isBlocking:false,resourceTypes:[]}],map:{'1':0,'2':0,'4':0,'8':0,'16':0,'32':0,'64':0}},{shared:[{name:'noopvmap-1.0',aliases:['noop-vmap1.0.xml'],description:'Redirects to an empty VMAP 1.0 XML file.',docs:null,versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,isBlocking:false,resourceTypes:[]},{name:'noop-vmap1.0.xml',aliases:null,description:'Redirects to an empty VMAP 1.0 XML file.',docs:null,versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,isBlocking:false,resourceTypes:['media']}],map:{'1':0,'2':0,'4':0,'8':0,'16':0,'32':0,'64':0,'1024':1,'2048':1,'4096':1,'8192':1}},{shared:[{name:'nowebrtc',aliases:['nowebrtc.js','ubo-nowebrtc.js','ubo-nowebrtc'],description:'Disables WebRTC by overriding `RTCPeerConnection`.',docs:null,versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,isBlocking:false,resourceTypes:[]},{name:'nowebrtc.js',aliases:null,description:'Disables WebRTC by overriding `RTCPeerConnection`.',docs:null,versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,isBlocking:false,resourceTypes:['other']}],map:{'1':0,'2':0,'4':0,'8':0,'16':0,'32':0,'64':0,'1024':1,'2048':1,'4096':1,'8192':1}},{shared:[{name:'outbrain-widget.js',aliases:null,description:null,docs:null,versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,isBlocking:false,resourceTypes:['script']}],map:{'1024':0,'2048':0,'4096':0,'8192':0}},{shared:[{name:'pardot-1.0',aliases:null,description:'Mocks the pd.js file of Salesforce.',docs:null,versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,isBlocking:false,resourceTypes:[]}],map:{'1':0,'2':0,'4':0,'8':0,'16':0,'32':0,'64':0}},{shared:[{name:'prebid-ads',aliases:['prebid-ads.js'],description:'Mocks prebid-ads.js script.',docs:null,versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,isBlocking:false,resourceTypes:[]},{name:'prebid-ads.js',aliases:null,description:'Mocks prebid-ads.js script.',docs:null,versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,isBlocking:false,resourceTypes:['script']}],map:{'1':0,'2':0,'4':0,'8':0,'16':0,'32':0,'64':0,'1024':1,'2048':1,'4096':1,'8192':1}},{shared:[{name:'prebid',aliases:null,description:'Mocks the prebid.js header bidding suit.',docs:null,versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,isBlocking:false,resourceTypes:[]}],map:{'1':0,'2':0,'4':0,'8':0,'16':0,'32':0,'64':0}},{shared:[{name:'prevent-bab',aliases:['nobab.js'],description:'Prevents BlockAdblock script from detecting an ad blocker.',docs:null,versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,isBlocking:false,resourceTypes:[]},{name:'nobab.js',aliases:null,description:'Prevents BlockAdblock script from detecting an ad blocker.',docs:null,versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,isBlocking:false,resourceTypes:['script']}],map:{'1':0,'2':0,'4':0,'8':0,'16':0,'32':0,'64':0,'1024':1,'2048':1,'4096':1,'8192':1}},{shared:[{name:'prevent-bab2',aliases:['nobab2.js'],description:'Prevents BlockAdblock script from detecting an ad blocker.',docs:null,versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,isBlocking:false,resourceTypes:[]},{name:'nobab2.js',aliases:null,description:'Prevents BlockAdblock script from detecting an ad blocker.',docs:null,versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,isBlocking:false,resourceTypes:['script']}],map:{'1':0,'2':0,'4':0,'8':0,'16':0,'32':0,'64':0,'1024':1,'2048':1,'4096':1,'8192':1}},{shared:[{name:'prevent-fab-3.2.0',aliases:['nofab.js'],description:'Mocks FAB script v3.2.0.',docs:null,versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,isBlocking:false,resourceTypes:[]},{name:'nofab.js',aliases:['fuckadblock.js-3.2.0','fuckadblock.js-3.2.0.js'],description:'Mocks FAB script v3.2.0.',docs:null,versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,isBlocking:false,resourceTypes:['script']}],map:{'1':0,'2':0,'4':0,'8':0,'16':0,'32':0,'64':0,'1024':1,'2048':1,'4096':1,'8192':1}},{shared:[{name:'prevent-popads-net',aliases:['popads.js'],description:'Aborts on property write (PopAds, popns), throws reference error with random id.',docs:null,versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,isBlocking:false,resourceTypes:[]},{name:'popads.js',aliases:null,description:'Aborts on property write (PopAds, popns), throws reference error with random id.',docs:null,versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,isBlocking:false,resourceTypes:['script']}],map:{'1':0,'2':0,'4':0,'8':0,'16':0,'32':0,'64':0,'1024':1,'2048':1,'4096':1,'8192':1}},{shared:[{name:'scorecardresearch-beacon',aliases:['scorecardresearch_beacon.js'],description:'Mocks Scorecard Research API.',docs:null,versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,isBlocking:false,resourceTypes:[]},{name:'scorecardresearch_beacon.js',aliases:null,description:'Mocks Scorecard Research API.',docs:null,versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,isBlocking:false,resourceTypes:['script']}],map:{'1':0,'2':0,'4':0,'8':0,'16':0,'32':0,'64':0,'1024':1,'2048':1,'4096':1,'8192':1}},{shared:[{name:'set-popads-dummy',aliases:['popads-dummy.js'],description:'Sets static properties PopAds and popns.',docs:null,versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,isBlocking:false,resourceTypes:[]},{name:'popads-dummy.js',aliases:null,description:'Sets static properties PopAds and popns.',docs:null,versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,isBlocking:false,resourceTypes:['script']}],map:{'1':0,'2':0,'4':0,'8':0,'16':0,'32':0,'64':0,'1024':1,'2048':1,'4096':1,'8192':1}}],map:{'1x1-transparent.gif':0,'1x1.gif':0,'1x1-transparent-gif':0,'2x2-transparent.png':1,'2x2.png':1,'2x2-transparent-png':1,'32x32-transparent.png':2,'32x32.png':2,'32x32-transparent-png':2,'3x2-transparent.png':3,'3x2.png':3,'3x2-transparent-png':3,'amazon-apstag':4,'ubo-amazon_apstag.js':4,'amazon_apstag.js':4,'amazon_ads.js':5,'ampproject_v0.js':6,'ati-smarttag':7,'chartbeat.js':8,'click2load.html':9,'ubo-click2load.html':9,'didomi-loader':10,empty:11,fingerprintjs2:12,'fingerprint2.js':12,fingerprintjs3:13,'fingerprint3.js':13,gemius:14,'google-analytics-ga':15,'ubo-google-analytics_ga.js':15,'google-analytics_ga.js':15,'google-analytics':16,'ubo-google-analytics_analytics.js':16,'google-analytics_analytics.js':16,'googletagmanager-gtm':16,'ubo-googletagmanager_gtm.js':16,'googletagmanager_gtm.js':16,'google-analytics_cx_api.js':17,'google-analytics_inpage_linkid.js':18,'google-ima3':19,'ubo-google-ima.js':19,'google-ima.js':19,'googlesyndication-adsbygoogle':20,'ubo-googlesyndication_adsbygoogle.js':20,'ubo-googlesyndication.com/adsbygoogle.js':20,'googlesyndication_adsbygoogle.js':20,'googlesyndication.com/adsbygoogle.js':20,'googletagservices-gpt':21,'ubo-googletagservices_gpt.js':21,'googletagservices_gpt.js':21,'hd-main.js':22,matomo:23,'metrika-yandex-tag':24,'metrika-yandex-watch':25,'naver-wcslog':26,'no-protected-audience':27,'no-topics':28,noeval:29,'noeval.js':29,'silent-noeval.js':29,'ubo-noeval.js':29,'ubo-silent-noeval.js':29,'ubo-noeval':29,'ubo-silent-noeval':29,'noop-0.5s.mp3':30,noopcss:31,'noop.css':31,'blank-css':31,noopframe:32,'noop.html':32,'blank-html':32,noopjs:33,'noop.js':33,'blank-js':33,noopjson:34,'noop.json':34,'noopmp3-0.1s':35,'noop-0.1s.mp3':35,'blank-mp3':35,'noopmp4-1s':36,'noop-1s.mp4':36,'blank-mp4':36,nooptext:37,'noop.txt':37,'blank-text':37,'noopvast-2.0':38,'noopvast-3.0':39,'noopvast-4.0':40,'noopvmap-1.0':41,'noop-vmap1.0.xml':41,nowebrtc:42,'nowebrtc.js':42,'ubo-nowebrtc.js':42,'ubo-nowebrtc':42,'outbrain-widget.js':43,'pardot-1.0':44,'prebid-ads':45,'prebid-ads.js':45,prebid:46,'prevent-bab':47,'nobab.js':47,'prevent-bab2':48,'nobab2.js':48,'prevent-fab-3.2.0':49,'nofab.js':49,'fuckadblock.js-3.2.0':49,'fuckadblock.js-3.2.0.js':49,'prevent-popads-net':50,'popads.js':50,'scorecardresearch-beacon':51,'scorecardresearch_beacon.js':51,'set-popads-dummy':52,'popads-dummy.js':52}};
const scriptletsCompatibilityTableData = {shared:[{shared:[{name:'abort-current-inline-script',aliases:['abort-current-script.js','ubo-abort-current-script.js','acs.js','ubo-acs.js','ubo-abort-current-script','ubo-acs','abort-current-inline-script.js','ubo-abort-current-inline-script.js','acis.js','ubo-acis.js','ubo-abort-current-inline-script','ubo-acis','abp-abort-current-inline-script'],description:null,docs:'https://github.com/AdguardTeam/Scriptlets/blob/master/wiki/about-scriptlets.md#abort-current-inline-script',versionAdded:'1.0.4',versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,parameters:[{name:'property',required:true,description:null,pattern:null,'default':null,debug:false},{name:'search',required:false,description:null,pattern:null,'default':null,debug:false}]},{name:'abort-current-script.js',aliases:['acs.js','abort-current-inline-script.js','acis.js'],description:null,docs:'https://github.com/gorhill/uBlock/wiki/Resources-Library#abort-current-scriptjs-',versionAdded:'1.37.0',versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,parameters:[{name:'property',required:true,description:null,pattern:null,'default':null,debug:false},{name:'search',required:false,description:null,pattern:null,'default':null,debug:false}]},{name:'abort-current-inline-script',aliases:null,description:null,docs:'https://help.adblockplus.org/hc/en-us/articles/1500002338501-Snippet-filters-tutorial#snippets-ref',versionAdded:'3.4.3',versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,parameters:[{name:'api',required:true,description:null,pattern:null,'default':null,debug:false},{name:'search',required:false,description:null,pattern:null,'default':null,debug:false}]}],map:{'1':0,'2':0,'4':0,'8':0,'16':0,'32':0,'64':0,'1024':1,'2048':1,'4096':1,'8192':1,'16384':2,'32768':2,'65536':2,'131072':2}},{shared:[{name:'abort-on-property-read',aliases:['abort-on-property-read.js','ubo-abort-on-property-read.js','aopr.js','ubo-aopr.js','ubo-abort-on-property-read','ubo-aopr','abp-abort-on-property-read'],description:null,docs:'https://github.com/AdguardTeam/Scriptlets/blob/master/wiki/about-scriptlets.md#abort-on-property-read',versionAdded:'1.0.4',versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,parameters:[{name:'property',required:true,description:null,pattern:null,'default':null,debug:false}]},{name:'abort-on-property-read.js',aliases:['aopr.js'],description:null,docs:'https://github.com/gorhill/uBlock/wiki/Resources-Library#abort-on-property-readjs-',versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,parameters:[{name:'property',required:true,description:null,pattern:null,'default':null,debug:false}]},{name:'abort-on-property-read',aliases:null,description:null,docs:'https://help.adblockplus.org/hc/en-us/articles/1500002338501-Snippet-filters-tutorial#snippets-ref',versionAdded:'3.4.1',versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,parameters:[{name:'property',required:true,description:null,pattern:null,'default':null,debug:false},{name:'setConfigurable',required:false,description:null,pattern:null,'default':null,debug:false}]}],map:{'1':0,'2':0,'4':0,'8':0,'16':0,'32':0,'64':0,'1024':1,'2048':1,'4096':1,'8192':1,'16384':2,'32768':2,'65536':2,'131072':2}},{shared:[{name:'abort-on-property-write',aliases:['abort-on-property-write.js','ubo-abort-on-property-write.js','aopw.js','ubo-aopw.js','ubo-abort-on-property-write','ubo-aopw','abp-abort-on-property-write'],description:null,docs:'https://github.com/AdguardTeam/Scriptlets/blob/master/wiki/about-scriptlets.md#abort-on-property-write',versionAdded:'1.0.4',versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,parameters:[{name:'property',required:true,description:null,pattern:null,'default':null,debug:false}]},{name:'abort-on-property-write.js',aliases:['aopw.js'],description:null,docs:'https://github.com/gorhill/uBlock/wiki/Resources-Library#abort-on-property-writejs-',versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,parameters:[{name:'property',required:true,description:null,pattern:null,'default':null,debug:false}]},{name:'abort-on-property-write',aliases:null,description:null,docs:'https://help.adblockplus.org/hc/en-us/articles/1500002338501-Snippet-filters-tutorial#snippets-ref',versionAdded:'3.4.3',versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,parameters:[{name:'property',required:true,description:null,pattern:null,'default':null,debug:false},{name:'setConfigurable',required:false,description:null,pattern:null,'default':null,debug:false}]}],map:{'1':0,'2':0,'4':0,'8':0,'16':0,'32':0,'64':0,'1024':1,'2048':1,'4096':1,'8192':1,'16384':2,'32768':2,'65536':2,'131072':2}},{shared:[{name:'abort-on-stack-trace',aliases:['abort-on-stack-trace.js','ubo-abort-on-stack-trace.js','aost.js','ubo-aost.js','ubo-abort-on-stack-trace','ubo-aost','abp-abort-on-stack-trace'],description:null,docs:'https://github.com/AdguardTeam/Scriptlets/blob/master/wiki/about-scriptlets.md#abort-on-stack-trace',versionAdded:'1.5.0',versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,parameters:[{name:'property',required:true,description:null,pattern:null,'default':null,debug:false},{name:'stack',required:true,description:null,pattern:null,'default':null,debug:false}]},{name:'abort-on-stack-trace.js',aliases:['aost.js'],description:null,docs:'https://github.com/gorhill/uBlock/wiki/Resources-Library#abort-on-stack-tracejs-',versionAdded:'1.29.3rc9',versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,parameters:[{name:'property',required:true,description:null,pattern:null,'default':null,debug:false},{name:'stack',required:true,description:null,pattern:null,'default':null,debug:false}]}],map:{'1':0,'2':0,'4':0,'8':0,'16':0,'32':0,'64':0,'1024':1,'2048':1,'4096':1,'8192':1}},{shared:[{name:'adjust-setInterval',aliases:['nano-setInterval-booster.js','ubo-nano-setInterval-booster.js','nano-sib.js','ubo-nano-sib.js','adjust-setInterval.js','ubo-adjust-setInterval.js','ubo-nano-setInterval-booster','ubo-nano-sib','ubo-adjust-setInterval'],description:null,docs:'https://github.com/AdguardTeam/Scriptlets/blob/master/wiki/about-scriptlets.md#adjust-setInterval',versionAdded:'1.0.4',versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,parameters:[{name:'matchCallback',required:false,description:null,pattern:null,'default':null,debug:false},{name:'matchDelay',required:false,description:null,pattern:null,'default':null,debug:false},{name:'boost',required:false,description:null,pattern:null,'default':null,debug:false}]},{name:'adjust-setInterval.js',aliases:['nano-setInterval-booster.js','nano-sib.js'],description:null,docs:'https://github.com/gorhill/uBlock/wiki/Resources-Library#adjust-setIntervaljs-',versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,parameters:[{name:'matchCallback',required:false,description:null,pattern:null,'default':null,debug:false},{name:'matchDelay',required:false,description:null,pattern:null,'default':null,debug:false},{name:'boost',required:false,description:null,pattern:null,'default':null,debug:false}]}],map:{'1':0,'2':0,'4':0,'8':0,'16':0,'32':0,'64':0,'1024':1,'2048':1,'4096':1,'8192':1}},{shared:[{name:'adjust-setTimeout',aliases:['adjust-setTimeout.js','ubo-adjust-setTimeout.js','nano-setTimeout-booster.js','ubo-nano-setTimeout-booster.js','nano-stb.js','ubo-nano-stb.js','ubo-adjust-setTimeout','ubo-nano-setTimeout-booster','ubo-nano-stb'],description:null,docs:'https://github.com/AdguardTeam/Scriptlets/blob/master/wiki/about-scriptlets.md#adjust-setTimeout',versionAdded:'1.0.4',versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,parameters:[{name:'matchCallback',required:false,description:null,pattern:null,'default':null,debug:false},{name:'matchDelay',required:false,description:null,pattern:null,'default':null,debug:false},{name:'boost',required:false,description:null,pattern:null,'default':null,debug:false}]},{name:'adjust-setTimeout.js',aliases:['nano-setTimeout-booster.js','nano-stb.js'],description:null,docs:'https://github.com/gorhill/uBlock/wiki/Resources-Library#adjust-setTimeoutjs-',versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,parameters:[{name:'matchCallback',required:false,description:null,pattern:null,'default':null,debug:false},{name:'matchDelay',required:false,description:null,pattern:null,'default':null,debug:false},{name:'boost',required:false,description:null,pattern:null,'default':null,debug:false}]}],map:{'1':0,'2':0,'4':0,'8':0,'16':0,'32':0,'64':0,'1024':1,'2048':1,'4096':1,'8192':1}},{shared:[{name:'amazon-apstag',aliases:['ubo-amazon_apstag.js','amazon_apstag.js'],description:null,docs:'https://github.com/AdguardTeam/Scriptlets/blob/master/wiki/about-scriptlets.md#amazon-apstag',versionAdded:'1.10.25',versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null}],map:{'1':0,'2':0,'4':0,'8':0,'16':0,'32':0,'64':0}},{shared:[{name:'call-nothrow',aliases:['call-nothrow.js','ubo-call-nothrow.js','ubo-call-nothrow'],description:null,docs:'https://github.com/AdguardTeam/Scriptlets/blob/master/wiki/about-scriptlets.md#call-nothrow',versionAdded:'1.10.1',versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,parameters:[{name:'functionName',required:true,description:null,pattern:null,'default':null,debug:false}]},{name:'call-nothrow.js',aliases:null,description:null,docs:'https://github.com/gorhill/uBlock/wiki/Resources-Library#call-nothrowjs-',versionAdded:'1.48.1b0',versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,parameters:[{name:'functionName',required:true,description:null,pattern:null,'default':null,debug:false}]}],map:{'1':0,'2':0,'4':0,'8':0,'16':0,'32':0,'64':0,'1024':1,'2048':1,'4096':1,'8192':1}},{shared:[{name:'close-window',aliases:['window-close-if.js','ubo-window-close-if.js','ubo-window-close-if','close-window.js','ubo-close-window.js','ubo-close-window'],description:null,docs:'https://github.com/AdguardTeam/Scriptlets/blob/master/wiki/about-scriptlets.md#close-window',versionAdded:'1.5.0',versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,parameters:[{name:'path',required:false,description:null,pattern:null,'default':null,debug:false}]},{name:'close-window.js',aliases:['window-close-if.js'],description:null,docs:'https://github.com/gorhill/uBlock/wiki/Resources-Library#close-windowjs-',versionAdded:'1.39.3b10',versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,parameters:[{name:'path',required:false,description:null,pattern:null,'default':null,debug:false}]}],map:{'1':0,'2':0,'4':0,'8':0,'16':0,'32':0,'64':0,'1024':1,'2048':1,'4096':1,'8192':1}},{shared:[{name:'debug-current-inline-script',aliases:null,description:null,docs:'https://github.com/AdguardTeam/Scriptlets/blob/master/wiki/about-scriptlets.md#debug-current-inline-script',versionAdded:'1.0.4',versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,parameters:[{name:'property',required:true,description:null,pattern:null,'default':null,debug:false},{name:'search',required:false,description:null,pattern:null,'default':null,debug:false}]}],map:{'1':0,'2':0,'4':0,'8':0,'16':0,'32':0,'64':0}},{shared:[{name:'debug-on-property-read',aliases:null,description:null,docs:'https://github.com/AdguardTeam/Scriptlets/blob/master/wiki/about-scriptlets.md#debug-on-property-read',versionAdded:'1.0.4',versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,parameters:[{name:'property',required:true,description:null,pattern:null,'default':null,debug:false}]}],map:{'1':0,'2':0,'4':0,'8':0,'16':0,'32':0,'64':0}},{shared:[{name:'debug-on-property-write',aliases:null,description:null,docs:'https://github.com/AdguardTeam/Scriptlets/blob/master/wiki/about-scriptlets.md#debug-on-property-write',versionAdded:'1.0.4',versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,parameters:[{name:'property',required:true,description:null,pattern:null,'default':null,debug:false}]}],map:{'1':0,'2':0,'4':0,'8':0,'16':0,'32':0,'64':0}},{shared:[{name:'didomi-loader',aliases:null,description:null,docs:'https://github.com/AdguardTeam/Scriptlets/blob/master/wiki/about-scriptlets.md#didomi-loader',versionAdded:'1.10.25',versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null}],map:{'1':0,'2':0,'4':0,'8':0,'16':0,'32':0,'64':0}},{shared:[{name:'dir-string',aliases:null,description:null,docs:'https://github.com/AdguardTeam/Scriptlets/blob/master/wiki/about-scriptlets.md#dir-string',versionAdded:'1.0.4',versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,parameters:[{name:'times',required:false,description:null,pattern:null,'default':null,debug:false}]}],map:{'1':0,'2':0,'4':0,'8':0,'16':0,'32':0,'64':0}},{shared:[{name:'disable-newtab-links',aliases:['disable-newtab-links.js','ubo-disable-newtab-links.js','ubo-disable-newtab-links'],description:null,docs:'https://github.com/AdguardTeam/Scriptlets/blob/master/wiki/about-scriptlets.md#disable-newtab-links',versionAdded:'1.0.4',versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null},{name:'disable-newtab-links.js',aliases:null,description:null,docs:'https://github.com/gorhill/uBlock/wiki/Resources-Library#disable-newtab-linksjs-',versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null}],map:{'1':0,'2':0,'4':0,'8':0,'16':0,'32':0,'64':0,'1024':1,'2048':1,'4096':1,'8192':1}},{shared:[{name:'evaldata-prune',aliases:['evaldata-prune.js','ubo-evaldata-prune.js','ubo-evaldata-prune'],description:null,docs:'https://github.com/AdguardTeam/Scriptlets/blob/master/wiki/about-scriptlets.md#evaldata-prune',versionAdded:'1.9.37',versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,parameters:[{name:'propsToRemove',required:false,description:null,pattern:null,'default':null,debug:false},{name:'obligatoryProps',required:false,description:null,pattern:null,'default':null,debug:false},{name:'stack',required:false,description:null,pattern:null,'default':null,debug:false}]},{name:'evaldata-prune.js',aliases:null,description:null,docs:'https://github.com/gorhill/uBlock/wiki/Resources-Library#evaldata-prunejs-',versionAdded:'1.49.3rc15',versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,parameters:[{name:'propsToRemove',required:false,description:null,pattern:null,'default':null,debug:false},{name:'obligatoryProps',required:false,description:null,pattern:null,'default':null,debug:false},{name:'stack',required:false,description:null,pattern:null,'default':null,debug:false}]}],map:{'1':0,'2':0,'4':0,'8':0,'16':0,'32':0,'64':0,'1024':1,'2048':1,'4096':1,'8192':1}},{shared:[{name:'fingerprintjs2',aliases:['ubo-fingerprint2.js','fingerprint2.js'],description:null,docs:'https://github.com/AdguardTeam/Scriptlets/blob/master/wiki/about-scriptlets.md#fingerprintjs2',versionAdded:'1.10.25',versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null}],map:{'1':0,'2':0,'4':0,'8':0,'16':0,'32':0,'64':0}},{shared:[{name:'fingerprintjs3',aliases:['ubo-fingerprint3.js','fingerprint3.js'],description:null,docs:'https://github.com/AdguardTeam/Scriptlets/blob/master/wiki/about-scriptlets.md#fingerprintjs3',versionAdded:'1.10.25',versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null}],map:{'1':0,'2':0,'4':0,'8':0,'16':0,'32':0,'64':0}},{shared:[{name:'gemius',aliases:null,description:null,docs:'https://github.com/AdguardTeam/Scriptlets/blob/master/wiki/about-scriptlets.md#gemius',versionAdded:'1.10.25',versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null}],map:{'1':0,'2':0,'4':0,'8':0,'16':0,'32':0,'64':0}},{shared:[{name:'google-analytics-ga',aliases:['ubo-google-analytics_ga.js','google-analytics_ga.js'],description:null,docs:'https://github.com/AdguardTeam/Scriptlets/blob/master/wiki/about-scriptlets.md#google-analytics-ga',versionAdded:'1.10.25',versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null}],map:{'1':0,'2':0,'4':0,'8':0,'16':0,'32':0,'64':0}},{shared:[{name:'google-analytics',aliases:['ubo-google-analytics_analytics.js','google-analytics_analytics.js','googletagmanager-gtm','ubo-googletagmanager_gtm.js','googletagmanager_gtm.js'],description:null,docs:'https://github.com/AdguardTeam/Scriptlets/blob/master/wiki/about-scriptlets.md#google-analytics',versionAdded:'1.10.25',versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null}],map:{'1':0,'2':0,'4':0,'8':0,'16':0,'32':0,'64':0}},{shared:[{name:'google-ima3',aliases:['ubo-google-ima.js','google-ima.js'],description:null,docs:'https://github.com/AdguardTeam/Scriptlets/blob/master/wiki/about-scriptlets.md#google-ima3',versionAdded:'1.10.25',versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null}],map:{'1':0,'2':0,'4':0,'8':0,'16':0,'32':0,'64':0}},{shared:[{name:'googlesyndication-adsbygoogle',aliases:['ubo-googlesyndication_adsbygoogle.js','googlesyndication_adsbygoogle.js'],description:null,docs:'https://github.com/AdguardTeam/Scriptlets/blob/master/wiki/about-scriptlets.md#googlesyndication-adsbygoogle',versionAdded:'1.10.25',versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null}],map:{'1':0,'2':0,'4':0,'8':0,'16':0,'32':0,'64':0}},{shared:[{name:'googletagservices-gpt',aliases:['ubo-googletagservices_gpt.js','googletagservices_gpt.js'],description:null,docs:'https://github.com/AdguardTeam/Scriptlets/blob/master/wiki/about-scriptlets.md#googletagservices-gpt',versionAdded:'1.10.25',versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null}],map:{'1':0,'2':0,'4':0,'8':0,'16':0,'32':0,'64':0}},{shared:[{name:'hide-in-shadow-dom',aliases:null,description:null,docs:'https://github.com/AdguardTeam/Scriptlets/blob/master/wiki/about-scriptlets.md#hide-in-shadow-dom',versionAdded:'1.3.0',versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,parameters:[{name:'selector',required:true,description:null,pattern:null,'default':null,debug:false},{name:'baseSelector',required:false,description:null,pattern:null,'default':null,debug:false}]}],map:{'1':0,'2':0,'4':0,'8':0,'16':0,'32':0,'64':0}},{shared:[{name:'href-sanitizer',aliases:['href-sanitizer.js','ubo-href-sanitizer.js','ubo-href-sanitizer'],description:null,docs:'https://github.com/AdguardTeam/Scriptlets/blob/master/wiki/about-scriptlets.md#href-sanitizer',versionAdded:'1.10.25',versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,parameters:[{name:'selector',required:true,description:null,pattern:null,'default':null,debug:false},{name:'attribute',required:false,description:null,pattern:null,'default':null,debug:false}]},{name:'href-sanitizer.js',aliases:null,description:null,docs:'https://github.com/gorhill/uBlock/wiki/Resources-Library#href-sanitizerjs-',versionAdded:'1.47.5b4',versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,parameters:[{name:'selector',required:true,description:null,pattern:null,'default':null,debug:false},{name:'attribute',required:false,description:null,pattern:null,'default':null,debug:false}]}],map:{'1':0,'2':0,'4':0,'8':0,'16':0,'32':0,'64':0,'1024':1,'2048':1,'4096':1,'8192':1}},{shared:[{name:'inject-css-in-shadow-dom',aliases:null,description:null,docs:'https://github.com/AdguardTeam/Scriptlets/blob/master/wiki/about-scriptlets.md#inject-css-in-shadow-dom',versionAdded:'1.8.2',versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,parameters:[{name:'cssRule',required:true,description:null,pattern:null,'default':null,debug:false},{name:'hostSelector',required:false,description:null,pattern:null,'default':null,debug:false}]}],map:{'1':0,'2':0,'4':0,'8':0,'16':0,'32':0,'64':0}},{shared:[{name:'json-prune-fetch-response',aliases:['json-prune-fetch-response.js','ubo-json-prune-fetch-response.js','ubo-json-prune-fetch-response'],description:null,docs:'https://github.com/AdguardTeam/Scriptlets/blob/master/wiki/about-scriptlets.md#json-prune-fetch-response',versionAdded:'1.10.25',versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,parameters:[{name:'propsToRemove',required:false,description:null,pattern:null,'default':null,debug:false},{name:'obligatoryProps',required:false,description:null,pattern:null,'default':null,debug:false},{name:'propsToMatch',required:false,description:null,pattern:null,'default':null,debug:false},{name:'stack',required:false,description:null,pattern:null,'default':null,debug:false}]},{name:'json-prune-fetch-response.js',aliases:null,description:null,docs:'https://github.com/gorhill/uBlock/wiki/Resources-Library#json-prune-fetch-responsejs-',versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,parameters:[{name:'propsToRemove',required:false,description:null,pattern:null,'default':null,debug:false},{name:'obligatoryProps',required:false,description:null,pattern:null,'default':null,debug:false},{name:'propsToMatch',required:false,description:null,pattern:null,'default':null,debug:false},{name:'stack',required:false,description:null,pattern:null,'default':null,debug:false}]}],map:{'1':0,'2':0,'4':0,'8':0,'16':0,'32':0,'64':0,'1024':1,'2048':1,'4096':1,'8192':1}},{shared:[{name:'json-prune-xhr-response',aliases:['json-prune-xhr-response.js','ubo-json-prune-xhr-response.js','ubo-json-prune-xhr-response'],description:null,docs:'https://github.com/AdguardTeam/Scriptlets/blob/master/wiki/about-scriptlets.md#json-prune-xhr-response',versionAdded:'1.10.25',versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,parameters:[{name:'propsToRemove',required:false,description:null,pattern:null,'default':null,debug:false},{name:'obligatoryProps',required:false,description:null,pattern:null,'default':null,debug:false},{name:'propsToMatch',required:false,description:null,pattern:null,'default':null,debug:false},{name:'stack',required:false,description:null,pattern:null,'default':null,debug:false}]},{name:'json-prune-xhr-response.js',aliases:null,description:null,docs:'https://github.com/gorhill/uBlock/wiki/Resources-Library#json-prune-xhr-responsejs-',versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,parameters:[{name:'propsToRemove',required:false,description:null,pattern:null,'default':null,debug:false},{name:'obligatoryProps',required:false,description:null,pattern:null,'default':null,debug:false},{name:'propsToMatch',required:false,description:null,pattern:null,'default':null,debug:false},{name:'stack',required:false,description:null,pattern:null,'default':null,debug:false}]}],map:{'1':0,'2':0,'4':0,'8':0,'16':0,'32':0,'64':0,'1024':1,'2048':1,'4096':1,'8192':1}},{shared:[{name:'json-prune',aliases:['json-prune.js','ubo-json-prune.js','ubo-json-prune','abp-json-prune'],description:null,docs:'https://github.com/AdguardTeam/Scriptlets/blob/master/wiki/about-scriptlets.md#json-prune',versionAdded:'1.1.0',versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,parameters:[{name:'propsToRemove',required:false,description:null,pattern:null,'default':null,debug:false},{name:'obligatoryProps',required:false,description:null,pattern:null,'default':null,debug:false},{name:'stack',required:false,description:null,pattern:null,'default':null,debug:false}]},{name:'json-prune.js',aliases:null,description:null,docs:'https://github.com/gorhill/uBlock/wiki/Resources-Library#json-prunejs-',versionAdded:'1.23.0',versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,parameters:[{name:'propsToRemove',required:false,description:null,pattern:null,'default':null,debug:false},{name:'obligatoryProps',required:false,description:null,pattern:null,'default':null,debug:false},{name:'stack',required:false,description:null,pattern:null,'default':null,debug:false}]},{name:'json-prune',aliases:null,description:null,docs:'https://help.adblockplus.org/hc/en-us/articles/1500002338501-Snippet-filters-tutorial#snippets-ref',versionAdded:'3.9.0',versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,parameters:[{name:'rawPrunePaths',required:true,description:null,pattern:null,'default':null,debug:false},{name:'rawNeedlePaths',required:false,description:null,pattern:null,'default':null,debug:false}]}],map:{'1':0,'2':0,'4':0,'8':0,'16':0,'32':0,'64':0,'1024':1,'2048':1,'4096':1,'8192':1,'16384':2,'32768':2,'65536':2,'131072':2}},{shared:[{name:'log-addEventListener',aliases:['addEventListener-logger.js','ubo-addEventListener-logger.js','aell.js','ubo-aell.js','ubo-addEventListener-logger','ubo-aell'],description:null,docs:'https://github.com/AdguardTeam/Scriptlets/blob/master/wiki/about-scriptlets.md#log-addEventListener',versionAdded:'1.0.4',versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null}],map:{'1':0,'2':0,'4':0,'8':0,'16':0,'32':0,'64':0}},{shared:[{name:'log-eval',aliases:null,description:null,docs:'https://github.com/AdguardTeam/Scriptlets/blob/master/wiki/about-scriptlets.md#log-eval',versionAdded:'1.0.4',versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null}],map:{'1':0,'2':0,'4':0,'8':0,'16':0,'32':0,'64':0}},{shared:[{name:'log-on-stack-trace',aliases:null,description:null,docs:'https://github.com/AdguardTeam/Scriptlets/blob/master/wiki/about-scriptlets.md#log-on-stack-trace',versionAdded:'1.5.0',versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,parameters:[{name:'property',required:true,description:null,pattern:null,'default':null,debug:false}]}],map:{'1':0,'2':0,'4':0,'8':0,'16':0,'32':0,'64':0}},{shared:[{name:'log',aliases:['abp-log'],description:null,docs:'https://github.com/AdguardTeam/Scriptlets/blob/master/wiki/about-scriptlets.md#log',versionAdded:'1.0.4',versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,parameters:[{name:'arguments',required:false,description:null,pattern:null,'default':null,debug:false}]}],map:{'1':0,'2':0,'4':0,'8':0,'16':0,'32':0,'64':0}},{shared:[{name:'m3u-prune',aliases:['m3u-prune.js','ubo-m3u-prune.js','ubo-m3u-prune'],description:null,docs:'https://github.com/AdguardTeam/Scriptlets/blob/master/wiki/about-scriptlets.md#m3u-prune',versionAdded:'1.9.1',versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,parameters:[{name:'propsToRemove',required:false,description:null,pattern:null,'default':null,debug:false},{name:'urlToMatch',required:false,description:null,pattern:null,'default':null,debug:false}]},{name:'m3u-prune.js',aliases:null,description:null,docs:'https://github.com/gorhill/uBlock/wiki/Resources-Library#m3u-prunejs-',versionAdded:'1.44.5b6',versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,parameters:[{name:'propsToRemove',required:false,description:null,pattern:null,'default':null,debug:false},{name:'urlToMatch',required:false,description:null,pattern:null,'default':null,debug:false}]}],map:{'1':0,'2':0,'4':0,'8':0,'16':0,'32':0,'64':0,'1024':1,'2048':1,'4096':1,'8192':1}},{shared:[{name:'matomo',aliases:null,description:null,docs:'https://github.com/AdguardTeam/Scriptlets/blob/master/wiki/about-scriptlets.md#matomo',versionAdded:'1.10.25',versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null}],map:{'1':0,'2':0,'4':0,'8':0,'16':0,'32':0,'64':0}},{shared:[{name:'metrika-yandex-tag',aliases:null,description:null,docs:'https://github.com/AdguardTeam/Scriptlets/blob/master/wiki/about-scriptlets.md#metrika-yandex-tag',versionAdded:'1.10.25',versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null}],map:{'1':0,'2':0,'4':0,'8':0,'16':0,'32':0,'64':0}},{shared:[{name:'metrika-yandex-watch',aliases:null,description:null,docs:'https://github.com/AdguardTeam/Scriptlets/blob/master/wiki/about-scriptlets.md#metrika-yandex-watch',versionAdded:'1.10.25',versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null}],map:{'1':0,'2':0,'4':0,'8':0,'16':0,'32':0,'64':0}},{shared:[{name:'naver-wcslog',aliases:null,description:null,docs:'https://github.com/AdguardTeam/Scriptlets/blob/master/wiki/about-scriptlets.md#naver-wcslog',versionAdded:'1.10.25',versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null}],map:{'1':0,'2':0,'4':0,'8':0,'16':0,'32':0,'64':0}},{shared:[{name:'no-protected-audience',aliases:null,description:null,docs:'https://github.com/AdguardTeam/Scriptlets/blob/master/wiki/about-scriptlets.md#no-protected-audience',versionAdded:'1.10.25',versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null}],map:{'1':0,'2':0,'4':0,'8':0,'16':0,'32':0,'64':0}},{shared:[{name:'no-topics',aliases:null,description:null,docs:'https://github.com/AdguardTeam/Scriptlets/blob/master/wiki/about-scriptlets.md#no-topics',versionAdded:'1.6.18',versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null}],map:{'1':0,'2':0,'4':0,'8':0,'16':0,'32':0,'64':0}},{shared:[{name:'noeval',aliases:['noeval.js','silent-noeval.js','ubo-noeval.js','ubo-silent-noeval.js','ubo-noeval','ubo-silent-noeval'],description:null,docs:'https://github.com/AdguardTeam/Scriptlets/blob/master/wiki/about-scriptlets.md#noeval',versionAdded:'1.0.4',versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null}],map:{'1':0,'2':0,'4':0,'8':0,'16':0,'32':0,'64':0}},{shared:[{name:'nowebrtc',aliases:['nowebrtc.js','ubo-nowebrtc.js','ubo-nowebrtc'],description:null,docs:'https://github.com/AdguardTeam/Scriptlets/blob/master/wiki/about-scriptlets.md#nowebrtc',versionAdded:'1.0.4',versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null},{name:'nowebrtc.js',aliases:null,description:null,docs:'https://github.com/gorhill/uBlock/wiki/Resources-Library#nowebrtcjs-',versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null}],map:{'1':0,'2':0,'4':0,'8':0,'16':0,'32':0,'64':0,'1024':1,'2048':1,'4096':1,'8192':1}},{shared:[{name:'pardot-1.0',aliases:null,description:null,docs:'https://github.com/AdguardTeam/Scriptlets/blob/master/wiki/about-scriptlets.md#pardot-1.0',versionAdded:'1.10.25',versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null}],map:{'1':0,'2':0,'4':0,'8':0,'16':0,'32':0,'64':0}},{shared:[{name:'prebid',aliases:null,description:null,docs:'https://github.com/AdguardTeam/Scriptlets/blob/master/wiki/about-scriptlets.md#prebid',versionAdded:'1.10.25',versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null}],map:{'1':0,'2':0,'4':0,'8':0,'16':0,'32':0,'64':0}},{shared:[{name:'prevent-addEventListener',aliases:['addEventListener-defuser.js','ubo-addEventListener-defuser.js','aeld.js','ubo-aeld.js','ubo-addEventListener-defuser','ubo-aeld','abp-prevent-listener'],description:null,docs:'https://github.com/AdguardTeam/Scriptlets/blob/master/wiki/about-scriptlets.md#prevent-addEventListener',versionAdded:'1.0.4',versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,parameters:[{name:'typeSearch',required:false,description:null,pattern:null,'default':null,debug:false},{name:'listenerSearch',required:false,description:null,pattern:null,'default':null,debug:false}]},{name:'addEventListener-defuser.js',aliases:['aeld.js','prevent-addEventListener.js'],description:null,docs:'https://github.com/gorhill/uBlock/wiki/Resources-Library#addEventListener-defuserjs-',versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,parameters:[{name:'typeSearch',required:false,description:null,pattern:null,'default':null,debug:false},{name:'listenerSearch',required:false,description:null,pattern:null,'default':null,debug:false}]},{name:'prevent-listener',aliases:null,description:null,docs:'https://help.adblockplus.org/hc/en-us/articles/1500002338501-Snippet-filters-tutorial#snippets-ref',versionAdded:'3.11.2',versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,parameters:[{name:'type',required:true,description:null,pattern:null,'default':null,debug:false},{name:'handler',required:false,description:null,pattern:null,'default':null,debug:false},{name:'selector',required:false,description:null,pattern:null,'default':null,debug:false}]}],map:{'1':0,'2':0,'4':0,'8':0,'16':0,'32':0,'64':0,'1024':1,'2048':1,'4096':1,'8192':1,'16384':2,'32768':2,'65536':2,'131072':2}},{shared:[{name:'prevent-adfly',aliases:['adfly-defuser.js','ubo-adfly-defuser.js','ubo-adfly-defuser'],description:null,docs:'https://github.com/AdguardTeam/Scriptlets/blob/master/wiki/about-scriptlets.md#prevent-adfly',versionAdded:'1.0.4',versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null}],map:{'1':0,'2':0,'4':0,'8':0,'16':0,'32':0,'64':0}},{shared:[{name:'prevent-bab',aliases:null,description:null,docs:'https://github.com/AdguardTeam/Scriptlets/blob/master/wiki/about-scriptlets.md#prevent-bab',versionAdded:'1.0.4',versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null}],map:{'1':0,'2':0,'4':0,'8':0,'16':0,'32':0,'64':0}},{shared:[{name:'prevent-element-src-loading',aliases:null,description:null,docs:'https://github.com/AdguardTeam/Scriptlets/blob/master/wiki/about-scriptlets.md#prevent-element-src-loading',versionAdded:'1.6.2',versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,parameters:[{name:'tagName',required:true,description:null,pattern:null,'default':null,debug:false},{name:'match',required:true,description:null,pattern:null,'default':null,debug:false}]}],map:{'1':0,'2':0,'4':0,'8':0,'16':0,'32':0,'64':0}},{shared:[{name:'prevent-eval-if',aliases:['noeval-if.js','ubo-noeval-if.js','ubo-noeval-if'],description:null,docs:'https://github.com/AdguardTeam/Scriptlets/blob/master/wiki/about-scriptlets.md#prevent-eval-if',versionAdded:'1.0.4',versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,parameters:[{name:'search',required:false,description:null,pattern:null,'default':null,debug:false}]},{name:'noeval-if.js',aliases:['prevent-eval-if.js'],description:null,docs:'https://github.com/gorhill/uBlock/wiki/Resources-Library#noeval-ifjs-',versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,parameters:[{name:'search',required:false,description:null,pattern:null,'default':null,debug:false}]}],map:{'1':0,'2':0,'4':0,'8':0,'16':0,'32':0,'64':0,'1024':1,'2048':1,'4096':1,'8192':1}},{shared:[{name:'prevent-fab-3.2.0',aliases:['nofab.js','ubo-nofab.js','fuckadblock.js-3.2.0','ubo-fuckadblock.js-3.2.0','ubo-nofab'],description:null,docs:'https://github.com/AdguardTeam/Scriptlets/blob/master/wiki/about-scriptlets.md#prevent-fab-3.2.0',versionAdded:'1.0.4',versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null}],map:{'1':0,'2':0,'4':0,'8':0,'16':0,'32':0,'64':0}},{shared:[{name:'prevent-fetch',aliases:['prevent-fetch.js','no-fetch-if.js','ubo-no-fetch-if.js','ubo-no-fetch-if'],description:null,docs:'https://github.com/AdguardTeam/Scriptlets/blob/master/wiki/about-scriptlets.md#prevent-fetch',versionAdded:'1.3.18',versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,parameters:[{name:'propsToMatch',required:false,description:null,pattern:null,'default':null,debug:false},{name:'responseBody',required:false,description:null,pattern:null,'default':null,debug:false},{name:'responseType',required:false,description:null,pattern:null,'default':null,debug:false}]},{name:'prevent-fetch.js',aliases:['no-fetch-if.js'],description:null,docs:'https://github.com/gorhill/uBlock/wiki/Resources-Library#prevent-fetchjs-',versionAdded:'1.31.3b9',versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,parameters:[{name:'propsToMatch',required:false,description:null,pattern:null,'default':null,debug:false},{name:'responseBody',required:false,description:null,pattern:null,'default':null,debug:false},{name:'responseType',required:false,description:null,pattern:null,'default':null,debug:false}]}],map:{'1':0,'2':0,'4':0,'8':0,'16':0,'32':0,'64':0,'1024':1,'2048':1,'4096':1,'8192':1}},{shared:[{name:'prevent-popads-net',aliases:['popads.net.js','ubo-popads.net.js','ubo-popads.net'],description:null,docs:'https://github.com/AdguardTeam/Scriptlets/blob/master/wiki/about-scriptlets.md#prevent-popads-net',versionAdded:'1.0.4',versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null}],map:{'1':0,'2':0,'4':0,'8':0,'16':0,'32':0,'64':0}},{shared:[{name:'prevent-refresh',aliases:['prevent-refresh.js','refresh-defuser.js','refresh-defuser','ubo-prevent-refresh.js','ubo-prevent-refresh','ubo-refresh-defuser.js','ubo-refresh-defuser'],description:null,docs:'https://github.com/AdguardTeam/Scriptlets/blob/master/wiki/about-scriptlets.md#prevent-refresh',versionAdded:'1.6.2',versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,parameters:[{name:'delay',required:false,description:null,pattern:null,'default':null,debug:false}]},{name:'prevent-refresh.js',aliases:['refresh-defuser.js'],description:null,docs:'https://github.com/gorhill/uBlock/wiki/Resources-Library#prevent-refreshjs-',versionAdded:'1.38.7b3',versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,parameters:[{name:'delay',required:false,description:null,pattern:null,'default':null,debug:false}]}],map:{'1':0,'2':0,'4':0,'8':0,'16':0,'32':0,'64':0,'1024':1,'2048':1,'4096':1,'8192':1}},{shared:[{name:'prevent-requestAnimationFrame',aliases:['no-requestAnimationFrame-if.js','ubo-no-requestAnimationFrame-if.js','norafif.js','ubo-norafif.js','ubo-no-requestAnimationFrame-if','ubo-norafif'],description:null,docs:'https://github.com/AdguardTeam/Scriptlets/blob/master/wiki/about-scriptlets.md#prevent-requestAnimationFrame',versionAdded:'1.1.15',versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,parameters:[{name:'search',required:false,description:null,pattern:null,'default':null,debug:false}]},{name:'no-requestAnimationFrame-if.js',aliases:['norafif.js','prevent-requestAnimationFrame.js'],description:null,docs:'https://github.com/gorhill/uBlock/wiki/Resources-Library#no-requestAnimationFrame-ifjs-',versionAdded:'1.27.0',versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,parameters:[{name:'search',required:false,description:null,pattern:null,'default':null,debug:false}]}],map:{'1':0,'2':0,'4':0,'8':0,'16':0,'32':0,'64':0,'1024':1,'2048':1,'4096':1,'8192':1}},{shared:[{name:'prevent-setInterval',aliases:['no-setInterval-if.js','ubo-no-setInterval-if.js','setInterval-defuser.js','ubo-setInterval-defuser.js','nosiif.js','ubo-nosiif.js','sid.js','ubo-sid.js','ubo-no-setInterval-if','ubo-setInterval-defuser','ubo-nosiif','ubo-sid'],description:null,docs:'https://github.com/AdguardTeam/Scriptlets/blob/master/wiki/about-scriptlets.md#prevent-setInterval',versionAdded:'1.0.4',versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,parameters:[{name:'matchCallback',required:false,description:null,pattern:null,'default':null,debug:false},{name:'matchDelay',required:false,description:null,pattern:null,'default':null,debug:false}]},{name:'no-setInterval-if.js',aliases:['nosiif.js','prevent-setInterval.js','setInterval-defuser.js'],description:null,docs:'https://github.com/gorhill/uBlock/wiki/Resources-Library#no-setInterval-ifjs-',versionAdded:'1.23.0',versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,parameters:[{name:'matchCallback',required:false,description:null,pattern:null,'default':null,debug:false},{name:'matchDelay',required:false,description:null,pattern:null,'default':null,debug:false}]}],map:{'1':0,'2':0,'4':0,'8':0,'16':0,'32':0,'64':0,'1024':1,'2048':1,'4096':1,'8192':1}},{shared:[{name:'prevent-setTimeout',aliases:['no-setTimeout-if.js','ubo-no-setTimeout-if.js','nostif.js','ubo-nostif.js','ubo-no-setTimeout-if','ubo-nostif','setTimeout-defuser.js','ubo-setTimeout-defuser.js','ubo-setTimeout-defuser','std.js','ubo-std.js','ubo-std'],description:null,docs:'https://github.com/AdguardTeam/Scriptlets/blob/master/wiki/about-scriptlets.md#prevent-setTimeout',versionAdded:'1.0.4',versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,parameters:[{name:'matchCallback',required:false,description:null,pattern:null,'default':null,debug:false},{name:'matchDelay',required:false,description:null,pattern:null,'default':null,debug:false}]},{name:'no-setTimeout-if.js',aliases:['nostif.js','prevent-setTimeout.js','setTimeout-defuser.js'],description:null,docs:'https://github.com/gorhill/uBlock/wiki/Resources-Library#no-setTimeout-ifjs-',versionAdded:'1.23.0',versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,parameters:[{name:'matchCallback',required:false,description:null,pattern:null,'default':null,debug:false},{name:'matchDelay',required:false,description:null,pattern:null,'default':null,debug:false}]}],map:{'1':0,'2':0,'4':0,'8':0,'16':0,'32':0,'64':0,'1024':1,'2048':1,'4096':1,'8192':1}},{shared:[{name:'prevent-window-open',aliases:['window.open-defuser.js','ubo-window.open-defuser.js','ubo-window.open-defuser','nowoif.js','ubo-nowoif.js','ubo-nowoif','no-window-open-if.js','ubo-no-window-open-if.js','ubo-no-window-open-if'],description:null,docs:'https://github.com/AdguardTeam/Scriptlets/blob/master/wiki/about-scriptlets.md#prevent-window-open',versionAdded:'1.0.4',versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,parameters:[{name:'match',required:false,description:null,pattern:null,'default':null,debug:false},{name:'delay',required:false,description:null,pattern:null,'default':null,debug:false},{name:'replacement',required:false,description:null,pattern:null,'default':null,debug:false}]},{name:'no-window-open-if.js',aliases:['nowoif.js','prevent-window-open.js','window.open-defuser.js'],description:null,docs:'https://github.com/gorhill/uBlock/wiki/Resources-Library#no-window-open-ifjs-',versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,parameters:[{name:'match',required:false,description:null,pattern:null,'default':null,debug:false},{name:'delay',required:false,description:null,pattern:null,'default':null,debug:false},{name:'replacement',required:false,description:null,pattern:null,'default':null,debug:false}]}],map:{'1':0,'2':0,'4':0,'8':0,'16':0,'32':0,'64':0,'1024':1,'2048':1,'4096':1,'8192':1}},{shared:[{name:'prevent-xhr',aliases:['no-xhr-if.js','ubo-no-xhr-if.js','ubo-no-xhr-if'],description:null,docs:'https://github.com/AdguardTeam/Scriptlets/blob/master/wiki/about-scriptlets.md#prevent-xhr',versionAdded:'1.5.0',versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,parameters:[{name:'propsToMatch',required:false,description:null,pattern:null,'default':null,debug:false},{name:'randomize',required:false,description:null,pattern:null,'default':null,debug:false}]},{name:'no-xhr-if.js',aliases:['prevent-xhr.js'],description:null,docs:'https://github.com/gorhill/uBlock/wiki/Resources-Library#no-xhr-ifjs-',versionAdded:'1.38.0',versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,parameters:[{name:'propsToMatch',required:false,description:null,pattern:null,'default':null,debug:false},{name:'randomize',required:false,description:null,pattern:null,'default':null,debug:false}]}],map:{'1':0,'2':0,'4':0,'8':0,'16':0,'32':0,'64':0,'1024':1,'2048':1,'4096':1,'8192':1}},{shared:[{name:'remove-attr',aliases:['remove-attr.js','ubo-remove-attr.js','ra.js','ubo-ra.js','ubo-remove-attr','ubo-ra'],description:null,docs:'https://github.com/AdguardTeam/Scriptlets/blob/master/wiki/about-scriptlets.md#remove-attr',versionAdded:'1.0.4',versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,parameters:[{name:'attrs',required:true,description:null,pattern:null,'default':null,debug:false},{name:'selector',required:false,description:null,pattern:null,'default':null,debug:false},{name:'applying',required:false,description:null,pattern:null,'default':null,debug:false}]},{name:'remove-attr.js',aliases:['ra.js','ra','remove-attr'],description:null,docs:'https://github.com/gorhill/uBlock/wiki/Resources-Library#remove-attrjs-',versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,parameters:[{name:'attrs',required:true,description:null,pattern:null,'default':null,debug:false},{name:'selector',required:false,description:null,pattern:null,'default':null,debug:false},{name:'applying',required:false,description:null,pattern:null,'default':null,debug:false}]}],map:{'1':0,'2':0,'4':0,'8':0,'16':0,'32':0,'64':0,'1024':1,'2048':1,'4096':1,'8192':1}},{shared:[{name:'remove-class',aliases:['remove-class.js','ubo-remove-class.js','rc.js','ubo-rc.js','ubo-remove-class','ubo-rc'],description:null,docs:'https://github.com/AdguardTeam/Scriptlets/blob/master/wiki/about-scriptlets.md#remove-class',versionAdded:'1.1.1',versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,parameters:[{name:'classes',required:true,description:null,pattern:null,'default':null,debug:false},{name:'selector',required:false,description:null,pattern:null,'default':null,debug:false},{name:'applying',required:false,description:null,pattern:null,'default':null,debug:false}]},{name:'remove-class.js',aliases:['rc.js','rc','remove-class'],description:null,docs:'https://github.com/gorhill/uBlock/wiki/Resources-Library#remove-classjs-',versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,parameters:[{name:'classes',required:true,description:null,pattern:null,'default':null,debug:false},{name:'selector',required:false,description:null,pattern:null,'default':null,debug:false},{name:'applying',required:false,description:null,pattern:null,'default':null,debug:false}]}],map:{'1':0,'2':0,'4':0,'8':0,'16':0,'32':0,'64':0,'1024':1,'2048':1,'4096':1,'8192':1}},{shared:[{name:'remove-cookie',aliases:['cookie-remover.js','ubo-cookie-remover.js','ubo-cookie-remover','remove-cookie.js','ubo-remove-cookie.js','ubo-remove-cookie','abp-cookie-remover'],description:null,docs:'https://github.com/AdguardTeam/Scriptlets/blob/master/wiki/about-scriptlets.md#remove-cookie',versionAdded:'1.0.4',versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,parameters:[{name:'match',required:false,description:null,pattern:null,'default':null,debug:false}]},{name:'remove-cookie.js',aliases:['cookie-remover.js'],description:null,docs:'https://github.com/gorhill/uBlock/wiki/Resources-Library#remove-cookiejs-',versionAdded:'1.28.0',versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,parameters:[{name:'match',required:false,description:null,pattern:null,'default':null,debug:false}]},{name:'cookie-remover',aliases:null,description:null,docs:'https://help.adblockplus.org/hc/en-us/articles/1500002338501-Snippet-filters-tutorial#snippets-ref',versionAdded:'3.11.2',versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,parameters:[{name:'cookie',required:true,description:null,pattern:null,'default':null,debug:false},{name:'autoRemoveCookie',required:false,description:null,pattern:null,'default':null,debug:false}]}],map:{'1':0,'2':0,'4':0,'8':0,'16':0,'32':0,'64':0,'1024':1,'2048':1,'4096':1,'8192':1,'16384':2,'32768':2,'65536':2,'131072':2}},{shared:[{name:'remove-in-shadow-dom',aliases:null,description:null,docs:'https://github.com/AdguardTeam/Scriptlets/blob/master/wiki/about-scriptlets.md#remove-in-shadow-dom',versionAdded:'1.3.14',versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,parameters:[{name:'selector',required:true,description:null,pattern:null,'default':null,debug:false},{name:'baseSelector',required:false,description:null,pattern:null,'default':null,debug:false}]}],map:{'1':0,'2':0,'4':0,'8':0,'16':0,'32':0,'64':0}},{shared:[{name:'remove-node-text',aliases:['remove-node-text.js','ubo-remove-node-text.js','rmnt.js','ubo-rmnt.js','ubo-remove-node-text','ubo-rmnt'],description:null,docs:'https://github.com/AdguardTeam/Scriptlets/blob/master/wiki/about-scriptlets.md#remove-node-text',versionAdded:'1.9.37',versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,parameters:[{name:'nodeName',required:true,description:null,pattern:null,'default':null,debug:false},{name:'textMatch',required:true,description:null,pattern:null,'default':null,debug:false}]},{name:'remove-node-text.js',aliases:['rmnt.js'],description:null,docs:'https://github.com/gorhill/uBlock/wiki/Resources-Library#remove-node-textjs-',versionAdded:'1.49.3rc15',versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,parameters:[{name:'nodeName',required:true,description:null,pattern:null,'default':null,debug:false},{name:'textMatch',required:true,description:null,pattern:null,'default':null,debug:false}]}],map:{'1':0,'2':0,'4':0,'8':0,'16':0,'32':0,'64':0,'1024':1,'2048':1,'4096':1,'8192':1}},{shared:[{name:'scorecardresearch-beacon',aliases:['ubo-scorecardresearch_beacon.js','scorecardresearch_beacon.js'],description:null,docs:'https://github.com/AdguardTeam/Scriptlets/blob/master/wiki/about-scriptlets.md#scorecardresearch-beacon',versionAdded:'1.10.25',versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null}],map:{'1':0,'2':0,'4':0,'8':0,'16':0,'32':0,'64':0}},{shared:[{name:'set-attr',aliases:['set-attr.js','ubo-set-attr.js','ubo-set-attr'],description:null,docs:'https://github.com/AdguardTeam/Scriptlets/blob/master/wiki/about-scriptlets.md#set-attr',versionAdded:'1.5.0',versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,parameters:[{name:'selector',required:true,description:null,pattern:null,'default':null,debug:false},{name:'attr',required:true,description:null,pattern:null,'default':null,debug:false},{name:'value',required:false,description:null,pattern:null,'default':null,debug:false}]},{name:'set-attr.js',aliases:null,description:null,docs:'https://github.com/gorhill/uBlock/wiki/Resources-Library#set-attrjs-',versionAdded:'1.50.1b16',versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,parameters:[{name:'selector',required:true,description:null,pattern:null,'default':null,debug:false},{name:'attr',required:true,description:null,pattern:null,'default':null,debug:false},{name:'value',required:false,description:null,pattern:null,'default':null,debug:false}]}],map:{'1':0,'2':0,'4':0,'8':0,'16':0,'32':0,'64':0,'1024':1,'2048':1,'4096':1,'8192':1}},{shared:[{name:'set-constant',aliases:['set-constant.js','ubo-set-constant.js','set.js','ubo-set.js','ubo-set-constant','ubo-set'],description:null,docs:'https://github.com/AdguardTeam/Scriptlets/blob/master/wiki/about-scriptlets.md#set-constant',versionAdded:'1.0.4',versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,parameters:[{name:'property',required:true,description:null,pattern:null,'default':null,debug:false},{name:'value',required:true,description:null,pattern:null,'default':null,debug:false},{name:'stack',required:false,description:null,pattern:null,'default':null,debug:false},{name:'valueWrapper',required:false,description:null,pattern:null,'default':null,debug:false},{name:'setProxyTrap',required:false,description:null,pattern:null,'default':null,debug:false}]},{name:'set-constant.js',aliases:['set.js'],description:null,docs:'https://github.com/gorhill/uBlock/wiki/Resources-Library#set-constantjs-',versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,parameters:[{name:'chain',required:true,description:null,pattern:null,'default':null,debug:false},{name:'rawValue',required:true,description:null,pattern:null,'default':null,debug:false},{name:'runAt',required:false,description:null,pattern:null,'default':null,debug:false}]},{name:'override-property-read',aliases:null,description:null,docs:'https://help.adblockplus.org/hc/en-us/articles/1500002338501-Snippet-filters-tutorial#snippets-ref',versionAdded:'3.9.4',versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,parameters:[{name:'property',required:true,description:null,pattern:null,'default':null,debug:false},{name:'value',required:true,description:null,pattern:null,'default':null,debug:false},{name:'setConfigurable',required:false,description:null,pattern:null,'default':null,debug:false}]}],map:{'1':0,'2':0,'4':0,'8':0,'16':0,'32':0,'64':0,'1024':1,'2048':1,'4096':1,'8192':1,'16384':2,'32768':2,'65536':2,'131072':2}},{shared:[{name:'set-cookie-reload',aliases:['set-cookie-reload.js','ubo-set-cookie-reload.js','ubo-set-cookie-reload'],description:null,docs:'https://github.com/AdguardTeam/Scriptlets/blob/master/wiki/about-scriptlets.md#set-cookie-reload',versionAdded:'1.3.14',versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,parameters:[{name:'name',required:true,description:null,pattern:null,'default':null,debug:false},{name:'value',required:true,description:null,pattern:null,'default':null,debug:false},{name:'path',required:false,description:null,pattern:null,'default':null,debug:false},{name:'domain',required:false,description:null,pattern:null,'default':null,debug:false}]},{name:'set-cookie-reload.js',aliases:null,description:null,docs:'https://github.com/gorhill/uBlock/wiki/Resources-Library#set-cookie-reloadjs-',versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,parameters:[{name:'name',required:true,description:null,pattern:null,'default':null,debug:false},{name:'value',required:true,description:null,pattern:null,'default':null,debug:false},{name:'path',required:false,description:null,pattern:null,'default':null,debug:false},{name:'domain',required:false,description:null,pattern:null,'default':null,debug:false}]}],map:{'1':0,'2':0,'4':0,'8':0,'16':0,'32':0,'64':0,'1024':1,'2048':1,'4096':1,'8192':1}},{shared:[{name:'set-cookie',aliases:['set-cookie.js','ubo-set-cookie.js','ubo-set-cookie'],description:null,docs:'https://github.com/AdguardTeam/Scriptlets/blob/master/wiki/about-scriptlets.md#set-cookie',versionAdded:'1.2.3',versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,parameters:[{name:'name',required:true,description:null,pattern:null,'default':null,debug:false},{name:'value',required:true,description:null,pattern:null,'default':null,debug:false},{name:'path',required:false,description:null,pattern:null,'default':null,debug:false}]},{name:'set-cookie.js',aliases:null,description:null,docs:'https://github.com/gorhill/uBlock/wiki/Resources-Library#set-cookiejs-',versionAdded:'1.50.1b0',versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,parameters:[{name:'name',required:true,description:null,pattern:null,'default':null,debug:false},{name:'value',required:true,description:null,pattern:null,'default':null,debug:false},{name:'path',required:false,description:null,pattern:null,'default':null,debug:false}]}],map:{'1':0,'2':0,'4':0,'8':0,'16':0,'32':0,'64':0,'1024':1,'2048':1,'4096':1,'8192':1}},{shared:[{name:'set-local-storage-item',aliases:['set-local-storage-item.js','ubo-set-local-storage-item.js','ubo-set-local-storage-item'],description:null,docs:'https://github.com/AdguardTeam/Scriptlets/blob/master/wiki/about-scriptlets.md#set-local-storage-item',versionAdded:'1.4.3',versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,parameters:[{name:'key',required:true,description:null,pattern:null,'default':null,debug:false},{name:'value',required:true,description:null,pattern:null,'default':null,debug:false}]},{name:'set-local-storage-item.js',aliases:null,description:null,docs:'https://github.com/gorhill/uBlock/wiki/Resources-Library#set-local-storage-itemjs-',versionAdded:'1.50.1b4',versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,parameters:[{name:'key',required:true,description:null,pattern:null,'default':null,debug:false},{name:'value',required:true,description:null,pattern:null,'default':null,debug:false}]}],map:{'1':0,'2':0,'4':0,'8':0,'16':0,'32':0,'64':0,'1024':1,'2048':1,'4096':1,'8192':1}},{shared:[{name:'set-popads-dummy',aliases:['popads-dummy.js','ubo-popads-dummy.js','ubo-popads-dummy'],description:null,docs:'https://github.com/AdguardTeam/Scriptlets/blob/master/wiki/about-scriptlets.md#set-popads-dummy',versionAdded:'1.0.4',versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null}],map:{'1':0,'2':0,'4':0,'8':0,'16':0,'32':0,'64':0}},{shared:[{name:'set-session-storage-item',aliases:['set-session-storage-item.js','ubo-set-session-storage-item.js','ubo-set-session-storage-item'],description:null,docs:'https://github.com/AdguardTeam/Scriptlets/blob/master/wiki/about-scriptlets.md#set-session-storage-item',versionAdded:'1.4.3',versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,parameters:[{name:'key',required:true,description:null,pattern:null,'default':null,debug:false},{name:'value',required:true,description:null,pattern:null,'default':null,debug:false}]},{name:'set-session-storage-item.js',aliases:null,description:null,docs:'https://github.com/gorhill/uBlock/wiki/Resources-Library#set-session-storage-itemjs-',versionAdded:'1.50.1b4',versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,parameters:[{name:'key',required:true,description:null,pattern:null,'default':null,debug:false},{name:'value',required:true,description:null,pattern:null,'default':null,debug:false}]}],map:{'1':0,'2':0,'4':0,'8':0,'16':0,'32':0,'64':0,'1024':1,'2048':1,'4096':1,'8192':1}},{shared:[{name:'spoof-css',aliases:['spoof-css.js','ubo-spoof-css.js','ubo-spoof-css'],description:null,docs:'https://github.com/AdguardTeam/Scriptlets/blob/master/wiki/about-scriptlets.md#spoof-css',versionAdded:'1.10.1',versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,parameters:[{name:'selectors',required:true,description:null,pattern:null,'default':null,debug:false},{name:'cssPropertyName',required:true,description:null,pattern:null,'default':null,debug:false},{name:'cssPropertyValue',required:true,description:null,pattern:null,'default':null,debug:false}]},{name:'spoof-css.js',aliases:null,description:null,docs:'https://github.com/gorhill/uBlock/wiki/Resources-Library#spoof-cssjs-',versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,parameters:[{name:'selectors',required:true,description:null,pattern:null,'default':null,debug:false},{name:'cssPropertyName',required:true,description:null,pattern:null,'default':null,debug:false},{name:'cssPropertyValue',required:true,description:null,pattern:null,'default':null,debug:false},{name:'arguments',required:false,description:null,pattern:null,'default':null,debug:false}]}],map:{'1':0,'2':0,'4':0,'8':0,'16':0,'32':0,'64':0,'1024':1,'2048':1,'4096':1,'8192':1}},{shared:[{name:'trusted-click-element',aliases:null,description:null,docs:null,versionAdded:'1.7.3',versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,parameters:[{name:'selectors',required:true,description:null,pattern:null,'default':null,debug:false},{name:'extraMatch',required:false,description:null,pattern:null,'default':null,debug:false},{name:'delay',required:false,description:null,pattern:null,'default':null,debug:false}]}],map:{'1':0,'2':0,'4':0,'8':0,'16':0,'32':0,'64':0}},{shared:[{name:'trusted-create-element',aliases:null,description:null,docs:null,versionAdded:'1.10.1',versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,parameters:[{name:'parentSelector',required:true,description:null,pattern:null,'default':null,debug:false},{name:'tagName',required:true,description:null,pattern:null,'default':null,debug:false},{name:'attributePairs',required:false,description:null,pattern:null,'default':null,debug:false},{name:'textContent',required:false,description:null,pattern:null,'default':null,debug:false},{name:'cleanupDelayMs',required:false,description:null,pattern:null,'default':null,debug:false}]}],map:{'1':0,'2':0,'4':0,'8':0,'16':0,'32':0,'64':0}},{shared:[{name:'trusted-dispatch-event',aliases:null,description:null,docs:null,versionAdded:null,versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,parameters:[{name:'event',required:true,description:null,pattern:null,'default':null,debug:false},{name:'target',required:false,description:null,pattern:null,'default':null,debug:false}]}],map:{'1':0,'2':0,'4':0,'8':0,'16':0,'32':0,'64':0}},{shared:[{name:'trusted-prune-inbound-object',aliases:null,description:null,docs:null,versionAdded:'1.9.91',versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,parameters:[{name:'functionName',required:true,description:null,pattern:null,'default':null,debug:false},{name:'propsToRemove',required:false,description:null,pattern:null,'default':null,debug:false},{name:'obligatoryProps',required:false,description:null,pattern:null,'default':null,debug:false},{name:'stack',required:false,description:null,pattern:null,'default':null,debug:false}]}],map:{'1':0,'2':0,'4':0,'8':0,'16':0,'32':0,'64':0}},{shared:[{name:'trusted-replace-fetch-response',aliases:null,description:null,docs:null,versionAdded:'1.7.3',versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,parameters:[{name:'pattern',required:false,description:null,pattern:null,'default':null,debug:false},{name:'replacement',required:false,description:null,pattern:null,'default':null,debug:false},{name:'propsToMatch',required:false,description:null,pattern:null,'default':null,debug:false}]}],map:{'1':0,'2':0,'4':0,'8':0,'16':0,'32':0,'64':0}},{shared:[{name:'trusted-replace-node-text',aliases:null,description:null,docs:null,versionAdded:'1.9.37',versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,parameters:[{name:'nodeName',required:true,description:null,pattern:null,'default':null,debug:false},{name:'textMatch',required:true,description:null,pattern:null,'default':null,debug:false},{name:'pattern',required:true,description:null,pattern:null,'default':null,debug:false},{name:'replacement',required:true,description:null,pattern:null,'default':null,debug:false}]}],map:{'1':0,'2':0,'4':0,'8':0,'16':0,'32':0,'64':0}},{shared:[{name:'trusted-replace-xhr-response',aliases:null,description:null,docs:null,versionAdded:'1.7.3',versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,parameters:[{name:'pattern',required:false,description:null,pattern:null,'default':null,debug:false},{name:'replacement',required:false,description:null,pattern:null,'default':null,debug:false},{name:'propsToMatch',required:false,description:null,pattern:null,'default':null,debug:false}]}],map:{'1':0,'2':0,'4':0,'8':0,'16':0,'32':0,'64':0}},{shared:[{name:'trusted-set-attr',aliases:null,description:null,docs:null,versionAdded:'1.10.1',versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,parameters:[{name:'selector',required:true,description:null,pattern:null,'default':null,debug:false},{name:'attr',required:true,description:null,pattern:null,'default':null,debug:false},{name:'value',required:false,description:null,pattern:null,'default':null,debug:false}]}],map:{'1':0,'2':0,'4':0,'8':0,'16':0,'32':0,'64':0}},{shared:[{name:'trusted-set-constant',aliases:null,description:null,docs:null,versionAdded:'1.8.2',versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,parameters:[{name:'property',required:true,description:null,pattern:null,'default':null,debug:false},{name:'value',required:true,description:null,pattern:null,'default':null,debug:false},{name:'stack',required:false,description:null,pattern:null,'default':null,debug:false}]}],map:{'1':0,'2':0,'4':0,'8':0,'16':0,'32':0,'64':0}},{shared:[{name:'trusted-set-cookie-reload',aliases:null,description:null,docs:null,versionAdded:'1.7.10',versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,parameters:[{name:'name',required:true,description:null,pattern:null,'default':null,debug:false},{name:'value',required:true,description:null,pattern:null,'default':null,debug:false},{name:'offsetExpiresSec',required:false,description:null,pattern:null,'default':null,debug:false},{name:'path',required:false,description:null,pattern:null,'default':null,debug:false},{name:'domain',required:false,description:null,pattern:null,'default':null,debug:false}]}],map:{'1':0,'2':0,'4':0,'8':0,'16':0,'32':0,'64':0}},{shared:[{name:'trusted-set-cookie',aliases:null,description:null,docs:null,versionAdded:'1.7.3',versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,parameters:[{name:'name',required:true,description:null,pattern:null,'default':null,debug:false},{name:'value',required:true,description:null,pattern:null,'default':null,debug:false},{name:'offsetExpiresSec',required:false,description:null,pattern:null,'default':null,debug:false},{name:'path',required:false,description:null,pattern:null,'default':null,debug:false},{name:'domain',required:false,description:null,pattern:null,'default':null,debug:false}]}],map:{'1':0,'2':0,'4':0,'8':0,'16':0,'32':0,'64':0}},{shared:[{name:'trusted-set-local-storage-item',aliases:null,description:null,docs:null,versionAdded:'1.7.3',versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,parameters:[{name:'key',required:true,description:null,pattern:null,'default':null,debug:false},{name:'value',required:true,description:null,pattern:null,'default':null,debug:false}]}],map:{'1':0,'2':0,'4':0,'8':0,'16':0,'32':0,'64':0}},{shared:[{name:'trusted-suppress-native-method',aliases:null,description:null,docs:null,versionAdded:'1.10.25',versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,parameters:[{name:'methodPath',required:true,description:null,pattern:null,'default':null,debug:false},{name:'signatureStr',required:true,description:null,pattern:null,'default':null,debug:false},{name:'how',required:false,description:null,pattern:null,'default':null,debug:false},{name:'stack',required:false,description:null,pattern:null,'default':null,debug:false}]}],map:{'1':0,'2':0,'4':0,'8':0,'16':0,'32':0,'64':0}},{shared:[{name:'xml-prune',aliases:['xml-prune.js','ubo-xml-prune.js','ubo-xml-prune'],description:null,docs:'https://github.com/AdguardTeam/Scriptlets/blob/master/wiki/about-scriptlets.md#xml-prune',versionAdded:'1.7.3',versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,parameters:[{name:'propsToMatch',required:false,description:null,pattern:null,'default':null,debug:false},{name:'optionalProp',required:false,description:null,pattern:null,'default':null,debug:false},{name:'urlToMatch',required:false,description:null,pattern:null,'default':null,debug:false}]},{name:'xml-prune.js',aliases:null,description:null,docs:'https://github.com/gorhill/uBlock/wiki/Resources-Library#xml-prunejs-',versionAdded:'1.49.3rc6',versionRemoved:null,deprecated:false,deprecationMessage:null,removed:false,removalMessage:null,parameters:[{name:'propsToMatch',required:false,description:null,pattern:null,'default':null,debug:false},{name:'optionalProp',required:false,description:null,pattern:null,'default':null,debug:false},{name:'urlToMatch',required:false,description:null,pattern:null,'default':null,debug:false}]}],map:{'1':0,'2':0,'4':0,'8':0,'16':0,'32':0,'64':0,'1024':1,'2048':1,'4096':1,'8192':1}}],map:{'abort-current-inline-script':0,'abort-current-script.js':0,'ubo-abort-current-script.js':0,'acs.js':0,'ubo-acs.js':0,'ubo-abort-current-script':0,'ubo-acs':0,'abort-current-inline-script.js':0,'ubo-abort-current-inline-script.js':0,'acis.js':0,'ubo-acis.js':0,'ubo-abort-current-inline-script':0,'ubo-acis':0,'abp-abort-current-inline-script':0,'abort-on-property-read':1,'abort-on-property-read.js':1,'ubo-abort-on-property-read.js':1,'aopr.js':1,'ubo-aopr.js':1,'ubo-abort-on-property-read':1,'ubo-aopr':1,'abp-abort-on-property-read':1,'abort-on-property-write':2,'abort-on-property-write.js':2,'ubo-abort-on-property-write.js':2,'aopw.js':2,'ubo-aopw.js':2,'ubo-abort-on-property-write':2,'ubo-aopw':2,'abp-abort-on-property-write':2,'abort-on-stack-trace':3,'abort-on-stack-trace.js':3,'ubo-abort-on-stack-trace.js':3,'aost.js':3,'ubo-aost.js':3,'ubo-abort-on-stack-trace':3,'ubo-aost':3,'abp-abort-on-stack-trace':3,'adjust-setInterval':4,'nano-setInterval-booster.js':4,'ubo-nano-setInterval-booster.js':4,'nano-sib.js':4,'ubo-nano-sib.js':4,'adjust-setInterval.js':4,'ubo-adjust-setInterval.js':4,'ubo-nano-setInterval-booster':4,'ubo-nano-sib':4,'ubo-adjust-setInterval':4,'adjust-setTimeout':5,'adjust-setTimeout.js':5,'ubo-adjust-setTimeout.js':5,'nano-setTimeout-booster.js':5,'ubo-nano-setTimeout-booster.js':5,'nano-stb.js':5,'ubo-nano-stb.js':5,'ubo-adjust-setTimeout':5,'ubo-nano-setTimeout-booster':5,'ubo-nano-stb':5,'amazon-apstag':6,'ubo-amazon_apstag.js':6,'amazon_apstag.js':6,'call-nothrow':7,'call-nothrow.js':7,'ubo-call-nothrow.js':7,'ubo-call-nothrow':7,'close-window':8,'window-close-if.js':8,'ubo-window-close-if.js':8,'ubo-window-close-if':8,'close-window.js':8,'ubo-close-window.js':8,'ubo-close-window':8,'debug-current-inline-script':9,'debug-on-property-read':10,'debug-on-property-write':11,'didomi-loader':12,'dir-string':13,'disable-newtab-links':14,'disable-newtab-links.js':14,'ubo-disable-newtab-links.js':14,'ubo-disable-newtab-links':14,'evaldata-prune':15,'evaldata-prune.js':15,'ubo-evaldata-prune.js':15,'ubo-evaldata-prune':15,fingerprintjs2:16,'ubo-fingerprint2.js':16,'fingerprint2.js':16,fingerprintjs3:17,'ubo-fingerprint3.js':17,'fingerprint3.js':17,gemius:18,'google-analytics-ga':19,'ubo-google-analytics_ga.js':19,'google-analytics_ga.js':19,'google-analytics':20,'ubo-google-analytics_analytics.js':20,'google-analytics_analytics.js':20,'googletagmanager-gtm':20,'ubo-googletagmanager_gtm.js':20,'googletagmanager_gtm.js':20,'google-ima3':21,'ubo-google-ima.js':21,'google-ima.js':21,'googlesyndication-adsbygoogle':22,'ubo-googlesyndication_adsbygoogle.js':22,'googlesyndication_adsbygoogle.js':22,'googletagservices-gpt':23,'ubo-googletagservices_gpt.js':23,'googletagservices_gpt.js':23,'hide-in-shadow-dom':24,'href-sanitizer':25,'href-sanitizer.js':25,'ubo-href-sanitizer.js':25,'ubo-href-sanitizer':25,'inject-css-in-shadow-dom':26,'json-prune-fetch-response':27,'json-prune-fetch-response.js':27,'ubo-json-prune-fetch-response.js':27,'ubo-json-prune-fetch-response':27,'json-prune-xhr-response':28,'json-prune-xhr-response.js':28,'ubo-json-prune-xhr-response.js':28,'ubo-json-prune-xhr-response':28,'json-prune':29,'json-prune.js':29,'ubo-json-prune.js':29,'ubo-json-prune':29,'abp-json-prune':29,'log-addEventListener':30,'addEventListener-logger.js':30,'ubo-addEventListener-logger.js':30,'aell.js':30,'ubo-aell.js':30,'ubo-addEventListener-logger':30,'ubo-aell':30,'log-eval':31,'log-on-stack-trace':32,log:33,'abp-log':33,'m3u-prune':34,'m3u-prune.js':34,'ubo-m3u-prune.js':34,'ubo-m3u-prune':34,matomo:35,'metrika-yandex-tag':36,'metrika-yandex-watch':37,'naver-wcslog':38,'no-protected-audience':39,'no-topics':40,noeval:41,'noeval.js':41,'silent-noeval.js':41,'ubo-noeval.js':41,'ubo-silent-noeval.js':41,'ubo-noeval':41,'ubo-silent-noeval':41,nowebrtc:42,'nowebrtc.js':42,'ubo-nowebrtc.js':42,'ubo-nowebrtc':42,'pardot-1.0':43,prebid:44,'prevent-addEventListener':45,'addEventListener-defuser.js':45,'ubo-addEventListener-defuser.js':45,'aeld.js':45,'ubo-aeld.js':45,'ubo-addEventListener-defuser':45,'ubo-aeld':45,'abp-prevent-listener':45,'prevent-addEventListener.js':45,'prevent-listener':45,'prevent-adfly':46,'adfly-defuser.js':46,'ubo-adfly-defuser.js':46,'ubo-adfly-defuser':46,'prevent-bab':47,'prevent-element-src-loading':48,'prevent-eval-if':49,'noeval-if.js':49,'ubo-noeval-if.js':49,'ubo-noeval-if':49,'prevent-eval-if.js':49,'prevent-fab-3.2.0':50,'nofab.js':50,'ubo-nofab.js':50,'fuckadblock.js-3.2.0':50,'ubo-fuckadblock.js-3.2.0':50,'ubo-nofab':50,'prevent-fetch':51,'prevent-fetch.js':51,'no-fetch-if.js':51,'ubo-no-fetch-if.js':51,'ubo-no-fetch-if':51,'prevent-popads-net':52,'popads.net.js':52,'ubo-popads.net.js':52,'ubo-popads.net':52,'prevent-refresh':53,'prevent-refresh.js':53,'refresh-defuser.js':53,'refresh-defuser':53,'ubo-prevent-refresh.js':53,'ubo-prevent-refresh':53,'ubo-refresh-defuser.js':53,'ubo-refresh-defuser':53,'prevent-requestAnimationFrame':54,'no-requestAnimationFrame-if.js':54,'ubo-no-requestAnimationFrame-if.js':54,'norafif.js':54,'ubo-norafif.js':54,'ubo-no-requestAnimationFrame-if':54,'ubo-norafif':54,'prevent-requestAnimationFrame.js':54,'prevent-setInterval':55,'no-setInterval-if.js':55,'ubo-no-setInterval-if.js':55,'setInterval-defuser.js':55,'ubo-setInterval-defuser.js':55,'nosiif.js':55,'ubo-nosiif.js':55,'sid.js':55,'ubo-sid.js':55,'ubo-no-setInterval-if':55,'ubo-setInterval-defuser':55,'ubo-nosiif':55,'ubo-sid':55,'prevent-setInterval.js':55,'prevent-setTimeout':56,'no-setTimeout-if.js':56,'ubo-no-setTimeout-if.js':56,'nostif.js':56,'ubo-nostif.js':56,'ubo-no-setTimeout-if':56,'ubo-nostif':56,'setTimeout-defuser.js':56,'ubo-setTimeout-defuser.js':56,'ubo-setTimeout-defuser':56,'std.js':56,'ubo-std.js':56,'ubo-std':56,'prevent-setTimeout.js':56,'prevent-window-open':57,'window.open-defuser.js':57,'ubo-window.open-defuser.js':57,'ubo-window.open-defuser':57,'nowoif.js':57,'ubo-nowoif.js':57,'ubo-nowoif':57,'no-window-open-if.js':57,'ubo-no-window-open-if.js':57,'ubo-no-window-open-if':57,'prevent-window-open.js':57,'prevent-xhr':58,'no-xhr-if.js':58,'ubo-no-xhr-if.js':58,'ubo-no-xhr-if':58,'prevent-xhr.js':58,'remove-attr':59,'remove-attr.js':59,'ubo-remove-attr.js':59,'ra.js':59,'ubo-ra.js':59,'ubo-remove-attr':59,'ubo-ra':59,ra:59,'remove-class':60,'remove-class.js':60,'ubo-remove-class.js':60,'rc.js':60,'ubo-rc.js':60,'ubo-remove-class':60,'ubo-rc':60,rc:60,'remove-cookie':61,'cookie-remover.js':61,'ubo-cookie-remover.js':61,'ubo-cookie-remover':61,'remove-cookie.js':61,'ubo-remove-cookie.js':61,'ubo-remove-cookie':61,'abp-cookie-remover':61,'cookie-remover':61,'remove-in-shadow-dom':62,'remove-node-text':63,'remove-node-text.js':63,'ubo-remove-node-text.js':63,'rmnt.js':63,'ubo-rmnt.js':63,'ubo-remove-node-text':63,'ubo-rmnt':63,'scorecardresearch-beacon':64,'ubo-scorecardresearch_beacon.js':64,'scorecardresearch_beacon.js':64,'set-attr':65,'set-attr.js':65,'ubo-set-attr.js':65,'ubo-set-attr':65,'set-constant':66,'set-constant.js':66,'ubo-set-constant.js':66,'set.js':66,'ubo-set.js':66,'ubo-set-constant':66,'ubo-set':66,'override-property-read':66,'set-cookie-reload':67,'set-cookie-reload.js':67,'ubo-set-cookie-reload.js':67,'ubo-set-cookie-reload':67,'set-cookie':68,'set-cookie.js':68,'ubo-set-cookie.js':68,'ubo-set-cookie':68,'set-local-storage-item':69,'set-local-storage-item.js':69,'ubo-set-local-storage-item.js':69,'ubo-set-local-storage-item':69,'set-popads-dummy':70,'popads-dummy.js':70,'ubo-popads-dummy.js':70,'ubo-popads-dummy':70,'set-session-storage-item':71,'set-session-storage-item.js':71,'ubo-set-session-storage-item.js':71,'ubo-set-session-storage-item':71,'spoof-css':72,'spoof-css.js':72,'ubo-spoof-css.js':72,'ubo-spoof-css':72,'trusted-click-element':73,'trusted-create-element':74,'trusted-dispatch-event':75,'trusted-prune-inbound-object':76,'trusted-replace-fetch-response':77,'trusted-replace-node-text':78,'trusted-replace-xhr-response':79,'trusted-set-attr':80,'trusted-set-constant':81,'trusted-set-cookie-reload':82,'trusted-set-cookie':83,'trusted-set-local-storage-item':84,'trusted-suppress-native-method':85,'xml-prune':86,'xml-prune.js':86,'ubo-xml-prune.js':86,'ubo-xml-prune':86}};



;// ./node_modules/.pnpm/@adguard+agtree@3.0.1/node_modules/@adguard/agtree/dist/utils/deep-freeze.js
/*
 * AGTree v3.0.1 (build date: Fri, 28 Feb 2025 15:31:12 GMT)
 * (c) 2025 Adguard Software Ltd.
 * Released under the MIT license
 * https://github.com/AdguardTeam/tsurlfilter/tree/master/packages/agtree#readme
 */
/**
 * Simple deep freeze implementation.
 * It freezes the object and all its properties recursively.
 *
 * @param object Object to freeze.
 *
 * @returns Frozen object.
 *
 * @template T Type of the object to freeze.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/freeze#deep_freezing}
 */
const deepFreeze = (object) => {
    // Retrieve the property names defined on object
    const propNames = Reflect.ownKeys(object);
    // Freeze properties before freezing self
    for (const name of propNames) {
        const value = object[name];
        if ((value && typeof value === 'object') || typeof value === 'function') {
            deepFreeze(value);
        }
    }
    return Object.freeze(object);
};



;// ./node_modules/.pnpm/@adguard+agtree@3.0.1/node_modules/@adguard/agtree/dist/utils/constants.js
/*
 * AGTree v3.0.1 (build date: Fri, 28 Feb 2025 15:31:12 GMT)
 * (c) 2025 Adguard Software Ltd.
 * Released under the MIT license
 * https://github.com/AdguardTeam/tsurlfilter/tree/master/packages/agtree#readme
 */
/**
 * @file Constant values used by all parts of the library
 */
// TODO: remove unused constants
// General
/**
 * Empty string.
 */
const EMPTY = '';
const SPACE = ' ';
const TAB = '\t';
const COLON = ':';
const COMMA = ',';
const DOT = '.';
const SEMICOLON = ';';
const AMPERSAND = '&';
const ASTERISK = '*';
const AT_SIGN = '@';
const CARET = '^';
const DOLLAR_SIGN = '$';
const EQUALS = '=';
const EXCLAMATION_MARK = '!';
const HASHMARK = '#';
const PIPE = '|';
const PLUS = '+';
const QUESTION_MARK = '?';
const SLASH = '/';
const UNDERSCORE = '_';
// Escape characters
const BACKSLASH = '\\';
const ESCAPE_CHARACTER = (/* unused pure expression or super */ null && (BACKSLASH));
// Newlines
const CR = '\r';
const FF = '\f';
const LF = '\n';
const CRLF = CR + LF;
const NEWLINE = (/* unused pure expression or super */ null && (LF));
// Quotes
const BACKTICK_QUOTE = '`';
const DOUBLE_QUOTE = '"';
const SINGLE_QUOTE = '\'';
// Brackets
const OPEN_PARENTHESIS = '(';
const CLOSE_PARENTHESIS = ')';
const OPEN_SQUARE_BRACKET = '[';
const CLOSE_SQUARE_BRACKET = ']';
const OPEN_CURLY_BRACKET = '{';
const CLOSE_CURLY_BRACKET = '}';
// Letters
const SMALL_LETTER_A = 'a';
const SMALL_LETTER_B = 'b';
const SMALL_LETTER_C = 'c';
const SMALL_LETTER_D = 'd';
const SMALL_LETTER_E = 'e';
const SMALL_LETTER_F = 'f';
const SMALL_LETTER_G = 'g';
const SMALL_LETTER_H = 'h';
const SMALL_LETTER_I = 'i';
const SMALL_LETTER_J = 'j';
const SMALL_LETTER_K = 'k';
const SMALL_LETTER_L = 'l';
const SMALL_LETTER_M = 'm';
const SMALL_LETTER_N = 'n';
const SMALL_LETTER_O = 'o';
const SMALL_LETTER_P = 'p';
const SMALL_LETTER_Q = 'q';
const SMALL_LETTER_R = 'r';
const SMALL_LETTER_S = 's';
const SMALL_LETTER_T = 't';
const SMALL_LETTER_U = 'u';
const SMALL_LETTER_V = 'v';
const SMALL_LETTER_W = 'w';
const SMALL_LETTER_X = 'x';
const SMALL_LETTER_Y = 'y';
const SMALL_LETTER_Z = 'z';
/**
 * Set of all small letters.
 */
const SMALL_LETTERS = new Set([
    SMALL_LETTER_A,
    SMALL_LETTER_B,
    SMALL_LETTER_C,
    SMALL_LETTER_D,
    SMALL_LETTER_E,
    SMALL_LETTER_F,
    SMALL_LETTER_G,
    SMALL_LETTER_H,
    SMALL_LETTER_I,
    SMALL_LETTER_J,
    SMALL_LETTER_K,
    SMALL_LETTER_L,
    SMALL_LETTER_M,
    SMALL_LETTER_N,
    SMALL_LETTER_O,
    SMALL_LETTER_P,
    SMALL_LETTER_Q,
    SMALL_LETTER_R,
    SMALL_LETTER_S,
    SMALL_LETTER_T,
    SMALL_LETTER_U,
    SMALL_LETTER_V,
    SMALL_LETTER_W,
    SMALL_LETTER_X,
    SMALL_LETTER_Y,
    SMALL_LETTER_Z,
]);
// Capital letters
const CAPITAL_LETTER_A = 'A';
const CAPITAL_LETTER_B = 'B';
const CAPITAL_LETTER_C = 'C';
const CAPITAL_LETTER_D = 'D';
const CAPITAL_LETTER_E = 'E';
const CAPITAL_LETTER_F = 'F';
const CAPITAL_LETTER_G = 'G';
const CAPITAL_LETTER_H = 'H';
const CAPITAL_LETTER_I = 'I';
const CAPITAL_LETTER_J = 'J';
const CAPITAL_LETTER_K = 'K';
const CAPITAL_LETTER_L = 'L';
const CAPITAL_LETTER_M = 'M';
const CAPITAL_LETTER_N = 'N';
const CAPITAL_LETTER_O = 'O';
const CAPITAL_LETTER_P = 'P';
const CAPITAL_LETTER_Q = 'Q';
const CAPITAL_LETTER_R = 'R';
const CAPITAL_LETTER_S = 'S';
const CAPITAL_LETTER_T = 'T';
const CAPITAL_LETTER_U = 'U';
const CAPITAL_LETTER_V = 'V';
const CAPITAL_LETTER_W = 'W';
const CAPITAL_LETTER_X = 'X';
const CAPITAL_LETTER_Y = 'Y';
const CAPITAL_LETTER_Z = 'Z';
/**
 * Set of all capital letters.
 */
const CAPITAL_LETTERS = new Set([
    CAPITAL_LETTER_A,
    CAPITAL_LETTER_B,
    CAPITAL_LETTER_C,
    CAPITAL_LETTER_D,
    CAPITAL_LETTER_E,
    CAPITAL_LETTER_F,
    CAPITAL_LETTER_G,
    CAPITAL_LETTER_H,
    CAPITAL_LETTER_I,
    CAPITAL_LETTER_J,
    CAPITAL_LETTER_K,
    CAPITAL_LETTER_L,
    CAPITAL_LETTER_M,
    CAPITAL_LETTER_N,
    CAPITAL_LETTER_O,
    CAPITAL_LETTER_P,
    CAPITAL_LETTER_Q,
    CAPITAL_LETTER_R,
    CAPITAL_LETTER_S,
    CAPITAL_LETTER_T,
    CAPITAL_LETTER_U,
    CAPITAL_LETTER_V,
    CAPITAL_LETTER_W,
    CAPITAL_LETTER_X,
    CAPITAL_LETTER_Y,
    CAPITAL_LETTER_Z,
]);
// Numbers as strings
const NUMBER_0 = '0';
const NUMBER_1 = '1';
const NUMBER_2 = '2';
const NUMBER_3 = '3';
const NUMBER_4 = '4';
const NUMBER_5 = '5';
const NUMBER_6 = '6';
const NUMBER_7 = '7';
const NUMBER_8 = '8';
const NUMBER_9 = '9';
/**
 * Set of all numbers as strings.
 */
const NUMBERS = new Set([
    NUMBER_0,
    NUMBER_1,
    NUMBER_2,
    NUMBER_3,
    NUMBER_4,
    NUMBER_5,
    NUMBER_6,
    NUMBER_7,
    NUMBER_8,
    NUMBER_9,
]);
const REGEX_MARKER = '/';
const ADG_SCRIPTLET_MASK = '//scriptlet';
const UBO_SCRIPTLET_MASK = '+js';
const UBO_SCRIPTLET_MASK_LEGACY = 'script:inject';
const UBO_HTML_MASK = '^';
// Modifiers are separated by ",". For example: "script,domain=example.com"
const MODIFIERS_SEPARATOR = ',';
const MODIFIER_ASSIGN_OPERATOR = '=';
const NEGATION_MARKER = '~';
/**
 * The wildcard symbol — `*`.
 */
const WILDCARD = (/* unused pure expression or super */ null && (ASTERISK));
/**
 * Classic domain separator.
 *
 * @example
 * ```adblock
 * ! Domains are separated by ",":
 * example.com,~example.org##.ads
 * ```
 */
const COMMA_DOMAIN_LIST_SEPARATOR = ',';
/**
 * Modifier separator for $app, $denyallow, $domain, $method.
 *
 * @example
 * ```adblock
 * ! Domains are separated by "|":
 * ads.js^$script,domains=example.com|~example.org
 * ```
 */
const PIPE_MODIFIER_SEPARATOR = '|';
const CSS_MEDIA_MARKER = '@media';
const CSS_NOT_PSEUDO = 'not';
const CSS_BLOCK_OPEN = '{';
const CSS_BLOCK_CLOSE = '}';
const HINT_MARKER = '!+';
const HINT_MARKER_LEN = HINT_MARKER.length;
const NETWORK_RULE_EXCEPTION_MARKER = '@@';
const NETWORK_RULE_EXCEPTION_MARKER_LEN = NETWORK_RULE_EXCEPTION_MARKER.length;
const NETWORK_RULE_SEPARATOR = '$';
const AGLINT_COMMAND_PREFIX = 'aglint';
const AGLINT_CONFIG_COMMENT_MARKER = '--';
const PREPROCESSOR_MARKER = '!#';
const PREPROCESSOR_MARKER_LEN = PREPROCESSOR_MARKER.length;
const PREPROCESSOR_SEPARATOR = ' ';
const SAFARI_CB_AFFINITY = 'safari_cb_affinity';
const IF = 'if';
const INCLUDE = 'include';
const NULL = 0;
const UINT8_MAX = 255;
const UINT16_MAX = 65535;



;// ./node_modules/.pnpm/@adguard+agtree@3.0.1/node_modules/@adguard/agtree/dist/compatibility-tables/modifiers.js
/*
 * AGTree v3.0.1 (build date: Fri, 28 Feb 2025 15:31:12 GMT)
 * (c) 2025 Adguard Software Ltd.
 * Released under the MIT license
 * https://github.com/AdguardTeam/tsurlfilter/tree/master/packages/agtree#readme
 */





/**
 * @file Compatibility tables for modifiers.
 */
/**
 * Transforms the name of the modifier to a normalized form.
 * This is a special case: the noop modifier normally '_', but it can consist of any number of characters,
 * e.g. '____' is also valid. In this case, we need to normalize the name to '_'.
 *
 * @param name Modifier name to normalize.
 * @returns Normalized modifier name.
 */
const noopModifierNameNormalizer = (name) => {
    if (name.startsWith(UNDERSCORE)) {
        if (name.split(EMPTY).every((char) => char === UNDERSCORE)) {
            // in compatibility tables, we just store '_', so we need to reduce the number of underscores to 1
            // before checking the existence of the noop modifier
            return UNDERSCORE;
        }
    }
    return name;
};
/**
 * Compatibility table for modifiers.
 */
class ModifiersCompatibilityTable extends CompatibilityTableBase {
    /**
     * Creates a new instance of the compatibility table for modifiers.
     *
     * @param data Compatibility table data.
     */
    constructor(data) {
        super(data, noopModifierNameNormalizer);
    }
}
/**
 * Deep freeze the compatibility table data to avoid accidental modifications.
 */
deepFreeze(modifiersCompatibilityTableData);
/**
 * Compatibility table instance for modifiers.
 */
const modifiers_modifiersCompatibilityTable = new ModifiersCompatibilityTable(modifiersCompatibilityTableData);



// EXTERNAL MODULE: ./node_modules/.pnpm/zod@3.21.4/node_modules/zod/lib/index.mjs
var lib = __webpack_require__(69509);
;// ./node_modules/.pnpm/@adguard+agtree@3.0.1/node_modules/@adguard/agtree/dist/compatibility-tables/schemas/resource-type.js
/*
 * AGTree v3.0.1 (build date: Fri, 28 Feb 2025 15:31:12 GMT)
 * (c) 2025 Adguard Software Ltd.
 * Released under the MIT license
 * https://github.com/AdguardTeam/tsurlfilter/tree/master/packages/agtree#readme
 */


/**
 * @file Resource type schema.
 */
/**
 * Resource type.
 *
 * @see {@link https://developer.chrome.com/docs/extensions/reference/declarativeNetRequest/#type-ResourceType}
 */
const resource_type_ResourceType = {
    MainFrame: 'main_frame',
    SubFrame: 'sub_frame',
    Stylesheet: 'stylesheet',
    Script: 'script',
    Image: 'image',
    Font: 'font',
    Object: 'object',
    XmlHttpRequest: 'xmlhttprequest',
    Ping: 'ping',
    Media: 'media',
    WebSocket: 'websocket',
    Other: 'other',
};
/**
 * Resource type schema.
 */
const resourceTypeSchema = lib/* default.nativeEnum */.Ay.nativeEnum(resource_type_ResourceType);



;// ./node_modules/.pnpm/@adguard+agtree@3.0.1/node_modules/@adguard/agtree/dist/compatibility-tables/utils/resource-type-helpers.js
/*
 * AGTree v3.0.1 (build date: Fri, 28 Feb 2025 15:31:12 GMT)
 * (c) 2025 Adguard Software Ltd.
 * Released under the MIT license
 * https://github.com/AdguardTeam/tsurlfilter/tree/master/packages/agtree#readme
 */




/**
 * Map of resource types to their corresponding adblock modifier names.
 *
 * @note Record type is used to ensure that all resource types are present in the map.
 */
const RESOURCE_TYPE_MODIFIER_MAP = Object.freeze({
    [resource_type_ResourceType.MainFrame]: 'document',
    [resource_type_ResourceType.SubFrame]: 'subdocument',
    [resource_type_ResourceType.Stylesheet]: 'stylesheet',
    [resource_type_ResourceType.Script]: 'script',
    [resource_type_ResourceType.Image]: 'image',
    [resource_type_ResourceType.Font]: 'font',
    [resource_type_ResourceType.Object]: 'object',
    [resource_type_ResourceType.XmlHttpRequest]: 'xmlhttprequest',
    [resource_type_ResourceType.Ping]: 'ping',
    [resource_type_ResourceType.Media]: 'media',
    [resource_type_ResourceType.WebSocket]: 'websocket',
    [resource_type_ResourceType.Other]: 'other',
});
/**
 * Gets the adblock modifier name for the given resource type.
 *
 * @param resourceType Resource type to get the modifier name for.
 * @param platform Platform to get the modifier for.
 *
 * @returns A string containing the adblock modifier name for the given resource type
 * or `null` if the modifier could not be found.
 */
const getResourceTypeModifier = (resourceType, platform) => {
    const modifierName = RESOURCE_TYPE_MODIFIER_MAP[resourceType];
    if (!modifierName) {
        return null;
    }
    const modifierData = modifiers_modifiersCompatibilityTable.getFirst(modifierName, platform);
    if (isNull(modifierData)) {
        return null;
    }
    return modifierData.name;
};
/**
 * Checks if the given resource type is valid.
 *
 * @param resourceType Resource type to check.
 *
 * @returns `true` if the resource type is valid, `false` otherwise.
 */
const isValidResourceType = (resourceType) => {
    return Object.values(ResourceType).includes(resourceType);
};



;// ./node_modules/.pnpm/@adguard+agtree@3.0.1/node_modules/@adguard/agtree/dist/compatibility-tables/redirects.js
/*
 * AGTree v3.0.1 (build date: Fri, 28 Feb 2025 15:31:12 GMT)
 * (c) 2025 Adguard Software Ltd.
 * Released under the MIT license
 * https://github.com/AdguardTeam/tsurlfilter/tree/master/packages/agtree#readme
 */







/**
 * @file Compatibility tables for redirects.
 */
/**
 * Prefix for resource redirection names.
 */
const ABP_RESOURCE_PREFIX = 'abp-resource:';
const ABP_RESOURCE_PREFIX_LENGTH = ABP_RESOURCE_PREFIX.length;
/**
 * Normalizes the redirect name.
 *
 * @param name Redirect name to normalize.
 *
 * @returns Normalized redirect name.
 *
 * @example
 * redirectNameNormalizer('abp-resource:my-resource') // => 'my-resource'
 * redirectNameNormalizer('noop.js:99') // => 'noop.js'
 */
const redirectNameNormalizer = (name) => {
    // Remove ABP resource prefix, if present
    if (name.startsWith(ABP_RESOURCE_PREFIX)) {
        return name.slice(ABP_RESOURCE_PREFIX_LENGTH);
    }
    // Remove :[integer] priority suffix from the name, if present
    // See:
    // - https://github.com/AdguardTeam/tsurlfilter/issues/59
    // - https://github.com/gorhill/uBlock/wiki/Static-filter-syntax#redirect
    const colonIndex = name.lastIndexOf(COLON);
    if (colonIndex !== -1 && /^\d+$/.test(name.slice(colonIndex + 1))) {
        return name.slice(0, colonIndex);
    }
    return name;
};
/**
 * Compatibility table for redirects.
 */
class RedirectsCompatibilityTable extends CompatibilityTableBase {
    /**
     * Creates a new instance of the compatibility table for redirects.
     *
     * @param data Compatibility table data.
     */
    constructor(data) {
        super(data, redirectNameNormalizer);
    }
    /**
     * Gets the resource type adblock modifiers for the redirect for the given platform
     * based on the `resourceTypes` field.
     *
     * @param redirect Redirect name or redirect data.
     * @param platform Platform to get the modifiers for.
     *
     * @returns Set of resource type modifiers or an empty set if the redirect is not found or has no resource types.
     */
    getResourceTypeModifiers(redirect, platform) {
        let redirectData = null;
        if (isString(redirect)) {
            redirectData = this.getFirst(redirect, platform);
        }
        else {
            redirectData = redirect;
        }
        const modifierNames = new Set();
        if (isNull(redirectData) || isUndefined(redirectData.resourceTypes)) {
            return modifierNames;
        }
        for (const resourceType of redirectData.resourceTypes) {
            const modifierName = getResourceTypeModifier(resourceType, platform);
            if (isNull(modifierName)) {
                continue;
            }
            modifierNames.add(modifierName);
        }
        return modifierNames;
    }
}
/**
 * Deep freeze the compatibility table data to avoid accidental modifications.
 */
deepFreeze(redirectsCompatibilityTableData);
/**
 * Compatibility table instance for redirects.
 */
const redirectsCompatibilityTable = new RedirectsCompatibilityTable(redirectsCompatibilityTableData);



;// ./node_modules/.pnpm/@adguard+scriptlets@2.1.6/node_modules/@adguard/scriptlets/dist/validators/index.js












var trustedClickElementNames = [ "trusted-click-element" ];

var abortOnPropertyReadNames = [ "abort-on-property-read", "abort-on-property-read.js", "ubo-abort-on-property-read.js", "aopr.js", "ubo-aopr.js", "ubo-abort-on-property-read", "ubo-aopr", "abp-abort-on-property-read" ];

var abortOnPropertyWriteNames = [ "abort-on-property-write", "abort-on-property-write.js", "ubo-abort-on-property-write.js", "aopw.js", "ubo-aopw.js", "ubo-abort-on-property-write", "ubo-aopw", "abp-abort-on-property-write" ];

var preventSetTimeoutNames = [ "prevent-setTimeout", "no-setTimeout-if.js", "ubo-no-setTimeout-if.js", "nostif.js", "ubo-nostif.js", "ubo-no-setTimeout-if", "ubo-nostif", "setTimeout-defuser.js", "ubo-setTimeout-defuser.js", "ubo-setTimeout-defuser", "std.js", "ubo-std.js", "ubo-std" ];

var preventSetIntervalNames = [ "prevent-setInterval", "no-setInterval-if.js", "ubo-no-setInterval-if.js", "setInterval-defuser.js", "ubo-setInterval-defuser.js", "nosiif.js", "ubo-nosiif.js", "sid.js", "ubo-sid.js", "ubo-no-setInterval-if", "ubo-setInterval-defuser", "ubo-nosiif", "ubo-sid" ];

var preventWindowOpenNames = [ "prevent-window-open", "window.open-defuser.js", "ubo-window.open-defuser.js", "ubo-window.open-defuser", "nowoif.js", "ubo-nowoif.js", "ubo-nowoif", "no-window-open-if.js", "ubo-no-window-open-if.js", "ubo-no-window-open-if" ];

var abortCurrentInlineScriptNames = [ "abort-current-inline-script", "abort-current-script.js", "ubo-abort-current-script.js", "acs.js", "ubo-acs.js", "ubo-abort-current-script", "ubo-acs", "abort-current-inline-script.js", "ubo-abort-current-inline-script.js", "acis.js", "ubo-acis.js", "ubo-abort-current-inline-script", "ubo-acis", "abp-abort-current-inline-script" ];

var setConstantNames = [ "set-constant", "set-constant.js", "ubo-set-constant.js", "set.js", "ubo-set.js", "ubo-set-constant", "ubo-set", "abp-override-property-read" ];

var removeCookieNames = [ "remove-cookie", "cookie-remover.js", "ubo-cookie-remover.js", "ubo-cookie-remover", "remove-cookie.js", "ubo-remove-cookie.js", "ubo-remove-cookie", "abp-cookie-remover" ];

var preventAddEventListenerNames = [ "prevent-addEventListener", "addEventListener-defuser.js", "ubo-addEventListener-defuser.js", "aeld.js", "ubo-aeld.js", "ubo-addEventListener-defuser", "ubo-aeld", "abp-prevent-listener" ];

var preventBabNames = [ "prevent-bab" ];

var nowebrtcNames = [ "nowebrtc", "nowebrtc.js", "ubo-nowebrtc.js", "ubo-nowebrtc" ];

var logAddEventListenerNames = [ "log-addEventListener", "addEventListener-logger.js", "ubo-addEventListener-logger.js", "aell.js", "ubo-aell.js", "ubo-addEventListener-logger", "ubo-aell" ];

var logEvalNames = [ "log-eval" ];

var logNames = [ "log", "abp-log" ];

var noevalNames = [ "noeval", "noeval.js", "silent-noeval.js", "ubo-noeval.js", "ubo-silent-noeval.js", "ubo-noeval", "ubo-silent-noeval" ];

var preventEvalIfNames = [ "prevent-eval-if", "noeval-if.js", "ubo-noeval-if.js", "ubo-noeval-if" ];

var preventFabNames = [ "prevent-fab-3.2.0", "nofab.js", "ubo-nofab.js", "fuckadblock.js-3.2.0", "ubo-fuckadblock.js-3.2.0", "ubo-nofab" ];

var setPopadsDummyNames = [ "set-popads-dummy", "popads-dummy.js", "ubo-popads-dummy.js", "ubo-popads-dummy" ];

var preventPopadsNetNames = [ "prevent-popads-net", "popads.net.js", "ubo-popads.net.js", "ubo-popads.net" ];

var preventAdflyNames = [ "prevent-adfly" ];

var debugOnPropertyReadNames = [ "debug-on-property-read" ];

var debugOnPropertyWriteNames = [ "debug-on-property-write" ];

var debugCurrentInlineScriptNames = [ "debug-current-inline-script" ];

var removeAttrNames = [ "remove-attr", "remove-attr.js", "ubo-remove-attr.js", "ra.js", "ubo-ra.js", "ubo-remove-attr", "ubo-ra" ];

var setAttrNames = [ "set-attr", "set-attr.js", "ubo-set-attr.js", "ubo-set-attr" ];

var removeClassNames = [ "remove-class", "remove-class.js", "ubo-remove-class.js", "rc.js", "ubo-rc.js", "ubo-remove-class", "ubo-rc" ];

var disableNewtabLinksNames = [ "disable-newtab-links", "disable-newtab-links.js", "ubo-disable-newtab-links.js", "ubo-disable-newtab-links" ];

var adjustSetIntervalNames = [ "adjust-setInterval", "nano-setInterval-booster.js", "ubo-nano-setInterval-booster.js", "nano-sib.js", "ubo-nano-sib.js", "adjust-setInterval.js", "ubo-adjust-setInterval.js", "ubo-nano-setInterval-booster", "ubo-nano-sib", "ubo-adjust-setInterval" ];

var adjustSetTimeoutNames = [ "adjust-setTimeout", "adjust-setTimeout.js", "ubo-adjust-setTimeout.js", "nano-setTimeout-booster.js", "ubo-nano-setTimeout-booster.js", "nano-stb.js", "ubo-nano-stb.js", "ubo-adjust-setTimeout", "ubo-nano-setTimeout-booster", "ubo-nano-stb" ];

var dirStringNames = [ "dir-string" ];

var jsonPruneNames = [ "json-prune", "json-prune.js", "ubo-json-prune.js", "ubo-json-prune", "abp-json-prune" ];

var preventRequestAnimationFrameNames = [ "prevent-requestAnimationFrame", "no-requestAnimationFrame-if.js", "ubo-no-requestAnimationFrame-if.js", "norafif.js", "ubo-norafif.js", "ubo-no-requestAnimationFrame-if", "ubo-norafif" ];

var setCookieNames = [ "set-cookie", "set-cookie.js", "ubo-set-cookie.js", "ubo-set-cookie" ];

var setCookieReloadNames = [ "set-cookie-reload", "set-cookie-reload.js", "ubo-set-cookie-reload.js", "ubo-set-cookie-reload" ];

var hideInShadowDomNames = [ "hide-in-shadow-dom" ];

var removeInShadowDomNames = [ "remove-in-shadow-dom" ];

var preventFetchNames = [ "prevent-fetch", "prevent-fetch.js", "ubo-prevent-fetch.js", "ubo-prevent-fetch", "no-fetch-if.js", "ubo-no-fetch-if.js", "ubo-no-fetch-if" ];

var setLocalStorageItemNames = [ "set-local-storage-item", "set-local-storage-item.js", "ubo-set-local-storage-item.js", "ubo-set-local-storage-item" ];

var setSessionStorageItemNames = [ "set-session-storage-item", "set-session-storage-item.js", "ubo-set-session-storage-item.js", "ubo-set-session-storage-item" ];

var abortOnStackTraceNames = [ "abort-on-stack-trace", "abort-on-stack-trace.js", "ubo-abort-on-stack-trace.js", "aost.js", "ubo-aost.js", "ubo-abort-on-stack-trace", "ubo-aost", "abp-abort-on-stack-trace" ];

var logOnStackTraceNames = [ "log-on-stack-trace" ];

var preventXHRNames = [ "prevent-xhr", "no-xhr-if.js", "ubo-no-xhr-if.js", "ubo-no-xhr-if" ];

var forceWindowCloseNames = [ "close-window", "window-close-if.js", "ubo-window-close-if.js", "ubo-window-close-if", "close-window.js", "ubo-close-window.js", "ubo-close-window" ];

var preventRefreshNames = [ "prevent-refresh", "prevent-refresh.js", "refresh-defuser.js", "refresh-defuser", "ubo-prevent-refresh.js", "ubo-prevent-refresh", "ubo-refresh-defuser.js", "ubo-refresh-defuser" ];

var preventElementSrcLoadingNames = [ "prevent-element-src-loading" ];

var noTopicsNames = [ "no-topics" ];

var trustedReplaceXhrResponseNames = [ "trusted-replace-xhr-response" ];

var xmlPruneNames = [ "xml-prune", "xml-prune.js", "ubo-xml-prune.js", "ubo-xml-prune" ];

var m3uPruneNames = [ "m3u-prune", "m3u-prune.js", "ubo-m3u-prune.js", "ubo-m3u-prune" ];

var trustedSetCookieNames = [ "trusted-set-cookie" ];

var trustedSetCookieReloadNames = [ "trusted-set-cookie-reload" ];

var trustedReplaceFetchResponseNames = [ "trusted-replace-fetch-response" ];

var trustedSetLocalStorageItemNames = [ "trusted-set-local-storage-item" ];

var trustedSetSessionStorageItemNames = [ "trusted-set-session-storage-item" ];

var trustedSetConstantNames = [ "trusted-set-constant" ];

var injectCssInShadowDomNames = [ "inject-css-in-shadow-dom" ];

var removeNodeTextNames = [ "remove-node-text", "remove-node-text.js", "ubo-remove-node-text.js", "rmnt.js", "ubo-rmnt.js", "ubo-remove-node-text", "ubo-rmnt" ];

var trustedReplaceNodeTextNames = [ "trusted-replace-node-text" ];

var evalDataPruneNames = [ "evaldata-prune", "evaldata-prune.js", "ubo-evaldata-prune.js", "ubo-evaldata-prune" ];

var trustedPruneInboundObjectNames = [ "trusted-prune-inbound-object" ];

var trustedSetAttrNames = [ "trusted-set-attr" ];

var spoofCSSNames = [ "spoof-css", "spoof-css.js", "ubo-spoof-css.js", "ubo-spoof-css" ];

var callNoThrowNames = [ "call-nothrow", "call-nothrow.js", "ubo-call-nothrow.js", "ubo-call-nothrow" ];

var trustedCreateElementNames = [ "trusted-create-element" ];

var hrefSanitizerNames = [ "href-sanitizer", "href-sanitizer.js", "ubo-href-sanitizer.js", "ubo-href-sanitizer" ];

var jsonPruneFetchResponseNames = [ "json-prune-fetch-response", "json-prune-fetch-response.js", "ubo-json-prune-fetch-response.js", "ubo-json-prune-fetch-response" ];

var noProtectedAudienceNames = [ "no-protected-audience" ];

var trustedSuppressNativeMethodNames = [ "trusted-suppress-native-method" ];

var jsonPruneXhrResponseNames = [ "json-prune-xhr-response", "json-prune-xhr-response.js", "ubo-json-prune-xhr-response.js", "ubo-json-prune-xhr-response" ];

var trustedDispatchEventNames = [ "trusted-dispatch-event" ];

var trustedReplaceOutboundTextNames = [ "trusted-replace-outbound-text" ];

var preventCanvasNames = [ "prevent-canvas", "prevent-canvas.js", "ubo-prevent-canvas.js", "ubo-prevent-canvas" ];

var AmazonApstagNames = [ "amazon-apstag", "ubo-amazon_apstag.js", "amazon_apstag.js" ];

var DidomiLoaderNames = [ "didomi-loader" ];

var Fingerprintjs2Names = [ "fingerprintjs2", "ubo-fingerprint2.js", "fingerprint2.js" ];

var Fingerprintjs3Names = [ "fingerprintjs3", "ubo-fingerprint3.js", "fingerprint3.js" ];

var GemiusNames = [ "gemius" ];

var GoogleAnalyticsNames = [ "google-analytics", "ubo-google-analytics_analytics.js", "google-analytics_analytics.js", "googletagmanager-gtm", "ubo-googletagmanager_gtm.js", "googletagmanager_gtm.js" ];

var GoogleAnalyticsGaNames = [ "google-analytics-ga", "ubo-google-analytics_ga.js", "google-analytics_ga.js" ];

var GoogleIma3Names = [ "google-ima3", "ubo-google-ima.js", "google-ima.js" ];

var GoogleSyndicationAdsByGoogleNames = [ "googlesyndication-adsbygoogle", "ubo-googlesyndication_adsbygoogle.js", "googlesyndication_adsbygoogle.js" ];

var GoogleTagServicesGptNames = [ "googletagservices-gpt", "ubo-googletagservices_gpt.js", "googletagservices_gpt.js" ];

var MatomoNames = [ "matomo" ];

var metrikaYandexTagNames = [ "metrika-yandex-tag" ];

var metrikaYandexWatchNames = [ "metrika-yandex-watch" ];

var NaverWcslogNames = [ "naver-wcslog" ];

var PardotNames = [ "pardot-1.0" ];

var PrebidNames = [ "prebid" ];

var ScoreCardResearchBeaconNames = [ "scorecardresearch-beacon", "ubo-scorecardresearch_beacon.js", "scorecardresearch_beacon.js" ];

var scriptletsNamesList = Object.freeze({
    __proto__: null,
    AmazonApstagNames: AmazonApstagNames,
    DidomiLoaderNames: DidomiLoaderNames,
    Fingerprintjs2Names: Fingerprintjs2Names,
    Fingerprintjs3Names: Fingerprintjs3Names,
    GemiusNames: GemiusNames,
    GoogleAnalyticsGaNames: GoogleAnalyticsGaNames,
    GoogleAnalyticsNames: GoogleAnalyticsNames,
    GoogleIma3Names: GoogleIma3Names,
    GoogleSyndicationAdsByGoogleNames: GoogleSyndicationAdsByGoogleNames,
    GoogleTagServicesGptNames: GoogleTagServicesGptNames,
    MatomoNames: MatomoNames,
    NaverWcslogNames: NaverWcslogNames,
    PardotNames: PardotNames,
    PrebidNames: PrebidNames,
    ScoreCardResearchBeaconNames: ScoreCardResearchBeaconNames,
    abortCurrentInlineScriptNames: abortCurrentInlineScriptNames,
    abortOnPropertyReadNames: abortOnPropertyReadNames,
    abortOnPropertyWriteNames: abortOnPropertyWriteNames,
    abortOnStackTraceNames: abortOnStackTraceNames,
    adjustSetIntervalNames: adjustSetIntervalNames,
    adjustSetTimeoutNames: adjustSetTimeoutNames,
    callNoThrowNames: callNoThrowNames,
    debugCurrentInlineScriptNames: debugCurrentInlineScriptNames,
    debugOnPropertyReadNames: debugOnPropertyReadNames,
    debugOnPropertyWriteNames: debugOnPropertyWriteNames,
    dirStringNames: dirStringNames,
    disableNewtabLinksNames: disableNewtabLinksNames,
    evalDataPruneNames: evalDataPruneNames,
    forceWindowCloseNames: forceWindowCloseNames,
    hideInShadowDomNames: hideInShadowDomNames,
    hrefSanitizerNames: hrefSanitizerNames,
    injectCssInShadowDomNames: injectCssInShadowDomNames,
    jsonPruneFetchResponseNames: jsonPruneFetchResponseNames,
    jsonPruneNames: jsonPruneNames,
    jsonPruneXhrResponseNames: jsonPruneXhrResponseNames,
    logAddEventListenerNames: logAddEventListenerNames,
    logEvalNames: logEvalNames,
    logNames: logNames,
    logOnStackTraceNames: logOnStackTraceNames,
    m3uPruneNames: m3uPruneNames,
    metrikaYandexTagNames: metrikaYandexTagNames,
    metrikaYandexWatchNames: metrikaYandexWatchNames,
    noProtectedAudienceNames: noProtectedAudienceNames,
    noTopicsNames: noTopicsNames,
    noevalNames: noevalNames,
    nowebrtcNames: nowebrtcNames,
    preventAddEventListenerNames: preventAddEventListenerNames,
    preventAdflyNames: preventAdflyNames,
    preventBabNames: preventBabNames,
    preventCanvasNames: preventCanvasNames,
    preventElementSrcLoadingNames: preventElementSrcLoadingNames,
    preventEvalIfNames: preventEvalIfNames,
    preventFabNames: preventFabNames,
    preventFetchNames: preventFetchNames,
    preventPopadsNetNames: preventPopadsNetNames,
    preventRefreshNames: preventRefreshNames,
    preventRequestAnimationFrameNames: preventRequestAnimationFrameNames,
    preventSetIntervalNames: preventSetIntervalNames,
    preventSetTimeoutNames: preventSetTimeoutNames,
    preventWindowOpenNames: preventWindowOpenNames,
    preventXHRNames: preventXHRNames,
    removeAttrNames: removeAttrNames,
    removeClassNames: removeClassNames,
    removeCookieNames: removeCookieNames,
    removeInShadowDomNames: removeInShadowDomNames,
    removeNodeTextNames: removeNodeTextNames,
    setAttrNames: setAttrNames,
    setConstantNames: setConstantNames,
    setCookieNames: setCookieNames,
    setCookieReloadNames: setCookieReloadNames,
    setLocalStorageItemNames: setLocalStorageItemNames,
    setPopadsDummyNames: setPopadsDummyNames,
    setSessionStorageItemNames: setSessionStorageItemNames,
    spoofCSSNames: spoofCSSNames,
    trustedClickElementNames: trustedClickElementNames,
    trustedCreateElementNames: trustedCreateElementNames,
    trustedDispatchEventNames: trustedDispatchEventNames,
    trustedPruneInboundObjectNames: trustedPruneInboundObjectNames,
    trustedReplaceFetchResponseNames: trustedReplaceFetchResponseNames,
    trustedReplaceNodeTextNames: trustedReplaceNodeTextNames,
    trustedReplaceOutboundTextNames: trustedReplaceOutboundTextNames,
    trustedReplaceXhrResponseNames: trustedReplaceXhrResponseNames,
    trustedSetAttrNames: trustedSetAttrNames,
    trustedSetConstantNames: trustedSetConstantNames,
    trustedSetCookieNames: trustedSetCookieNames,
    trustedSetCookieReloadNames: trustedSetCookieReloadNames,
    trustedSetLocalStorageItemNames: trustedSetLocalStorageItemNames,
    trustedSetSessionStorageItemNames: trustedSetSessionStorageItemNames,
    trustedSuppressNativeMethodNames: trustedSuppressNativeMethodNames,
    xmlPruneNames: xmlPruneNames
});

function _createForOfIteratorHelper(r, e) {
    var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"];
    if (!t) {
        if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e) {
            t && (r = t);
            var _n = 0, F = function F() {};
            return {
                s: F,
                n: function n() {
                    return _n >= r.length ? {
                        done: !0
                    } : {
                        done: !1,
                        value: r[_n++]
                    };
                },
                e: function e(r) {
                    throw r;
                },
                f: F
            };
        }
        throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    var o, a = !0, u = !1;
    return {
        s: function s() {
            t = t.call(r);
        },
        n: function n() {
            var r = t.next();
            return a = r.done, r;
        },
        e: function e(r) {
            u = !0, o = r;
        },
        f: function f() {
            try {
                a || null == t.return || t.return();
            } finally {
                if (u) throw o;
            }
        }
    };
}

function _unsupportedIterableToArray(r, a) {
    if (r) {
        if ("string" == typeof r) return _arrayLikeToArray(r, a);
        var t = {}.toString.call(r).slice(8, -1);
        return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0;
    }
}

function _arrayLikeToArray(r, a) {
    (null == a || a > r.length) && (a = r.length);
    for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e];
    return n;
}

var UBO_JS_SUFFIX = ".js";

var isScriptletRuleForSyntax = function isScriptletRuleForSyntax(rule, syntax) {
    try {
        var ruleNode = getRuleNode(rule);
        return ruleNode.category === RuleCategory.Cosmetic && ruleNode.type === CosmeticRuleType.ScriptletInjectionRule && ruleNode.syntax === syntax;
    } catch (e) {
        return false;
    }
};

var isAdgScriptletRule = function isAdgScriptletRule(rule) {
    return isScriptletRuleForSyntax(rule, AdblockSyntax.Adg);
};

var isUboScriptletRule = function isUboScriptletRule(rule) {
    return isScriptletRuleForSyntax(rule, AdblockSyntax.Ubo);
};

var isAbpSnippetRule = function isAbpSnippetRule(rule) {
    return isScriptletRuleForSyntax(rule, AdblockSyntax.Abp);
};

var scriptletsNamesContainer;

var getScriptletsNames = function getScriptletsNames() {
    if (scriptletsNamesContainer) {
        return scriptletsNamesContainer;
    }
    scriptletsNamesContainer = new Set;
    var names = Object.values(scriptletsNamesList).flat();
    scriptletsNamesContainer = new Set(names);
    return scriptletsNamesContainer;
};

var hasScriptlet = function hasScriptlet(name) {
    var scriptletsNames = getScriptletsNames();
    return scriptletsNames.has(name) || !name.endsWith(UBO_JS_SUFFIX) && scriptletsNames.has(`${name}${UBO_JS_SUFFIX}`);
};

var isValidScriptletNameNotCached = function isValidScriptletNameNotCached(name) {
    if (!name) {
        return false;
    }
    return hasScriptlet(name);
};

var scriptletNameValidationCache = new Map;

var isValidScriptletName = function isValidScriptletName(name) {
    if (name === "") {
        return true;
    }
    if (!name) {
        return false;
    }
    if (!scriptletNameValidationCache.has(name)) {
        var isValid = isValidScriptletNameNotCached(name);
        scriptletNameValidationCache.set(name, isValid);
        return isValid;
    }
    return scriptletNameValidationCache.get(name);
};

var isArrayOfScriptletRules = function isArrayOfScriptletRules(rules) {
    return rules.every((function(rule) {
        return rule.category === RuleCategory.Cosmetic && rule.type === CosmeticRuleType.ScriptletInjectionRule;
    }));
};

var isValidScriptletRule = function isValidScriptletRule(rule) {
    var ruleNodes;
    try {
        ruleNodes = RuleConverter.convertToAdg(getRuleNode(rule)).result;
    } catch (e) {
        return false;
    }
    if (!isArrayOfScriptletRules(ruleNodes)) {
        return false;
    }
    var isValid = ruleNodes.every((function(ruleNode) {
        var _ruleNode$body$childr;
        var name = (_ruleNode$body$childr = ruleNode.body.children[0]) === null || _ruleNode$body$childr === void 0 || (_ruleNode$body$childr = _ruleNode$body$childr.children[0]) === null || _ruleNode$body$childr === void 0 ? void 0 : _ruleNode$body$childr.value;
        if (!name) {
            return ruleNode.exception;
        }
        var unquotedName = QuoteUtils.removeQuotes(name);
        if (!unquotedName) {
            return false;
        }
        return isValidScriptletName(unquotedName);
    }));
    return isValid;
};

var POSSIBLE_REDIRECT_MODIFIERS = new Set([ "redirect", "redirect-rule", "rewrite" ]);

var getRedirectResourcesFromRule = function getRedirectResourcesFromRule(rule) {
    var result = [];
    try {
        var ruleNode = getRuleNode(rule);
        if (ruleNode.category !== RuleCategory.Network) {
            return result;
        }
        if (ruleNode.type !== NetworkRuleType.NetworkRule) {
            return result;
        }
        var ruleModifiers = ruleNode.modifiers;
        if (!ruleModifiers) {
            return result;
        }
        var _iterator = _createForOfIteratorHelper(ruleModifiers.children), _step;
        try {
            for (_iterator.s(); !(_step = _iterator.n()).done; ) {
                var el = _step.value;
                if (el.exception) {
                    continue;
                }
                if (POSSIBLE_REDIRECT_MODIFIERS.has(el.name.value)) {
                    var _el$value;
                    result.push({
                        modifier: el.name.value,
                        resource: (_el$value = el.value) === null || _el$value === void 0 ? void 0 : _el$value.value,
                        exceptionRule: ruleNode.exception
                    });
                }
            }
        } catch (err) {
            _iterator.e(err);
        } finally {
            _iterator.f();
        }
        return result;
    } catch (e) {
        return result;
    }
};

var isRedirectResourceCompatibleWithAdg = function isRedirectResourceCompatibleWithAdg(redirectName) {
    return redirectsCompatibilityTable.exists(redirectName, platforms_GenericPlatform.AdgAny);
};

var isValidAdgRedirectRule = function isValidAdgRedirectRule(rule) {
    var resources = getRedirectResourcesFromRule(rule);
    if (!resources.length || resources.length > 1) {
        return false;
    }
    var resource = resources[0];
    if (!resource.resource) {
        return resource.exceptionRule;
    }
    return modifiersCompatibilityTable.exists(resource.modifier, GenericPlatform.AdgAny) && isRedirectResourceCompatibleWithAdg(resource.resource);
};




/***/ }),

/***/ 44648:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  zV: () => (/* binding */ BufferRuleList),
  B$: () => (/* binding */ CSP_HEADER_NAME),
  YD: () => (/* binding */ CompatibilityTypes),
  jw: () => (/* binding */ CosmeticResult),
  N$: () => (/* binding */ Engine),
  aQ: () => (/* binding */ FilterListPreprocessor),
  tz: () => (/* binding */ NetworkRule),
  iR: () => (/* binding */ NetworkRuleOption),
  iw: () => (/* binding */ PERMISSIONS_POLICY_HEADER_NAME),
  Kd: () => (/* binding */ Request),
  Vf: () => (/* binding */ RuleFactory),
  _6: () => (/* binding */ RuleStorage),
  IE: () => (/* binding */ STEALTH_MODE_FILTER_ID),
  _L: () => (/* binding */ StealthOptionName),
  kn: () => (/* binding */ createAllowlistRuleList),
  B8: () => (/* binding */ filterListChunksValidator),
  kA: () => (/* binding */ filterListSourceMapValidator),
  xN: () => (/* binding */ setConfiguration)
});

// UNUSED EXPORTS: CookieModifier, CosmeticEngine, CosmeticOption, CosmeticRule, DnsEngine, DnsResult, HTTPMethod, HostRule, IndexedRule, IndexedStorageRule, LIST_ID_MAX_VALUE, MatchingResult, NETWORK_RULE_OPTIONS, NetworkEngine, NetworkRuleGroupOptions, OPTIONS_DELIMITER, PREPROCESSOR_AGTREE_OPTIONS, RULE_INDEX_NONE, RemoveHeaderModifier, RemoveParamModifier, ReplaceModifier, RequestType, RuleSyntaxUtils, SimpleRegex, TSURLFILTER_VERSION, cleanUrlParamByRegExp, config, countEnabledBits, fastHash, fetchExtensionResourceText, filterListConversionMapValidator, findNextLineBreakIndex, findNextUnescapedIndex, getBitCount, getIdFromFilterName, getRelativeUrl, getRuleSourceIndex, getRuleSourceText, hasSpaces, hasUnquotedSubstring, indexOfAny, isAlpha, isAlphaNumeric, isCompatibleWith, isHttpOrWsRequest, isNumber, isString, logger, preprocessedFilterListValidator, replaceAll, setLogger, splitByDelimiterWithEscapeCharacter, startsAtIndexWith, stringArraysEquals, stringArraysHaveIntersection, unescapeChar

// EXTERNAL MODULE: ./node_modules/.pnpm/@adguard+agtree@3.1.3/node_modules/@adguard/agtree/dist/utils/constants.js
var constants = __webpack_require__(27895);
// EXTERNAL MODULE: ./node_modules/.pnpm/@adguard+agtree@3.1.3/node_modules/@adguard/agtree/dist/utils/quotes.js
var quotes = __webpack_require__(31529);
// EXTERNAL MODULE: ./node_modules/.pnpm/@adguard+agtree@3.1.3/node_modules/@adguard/agtree/dist/utils/domain.js
var utils_domain = __webpack_require__(40680);
// EXTERNAL MODULE: ./node_modules/.pnpm/@adguard+agtree@3.1.3/node_modules/@adguard/agtree/dist/nodes/index.js
var nodes = __webpack_require__(91354);
// EXTERNAL MODULE: ./node_modules/.pnpm/@adguard+agtree@3.1.3/node_modules/@adguard/agtree/dist/utils/cosmetic-rule-separator.js
var cosmetic_rule_separator = __webpack_require__(80576);
// EXTERNAL MODULE: ./node_modules/.pnpm/@adguard+agtree@3.1.3/node_modules/@adguard/agtree/dist/utils/binary-schema-version.js
var binary_schema_version = __webpack_require__(75096);
// EXTERNAL MODULE: ./node_modules/.pnpm/@adguard+agtree@3.1.3/node_modules/@adguard/agtree/dist/utils/byte-buffer.js
var byte_buffer = __webpack_require__(50253);
// EXTERNAL MODULE: ./node_modules/.pnpm/@adguard+agtree@3.1.3/node_modules/@adguard/agtree/dist/utils/is-chromium.js
var is_chromium = __webpack_require__(36765);
;// ./node_modules/.pnpm/@adguard+agtree@3.1.3/node_modules/@adguard/agtree/dist/utils/text-encoder-polyfill.js
/*
 * AGTree v3.1.3 (build date: Tue, 29 Apr 2025 12:25:03 GMT)
 * (c) 2025 Adguard Software Ltd.
 * Released under the MIT license
 * https://github.com/AdguardTeam/tsurlfilter/tree/master/packages/agtree#readme
 */
/* eslint-disable no-param-reassign */
/* eslint-disable no-bitwise */
/**
 * @file Utility for encoding strings to byte sequences.
 */
/**
 * Checks if the given code point is an ASCII code point.
 *
 * @param codePoint Code point to check.
 * @returns `true` if the given code point is an ASCII code point, `false` otherwise.
 * @see {@link https://infra.spec.whatwg.org/#ascii-code-point}
 */
const isAsciiCodePoint = (codePoint) => {
    return codePoint >= 0x0000 && codePoint <= 0x007F;
};
const OFFSETS = [0xC0, 0xE0, 0xF0];
/**
 * Encodes an UTF-8 string into a byte sequence according to the WHATWG spec.
 *
 * @param str String to encode.
 * @param buffer Buffer to write the encoded bytes to.
 * @returns Number of bytes written to the buffer.
 * @see {@link https://encoding.spec.whatwg.org/#utf-8-encoder}
 * @note Bytes written maybe larger than the string length, but never smaller.
 * For example, the string '你好' has a length of 2, but its byte representation has a length of 6.
 */
const encodeIntoPolyfill = (str, buffer) => {
    const { length } = buffer;
    let read = 0;
    let written = 0;
    for (let i = 0; i < str.length;) {
        const codePoint = str.codePointAt(i) || 0;
        let bytesNeeded = 1;
        if (isAsciiCodePoint(codePoint)) {
            if (written >= length)
                break; // Stop if no space in buffer
            buffer[written] = codePoint;
            written += 1;
            read += 1; // Increment read for ASCII
            i += 1;
        }
        else {
            if (codePoint >= 0x0080 && codePoint <= 0x07FF) {
                bytesNeeded = 2;
            }
            else if (codePoint >= 0x0800 && codePoint <= 0xFFFF) {
                bytesNeeded = 3;
            }
            else if (codePoint >= 0x10000 && codePoint <= 0x10FFFF) {
                bytesNeeded = 4;
            }
            if (written + bytesNeeded - 1 >= length) {
                // Stop if no space for the whole encoding
                break;
            }
            let count = bytesNeeded - 1;
            const offset = OFFSETS[bytesNeeded - 2];
            buffer[written] = (codePoint >> (6 * count)) + offset;
            written += 1;
            while (count > 0) {
                buffer[written] = 0x80 | ((codePoint >> (6 * (count - 1))) & 0x3F);
                written += 1;
                count -= 1;
            }
            read += codePoint >= 0x10000 ? 2 : 1; // Increment read by 1 or 2 depending on code point
            i += codePoint >= 0x10000 ? 2 : 1; // Move i by 1 or 2
        }
    }
    return { read, written };
};



;// ./node_modules/.pnpm/@adguard+agtree@3.1.3/node_modules/@adguard/agtree/dist/utils/output-byte-buffer.js
/*
 * AGTree v3.1.3 (build date: Tue, 29 Apr 2025 12:25:03 GMT)
 * (c) 2025 Adguard Software Ltd.
 * Released under the MIT license
 * https://github.com/AdguardTeam/tsurlfilter/tree/master/packages/agtree#readme
 */





/* eslint-disable no-plusplus */
/* eslint-disable no-bitwise */
/**
 * @file Output byte buffer for writing binary data.
 */
/**
 * Output byte buffer for writing binary data.
 *
 * @note Internally, this class uses a {@link ByteBuffer} instance, just providing a convenient API for reading data.
 */
class OutputByteBuffer extends byte_buffer/* ByteBuffer */.$ {
    /**
     * Current offset in the buffer for writing.
     */
    offset;
    /**
     * Size of the shared buffer for encoding strings in bytes.
     * This is a divisor of ByteBuffer.CHUNK_SIZE and experience shows that this value works optimally.
     * This is sufficient for most strings that occur in filter lists (we checked average string length in popular
     * filter lists).
     */
    static ENCODER_BUFFER_SIZE = 8192;
    /**
     * Length threshold for using a shared buffer for encoding strings.
     * This temp buffer is needed because we write the short strings in it
     * (so there is no need to constantly allocate a new buffer).
     * The reason for dividing ENCODER_BUFFER_SIZE by 4 is to ensure that the encoded string fits in the buffer,
     * if we also take into account the worst possible case (each character is encoded with 4 bytes).
     */
    static SHORT_STRING_THRESHOLD = 2048; // 8192 / 4
    /**
     * Represents the maximum value that can be written as a 'storage optimized' unsigned integer.
     * 0x1FFFFFFF means 29 bits — 32 bits minus 3 bits — because the last bit in each byte is a flag indicating
     * if there are more bytes (except for the last byte).
     */
    static MAX_OPTIMIZED_UINT = 0x1FFFFFFF;
    /**
     * Shared buffer for encoding strings.
     */
    sharedBuffer;
    /**
     * Shared native encoder for encoding strings.
     */
    sharedNativeEncoder;
    /**
     * Flag indicating if the current environment is Chromium.
     * This is used for performance optimizations, because Chromium's TextEncoder/TextDecoder has a relatively
     * large marshalling overhead for small strings.
     */
    isChromium;
    /**
     * Constructs a new OutputByteBuffer instance.
     */
    // TODO: add chunks as a parameter, if ever needed
    constructor() {
        super();
        this.sharedBuffer = new Uint8Array(OutputByteBuffer.ENCODER_BUFFER_SIZE);
        this.sharedNativeEncoder = new TextEncoder();
        this.isChromium = (0,is_chromium/* isChromium */.F)();
        // write the schema version at the beginning of the buffer
        this.writeUint32ToIndex(binary_schema_version/* BINARY_SCHEMA_VERSION */.T, 0);
        this.offset = 4; // schema version is already written
    }
    /**
     * Writes a 8-bit unsigned integer to the buffer.
     *
     * @param value Value to write.
     * @returns Number of bytes written to the buffer.
     */
    writeUint8(value) {
        this.writeByte(this.offset++, value);
        return 1;
    }
    /**
     * Writes a 16-bit unsigned integer to the buffer.
     *
     * @param value Value to write.
     * @returns Number of bytes written to the buffer.
     */
    writeUint16(value) {
        this.writeByte(this.offset++, value >> 8);
        this.writeByte(this.offset++, value);
        return 2;
    }
    /**
     * Writes a 32-bit unsigned integer to the buffer at a specific index.
     *
     * @param value Value to write.
     * @param index Index to write the value to.
     * @returns Number of bytes written to the buffer.
     */
    writeUint32ToIndex(value, index) {
        this.writeByte(index, value >> 24);
        this.writeByte(index + 1, value >> 16);
        this.writeByte(index + 2, value >> 8);
        this.writeByte(index + 3, value);
        return 4;
    }
    /**
     * Writes a 32-bit unsigned integer to the buffer.
     *
     * @param value Value to write.
     * @returns Number of bytes written to the buffer.
     */
    writeUint32(value) {
        this.writeUint32ToIndex(value, this.offset);
        this.offset += 4;
        return 4;
    }
    /**
     * Writes a 32-bit signed integer to the buffer.
     *
     * @param value Value to write.
     * @returns Number of bytes written to the buffer.
     */
    writeInt32(value) {
        return this.writeUint32(value ? value >>> 0 : 0);
    }
    /**
     * Writes a Uint8Array to the byte buffer.
     *
     * @param buffer Buffer to write.
     */
    writeBuffer(buffer) {
        const { length } = buffer;
        this.ensureCapacity(this.offset + length);
        let chunkIndex = this.offset >>> 0x000F;
        let chunkOffset = this.offset & 0x7FFF;
        let remainingBytes = length;
        while (remainingBytes) {
            const leftInChunk = byte_buffer/* ByteBuffer */.$.CHUNK_SIZE - chunkOffset;
            const bytesToWrite = Math.min(remainingBytes, leftInChunk);
            this.chunks[chunkIndex].set(buffer.subarray(length - remainingBytes, length - remainingBytes + bytesToWrite), chunkOffset);
            remainingBytes -= bytesToWrite;
            chunkIndex += 1;
            chunkOffset = 0;
        }
    }
    /**
     * Writes a string to the buffer.
     *
     * @param value Value to write.
     * @returns Number of bytes written to the buffer.
     */
    writeString(value) {
        const start = this.offset;
        if (value.length <= OutputByteBuffer.SHORT_STRING_THRESHOLD) {
            let bytesWritten;
            if (this.isChromium) {
                bytesWritten = encodeIntoPolyfill(value, this.sharedBuffer).written ?? 0;
            }
            else {
                bytesWritten = this.sharedNativeEncoder.encodeInto(value, this.sharedBuffer).written ?? 0;
            }
            this.writeOptimizedUint(bytesWritten);
            this.writeBuffer(this.sharedBuffer.subarray(0, bytesWritten));
            this.offset += bytesWritten;
            return this.offset - start;
        }
        // TODO: Optimize for long strings, if needed. Not a common case for our use case
        const buffer = this.sharedNativeEncoder.encode(value);
        const bytesWritten = buffer.length;
        this.writeOptimizedUint(bytesWritten);
        this.writeBuffer(buffer);
        this.offset += bytesWritten;
        return this.offset - start;
    }
    /**
     * Writes chunks to the storage.
     *
     * @param storage Storage to write the chunks to.
     * @param key Key to write the chunks to.
     * @note For performance reasons, chunks are passed by reference and not copied.
     * @throws If the storage write operation throws.
     */
    async writeChunksToStorage(storage, key) {
        await storage.set(key, this.chunks);
    }
    /**
     * Writes an 'optimized' unsigned integer to the buffer.
     * 'Optimized' means smaller storage usage for smaller numbers.
     * Except for the last byte, each byte's most significant bit is a flag indicating if there are more bytes.
     *
     * @param value Value to write.
     * @returns Number of bytes written to the buffer.
     * @throws If the value exceeds the 29-bit limit.
     */
    writeOptimizedUint(value) {
        if (value < 0 || value > OutputByteBuffer.MAX_OPTIMIZED_UINT) {
            throw new Error('Value exceeds 29-bit limit');
        }
        let remainingValue = value;
        const startOffset = this.offset;
        while (remainingValue >= 0x80) {
            const byteValue = remainingValue & 0x7F;
            remainingValue >>>= 7;
            this.writeByte(this.offset++, byteValue | 0x80);
        }
        this.writeByte(this.offset++, remainingValue);
        return this.offset - startOffset;
    }
    /**
     * Gets the current offset in the buffer for writing.
     *
     * @returns Current offset in the buffer for writing.
     */
    get currentOffset() {
        return this.offset;
    }
    /**
     * Gets the chunks of the buffer.
     *
     * @returns Chunks of the buffer.
     */
    getChunks() {
        return this.chunks;
    }
}



// EXTERNAL MODULE: ./node_modules/.pnpm/tldts@5.7.112/node_modules/tldts/dist/es6/index.js + 12 modules
var es6 = __webpack_require__(13548);
// EXTERNAL MODULE: ./node_modules/.pnpm/@adguard+agtree@3.1.3/node_modules/@adguard/agtree/dist/parser/misc/domain-list-parser.js + 1 modules
var domain_list_parser = __webpack_require__(2607);
// EXTERNAL MODULE: ./node_modules/.pnpm/@adguard+agtree@3.1.3/node_modules/@adguard/agtree/dist/parser/options.js
var options = __webpack_require__(49604);
// EXTERNAL MODULE: ./node_modules/.pnpm/@adguard+agtree@3.1.3/node_modules/@adguard/agtree/dist/parser/rule-parser.js + 21 modules
var rule_parser = __webpack_require__(12320);
// EXTERNAL MODULE: ./node_modules/.pnpm/@adguard+tsurlfilter@3.3.0-alpha.0_@adguard+re2-wasm@1.2.0/node_modules/@adguard/tsurlfilter/dist/es/simple-regex-BBjA8AEZ.js
var simple_regex_BBjA8AEZ = __webpack_require__(87070);
// EXTERNAL MODULE: ./node_modules/.pnpm/@adguard+scriptlets@2.1.6/node_modules/@adguard/scriptlets/dist/scriptlets/index.js
var scriptlets = __webpack_require__(3030);
// EXTERNAL MODULE: ./node_modules/.pnpm/@adguard+scriptlets@2.1.6/node_modules/@adguard/scriptlets/dist/validators/index.js + 12 modules
var validators = __webpack_require__(66448);
// EXTERNAL MODULE: ./node_modules/.pnpm/@adguard+agtree@3.1.3/node_modules/@adguard/agtree/dist/generator/cosmetic/cosmetic-rule-body-generator.js + 4 modules
var cosmetic_rule_body_generator = __webpack_require__(67918);
// EXTERNAL MODULE: ./node_modules/.pnpm/@adguard+agtree@3.1.3/node_modules/@adguard/agtree/dist/generator/rule-generator.js + 18 modules
var rule_generator = __webpack_require__(98154);
// EXTERNAL MODULE: ./node_modules/.pnpm/@adguard+css-tokenizer@1.2.0/node_modules/@adguard/css-tokenizer/dist/csstokenizer.mjs
var csstokenizer = __webpack_require__(25651);
// EXTERNAL MODULE: ./node_modules/.pnpm/zod@3.21.4/node_modules/zod/lib/index.mjs
var lib = __webpack_require__(69509);
// EXTERNAL MODULE: ./node_modules/.pnpm/zod-validation-error@3.4.0_zod@3.21.4/node_modules/zod-validation-error/dist/index.mjs
var dist = __webpack_require__(51851);
// EXTERNAL MODULE: ./node_modules/.pnpm/@adguard+tsurlfilter@3.3.0-alpha.0_@adguard+re2-wasm@1.2.0/node_modules/@adguard/tsurlfilter/dist/es/network-rule-options.js
var network_rule_options = __webpack_require__(99626);
// EXTERNAL MODULE: ./node_modules/.pnpm/@adguard+tsurlfilter@3.3.0-alpha.0_@adguard+re2-wasm@1.2.0/node_modules/@adguard/tsurlfilter/dist/es/request-type.js
var request_type = __webpack_require__(30070);
// EXTERNAL MODULE: ./node_modules/.pnpm/is-cidr@4.0.2/node_modules/is-cidr/index.js
var is_cidr = __webpack_require__(32537);
// EXTERNAL MODULE: ./node_modules/.pnpm/is-ip@3.1.0/node_modules/is-ip/index.js
var is_ip = __webpack_require__(85183);
// EXTERNAL MODULE: ./node_modules/.pnpm/cidr-tools@6.4.2/node_modules/cidr-tools/index.js + 3 modules
var cidr_tools = __webpack_require__(47562);
// EXTERNAL MODULE: ./node_modules/.pnpm/lru-cache@11.0.2/node_modules/lru-cache/dist/esm/index.js
var esm = __webpack_require__(38037);
// EXTERNAL MODULE: ./node_modules/.pnpm/@adguard+agtree@3.1.3/node_modules/@adguard/agtree/dist/utils/adblockers.js
var adblockers = __webpack_require__(73734);
// EXTERNAL MODULE: ./node_modules/.pnpm/@adguard+agtree@3.1.3/node_modules/@adguard/agtree/dist/utils/input-byte-buffer.js + 2 modules
var input_byte_buffer = __webpack_require__(72313);
// EXTERNAL MODULE: ./node_modules/.pnpm/@adguard+agtree@3.1.3/node_modules/@adguard/agtree/dist/deserializer/rule-deserializer.js + 32 modules
var rule_deserializer = __webpack_require__(51935);
// EXTERNAL MODULE: ./node_modules/.pnpm/@adguard+agtree@3.1.3/node_modules/@adguard/agtree/dist/converter/rule.js + 33 modules
var rule = __webpack_require__(49415);
// EXTERNAL MODULE: ./node_modules/.pnpm/@adguard+agtree@3.1.3/node_modules/@adguard/agtree/dist/serializer/base-serializer.js
var base_serializer = __webpack_require__(45577);
// EXTERNAL MODULE: ./node_modules/.pnpm/@adguard+agtree@3.1.3/node_modules/@adguard/agtree/dist/utils/type-guards.js
var type_guards = __webpack_require__(8123);
// EXTERNAL MODULE: ./node_modules/.pnpm/@adguard+agtree@3.1.3/node_modules/@adguard/agtree/dist/marshalling-utils/misc/value-common.js
var value_common = __webpack_require__(54749);
// EXTERNAL MODULE: ./node_modules/.pnpm/@adguard+agtree@3.1.3/node_modules/@adguard/agtree/dist/marshalling-utils/misc/binary-type-common.js
var binary_type_common = __webpack_require__(82938);
;// ./node_modules/.pnpm/@adguard+agtree@3.1.3/node_modules/@adguard/agtree/dist/serializer/misc/value-serializer.js
/*
 * AGTree v3.1.3 (build date: Tue, 29 Apr 2025 12:25:03 GMT)
 * (c) 2025 Adguard Software Ltd.
 * Released under the MIT license
 * https://github.com/AdguardTeam/tsurlfilter/tree/master/packages/agtree#readme
 */






/**
 * Value serializer.
 */
class ValueSerializer extends base_serializer/* BaseSerializer */.S {
    /**
     * Serializes a value node to binary format.
     *
     * @param node Node to serialize.
     * @param buffer ByteBuffer for writing binary data.
     * @param frequentValuesMap Optional map of frequent values.
     * @param toLower Whether to lowercase the value before the frequent value match (defaults to `false`).
     */
    static serialize(node, buffer, frequentValuesMap, toLower = false) {
        buffer.writeUint8(binary_type_common/* BinaryTypeMarshallingMap */.u.ValueNode);
        const frequentValue = frequentValuesMap?.get(toLower ? node.value.toLowerCase() : node.value);
        // note: do not use just `if (frequentValue)` because it can be 0
        if (!(0,type_guards/* isUndefined */.b0)(frequentValue)) {
            buffer.writeUint8(value_common/* ValueNodeMarshallingMap */.e.FrequentValue);
            buffer.writeUint8(frequentValue);
        }
        else {
            buffer.writeUint8(value_common/* ValueNodeMarshallingMap */.e.Value);
            buffer.writeString(node.value);
        }
        // note: do not use just `if (node.start)` because it can be 0
        if (!(0,type_guards/* isUndefined */.b0)(node.start)) {
            buffer.writeUint8(value_common/* ValueNodeMarshallingMap */.e.Start);
            buffer.writeUint32(node.start);
        }
        if (!(0,type_guards/* isUndefined */.b0)(node.end)) {
            buffer.writeUint8(value_common/* ValueNodeMarshallingMap */.e.End);
            buffer.writeUint32(node.end);
        }
        buffer.writeUint8(constants/* NULL */.Cq);
    }
}



// EXTERNAL MODULE: ./node_modules/.pnpm/@adguard+agtree@3.1.3/node_modules/@adguard/agtree/dist/marshalling-utils/comment/agent-common.js
var agent_common = __webpack_require__(60390);
;// ./node_modules/.pnpm/@adguard+agtree@3.1.3/node_modules/@adguard/agtree/dist/serializer/comment/agent-serializer.js
/*
 * AGTree v3.1.3 (build date: Tue, 29 Apr 2025 12:25:03 GMT)
 * (c) 2025 Adguard Software Ltd.
 * Released under the MIT license
 * https://github.com/AdguardTeam/tsurlfilter/tree/master/packages/agtree#readme
 */







/**
 * Value map for binary serialization. This helps to reduce the size of the serialized data,
 * as it allows us to use a single byte to represent frequently used values.
 *
 * ! IMPORTANT: If you change values here, please update the {@link BINARY_SCHEMA_VERSION}!
 *
 * @note Only 256 values can be represented this way.
 */
let frequentAgentsSerializationMap;
const getFrequentAgentsSerializationMap = () => {
    if (!frequentAgentsSerializationMap) {
        frequentAgentsSerializationMap = new Map(Array.from(agent_common/* FREQUENT_AGENTS_DESERIALIZATION_MAP */.h).map(([key, value]) => [value.toLowerCase(), key]));
    }
    return frequentAgentsSerializationMap;
};
/**
 * `AgentSerializer` is responsible for serializing single adblock agent elements into a binary format.
 */
class AgentSerializer extends base_serializer/* BaseSerializer */.S {
    /**
     * Serializes an agent node to binary format.
     *
     * @param node Node to serialize.
     * @param buffer ByteBuffer for writing binary data.
     */
    static serialize(node, buffer) {
        buffer.writeUint8(binary_type_common/* BinaryTypeMarshallingMap */.u.AgentNode);
        buffer.writeUint8(agent_common/* AgentNodeMarshallingMap */.o.Adblock);
        ValueSerializer.serialize(node.adblock, buffer, getFrequentAgentsSerializationMap(), true);
        if (!(0,type_guards/* isUndefined */.b0)(node.version)) {
            buffer.writeUint8(agent_common/* AgentNodeMarshallingMap */.o.Version);
            ValueSerializer.serialize(node.version, buffer);
        }
        if (!(0,type_guards/* isUndefined */.b0)(node.start)) {
            buffer.writeUint8(agent_common/* AgentNodeMarshallingMap */.o.Start);
            buffer.writeUint32(node.start);
        }
        if (!(0,type_guards/* isUndefined */.b0)(node.end)) {
            buffer.writeUint8(agent_common/* AgentNodeMarshallingMap */.o.End);
            buffer.writeUint32(node.end);
        }
        buffer.writeUint8(constants/* NULL */.Cq);
    }
}



// EXTERNAL MODULE: ./node_modules/.pnpm/@adguard+agtree@3.1.3/node_modules/@adguard/agtree/dist/marshalling-utils/comment/agent-comment-common.js
var agent_comment_common = __webpack_require__(23070);
;// ./node_modules/.pnpm/@adguard+agtree@3.1.3/node_modules/@adguard/agtree/dist/serializer/comment/agent-comment-serializer.js
/*
 * AGTree v3.1.3 (build date: Tue, 29 Apr 2025 12:25:03 GMT)
 * (c) 2025 Adguard Software Ltd.
 * Released under the MIT license
 * https://github.com/AdguardTeam/tsurlfilter/tree/master/packages/agtree#readme
 */







/**
 * `AgentCommentSerializer` is responsible for serializing an Adblock agent comments.
 * Adblock agent comment marks that the filter list is supposed to
 * be used by the specified ad blockers.
 *
 * @example
 *  - ```adblock
 *    [AdGuard]
 *    ```
 *  - ```adblock
 *    [Adblock Plus 2.0]
 *    ```
 *  - ```adblock
 *    [uBlock Origin]
 *    ```
 *  - ```adblock
 *    [uBlock Origin 1.45.3]
 *    ```
 *  - ```adblock
 *    [Adblock Plus 2.0; AdGuard]
 *    ```
 */
class AgentCommentSerializer extends base_serializer/* BaseSerializer */.S {
    /**
     * Serializes an adblock agent list node to binary format.
     *
     * @param node Node to serialize.
     * @param buffer ByteBuffer for writing binary data.
     */
    // TODO: add support for raws, if ever needed
    static serialize(node, buffer) {
        buffer.writeUint8(binary_type_common/* BinaryTypeMarshallingMap */.u.AgentRuleNode);
        const count = node.children.length;
        // If there are no children, we do not write any data related to them, to avoid using unnecessary storage,
        // but children is a required field, so during deserialization we should initialize it as an empty array,
        // if there are no children in the binary data.
        if (count) {
            buffer.writeUint8(agent_comment_common/* AgentCommentMarshallingMap */.j.Children);
            // note: we store the count, because re-construction of the array is faster if we know the length
            // 8 bits is more than enough here
            if (count > constants/* UINT8_MAX */.II) {
                throw new Error(`Too many children: ${count}, the limit is ${constants/* UINT8_MAX */.II}`);
            }
            buffer.writeUint8(count);
            for (let i = 0; i < count; i += 1) {
                AgentSerializer.serialize(node.children[i], buffer);
            }
        }
        if (!(0,type_guards/* isUndefined */.b0)(node.start)) {
            buffer.writeUint8(agent_comment_common/* AgentCommentMarshallingMap */.j.Start);
            buffer.writeUint32(node.start);
        }
        if (!(0,type_guards/* isUndefined */.b0)(node.end)) {
            buffer.writeUint8(agent_comment_common/* AgentCommentMarshallingMap */.j.End);
            buffer.writeUint32(node.end);
        }
        buffer.writeUint8(constants/* NULL */.Cq);
    }
}



// EXTERNAL MODULE: ./node_modules/.pnpm/@adguard+agtree@3.1.3/node_modules/@adguard/agtree/dist/marshalling-utils/misc/parameter-list-common.js
var parameter_list_common = __webpack_require__(21434);
;// ./node_modules/.pnpm/@adguard+agtree@3.1.3/node_modules/@adguard/agtree/dist/serializer/misc/parameter-list-serializer.js
/*
 * AGTree v3.1.3 (build date: Tue, 29 Apr 2025 12:25:03 GMT)
 * (c) 2025 Adguard Software Ltd.
 * Released under the MIT license
 * https://github.com/AdguardTeam/tsurlfilter/tree/master/packages/agtree#readme
 */







/**
 * Serializer for parameter list nodes.
 */
class ParameterListSerializer extends base_serializer/* BaseSerializer */.S {
    /**
     * Serializes a parameter list node to binary format.
     *
     * @param node Node to serialize.
     * @param buffer ByteBuffer for writing binary data.
     * @param frequentValuesMap Optional map of frequent values.
     * @param toLower Whether to lowercase the value before the frequent value match (defaults to `false`).
     */
    static serialize(node, buffer, frequentValuesMap, toLower = false) {
        buffer.writeUint8(binary_type_common/* BinaryTypeMarshallingMap */.u.ParameterListNode);
        const count = node.children.length;
        buffer.writeUint8(parameter_list_common/* ParameterListNodeMarshallingMap */._.Children);
        // note: we store the count, because re-construction of the array is faster if we know the length
        buffer.writeUint32(count);
        for (let i = 0; i < count; i += 1) {
            const child = node.children[i];
            if ((0,type_guards/* isNull */.kZ)(child)) {
                buffer.writeUint8(binary_type_common/* BinaryTypeMarshallingMap */.u.Null);
                continue;
            }
            ValueSerializer.serialize(child, buffer, frequentValuesMap, toLower);
        }
        if (!(0,type_guards/* isUndefined */.b0)(node.start)) {
            buffer.writeUint8(parameter_list_common/* ParameterListNodeMarshallingMap */._.Start);
            buffer.writeUint32(node.start);
        }
        if (!(0,type_guards/* isUndefined */.b0)(node.end)) {
            buffer.writeUint8(parameter_list_common/* ParameterListNodeMarshallingMap */._.End);
            buffer.writeUint32(node.end);
        }
        buffer.writeUint8(constants/* NULL */.Cq);
    }
}



// EXTERNAL MODULE: ./node_modules/.pnpm/@adguard+agtree@3.1.3/node_modules/@adguard/agtree/dist/marshalling-utils/comment/config-comment-common.js
var config_comment_common = __webpack_require__(92379);
;// ./node_modules/.pnpm/@adguard+agtree@3.1.3/node_modules/@adguard/agtree/dist/serializer/comment/config-comment-serializer.js
/*
 * AGTree v3.1.3 (build date: Tue, 29 Apr 2025 12:25:03 GMT)
 * (c) 2025 Adguard Software Ltd.
 * Released under the MIT license
 * https://github.com/AdguardTeam/tsurlfilter/tree/master/packages/agtree#readme
 */








/**
 * `ConfigCommentSerializer` is responsible for serializing inline AGLint configuration rules into a binary format.
 * Generally, the idea is inspired by ESLint inline configuration comments.
 *
 * @see {@link https://eslint.org/docs/latest/user-guide/configuring/rules#using-configuration-comments}
 */
class ConfigCommentSerializer extends base_serializer/* BaseSerializer */.S {
    /**
     * Serializes a config node to binary format.
     *
     * @param node Node to serialize.
     * @param buffer ByteBuffer for writing binary data.
     */
    static serializeConfigNode(node, buffer) {
        buffer.writeUint8(binary_type_common/* BinaryTypeMarshallingMap */.u.ConfigNode);
        buffer.writeUint8(config_comment_common/* ConfigNodeMarshallingMap */.H4.Value);
        // note: we don't support serializing generic objects, only AGTree nodes
        // this is a very special case, so we just stringify the configuration object
        buffer.writeString(JSON.stringify(node.value));
        if (!(0,type_guards/* isUndefined */.b0)(node.start)) {
            buffer.writeUint8(config_comment_common/* ConfigNodeMarshallingMap */.H4.Start);
            buffer.writeUint32(node.start);
        }
        if (!(0,type_guards/* isUndefined */.b0)(node.end)) {
            buffer.writeUint8(config_comment_common/* ConfigNodeMarshallingMap */.H4.End);
            buffer.writeUint32(node.end);
        }
        buffer.writeUint8(constants/* NULL */.Cq);
    }
    /**
     * Serializes a metadata comment node to binary format.
     *
     * @param node Node to serialize.
     * @param buffer ByteBuffer for writing binary data.
     */
    // TODO: add support for raws, if ever needed
    static serialize(node, buffer) {
        buffer.writeUint8(binary_type_common/* BinaryTypeMarshallingMap */.u.ConfigCommentRuleNode);
        buffer.writeUint8(config_comment_common/* ConfigCommentRuleMarshallingMap */.E0.Marker);
        ValueSerializer.serialize(node.marker, buffer);
        buffer.writeUint8(config_comment_common/* ConfigCommentRuleMarshallingMap */.E0.Command);
        ValueSerializer.serialize(node.command, buffer, config_comment_common/* FREQUENT_COMMANDS_SERIALIZATION_MAP */.O6, true);
        if (!(0,type_guards/* isUndefined */.b0)(node.params)) {
            buffer.writeUint8(config_comment_common/* ConfigCommentRuleMarshallingMap */.E0.Params);
            if (node.params.type === 'ParameterList') {
                ParameterListSerializer.serialize(node.params, buffer);
            }
            else {
                ConfigCommentSerializer.serializeConfigNode(node.params, buffer);
            }
        }
        if (!(0,type_guards/* isUndefined */.b0)(node.comment)) {
            buffer.writeUint8(config_comment_common/* ConfigCommentRuleMarshallingMap */.E0.Comment);
            ValueSerializer.serialize(node.comment, buffer);
        }
        if (!(0,type_guards/* isUndefined */.b0)(node.start)) {
            buffer.writeUint8(config_comment_common/* ConfigCommentRuleMarshallingMap */.E0.Start);
            buffer.writeUint32(node.start);
        }
        if (!(0,type_guards/* isUndefined */.b0)(node.end)) {
            buffer.writeUint8(config_comment_common/* ConfigCommentRuleMarshallingMap */.E0.End);
            buffer.writeUint32(node.end);
        }
        buffer.writeUint8(constants/* NULL */.Cq);
    }
}



// EXTERNAL MODULE: ./node_modules/.pnpm/@adguard+agtree@3.1.3/node_modules/@adguard/agtree/dist/marshalling-utils/comment/hint-common.js
var hint_common = __webpack_require__(1622);
;// ./node_modules/.pnpm/@adguard+agtree@3.1.3/node_modules/@adguard/agtree/dist/serializer/comment/hint-serializer.js
/*
 * AGTree v3.1.3 (build date: Tue, 29 Apr 2025 12:25:03 GMT)
 * (c) 2025 Adguard Software Ltd.
 * Released under the MIT license
 * https://github.com/AdguardTeam/tsurlfilter/tree/master/packages/agtree#readme
 */








/**
 * `HintSerializer` is responsible for serializing AdGuard hints.
 *
 * @example
 * If the hint rule is
 * ```adblock
 * !+ NOT_OPTIMIZED PLATFORM(windows)
 * ```
 * then the hints are `NOT_OPTIMIZED` and `PLATFORM(windows)`, and this
 * class is responsible for parsing them. The rule itself is parsed by
 * the `HintRuleParser`, which uses this class to parse single hints.
 */
class HintSerializer extends base_serializer/* BaseSerializer */.S {
    /**
     * Serializes a hint node to binary format.
     *
     * @param node Node to serialize.
     * @param buffer ByteBuffer for writing binary data.
     */
    static serialize(node, buffer) {
        buffer.writeUint8(binary_type_common/* BinaryTypeMarshallingMap */.u.HintNode);
        buffer.writeUint8(hint_common/* HintNodeMarshallingMap */.ae.Name);
        ValueSerializer.serialize(node.name, buffer, hint_common/* FREQUENT_HINTS_SERIALIZATION_MAP */.EX);
        if (!(0,type_guards/* isUndefined */.b0)(node.params)) {
            buffer.writeUint8(hint_common/* HintNodeMarshallingMap */.ae.Params);
            ParameterListSerializer.serialize(node.params, buffer, hint_common/* FREQUENT_PLATFORMS_SERIALIZATION_MAP */.QE);
        }
        if (!(0,type_guards/* isUndefined */.b0)(node.start)) {
            buffer.writeUint8(hint_common/* HintNodeMarshallingMap */.ae.Start);
            buffer.writeUint32(node.start);
        }
        if (!(0,type_guards/* isUndefined */.b0)(node.end)) {
            buffer.writeUint8(hint_common/* HintNodeMarshallingMap */.ae.End);
            buffer.writeUint32(node.end);
        }
        buffer.writeUint8(constants/* NULL */.Cq);
    }
}



// EXTERNAL MODULE: ./node_modules/.pnpm/@adguard+agtree@3.1.3/node_modules/@adguard/agtree/dist/marshalling-utils/comment/hint-comment-common.js
var hint_comment_common = __webpack_require__(89518);
// EXTERNAL MODULE: ./node_modules/.pnpm/@adguard+agtree@3.1.3/node_modules/@adguard/agtree/dist/marshalling-utils/syntax-serialization-map.js
var syntax_serialization_map = __webpack_require__(42912);
;// ./node_modules/.pnpm/@adguard+agtree@3.1.3/node_modules/@adguard/agtree/dist/serializer/comment/hint-comment-serializer.js
/*
 * AGTree v3.1.3 (build date: Tue, 29 Apr 2025 12:25:03 GMT)
 * (c) 2025 Adguard Software Ltd.
 * Released under the MIT license
 * https://github.com/AdguardTeam/tsurlfilter/tree/master/packages/agtree#readme
 */









/**
 * `HintCommentSerializer` is responsible for serializing AdGuard hint rules.
 *
 * @example
 * The following hint rule
 * ```adblock
 * !+ NOT_OPTIMIZED PLATFORM(windows)
 * ```
 * contains two hints: `NOT_OPTIMIZED` and `PLATFORM`.
 * @see {@link https://kb.adguard.com/en/general/how-to-create-your-own-ad-filters#hints}
 */
class HintCommentSerializer extends base_serializer/* BaseSerializer */.S {
    /**
     * Serializes a hint rule node to binary format.
     *
     * @param node Node to serialize.
     * @param buffer ByteBuffer for writing binary data.
     */
    // TODO: add support for raws, if ever needed
    static serialize(node, buffer) {
        buffer.writeUint8(binary_type_common/* BinaryTypeMarshallingMap */.u.HintRuleNode);
        if (node.syntax === adblockers/* AdblockSyntax */.Y.Adg) {
            buffer.writeUint8(hint_comment_common/* HintCommentMarshallingMap */.r.Syntax);
            buffer.writeUint8((0,syntax_serialization_map/* getSyntaxSerializationMap */.M)().get(adblockers/* AdblockSyntax */.Y.Adg) ?? 0);
        }
        const count = node.children.length;
        // If there are no children, we do not write any data related to them, to avoid using unnecessary storage,
        // but children is a required field, so during deserialization we should initialize it as an empty array,
        // if there are no children in the binary data.
        if (count) {
            buffer.writeUint8(hint_comment_common/* HintCommentMarshallingMap */.r.Children);
            // note: we store the count, because re-construction of the array is faster if we know the length
            buffer.writeUint8(count);
            for (let i = 0; i < count; i += 1) {
                HintSerializer.serialize(node.children[i], buffer);
            }
        }
        if (!(0,type_guards/* isUndefined */.b0)(node.start)) {
            buffer.writeUint8(hint_comment_common/* HintCommentMarshallingMap */.r.Start);
            buffer.writeUint32(node.start);
        }
        if (!(0,type_guards/* isUndefined */.b0)(node.end)) {
            buffer.writeUint8(hint_comment_common/* HintCommentMarshallingMap */.r.End);
            buffer.writeUint32(node.end);
        }
        buffer.writeUint8(constants/* NULL */.Cq);
    }
}



// EXTERNAL MODULE: ./node_modules/.pnpm/@adguard+agtree@3.1.3/node_modules/@adguard/agtree/dist/marshalling-utils/comment/metadata-comment-common.js
var metadata_comment_common = __webpack_require__(218);
;// ./node_modules/.pnpm/@adguard+agtree@3.1.3/node_modules/@adguard/agtree/dist/serializer/comment/metadata-comment-serializer.js
/*
 * AGTree v3.1.3 (build date: Tue, 29 Apr 2025 12:25:03 GMT)
 * (c) 2025 Adguard Software Ltd.
 * Released under the MIT license
 * https://github.com/AdguardTeam/tsurlfilter/tree/master/packages/agtree#readme
 */







/**
 * Value map for binary serialization. This helps to reduce the size of the serialized data,
 * as it allows us to use a single byte to represent frequently used values.
 *
 * ! IMPORTANT: If you change values here, please update the {@link BINARY_SCHEMA_VERSION}!
 *
 * @note Only 256 values can be represented this way.
 * @note This map is generated from `FREQUENT_HEADERS_DESERIALIZATION_MAP` to keep uppercase characters
 * while deserializing.
 */
let frequentHeadersSerializationMap;
const getFrequentHeadersSerializationMap = () => {
    if (!frequentHeadersSerializationMap) {
        frequentHeadersSerializationMap = new Map(Array.from(metadata_comment_common/* FREQUENT_HEADERS_DESERIALIZATION_MAP */.l.entries())
            .map(([key, value]) => [value.toLowerCase(), key]));
    }
    return frequentHeadersSerializationMap;
};
/**
 * `MetadataCommentSerializer` is responsible for serializing metadata comments.
 * Metadata comments are special comments that specify some properties of the list.
 *
 * @example
 * For example, in the case of
 * ```adblock
 * ! Title: My List
 * ```
 * the name of the header is `Title`, and the value is `My List`, which means that
 * the list title is `My List`, and it can be used in the adblocker UI.
 * @see {@link https://help.eyeo.com/adblockplus/how-to-write-filters#special-comments}
 */
class MetadataCommentSerializer extends base_serializer/* BaseSerializer */.S {
    /**
     * Serializes a metadata comment node to binary format.
     *
     * @param node Node to serialize.
     * @param buffer ByteBuffer for writing binary data.
     */
    // TODO: add support for raws, if ever needed
    static serialize(node, buffer) {
        buffer.writeUint8(binary_type_common/* BinaryTypeMarshallingMap */.u.MetadataCommentRuleNode);
        buffer.writeUint8(metadata_comment_common/* MetadataCommentMarshallingMap */.Z.Marker);
        ValueSerializer.serialize(node.marker, buffer);
        buffer.writeUint8(metadata_comment_common/* MetadataCommentMarshallingMap */.Z.Header);
        ValueSerializer.serialize(node.header, buffer, getFrequentHeadersSerializationMap(), true);
        buffer.writeUint8(metadata_comment_common/* MetadataCommentMarshallingMap */.Z.Value);
        ValueSerializer.serialize(node.value, buffer);
        if (!(0,type_guards/* isUndefined */.b0)(node.start)) {
            buffer.writeUint8(metadata_comment_common/* MetadataCommentMarshallingMap */.Z.Start);
            buffer.writeUint32(node.start);
        }
        if (!(0,type_guards/* isUndefined */.b0)(node.end)) {
            buffer.writeUint8(metadata_comment_common/* MetadataCommentMarshallingMap */.Z.End);
            buffer.writeUint32(node.end);
        }
        buffer.writeUint8(constants/* NULL */.Cq);
    }
}



// EXTERNAL MODULE: ./node_modules/.pnpm/@adguard+agtree@3.1.3/node_modules/@adguard/agtree/dist/serializer/misc/logical-expression-serializer.js
var logical_expression_serializer = __webpack_require__(63113);
// EXTERNAL MODULE: ./node_modules/.pnpm/@adguard+agtree@3.1.3/node_modules/@adguard/agtree/dist/marshalling-utils/comment/pre-processor-comment-common.js
var pre_processor_comment_common = __webpack_require__(3025);
;// ./node_modules/.pnpm/@adguard+agtree@3.1.3/node_modules/@adguard/agtree/dist/serializer/comment/pre-processor-comment-serializer.js
/*
 * AGTree v3.1.3 (build date: Tue, 29 Apr 2025 12:25:03 GMT)
 * (c) 2025 Adguard Software Ltd.
 * Released under the MIT license
 * https://github.com/AdguardTeam/tsurlfilter/tree/master/packages/agtree#readme
 */










/**
 * `PreProcessorSerializer` is responsible for serializing preprocessor rules.
 * Pre-processor comments are special comments that are used to control the behavior of the filter list processor.
 * Please note that this parser only handles general syntax for now, and does not validate the parameters at
 * the parsing stage.
 *
 * @example
 * If your rule is
 * ```adblock
 * !#if (adguard)
 * ```
 * then the directive's name is `if` and its value is `(adguard)`, but the parameter list
 * is not parsed / validated further.
 * @see {@link https://kb.adguard.com/en/general/how-to-create-your-own-ad-filters#pre-processor-directives}
 * @see {@link https://github.com/gorhill/uBlock/wiki/Static-filter-syntax#pre-parsing-directives}
 */
class PreProcessorCommentSerializer extends base_serializer/* BaseSerializer */.S {
    /**
     * Serializes a pre-processor comment node to binary format.
     *
     * @param node Node to serialize.
     * @param buffer ByteBuffer for writing binary data.
     */
    // TODO: add support for raws, if ever needed
    static serialize(node, buffer) {
        buffer.writeUint8(binary_type_common/* BinaryTypeMarshallingMap */.u.PreProcessorCommentRuleNode);
        buffer.writeUint8(pre_processor_comment_common/* PreProcessorRuleMarshallingMap */.Qz.Name);
        ValueSerializer.serialize(node.name, buffer, pre_processor_comment_common/* FREQUENT_DIRECTIVES_SERIALIZATION_MAP */.u_);
        buffer.writeUint8(pre_processor_comment_common/* PreProcessorRuleMarshallingMap */.Qz.Syntax);
        buffer.writeUint8((0,syntax_serialization_map/* getSyntaxSerializationMap */.M)().get(node.syntax) ?? 0);
        if (!(0,type_guards/* isUndefined */.b0)(node.params)) {
            buffer.writeUint8(pre_processor_comment_common/* PreProcessorRuleMarshallingMap */.Qz.Params);
            if (node.params.type === 'Value') {
                ValueSerializer.serialize(node.params, buffer);
            }
            else if (node.params.type === 'ParameterList') {
                ParameterListSerializer.serialize(node.params, buffer, pre_processor_comment_common/* FREQUENT_PARAMS_SERIALIZATION_MAP */.k7, true);
            }
            else {
                logical_expression_serializer/* LogicalExpressionSerializer */.y.serialize(node.params, buffer);
            }
        }
        if (!(0,type_guards/* isUndefined */.b0)(node.start)) {
            buffer.writeUint8(pre_processor_comment_common/* PreProcessorRuleMarshallingMap */.Qz.Start);
            buffer.writeUint32(node.start);
        }
        if (!(0,type_guards/* isUndefined */.b0)(node.end)) {
            buffer.writeUint8(pre_processor_comment_common/* PreProcessorRuleMarshallingMap */.Qz.End);
            buffer.writeUint32(node.end);
        }
        buffer.writeUint8(constants/* NULL */.Cq);
    }
}



// EXTERNAL MODULE: ./node_modules/.pnpm/@adguard+agtree@3.1.3/node_modules/@adguard/agtree/dist/marshalling-utils/comment/simple-comment-common.js
var simple_comment_common = __webpack_require__(94807);
;// ./node_modules/.pnpm/@adguard+agtree@3.1.3/node_modules/@adguard/agtree/dist/serializer/comment/simple-comment-serializer.js
/*
 * AGTree v3.1.3 (build date: Tue, 29 Apr 2025 12:25:03 GMT)
 * (c) 2025 Adguard Software Ltd.
 * Released under the MIT license
 * https://github.com/AdguardTeam/tsurlfilter/tree/master/packages/agtree#readme
 */







/**
 * `SimpleCommentSerializer` is responsible for serializing simple comments.
 * Some comments have a special meaning in adblock syntax, like agent comments or hints,
 * but this serializer is only responsible for serializing regular comments,
 * whose only purpose is to provide some human-readable information.
 *
 * @example
 * ```adblock
 * ! This is a simple comment
 * # This is a simple comment, but in host-like syntax
 * ```
 */
class SimpleCommentSerializer extends base_serializer/* BaseSerializer */.S {
    /**
     * Serializes a simple comment rule node to binary format.
     *
     * @param node Node to serialize.
     * @param buffer ByteBuffer for writing binary data.
     */
    // TODO: add support for raws, if ever needed
    static serialize(node, buffer) {
        buffer.writeUint8(binary_type_common/* BinaryTypeMarshallingMap */.u.CommentRuleNode);
        buffer.writeUint8(simple_comment_common/* SimpleCommentMarshallingMap */.i.Marker);
        ValueSerializer.serialize(node.marker, buffer);
        buffer.writeUint8(simple_comment_common/* SimpleCommentMarshallingMap */.i.Text);
        ValueSerializer.serialize(node.text, buffer);
        if (!(0,type_guards/* isUndefined */.b0)(node.start)) {
            buffer.writeUint8(simple_comment_common/* SimpleCommentMarshallingMap */.i.Start);
            buffer.writeUint32(node.start);
        }
        if (!(0,type_guards/* isUndefined */.b0)(node.end)) {
            buffer.writeUint8(simple_comment_common/* SimpleCommentMarshallingMap */.i.End);
            buffer.writeUint32(node.end);
        }
        buffer.writeUint8(constants/* NULL */.Cq);
    }
}



;// ./node_modules/.pnpm/@adguard+agtree@3.1.3/node_modules/@adguard/agtree/dist/serializer/comment/comment-rule-serializer.js
/*
 * AGTree v3.1.3 (build date: Tue, 29 Apr 2025 12:25:03 GMT)
 * (c) 2025 Adguard Software Ltd.
 * Released under the MIT license
 * https://github.com/AdguardTeam/tsurlfilter/tree/master/packages/agtree#readme
 */









/**
 * `CommentRuleSerializer` is responsible for serializing any comment-like adblock rules.
 *
 * @example
 * Example rules:
 *  - Adblock agent rules:
 *      - ```adblock
 *        [AdGuard]
 *        ```
 *      - ```adblock
 *        [Adblock Plus 2.0]
 *        ```
 *      - etc.
 *  - AdGuard hint rules:
 *      - ```adblock
 *        !+ NOT_OPTIMIZED
 *        ```
 *      - ```adblock
 *        !+ NOT_OPTIMIZED PLATFORM(windows)
 *        ```
 *      - etc.
 *  - Pre-processor rules:
 *      - ```adblock
 *        !#if (adguard)
 *        ```
 *      - ```adblock
 *        !#endif
 *        ```
 *      - etc.
 *  - Metadata rules:
 *      - ```adblock
 *        ! Title: My List
 *        ```
 *      - ```adblock
 *        ! Version: 2.0.150
 *        ```
 *      - etc.
 *  - AGLint inline config rules:
 *      - ```adblock
 *        ! aglint-enable some-rule
 *        ```
 *      - ```adblock
 *        ! aglint-disable some-rule
 *        ```
 *      - etc.
 *  - Simple comments:
 *      - Regular version:
 *        ```adblock
 *        ! This is just a comment
 *        ```
 *      - uBlock Origin / "hostlist" version:
 *        ```adblock
 *        # This is just a comment
 *        ```
 *      - etc.
 */
class CommentRuleSerializer extends base_serializer/* BaseSerializer */.S {
    /**
     * Serializes a comment rule node to binary format.
     *
     * @param node Node to serialize.
     * @param buffer ByteBuffer for writing binary data.
     */
    static serialize(node, buffer) {
        switch (node.type) {
            case nodes/* CommentRuleType */.gV.AgentCommentRule:
                AgentCommentSerializer.serialize(node, buffer);
                return;
            case nodes/* CommentRuleType */.gV.HintCommentRule:
                HintCommentSerializer.serialize(node, buffer);
                return;
            case nodes/* CommentRuleType */.gV.PreProcessorCommentRule:
                PreProcessorCommentSerializer.serialize(node, buffer);
                return;
            case nodes/* CommentRuleType */.gV.MetadataCommentRule:
                MetadataCommentSerializer.serialize(node, buffer);
                return;
            case nodes/* CommentRuleType */.gV.ConfigCommentRule:
                ConfigCommentSerializer.serialize(node, buffer);
                return;
            case nodes/* CommentRuleType */.gV.CommentRule:
                SimpleCommentSerializer.serialize(node, buffer);
                break;
            default:
                throw new Error('Unknown comment rule type');
        }
    }
}



// EXTERNAL MODULE: ./node_modules/.pnpm/@adguard+agtree@3.1.3/node_modules/@adguard/agtree/dist/marshalling-utils/misc/list-item-common.js
var list_item_common = __webpack_require__(4402);
;// ./node_modules/.pnpm/@adguard+agtree@3.1.3/node_modules/@adguard/agtree/dist/serializer/misc/list-item-serializer.js
/*
 * AGTree v3.1.3 (build date: Tue, 29 Apr 2025 12:25:03 GMT)
 * (c) 2025 Adguard Software Ltd.
 * Released under the MIT license
 * https://github.com/AdguardTeam/tsurlfilter/tree/master/packages/agtree#readme
 */







/**
 * Serializer for list item nodes.
 */
class ListItemSerializer extends base_serializer/* BaseSerializer */.S {
    /**
     * Serializes a list item to binary format.
     *
     * @param item List item to serialize.
     * @param buffer Output byte buffer.
     * @template T Type of the list item.
     */
    static serialize(item, buffer) {
        switch (item.type) {
            case nodes/* ListItemNodeType */.WR.App:
                buffer.writeUint8(binary_type_common/* BinaryTypeMarshallingMap */.u.AppNode);
                break;
            case nodes/* ListItemNodeType */.WR.Domain:
                buffer.writeUint8(binary_type_common/* BinaryTypeMarshallingMap */.u.DomainNode);
                break;
            case nodes/* ListItemNodeType */.WR.Method:
                buffer.writeUint8(binary_type_common/* BinaryTypeMarshallingMap */.u.MethodNode);
                break;
            case nodes/* ListItemNodeType */.WR.StealthOption:
                buffer.writeUint8(binary_type_common/* BinaryTypeMarshallingMap */.u.StealthOptionNode);
                break;
            default:
                throw new Error(`Invalid list item type: ${item.type}`);
        }
        buffer.writeUint8(list_item_common/* ListItemMarshallingMap */.i.Exception);
        buffer.writeUint8(item.exception ? 1 : 0);
        buffer.writeUint8(list_item_common/* ListItemMarshallingMap */.i.Value);
        buffer.writeString(item.value);
        if (!(0,type_guards/* isUndefined */.b0)(item.start)) {
            buffer.writeUint8(list_item_common/* ListItemMarshallingMap */.i.Start);
            buffer.writeUint32(item.start);
        }
        if (!(0,type_guards/* isUndefined */.b0)(item.end)) {
            buffer.writeUint8(list_item_common/* ListItemMarshallingMap */.i.End);
            buffer.writeUint32(item.end);
        }
        buffer.writeUint8(constants/* NULL */.Cq);
    }
}



;// ./node_modules/.pnpm/@adguard+agtree@3.1.3/node_modules/@adguard/agtree/dist/serializer/misc/list-items-serializer.js
/*
 * AGTree v3.1.3 (build date: Tue, 29 Apr 2025 12:25:03 GMT)
 * (c) 2025 Adguard Software Ltd.
 * Released under the MIT license
 * https://github.com/AdguardTeam/tsurlfilter/tree/master/packages/agtree#readme
 */


/**
 * Serializer for list items.
 */
class ListItemsSerializer {
    /**
     * Serializes a list of items to binary format.
     *
     * @param items List of items to serialize.
     * @param buffer Output byte buffer.
     * @template T Type of the list items.
     */
    static serialize(items, buffer) {
        const { length } = items;
        buffer.writeUint16(length);
        for (let i = 0; i < length; i += 1) {
            ListItemSerializer.serialize(items[i], buffer);
        }
    }
}



// EXTERNAL MODULE: ./node_modules/.pnpm/@adguard+agtree@3.1.3/node_modules/@adguard/agtree/dist/marshalling-utils/misc/domain-list-common.js
var domain_list_common = __webpack_require__(53967);
;// ./node_modules/.pnpm/@adguard+agtree@3.1.3/node_modules/@adguard/agtree/dist/serializer/misc/domain-list-serializer.js
/*
 * AGTree v3.1.3 (build date: Tue, 29 Apr 2025 12:25:03 GMT)
 * (c) 2025 Adguard Software Ltd.
 * Released under the MIT license
 * https://github.com/AdguardTeam/tsurlfilter/tree/master/packages/agtree#readme
 */







/**
 * Value map for binary serialization. This helps to reduce the size of the serialized data,
 * as it allows us to use a single byte to represent frequently used values.
 *
 * ! IMPORTANT: If you change values here, please update the {@link BINARY_SCHEMA_VERSION}!
 *
 * @note Only 256 values can be represented this way.
 */
const SEPARATOR_SERIALIZATION_MAP = new Map([
    [constants/* COMMA */.KE, 0],
    [constants/* PIPE */.L5, 1],
]);
/**
 * `DomainListSerializer` is responsible for serializing a domain list.
 *
 * @example
 * - If the rule is `example.com,~example.net##.ads`, the domain list is `example.com,~example.net`.
 * - If the rule is `ads.js^$script,domains=example.com|~example.org`, the domain list is `example.com|~example.org`.
 * This serializer is responsible for serializing these domain lists.
 * @see {@link https://help.eyeo.com/adblockplus/how-to-write-filters#elemhide_domains}
 */
class DomainListSerializer extends base_serializer/* BaseSerializer */.S {
    /**
     * Serializes a domain list node to binary format.
     *
     * @param node Node to serialize.
     * @param buffer ByteBuffer for writing binary data.
     */
    static serialize(node, buffer) {
        buffer.writeUint8(binary_type_common/* BinaryTypeMarshallingMap */.u.DomainListNode);
        const separator = SEPARATOR_SERIALIZATION_MAP.get(node.separator);
        if ((0,type_guards/* isUndefined */.b0)(separator)) {
            throw new Error(`Invalid separator: ${node.separator}`);
        }
        buffer.writeUint8(domain_list_common/* DomainListMarshallingMap */.T.Separator);
        buffer.writeUint8(separator);
        buffer.writeUint8(domain_list_common/* DomainListMarshallingMap */.T.Children);
        ListItemsSerializer.serialize(node.children, buffer);
        if (!(0,type_guards/* isUndefined */.b0)(node.start)) {
            buffer.writeUint8(domain_list_common/* DomainListMarshallingMap */.T.Start);
            buffer.writeUint32(node.start);
        }
        if (!(0,type_guards/* isUndefined */.b0)(node.end)) {
            buffer.writeUint8(domain_list_common/* DomainListMarshallingMap */.T.End);
            buffer.writeUint32(node.end);
        }
        buffer.writeUint8(constants/* NULL */.Cq);
    }
}



// EXTERNAL MODULE: ./node_modules/.pnpm/@adguard+agtree@3.1.3/node_modules/@adguard/agtree/dist/marshalling-utils/cosmetic/body/abp-snippet-injection-body-common.js
var abp_snippet_injection_body_common = __webpack_require__(7552);
;// ./node_modules/.pnpm/@adguard+agtree@3.1.3/node_modules/@adguard/agtree/dist/serializer/cosmetic/body/scriptlet-body-serializer.js
/*
 * AGTree v3.1.3 (build date: Tue, 29 Apr 2025 12:25:03 GMT)
 * (c) 2025 Adguard Software Ltd.
 * Released under the MIT license
 * https://github.com/AdguardTeam/tsurlfilter/tree/master/packages/agtree#readme
 */







/**
 * Serializer for scriptlet injection rule body nodes.
 */
class ScriptletBodySerializer extends base_serializer/* BaseSerializer */.S {
    /**
     * Serializes a scriptlet injection rule body node into a compact binary format.
     *
     * @param node The ScriptletInjectionRuleBody node to serialize.
     * @param buffer The OutputByteBuffer used for writing the binary data.
     * @param frequentScriptletArgs An optional map of frequently used scriptlet names and their arguments,
     * along with their corresponding serialization index.
     */
    static serialize = (node, buffer, frequentScriptletArgs) => {
        buffer.writeUint8(binary_type_common/* BinaryTypeMarshallingMap */.u.ScriptletInjectionRuleBodyNode);
        const { length } = node.children;
        buffer.writeUint8(abp_snippet_injection_body_common/* AbpSnippetBodyMarshallingMap */.f.Children);
        // note: we store the count, because re-construction of the array is faster if we know the length
        if (length > constants/* UINT8_MAX */.II) {
            throw new Error(`Too many scriptlet children: ${length}, the limit is ${constants/* UINT8_MAX */.II}`);
        }
        buffer.writeUint8(length);
        for (let i = 0; i < length; i += 1) {
            ParameterListSerializer.serialize(node.children[i], buffer, frequentScriptletArgs);
        }
        if (!(0,type_guards/* isUndefined */.b0)(node.start)) {
            buffer.writeUint8(abp_snippet_injection_body_common/* AbpSnippetBodyMarshallingMap */.f.Start);
            buffer.writeUint32(node.start);
        }
        if (!(0,type_guards/* isUndefined */.b0)(node.end)) {
            buffer.writeUint8(abp_snippet_injection_body_common/* AbpSnippetBodyMarshallingMap */.f.End);
            buffer.writeUint32(node.end);
        }
        buffer.writeUint8(constants/* NULL */.Cq);
    };
}



;// ./node_modules/.pnpm/@adguard+agtree@3.1.3/node_modules/@adguard/agtree/dist/serializer/cosmetic/body/abp-snippet-injection-body-serializer.js
/*
 * AGTree v3.1.3 (build date: Tue, 29 Apr 2025 12:25:03 GMT)
 * (c) 2025 Adguard Software Ltd.
 * Released under the MIT license
 * https://github.com/AdguardTeam/tsurlfilter/tree/master/packages/agtree#readme
 */




/**
 * `AbpSnippetInjectionBodySerializer` is responsible for serializing the body of an Adblock Plus-style snippet rule.
 *
 * Please note that the serializer will serialize any scriptlet rule if it is syntactically correct.
 * For example, it will serialize this:
 * ```adblock
 * example.com#$#snippet0 arg0
 * ```
 *
 * but it doesn't check if the scriptlet `snippet0` is actually supported by any adblocker.
 *
 * @see {@link https://help.eyeo.com/adblockplus/snippet-filters-tutorial}
 */
class AbpSnippetInjectionBodySerializer extends base_serializer/* BaseSerializer */.S {
    /**
     * Serializes a scriptlet call body node to binary format.
     *
     * @param node Node to serialize.
     * @param buffer ByteBuffer for writing binary data.
     */
    static serialize(node, buffer) {
        ScriptletBodySerializer.serialize(node, buffer, abp_snippet_injection_body_common/* FREQUENT_ABP_SNIPPET_ARGS_SERIALIZATION_MAP */.T);
    }
}



// EXTERNAL MODULE: ./node_modules/.pnpm/@adguard+agtree@3.1.3/node_modules/@adguard/agtree/dist/marshalling-utils/cosmetic/body/ubo-scriptlet-injection-body-common.js
var ubo_scriptlet_injection_body_common = __webpack_require__(26108);
;// ./node_modules/.pnpm/@adguard+agtree@3.1.3/node_modules/@adguard/agtree/dist/serializer/cosmetic/body/ubo-scriptlet-injection-body-serializer.js
/*
 * AGTree v3.1.3 (build date: Tue, 29 Apr 2025 12:25:03 GMT)
 * (c) 2025 Adguard Software Ltd.
 * Released under the MIT license
 * https://github.com/AdguardTeam/tsurlfilter/tree/master/packages/agtree#readme
 */




/**
 * `UboScriptletInjectionBodySerializer` is responsible for serializing the body of a uBlock-style scriptlet rule.
 *
 * Please note that the parser will parse any scriptlet rule if it is syntactically correct.
 * For example, it will parse this:
 * ```adblock
 * example.com##+js(scriptlet0, arg0)
 * ```
 *
 * but it didn't check if the scriptlet `scriptlet0` actually supported by any adblocker.
 *
 * @see {@link https://github.com/gorhill/uBlock/wiki/Static-filter-syntax#scriptlet-injection}
 */
class UboScriptletInjectionBodySerializer extends base_serializer/* BaseSerializer */.S {
    /**
     * Serializes a scriptlet call body node to binary format.
     *
     * @param node Node to serialize.
     * @param buffer ByteBuffer for writing binary data.
     */
    static serialize(node, buffer) {
        ScriptletBodySerializer.serialize(node, buffer, ubo_scriptlet_injection_body_common/* FREQUENT_UBO_SCRIPTLET_ARGS_SERIALIZATION_MAP */.Z);
    }
}



// EXTERNAL MODULE: ./node_modules/.pnpm/@adguard+agtree@3.1.3/node_modules/@adguard/agtree/dist/marshalling-utils/cosmetic/body/adg-scriptlet-injection-body-common.js
var adg_scriptlet_injection_body_common = __webpack_require__(15078);
;// ./node_modules/.pnpm/@adguard+agtree@3.1.3/node_modules/@adguard/agtree/dist/serializer/cosmetic/body/adg-scriptlet-injection-body-serializer.js
/*
 * AGTree v3.1.3 (build date: Tue, 29 Apr 2025 12:25:03 GMT)
 * (c) 2025 Adguard Software Ltd.
 * Released under the MIT license
 * https://github.com/AdguardTeam/tsurlfilter/tree/master/packages/agtree#readme
 */




/**
 * `AdgScriptletInjectionBodySerializer` is responsible for serializing the body of an AdGuard-style scriptlet rule.
 *
 * Please note that the serializer will serialize any scriptlet rule if it is syntactically correct.
 * For example, it will serialize this:
 * ```adblock
 * example.com#%#//scriptlet('scriptlet0', 'arg0')
 * ```
 *
 * but it doesn't check if the scriptlet `scriptlet0` is actually supported by any adblocker.
 *
 * @see {@link https://kb.adguard.com/en/general/how-to-create-your-own-ad-filters#scriptlets}
 */
class AdgScriptletInjectionBodySerializer extends base_serializer/* BaseSerializer */.S {
    /**
     * Serializes a scriptlet call body node to binary format.
     *
     * @param node Node to serialize.
     * @param buffer ByteBuffer for writing binary data.
     */
    static serialize(node, buffer) {
        ScriptletBodySerializer.serialize(node, buffer, adg_scriptlet_injection_body_common/* FREQUENT_ADG_SCRIPTLET_ARGS_SERIALIZATION_MAP */.T);
    }
}



// EXTERNAL MODULE: ./node_modules/.pnpm/@adguard+agtree@3.1.3/node_modules/@adguard/agtree/dist/marshalling-utils/cosmetic/body/element-hiding-body-common.js
var element_hiding_body_common = __webpack_require__(66335);
;// ./node_modules/.pnpm/@adguard+agtree@3.1.3/node_modules/@adguard/agtree/dist/serializer/cosmetic/element-hiding-body-serializer.js
/*
 * AGTree v3.1.3 (build date: Tue, 29 Apr 2025 12:25:03 GMT)
 * (c) 2025 Adguard Software Ltd.
 * Released under the MIT license
 * https://github.com/AdguardTeam/tsurlfilter/tree/master/packages/agtree#readme
 */







/**
 * Serializer for element hiding rule body nodes.
 */
class ElementHidingBodySerializer extends base_serializer/* BaseSerializer */.S {
    /**
     * Serializes an element hiding rule body node to binary format.
     *
     * @param node Node to serialize.
     * @param buffer ByteBuffer for writing binary data.
     */
    static serialize(node, buffer) {
        buffer.writeUint8(binary_type_common/* BinaryTypeMarshallingMap */.u.ElementHidingRuleBody);
        buffer.writeUint8(element_hiding_body_common/* ElementHidingRuleMarshallingMap */.G.SelectorList);
        ValueSerializer.serialize(node.selectorList, buffer);
        if (!(0,type_guards/* isUndefined */.b0)(node.start)) {
            buffer.writeUint8(element_hiding_body_common/* ElementHidingRuleMarshallingMap */.G.Start);
            buffer.writeUint32(node.start);
        }
        if (!(0,type_guards/* isUndefined */.b0)(node.end)) {
            buffer.writeUint8(element_hiding_body_common/* ElementHidingRuleMarshallingMap */.G.End);
            buffer.writeUint32(node.end);
        }
        buffer.writeUint8(constants/* NULL */.Cq);
    }
}



// EXTERNAL MODULE: ./node_modules/.pnpm/@adguard+agtree@3.1.3/node_modules/@adguard/agtree/dist/marshalling-utils/cosmetic/body/css-injection-body-common.js
var css_injection_body_common = __webpack_require__(38950);
;// ./node_modules/.pnpm/@adguard+agtree@3.1.3/node_modules/@adguard/agtree/dist/serializer/cosmetic/css-injection-body-serializer.js
/*
 * AGTree v3.1.3 (build date: Tue, 29 Apr 2025 12:25:03 GMT)
 * (c) 2025 Adguard Software Ltd.
 * Released under the MIT license
 * https://github.com/AdguardTeam/tsurlfilter/tree/master/packages/agtree#readme
 */







/**
 * Serializer for CSS injection rule body nodes.
 */
class CssInjectionBodySerializer extends base_serializer/* BaseSerializer */.S {
    /**
     * Serializes a CSS injection rule body node to binary format.
     *
     * @param node Node to serialize.
     * @param buffer ByteBuffer for writing binary data.
     */
    static serialize(node, buffer) {
        buffer.writeUint8(binary_type_common/* BinaryTypeMarshallingMap */.u.CssInjectionRuleBody);
        if (node.mediaQueryList) {
            buffer.writeUint8(css_injection_body_common/* CssInjectionRuleMarshallingMap */.V.MediaQueryList);
            ValueSerializer.serialize(node.mediaQueryList, buffer);
        }
        buffer.writeUint8(css_injection_body_common/* CssInjectionRuleMarshallingMap */.V.SelectorList);
        ValueSerializer.serialize(node.selectorList, buffer);
        if (node.declarationList) {
            buffer.writeUint8(css_injection_body_common/* CssInjectionRuleMarshallingMap */.V.DeclarationList);
            ValueSerializer.serialize(node.declarationList, buffer);
        }
        if (node.remove) {
            buffer.writeUint8(css_injection_body_common/* CssInjectionRuleMarshallingMap */.V.Remove);
        }
        if (!(0,type_guards/* isUndefined */.b0)(node.start)) {
            buffer.writeUint8(css_injection_body_common/* CssInjectionRuleMarshallingMap */.V.Start);
            buffer.writeUint32(node.start);
        }
        if (!(0,type_guards/* isUndefined */.b0)(node.end)) {
            buffer.writeUint8(css_injection_body_common/* CssInjectionRuleMarshallingMap */.V.End);
            buffer.writeUint32(node.end);
        }
        buffer.writeUint8(constants/* NULL */.Cq);
    }
}



// EXTERNAL MODULE: ./node_modules/.pnpm/@adguard+agtree@3.1.3/node_modules/@adguard/agtree/dist/marshalling-utils/misc/modifier-common.js
var modifier_common = __webpack_require__(42471);
;// ./node_modules/.pnpm/@adguard+agtree@3.1.3/node_modules/@adguard/agtree/dist/serializer/misc/modifier-serializer.js
/*
 * AGTree v3.1.3 (build date: Tue, 29 Apr 2025 12:25:03 GMT)
 * (c) 2025 Adguard Software Ltd.
 * Released under the MIT license
 * https://github.com/AdguardTeam/tsurlfilter/tree/master/packages/agtree#readme
 */







/**
 * `ModifierSerializer` is responsible for serializing modifiers.
 *
 * @example
 * `match-case`, `~third-party`, `domain=example.com|~example.org`
 */
class ModifierSerializer extends base_serializer/* BaseSerializer */.S {
    /**
     * Serializes a modifier node to binary format.
     *
     * @param node Node to serialize.
     * @param buffer ByteBuffer for writing binary data.
     */
    static serialize(node, buffer) {
        buffer.writeUint8(binary_type_common/* BinaryTypeMarshallingMap */.u.ModifierNode);
        buffer.writeUint8(modifier_common/* ModifierNodeMarshallingMap */.sD.Name);
        ValueSerializer.serialize(node.name, buffer, modifier_common/* FREQUENT_MODIFIERS_SERIALIZATION_MAP */.uu);
        if (!(0,type_guards/* isUndefined */.b0)(node.value)) {
            buffer.writeUint8(modifier_common/* ModifierNodeMarshallingMap */.sD.Value);
            ValueSerializer.serialize(node.value, buffer, modifier_common/* FREQUENT_REDIRECT_MODIFIERS_SERIALIZATION_MAP */.vG.get(node.name.value));
        }
        buffer.writeUint8(modifier_common/* ModifierNodeMarshallingMap */.sD.Exception);
        buffer.writeUint8(node.exception ? 1 : 0);
        if (!(0,type_guards/* isUndefined */.b0)(node.start)) {
            buffer.writeUint8(modifier_common/* ModifierNodeMarshallingMap */.sD.Start);
            buffer.writeUint32(node.start);
        }
        if (!(0,type_guards/* isUndefined */.b0)(node.end)) {
            buffer.writeUint8(modifier_common/* ModifierNodeMarshallingMap */.sD.End);
            buffer.writeUint32(node.end);
        }
        buffer.writeUint8(constants/* NULL */.Cq);
    }
}



// EXTERNAL MODULE: ./node_modules/.pnpm/@adguard+agtree@3.1.3/node_modules/@adguard/agtree/dist/marshalling-utils/misc/modifier-list-common.js
var modifier_list_common = __webpack_require__(26882);
;// ./node_modules/.pnpm/@adguard+agtree@3.1.3/node_modules/@adguard/agtree/dist/serializer/misc/modifier-list-serializer.js
/*
 * AGTree v3.1.3 (build date: Tue, 29 Apr 2025 12:25:03 GMT)
 * (c) 2025 Adguard Software Ltd.
 * Released under the MIT license
 * https://github.com/AdguardTeam/tsurlfilter/tree/master/packages/agtree#readme
 */







/**
 * `ModifierListSerializer` is responsible for serializing modifier lists. Please note that the name is not
 * uniform, "modifiers" are also known as "options".
 *
 * @see {@link https://kb.adguard.com/en/general/how-to-create-your-own-ad-filters#basic-rules-modifiers}
 * @see {@link https://kb.adguard.com/en/general/how-to-create-your-own-ad-filters#non-basic-rules-modifiers}
 * @see {@link https://help.eyeo.com/adblockplus/how-to-write-filters#options}
 */
class ModifierListSerializer extends base_serializer/* BaseSerializer */.S {
    /**
     * Serializes a modifier list node to binary format.
     *
     * @param node Node to serialize.
     * @param buffer ByteBuffer for writing binary data.
     */
    static serialize(node, buffer) {
        buffer.writeUint8(binary_type_common/* BinaryTypeMarshallingMap */.u.ModifierListNode);
        const count = node.children.length;
        // If there are no children, we do not write any data related to them, to avoid using unnecessary storage,
        // but children is a required field, so during deserialization we should initialize it as an empty array,
        // if there are no children in the binary data.
        if (count) {
            buffer.writeUint8(modifier_list_common/* ModifierListNodeMarshallingMap */.I.Children);
            // note: we store the count, because re-construction of the array is faster if we know the length
            if (count > constants/* UINT16_MAX */.zg) {
                throw new Error(`Too many modifiers: ${count}, the limit is ${constants/* UINT16_MAX */.zg}`);
            }
            buffer.writeUint16(count);
            for (let i = 0; i < count; i += 1) {
                ModifierSerializer.serialize(node.children[i], buffer);
            }
        }
        if (!(0,type_guards/* isUndefined */.b0)(node.start)) {
            buffer.writeUint8(modifier_list_common/* ModifierListNodeMarshallingMap */.I.Start);
            buffer.writeUint32(node.start);
        }
        if (!(0,type_guards/* isUndefined */.b0)(node.end)) {
            buffer.writeUint8(modifier_list_common/* ModifierListNodeMarshallingMap */.I.End);
            buffer.writeUint32(node.end);
        }
        buffer.writeUint8(constants/* NULL */.Cq);
    }
}



// EXTERNAL MODULE: ./node_modules/.pnpm/@adguard+agtree@3.1.3/node_modules/@adguard/agtree/dist/marshalling-utils/cosmetic/cosmetic-rule-common.js
var cosmetic_rule_common = __webpack_require__(51787);
;// ./node_modules/.pnpm/@adguard+agtree@3.1.3/node_modules/@adguard/agtree/dist/serializer/cosmetic/cosmetic-rule-serializer.js
/*
 * AGTree v3.1.3 (build date: Tue, 29 Apr 2025 12:25:03 GMT)
 * (c) 2025 Adguard Software Ltd.
 * Released under the MIT license
 * https://github.com/AdguardTeam/tsurlfilter/tree/master/packages/agtree#readme
 */

















/**
 * `CosmeticRuleSerializer` is responsible for serializing cosmetic rules into a binary format.
 *
 * This class takes a cosmetic rule Abstract Syntax Tree (AST) and converts it into a compact binary representation.
 * It handles the serialization of different types of cosmetic rules, including element hiding, CSS injection,
 * JavaScript injection, HTML filtering, and scriptlet injection rules.
 */
class CosmeticRuleSerializer extends base_serializer/* BaseSerializer */.S {
    /**
     * Serializes a cosmetic rule node to binary format.
     *
     * @param node Node to serialize.
     * @param buffer ByteBuffer for writing binary data.
     */
    // TODO: add support for raws, if ever needed
    static serialize(node, buffer) {
        // specific properties
        switch (node.type) {
            case nodes/* CosmeticRuleType */.k9.ElementHidingRule:
                // rule type
                buffer.writeUint8(binary_type_common/* BinaryTypeMarshallingMap */.u.ElementHidingRule);
                // syntax
                buffer.writeUint8((0,syntax_serialization_map/* getSyntaxSerializationMap */.M)().get(node.syntax) ?? 0);
                // rule body
                ElementHidingBodySerializer.serialize(node.body, buffer);
                break;
            case nodes/* CosmeticRuleType */.k9.CssInjectionRule:
                // rule type
                buffer.writeUint8(binary_type_common/* BinaryTypeMarshallingMap */.u.CssInjectionRule);
                // syntax
                buffer.writeUint8((0,syntax_serialization_map/* getSyntaxSerializationMap */.M)().get(node.syntax) ?? 0);
                // rule body
                CssInjectionBodySerializer.serialize(node.body, buffer);
                break;
            case nodes/* CosmeticRuleType */.k9.JsInjectionRule:
                // rule type
                buffer.writeUint8(binary_type_common/* BinaryTypeMarshallingMap */.u.JsInjectionRule);
                // syntax
                buffer.writeUint8((0,syntax_serialization_map/* getSyntaxSerializationMap */.M)().get(node.syntax) ?? 0);
                // rule body
                ValueSerializer.serialize(node.body, buffer);
                break;
            case nodes/* CosmeticRuleType */.k9.HtmlFilteringRule:
                // rule type
                buffer.writeUint8(binary_type_common/* BinaryTypeMarshallingMap */.u.HtmlFilteringRule);
                // syntax
                buffer.writeUint8((0,syntax_serialization_map/* getSyntaxSerializationMap */.M)().get(node.syntax) ?? 0);
                // rule body
                ValueSerializer.serialize(node.body, buffer);
                break;
            case nodes/* CosmeticRuleType */.k9.ScriptletInjectionRule:
                // rule type
                buffer.writeUint8(binary_type_common/* BinaryTypeMarshallingMap */.u.ScriptletInjectionRule);
                // syntax
                buffer.writeUint8((0,syntax_serialization_map/* getSyntaxSerializationMap */.M)().get(node.syntax) ?? 0);
                // rule body
                switch (node.syntax) {
                    case adblockers/* AdblockSyntax */.Y.Adg:
                        AdgScriptletInjectionBodySerializer.serialize(node.body, buffer);
                        break;
                    case adblockers/* AdblockSyntax */.Y.Abp:
                        AbpSnippetInjectionBodySerializer.serialize(node.body, buffer);
                        break;
                    case adblockers/* AdblockSyntax */.Y.Ubo:
                        UboScriptletInjectionBodySerializer.serialize(node.body, buffer);
                        break;
                    default:
                        throw new Error('Scriptlet rule should have an explicit syntax');
                }
                break;
            default:
                throw new Error('Unknown cosmetic rule type');
        }
        // common properties
        buffer.writeUint8(cosmetic_rule_common/* CosmeticRuleMarshallingMap */.U.Exception);
        buffer.writeUint8(node.exception ? 1 : 0);
        buffer.writeUint8(cosmetic_rule_common/* CosmeticRuleMarshallingMap */.U.Separator);
        ValueSerializer.serialize(node.separator, buffer, cosmetic_rule_common/* COSMETIC_RULE_SEPARATOR_SERIALIZATION_MAP */.h);
        if (node.modifiers) {
            buffer.writeUint8(cosmetic_rule_common/* CosmeticRuleMarshallingMap */.U.Modifiers);
            ModifierListSerializer.serialize(node.modifiers, buffer);
        }
        buffer.writeUint8(cosmetic_rule_common/* CosmeticRuleMarshallingMap */.U.Domains);
        DomainListSerializer.serialize(node.domains, buffer);
        if (!(0,type_guards/* isUndefined */.b0)(node.start)) {
            buffer.writeUint8(cosmetic_rule_common/* CosmeticRuleMarshallingMap */.U.Start);
            buffer.writeUint32(node.start);
        }
        if (!(0,type_guards/* isUndefined */.b0)(node.end)) {
            buffer.writeUint8(cosmetic_rule_common/* CosmeticRuleMarshallingMap */.U.End);
            buffer.writeUint32(node.end);
        }
        buffer.writeUint8(constants/* NULL */.Cq);
    }
}



// EXTERNAL MODULE: ./node_modules/.pnpm/@adguard+agtree@3.1.3/node_modules/@adguard/agtree/dist/marshalling-utils/misc/hostname-list-common.js
var hostname_list_common = __webpack_require__(28894);
;// ./node_modules/.pnpm/@adguard+agtree@3.1.3/node_modules/@adguard/agtree/dist/serializer/network/hostname-list-serializer.js
/*
 * AGTree v3.1.3 (build date: Tue, 29 Apr 2025 12:25:03 GMT)
 * (c) 2025 Adguard Software Ltd.
 * Released under the MIT license
 * https://github.com/AdguardTeam/tsurlfilter/tree/master/packages/agtree#readme
 */







/**
 * Serializer for hostname list nodes.
 */
class HostnameListSerializer extends base_serializer/* BaseSerializer */.S {
    /**
     * Serializes a hostname list node to binary format.
     *
     * @param node Node to serialize.
     * @param buffer ByteBuffer for writing binary data.
     */
    static serialize(node, buffer) {
        buffer.writeUint8(binary_type_common/* BinaryTypeMarshallingMap */.u.HostnameListNode);
        if (!(0,type_guards/* isUndefined */.b0)(node.start)) {
            buffer.writeUint8(hostname_list_common/* HostnameListNodeMarshallingMap */.W.Start);
            buffer.writeUint32(node.start);
        }
        if (!(0,type_guards/* isUndefined */.b0)(node.end)) {
            buffer.writeUint8(hostname_list_common/* HostnameListNodeMarshallingMap */.W.End);
            buffer.writeUint32(node.end);
        }
        const count = node.children.length;
        // If there are no children, we do not write any data related to them, to avoid using unnecessary storage,
        // but children is a required field, so during deserialization we should initialize it as an empty array,
        // if there are no children in the binary data.
        if (count) {
            // note: we store the count, because re-construction of the array is faster if we know the length
            if (count > constants/* UINT16_MAX */.zg) {
                throw new Error(`Too many children: ${count}, the limit is ${constants/* UINT16_MAX */.zg}`);
            }
            buffer.writeUint8(hostname_list_common/* HostnameListNodeMarshallingMap */.W.Children);
            buffer.writeUint16(count);
            for (let i = 0; i < count; i += 1) {
                ValueSerializer.serialize(node.children[i], buffer);
            }
        }
        buffer.writeUint8(constants/* NULL */.Cq);
    }
}



// EXTERNAL MODULE: ./node_modules/.pnpm/@adguard+agtree@3.1.3/node_modules/@adguard/agtree/dist/marshalling-utils/misc/host-rule-common.js
var host_rule_common = __webpack_require__(49107);
;// ./node_modules/.pnpm/@adguard+agtree@3.1.3/node_modules/@adguard/agtree/dist/serializer/network/host-rule-serializer.js
/*
 * AGTree v3.1.3 (build date: Tue, 29 Apr 2025 12:25:03 GMT)
 * (c) 2025 Adguard Software Ltd.
 * Released under the MIT license
 * https://github.com/AdguardTeam/tsurlfilter/tree/master/packages/agtree#readme
 */









/**
 * `HostRuleSerializer` is responsible for serializing hosts-like rules.
 *
 * HostRule is a structure for simple host-level rules (i.e. /etc/hosts syntax).
 * It also supports "just domain" syntax. In this case, the IP will be set to 0.0.0.0.
 *
 * Rules syntax looks like this:
 * ```text
 * IP_address canonical_hostname [aliases...]
 * ```
 *
 * @example
 * `192.168.1.13 bar.mydomain.org bar` -- ipv4
 * `ff02::1 ip6-allnodes` -- ipv6
 * `::1 localhost ip6-localhost ip6-loopback` -- ipv6 aliases
 * `example.org` -- "just domain" syntax
 * @see {@link http://man7.org/linux/man-pages/man5/hosts.5.html}
 */
class HostRuleSerializer extends base_serializer/* BaseSerializer */.S {
    /**
     * Serializes a host rule node to binary format.
     *
     * @param node Node to serialize.
     * @param buffer ByteBuffer for writing binary data.
     */
    // TODO: add support for raws, if ever needed
    static serialize(node, buffer) {
        buffer.writeUint8(binary_type_common/* BinaryTypeMarshallingMap */.u.HostRuleNode);
        buffer.writeUint8(host_rule_common/* HostRuleMarshallingMap */.J.Syntax);
        buffer.writeUint8((0,syntax_serialization_map/* getSyntaxSerializationMap */.M)().get(node.syntax) ?? 0);
        if (node.ip) {
            buffer.writeUint8(host_rule_common/* HostRuleMarshallingMap */.J.Ip);
            ValueSerializer.serialize(node.ip, buffer);
        }
        if (node.hostnames) {
            buffer.writeUint8(host_rule_common/* HostRuleMarshallingMap */.J.HostnameList);
            HostnameListSerializer.serialize(node.hostnames, buffer);
        }
        if (node.comment) {
            buffer.writeUint8(host_rule_common/* HostRuleMarshallingMap */.J.Comment);
            ValueSerializer.serialize(node.comment, buffer);
        }
        if (!(0,type_guards/* isUndefined */.b0)(node.start)) {
            buffer.writeUint8(host_rule_common/* HostRuleMarshallingMap */.J.Start);
            buffer.writeUint32(node.start);
        }
        if (!(0,type_guards/* isUndefined */.b0)(node.end)) {
            buffer.writeUint8(host_rule_common/* HostRuleMarshallingMap */.J.End);
            buffer.writeUint32(node.end);
        }
        buffer.writeUint8(constants/* NULL */.Cq);
    }
}



// EXTERNAL MODULE: ./node_modules/.pnpm/@adguard+agtree@3.1.3/node_modules/@adguard/agtree/dist/marshalling-utils/network/network-rule-common.js
var network_rule_common = __webpack_require__(1447);
;// ./node_modules/.pnpm/@adguard+agtree@3.1.3/node_modules/@adguard/agtree/dist/serializer/network/network-rule-serializer.js
/*
 * AGTree v3.1.3 (build date: Tue, 29 Apr 2025 12:25:03 GMT)
 * (c) 2025 Adguard Software Ltd.
 * Released under the MIT license
 * https://github.com/AdguardTeam/tsurlfilter/tree/master/packages/agtree#readme
 */









/**
 * `NetworkRuleSerializer` is responsible for serializing network rules.
 *
 * @see {@link https://kb.adguard.com/en/general/how-to-create-your-own-ad-filters#basic-rules}
 * @see {@link https://help.eyeo.com/adblockplus/how-to-write-filters#basic}
 */
class NetworkRuleSerializer extends base_serializer/* BaseSerializer */.S {
    /**
     * Serializes a network rule node to binary format.
     *
     * @param node Node to serialize.
     * @param buffer ByteBuffer for writing binary data.
     */
    // TODO: add support for raws, if ever needed
    static serialize(node, buffer) {
        buffer.writeUint8(binary_type_common/* BinaryTypeMarshallingMap */.u.NetworkRuleNode);
        buffer.writeUint8(network_rule_common/* NetworkRuleMarshallingMap */.v.Syntax);
        buffer.writeUint8((0,syntax_serialization_map/* getSyntaxSerializationMap */.M)().get(node.syntax) ?? 0);
        buffer.writeUint8(network_rule_common/* NetworkRuleMarshallingMap */.v.Exception);
        buffer.writeUint8(node.exception ? 1 : 0);
        buffer.writeUint8(network_rule_common/* NetworkRuleMarshallingMap */.v.Pattern);
        ValueSerializer.serialize(node.pattern, buffer);
        if (!(0,type_guards/* isUndefined */.b0)(node.modifiers)) {
            buffer.writeUint8(network_rule_common/* NetworkRuleMarshallingMap */.v.ModifierList);
            ModifierListSerializer.serialize(node.modifiers, buffer);
        }
        if (!(0,type_guards/* isUndefined */.b0)(node.start)) {
            buffer.writeUint8(network_rule_common/* NetworkRuleMarshallingMap */.v.Start);
            buffer.writeUint32(node.start);
        }
        if (!(0,type_guards/* isUndefined */.b0)(node.end)) {
            buffer.writeUint8(network_rule_common/* NetworkRuleMarshallingMap */.v.End);
            buffer.writeUint32(node.end);
        }
        buffer.writeUint8(constants/* NULL */.Cq);
    }
}



// EXTERNAL MODULE: ./node_modules/.pnpm/@adguard+agtree@3.1.3/node_modules/@adguard/agtree/dist/marshalling-utils/empty-rule-common.js
var empty_rule_common = __webpack_require__(42585);
;// ./node_modules/.pnpm/@adguard+agtree@3.1.3/node_modules/@adguard/agtree/dist/serializer/empty-rule-serializer.js
/*
 * AGTree v3.1.3 (build date: Tue, 29 Apr 2025 12:25:03 GMT)
 * (c) 2025 Adguard Software Ltd.
 * Released under the MIT license
 * https://github.com/AdguardTeam/tsurlfilter/tree/master/packages/agtree#readme
 */






/**
 * Serializer for empty rule nodes.
 */
class EmptyRuleSerializer extends base_serializer/* BaseSerializer */.S {
    /**
     * Serializes an empty rule node to binary format.
     *
     * @param node Node to serialize.
     * @param buffer ByteBuffer for writing binary data.
     */
    static serialize(node, buffer) {
        buffer.writeUint8(binary_type_common/* BinaryTypeMarshallingMap */.u.EmptyRule);
        if (!(0,type_guards/* isUndefined */.b0)(node.start)) {
            buffer.writeUint8(empty_rule_common/* EmptyRuleMarshallingMap */.K.Start);
            buffer.writeUint32(node.start);
        }
        if (!(0,type_guards/* isUndefined */.b0)(node.end)) {
            buffer.writeUint8(empty_rule_common/* EmptyRuleMarshallingMap */.K.End);
            buffer.writeUint32(node.end);
        }
        buffer.writeUint8(constants/* NULL */.Cq);
    }
}



// EXTERNAL MODULE: ./node_modules/.pnpm/@adguard+agtree@3.1.3/node_modules/@adguard/agtree/dist/marshalling-utils/invalid-rule-error-node-common.js
var invalid_rule_error_node_common = __webpack_require__(73561);
;// ./node_modules/.pnpm/@adguard+agtree@3.1.3/node_modules/@adguard/agtree/dist/serializer/invalid-rule-error-node-serializer.js
/*
 * AGTree v3.1.3 (build date: Tue, 29 Apr 2025 12:25:03 GMT)
 * (c) 2025 Adguard Software Ltd.
 * Released under the MIT license
 * https://github.com/AdguardTeam/tsurlfilter/tree/master/packages/agtree#readme
 */






/**
 * Serializer for invalid rule error nodes.
 */
class InvalidRuleErrorNodeSerializer extends base_serializer/* BaseSerializer */.S {
    /**
     * Serializes an invalid rule error node to binary format.
     *
     * @param node Node to serialize.
     * @param buffer ByteBuffer for writing binary data.
     */
    static serialize(node, buffer) {
        buffer.writeUint8(binary_type_common/* BinaryTypeMarshallingMap */.u.InvalidRuleErrorNode);
        buffer.writeUint8(invalid_rule_error_node_common/* InvalidRuleErrorNodeMarshallingMap */.K.Name);
        buffer.writeString(node.name);
        buffer.writeUint8(invalid_rule_error_node_common/* InvalidRuleErrorNodeMarshallingMap */.K.Message);
        buffer.writeString(node.message);
        if (!(0,type_guards/* isUndefined */.b0)(node.start)) {
            buffer.writeUint8(invalid_rule_error_node_common/* InvalidRuleErrorNodeMarshallingMap */.K.Start);
            buffer.writeUint32(node.start);
        }
        if (!(0,type_guards/* isUndefined */.b0)(node.end)) {
            buffer.writeUint8(invalid_rule_error_node_common/* InvalidRuleErrorNodeMarshallingMap */.K.End);
            buffer.writeUint32(node.end);
        }
        buffer.writeUint8(constants/* NULL */.Cq);
    }
}



// EXTERNAL MODULE: ./node_modules/.pnpm/@adguard+agtree@3.1.3/node_modules/@adguard/agtree/dist/marshalling-utils/invalid-rule-common.js
var invalid_rule_common = __webpack_require__(33955);
;// ./node_modules/.pnpm/@adguard+agtree@3.1.3/node_modules/@adguard/agtree/dist/serializer/invalid-rule-serializer.js
/*
 * AGTree v3.1.3 (build date: Tue, 29 Apr 2025 12:25:03 GMT)
 * (c) 2025 Adguard Software Ltd.
 * Released under the MIT license
 * https://github.com/AdguardTeam/tsurlfilter/tree/master/packages/agtree#readme
 */







/**
 * Serializer for invalid rule nodes.
 */
class InvalidRuleSerializer extends base_serializer/* BaseSerializer */.S {
    /**
     * Serializes an invalid rule node to binary format.
     *
     * @param node Node to serialize.
     * @param buffer ByteBuffer for writing binary data.
     */
    static serialize(node, buffer) {
        buffer.writeUint8(binary_type_common/* BinaryTypeMarshallingMap */.u.InvalidRule);
        buffer.writeUint8(invalid_rule_common/* InvalidRuleMarshallingMap */.W.Error);
        InvalidRuleErrorNodeSerializer.serialize(node.error, buffer);
        if (!(0,type_guards/* isUndefined */.b0)(node.start)) {
            buffer.writeUint8(invalid_rule_common/* InvalidRuleMarshallingMap */.W.Start);
            buffer.writeUint32(node.start);
        }
        if (!(0,type_guards/* isUndefined */.b0)(node.end)) {
            buffer.writeUint8(invalid_rule_common/* InvalidRuleMarshallingMap */.W.End);
            buffer.writeUint32(node.end);
        }
        buffer.writeUint8(constants/* NULL */.Cq);
    }
}



;// ./node_modules/.pnpm/@adguard+agtree@3.1.3/node_modules/@adguard/agtree/dist/serializer/rule-serializer.js
/*
 * AGTree v3.1.3 (build date: Tue, 29 Apr 2025 12:25:03 GMT)
 * (c) 2025 Adguard Software Ltd.
 * Released under the MIT license
 * https://github.com/AdguardTeam/tsurlfilter/tree/master/packages/agtree#readme
 */









/**
 * `RuleSerializer` is responsible for serializing the rules.
 *
 * It automatically determines the category and syntax of the rule, so you can pass any kind of rule to it.
 */
class RuleSerializer extends base_serializer/* BaseSerializer */.S {
    /**
     * Serializes a rule node to binary format.
     *
     * @param node Node to serialize.
     * @param buffer ByteBuffer for writing binary data.
     */
    // TODO: add support for raws, if ever needed
    static serialize(node, buffer) {
        switch (node.category) {
            case nodes/* RuleCategory */.$O.Comment:
                CommentRuleSerializer.serialize(node, buffer);
                break;
            case nodes/* RuleCategory */.$O.Cosmetic:
                CosmeticRuleSerializer.serialize(node, buffer);
                break;
            case nodes/* RuleCategory */.$O.Network:
                switch (node.type) {
                    case nodes/* NetworkRuleType */.vY.HostRule:
                        HostRuleSerializer.serialize(node, buffer);
                        break;
                    case nodes/* NetworkRuleType */.vY.NetworkRule:
                        NetworkRuleSerializer.serialize(node, buffer);
                        break;
                    default:
                        throw new Error('Unknown network rule type');
                }
                break;
            case nodes/* RuleCategory */.$O.Empty:
                EmptyRuleSerializer.serialize(node, buffer);
                break;
            case nodes/* RuleCategory */.$O.Invalid:
                InvalidRuleSerializer.serialize(node, buffer);
                break;
            default:
                throw new Error('Unknown rule category');
        }
    }
}



;// ./node_modules/.pnpm/@adguard+tsurlfilter@3.3.0-alpha.0_@adguard+re2-wasm@1.2.0/node_modules/@adguard/tsurlfilter/dist/es/index.js























var version = "3.3.0-alpha.0";

const TSURLFILTER_VERSION = (/* unused pure expression or super */ null && (version));
/**
 * Compatibility types are used to configure engine for better support of different libraries
 * For example:
 *  extension doesn't support $app modifier. So if we set in configuration CompatibilityTypes.Extension,
 *  engine would ignore rules with $app modifier.
 */
var CompatibilityTypes;
(function (CompatibilityTypes) {
    CompatibilityTypes[CompatibilityTypes["Extension"] = 1] = "Extension";
    CompatibilityTypes[CompatibilityTypes["CoreLibs"] = 2] = "CoreLibs";
    CompatibilityTypes[CompatibilityTypes["Dns"] = 4] = "Dns";
})(CompatibilityTypes || (CompatibilityTypes = {}));
/**
 * Application configuration class.
 */
class Configuration {
    defaultConfig = {
        engine: null,
        version: null,
        verbose: false,
        compatibility: null,
    };
    /**
     * {'extension'|'corelibs'} engine application type.
     */
    engine = null;
    /**
     * {string} version.
     */
    version = null;
    /**
     * {boolean} verbose flag.
     */
    verbose = false;
    /**
     * Compatibility flag.
     */
    compatibility = CompatibilityTypes.Extension;
    constructor(inputConfig) {
        const config = { ...this.defaultConfig, ...inputConfig };
        this.engine = config.engine;
        this.version = config.version;
        this.verbose = config.verbose;
        this.compatibility = config.compatibility;
    }
}
// eslint-disable-next-line import/no-mutable-exports
let config = new Configuration();
/**
 * Checks config is compatible with input level.
 *
 * @param compatibilityLevel Compatibility level to check against.
 *
 * @returns True if compatible, otherwise false.
 */
function isCompatibleWith(compatibilityLevel) {
    if (config.compatibility === null) {
        return false;
    }
    return (config.compatibility & compatibilityLevel) === compatibilityLevel;
}
const setConfiguration = (outerConfig) => {
    config = new Configuration(outerConfig);
};

/**
 * Export logger implementation.
 */
let logger = console;
/**
 * Set logger implementation.
 *
 * @param loggerImpl The logger implementation to set.
 */
function setLogger(loggerImpl) {
    logger = loggerImpl;
}

/**
 * Pipe separator.
 */
const PIPE_SEPARATOR$1 = '|';
/**
 * This is a helper class that is used specifically to work
 * with domains restrictions.
 *
 * There are two options how you can add a domain restriction:
 * - `$domain` modifier;
 * - domains list for the cosmetic rules.
 *
 * @see {@link https://adguard.com/kb/general/ad-filtering/create-own-filters/#domain-modifier}
 * @see {@link https://adguard.com/kb/general/ad-filtering/create-own-filters/#cosmetic-rules}
 *
 * The only difference between them is that in one case we use `|` as a separator,
 * and in the other case - `,`.
 *
 * @example
 * `||example.org^$domain=example.com|~sub.example.com` -- network rule
 * `example.com,~sub.example.com##banner` -- cosmetic rule
 */
class DomainModifier {
    /**
     * List of permitted domains or null.
     */
    permittedDomains;
    /**
     * List of restricted domains or null.
     */
    restrictedDomains;
    /**
     * Processes domain list node, which means extracting permitted and restricted
     * domains from it.
     *
     * @param domainListNode Domain list node to process.
     *
     * @returns Processed domain list (permitted and restricted domains) ({@link ProcessedDomainList}).
     */
    static processDomainList(domainListNode) {
        const result = {
            permittedDomains: [],
            restrictedDomains: [],
        };
        const { children: domains } = domainListNode;
        for (const { exception, value: domain } of domains) {
            const domainLowerCased = domain.toLowerCase();
            if (!simple_regex_BBjA8AEZ.S.isRegexPattern(domain) && domain.includes(simple_regex_BBjA8AEZ.W) && !domain.endsWith(simple_regex_BBjA8AEZ.W)) {
                throw new SyntaxError(`Wildcards are only supported for top-level domains: "${domain}"`);
            }
            if (exception) {
                result.restrictedDomains.push(domainLowerCased);
            }
            else {
                result.permittedDomains.push(domainLowerCased);
            }
        }
        return result;
    }
    /**
     * Parses the `domains` string and initializes the object.
     *
     * @param domains Domain list string or AGTree DomainList node.
     * @param separator Separator — `,` or `|`.
     *
     * @throws An error if the domains string is empty or invalid.
     */
    constructor(domains, separator) {
        let processed;
        if ((0,simple_regex_BBjA8AEZ.i)(domains)) {
            const node = domain_list_parser/* DomainListParser */.y.parse(domains.trim(), { ...options/* defaultParserOptions */.n, isLocIncluded: false }, 0, separator);
            if (node.children.length === 0) {
                throw new SyntaxError('At least one domain must be specified');
            }
            processed = DomainModifier.processDomainList(node);
        }
        else {
            // domain list node stores the separator
            if (separator !== domains.separator) {
                throw new SyntaxError('Separator mismatch');
            }
            processed = DomainModifier.processDomainList(domains);
        }
        // Unescape separator character in domains
        processed.permittedDomains = processed.permittedDomains.map((domain) => (0,simple_regex_BBjA8AEZ.u)(domain, separator));
        processed.restrictedDomains = processed.restrictedDomains.map((domain) => (0,simple_regex_BBjA8AEZ.u)(domain, separator));
        this.restrictedDomains = processed.restrictedDomains.length > 0 ? processed.restrictedDomains : null;
        this.permittedDomains = processed.permittedDomains.length > 0 ? processed.permittedDomains : null;
    }
    /**
     * Checks if the filtering rule is allowed on this domain.
     *
     * @param domain Domain to check.
     *
     * @returns True if the filtering rule is allowed on this domain.
     */
    matchDomain(domain) {
        if (this.hasRestrictedDomains()) {
            if (DomainModifier.isDomainOrSubdomainOfAny(domain, this.restrictedDomains)) {
                // Domain or host is restricted
                // i.e. $domain=~example.org
                return false;
            }
        }
        if (this.hasPermittedDomains()) {
            if (!DomainModifier.isDomainOrSubdomainOfAny(domain, this.permittedDomains)) {
                // Domain is not among permitted
                // i.e. $domain=example.org and we're checking example.com
                return false;
            }
        }
        return true;
    }
    /**
     * Checks if rule has permitted domains.
     *
     * @returns True if the rule has permitted domains.
     */
    hasPermittedDomains() {
        return !!this.permittedDomains && this.permittedDomains.length > 0;
    }
    /**
     * Checks if rule has restricted domains.
     *
     * @returns True if the rule has restricted domains.
     */
    hasRestrictedDomains() {
        return !!this.restrictedDomains && this.restrictedDomains.length > 0;
    }
    /**
     * Gets list of permitted domains.
     *
     * @returns List of permitted domains or null if none.
     */
    getPermittedDomains() {
        return this.permittedDomains;
    }
    /**
     * Gets list of restricted domains.
     *
     * @returns List of restricted domains or null if none.
     */
    getRestrictedDomains() {
        return this.restrictedDomains;
    }
    /**
     * Checks if `domain` is the same or a subdomain
     * of any of `domains`.
     *
     * @param domain Domain to check.
     * @param domains Domains list to check against.
     *
     * @returns True if `domain` is the same or a subdomain of any of `domains`.
     */
    static isDomainOrSubdomainOfAny(domain, domains) {
        for (let i = 0; i < domains.length; i += 1) {
            const d = domains[i];
            if (DomainModifier.isWildcardDomain(d)) {
                if (DomainModifier.matchAsWildcard(d, domain)) {
                    return true;
                }
            }
            if (domain === d || (domain.endsWith(d) && domain.endsWith(`.${d}`))) {
                return true;
            }
            if (simple_regex_BBjA8AEZ.S.isRegexPattern(d)) {
                try {
                    /**
                     * Regular expressions are cached internally by the browser
                     * (for instance, they're stored in the CompilationCache in V8/Chromium),
                     * so calling the constructor here should not be a problem.
                     *
                     * TODO: use SimpleRegex.patternFromString(d) after it is refactored to not add 'g' flag.
                     */
                    const domainPattern = new RegExp(d.slice(1, -1));
                    if (domainPattern.test(domain)) {
                        return true;
                    }
                }
                catch {
                    logger.error(`Invalid regular expression as domain pattern: "${d}"`);
                }
                continue;
            }
        }
        return false;
    }
    /**
     * Checks if domain ends with wildcard.
     *
     * @param domain Domain string to check.
     *
     * @returns True if domain ends with wildcard.
     */
    static isWildcardDomain(domain) {
        return domain.endsWith('.*');
    }
    /**
     * Checks if domain string does not ends with wildcard and is not regex pattern.
     *
     * @param domain Domain string to check.
     *
     * @returns True if given domain is a wildcard or regexp pattern.
     */
    static isWildcardOrRegexDomain(domain) {
        return DomainModifier.isWildcardDomain(domain) || simple_regex_BBjA8AEZ.S.isRegexPattern(domain);
    }
    /**
     * Checks if wildcard matches domain.
     *
     * @param wildcard The wildcard pattern to match against the domain.
     * @param domainNameToCheck The domain name to check against the wildcard pattern.
     *
     * @returns True if wildcard matches domain.
     */
    static matchAsWildcard(wildcard, domainNameToCheck) {
        const wildcardedDomainToCheck = DomainModifier.genTldWildcard(domainNameToCheck);
        if (wildcardedDomainToCheck) {
            return wildcardedDomainToCheck === wildcard
                || (wildcardedDomainToCheck.endsWith(wildcard) && wildcardedDomainToCheck.endsWith(`.${wildcard}`));
        }
        return false;
    }
    /**
     * Generates from domain tld wildcard.
     *
     * @param domainName The domain name to generate the TLD wildcard for.
     *
     * @returns String is empty if tld for provided domain name doesn't exists.
     *
     * @example
     * `google.com` -> `google.*`
     * `youtube.co.uk` -> `youtube.*`
     */
    static genTldWildcard(domainName) {
        // To match eTld like "com.ru" we use allowPrivateDomains wildcard
        // https://github.com/AdguardTeam/AdguardBrowserExtension/issues/2650
        const tld = (0,es6/* getPublicSuffix */.pj)(domainName, { allowPrivateDomains: true });
        if (tld) {
            // lastIndexOf() is needed not to match the domain, e.g. 'www.chrono24.ch'.
            // https://github.com/AdguardTeam/AdguardBrowserExtension/issues/2312.
            return `${domainName.slice(0, domainName.lastIndexOf(`.${tld}`))}.*`;
        }
        return '';
    }
}

/**
 * @typedef {import('./cosmetic-engine').CosmeticEngine} CosmeticEngine
 */
/**
 * CosmeticLookupTable lets quickly lookup cosmetic rules for the specified hostname.
 * It is primarily used by the {@link CosmeticEngine}.
 */
class CosmeticLookupTable {
    /**
     * Map with rules indices grouped by the permitted domains names.
     */
    byHostname;
    /**
     * List of domain-specific rules that are not organized into any index structure.
     * These rules are sequentially scanned one by one.
     */
    seqScanRules;
    /**
     * Collection of generic rules.
     * Generic means that the rule is not limited to particular websites and works (almost) everywhere.
     */
    genericRules;
    /**
     * Map with allowlist rules indices. Key is the rule content.
     *
     * @see {@link https://kb.adguard.com/en/general/how-to-create-your-own-ad-filters#element-hiding-rules-exceptions}
     */
    allowlist;
    /**
     * Storage for the filtering rules.
     */
    ruleStorage;
    /**
     * Creates a new instance.
     *
     * @param storage Rules storage. We store "rule indexes" in the lookup table which
     * can be used to retrieve the full rules from the storage.
     */
    constructor(storage) {
        this.byHostname = new Map();
        this.seqScanRules = [];
        this.genericRules = [];
        this.allowlist = new Map();
        this.ruleStorage = storage;
    }
    /**
     * Adds rule to the allowlist map.
     *
     * @param key Can be used any string, but here we use ruleContent, scriptlet content, or scriptlet name.
     * @param storageIdx Index of the rule.
     */
    addAllowlistRule(key, storageIdx) {
        const existingRules = this.allowlist.get(key);
        if (!existingRules) {
            this.allowlist.set(key, [storageIdx]);
            return;
        }
        existingRules.push(storageIdx);
    }
    /**
     * Adds rule to the appropriate collection.
     *
     * @param rule Rule to add.
     * @param storageIdx Index of the rule in the storage.
     */
    addRule(rule, storageIdx) {
        if (rule.isAllowlist()) {
            if (rule.isScriptlet) {
                // Store scriptlet rules by name to enable the possibility of allowlisting them.
                // See https://github.com/AdguardTeam/Scriptlets/issues/377 for more details.
                if (rule.scriptletParams.name !== undefined
                    && rule.scriptletParams.args.length === 0) {
                    this.addAllowlistRule(rule.scriptletParams.name, storageIdx);
                }
                // Use normalized scriptlet content for better matching.
                // For example, //scriptlet('log', 'arg') can be matched by //scriptlet("log", "arg").
                this.addAllowlistRule(rule.scriptletParams.toString(), storageIdx);
            }
            else {
                // Store all other rules by their content.
                this.addAllowlistRule(rule.getContent(), storageIdx);
            }
            return;
        }
        if (rule.isGeneric()) {
            this.genericRules.push(rule);
            return;
        }
        const permittedDomains = rule.getPermittedDomains();
        if (permittedDomains) {
            if (permittedDomains.some(DomainModifier.isWildcardOrRegexDomain)) {
                this.seqScanRules.push(rule);
                return;
            }
            for (const domain of permittedDomains) {
                const tldResult = (0,es6/* parse */.qg)(domain);
                // tldResult.domain equals to eTLD domain,
                // e.g. sub.example.uk.org would result in example.uk.org
                const parsedDomain = tldResult.domain || domain;
                const key = (0,simple_regex_BBjA8AEZ.f)(parsedDomain);
                const rules = this.byHostname.get(key) || [];
                rules.push(storageIdx);
                this.byHostname.set(key, rules);
            }
        }
    }
    /**
     * Finds rules by hostname.
     *
     * @param request Request to check.
     *
     * @returns Array of matching cosmetic rules.
     */
    findByHostname(request) {
        const result = [];
        const { subdomains } = request;
        // Iterate over all sub-domains
        for (let i = 0; i < subdomains.length; i += 1) {
            const subdomain = subdomains[i];
            let rulesIndexes = this.byHostname.get((0,simple_regex_BBjA8AEZ.f)(subdomain));
            if (rulesIndexes) {
                // Filtering out duplicates
                rulesIndexes = rulesIndexes.filter((v, index) => rulesIndexes.indexOf(v) === index);
                for (let j = 0; j < rulesIndexes.length; j += 1) {
                    const rule = this.ruleStorage.retrieveRule(rulesIndexes[j]);
                    if (rule && !rule.isAllowlist() && rule.match(request)) {
                        result.push(rule);
                    }
                }
            }
        }
        result.push(...this.seqScanRules.filter((r) => !r.isAllowlist() && r.match(request)));
        return result;
    }
    /**
     * Checks if a scriptlet is allowlisted for a request. It looks up the scriptlet
     * by content in the allowlist map and evaluates two conditions:
     * 1. If there's a generic allowlist rule applicable to all sites.
     * 2. If there's a specific allowlist rule that matches the request.
     *
     * @param content Content of the scriptlet. Empty string '' searches for scriptlets allowlisted globally.
     * @param request Request details to match against allowlist rules.
     *
     * @returns True if allowlisted by a matching rule or a generic rule. False otherwise.
     */
    isScriptletAllowlisted = (content, request) => {
        // check for rules with that content
        const allowlistScriptletRulesIndexes = this.allowlist.get(content);
        if (allowlistScriptletRulesIndexes) {
            const rules = allowlistScriptletRulesIndexes
                .map((i) => {
                return this.ruleStorage.retrieveRule(i);
            })
                .filter((r) => r);
            // here we check if there is at least one generic allowlist rule
            const hasAllowlistGenericScriptlet = rules.some((r) => {
                return r.isGeneric();
            });
            if (hasAllowlistGenericScriptlet) {
                return true;
            }
            // here we check if there is at least one allowlist rule that matches the request
            const hasRuleMatchingRequest = rules.some((r) => r.match(request));
            if (hasRuleMatchingRequest) {
                return true;
            }
        }
        return false;
    };
    /**
     * Checks if the rule is disabled on the specified hostname.
     *
     * @param request Request to check.
     * @param rule Rule to check.
     *
     * @returns True if the rule is disabled on the specified hostname.
     */
    isAllowlisted(request, rule) {
        if (rule.isScriptlet) {
            // Empty string '' is a special case for scriptlet when the allowlist scriptlet has no name
            // e.g. #@%#//scriptlet(); example.org#@%#//scriptlet();
            const EMPTY_SCRIPTLET_NAME = '';
            if (this.isScriptletAllowlisted(EMPTY_SCRIPTLET_NAME, request)) {
                return true;
            }
            // If scriptlet allowlisted by name
            // e.g. #@%#//scriptlet('set-cookie'); example.org#@%#//scriptlet('set-cookie');
            if (rule.scriptletParams.name !== undefined
                && this.isScriptletAllowlisted(rule.scriptletParams.name, request)) {
                return true;
            }
            // If scriptlet allowlisted with args, using normalized scriptlet content for better matching
            // on different quote types (see https://github.com/AdguardTeam/AdguardBrowserExtension/issues/2947)
            // e.g. #@%#//scriptlet("set-cookie", "arg1"); example.org#@%#//scriptlet('set-cookie', 'arg1');
            if (rule.scriptletParams.name !== undefined
                && rule.scriptletParams.args.length > 0
                && this.isScriptletAllowlisted(rule.scriptletParams.toString(), request)) {
                return true;
            }
        }
        const rulesIndexes = this.allowlist.get(rule.getContent());
        if (!rulesIndexes) {
            return false;
        }
        for (let j = 0; j < rulesIndexes.length; j += 1) {
            const r = this.ruleStorage.retrieveRule(rulesIndexes[j]);
            if (r && r.match(request)) {
                return true;
            }
        }
        return false;
    }
}

/* eslint-disable max-classes-per-file */
/**
 * Default rule index for source mapping.
 *
 * It is -1, similar to `Array.indexOf()` return value when element is not found.
 */
const RULE_INDEX_NONE = -1;
/**
 * Rule with index.
 */
// TODO: Consider remove this because rule already has an index field
class IndexedRule {
    /**
     * Rule.
     */
    rule;
    /**
     * Index.
     */
    index;
    /**
     * Constructor.
     *
     * @param rule Rule.
     * @param index Index of the rule.
     */
    constructor(rule, index) {
        this.rule = rule;
        this.index = index;
    }
}
/**
 * Rule with storage index.
 */
class IndexedStorageRule {
    /**
     * Rule.
     */
    rule;
    /**
     * Index.
     */
    index;
    /**
     * Constructor.
     *
     * @param rule Rule.
     * @param index Index of the rule.
     */
    constructor(rule, index) {
        this.rule = rule;
        this.index = index;
    }
}

/**
 * Splits url into parts.
 *
 * @param url The URL to be checked.
 *
 * @returns An object containing the path, query, and hash of the URL.
 */
function splitUrl(url) {
    let strippedUrl = url;
    let hash = '';
    const hashIndex = url.indexOf('#');
    if (hashIndex >= 0) {
        hash = url.slice(hashIndex);
        strippedUrl = url.slice(0, hashIndex);
    }
    let query = '';
    const queryIndex = url.indexOf('?');
    if (queryIndex >= 0) {
        query = strippedUrl.slice(queryIndex + 1);
        strippedUrl = strippedUrl.slice(0, queryIndex);
    }
    return {
        path: strippedUrl,
        query,
        hash,
    };
}
/**
 * Normalizes url query parameters.
 *
 * @param query The query string to be normalized.
 *
 * @returns The normalized query string.
 */
function normalizeQuery(query) {
    // Cleanup empty params (p0=0&=2&=3)
    let result = query
        .split('&')
        .filter((x) => x && !x.startsWith('='))
        .join('&');
    // If we've collapsed the URL to the point where there's an '&' against the '?'
    // then we need to get rid of that.
    while (result.charAt(0) === '&') {
        result = result.slice(1);
    }
    return result;
}
/**
 * Removes query params from url by regexp.
 *
 * @param url The URL from which query parameters will be removed.
 * @param regExp The regular expression to match query parameters.
 * @param invert Remove every parameter in url except the ones matched regexp.
 *
 * @returns The URL with the specified query parameters removed.
 */
function cleanUrlParamByRegExp(url, regExp, invert = false) {
    const searchIndex = url.indexOf('?');
    // If no params, nothing to modify
    if (searchIndex === -1) {
        return url;
    }
    const split = splitUrl(url);
    /**
     * We are checking both regular param and decoded param, in case if regexp
     * contains decoded params and url contains encoded params.
     *
     * @see {@link https://github.com/AdguardTeam/AdguardBrowserExtension/issues/3015}
     */
    let modifiedQuery;
    if (invert) {
        modifiedQuery = split.query
            .split('&')
            .filter((x) => x && (x.match(regExp) || decodeURIComponent(x).match(regExp)))
            .join('&');
    }
    else {
        modifiedQuery = split.query
            .split('&')
            .filter((x) => {
            const test = x.includes('=') ? x : `${x}=`;
            return !test.match(regExp) && !decodeURIComponent(test).match(regExp);
        })
            .join('&');
    }
    // Do not normalize if regexp is not applied
    if (modifiedQuery === split.query) {
        return url;
    }
    modifiedQuery = normalizeQuery(modifiedQuery);
    let result = split.path;
    if (modifiedQuery) {
        result += `?${modifiedQuery}`;
    }
    return result + split.hash;
}
/**
 * Extract relative part from hierarchical structured URL.
 *
 * @param url The URL from which the relative part will be extracted.
 *
 * @returns The relative part of the URL or null if not found.
 */
const getRelativeUrl = (url) => {
    const i = url.indexOf('/', url.indexOf('://') + 3);
    return i !== -1 ? url.slice(i) : null;
};
/**
 * Checks if url is http or websocket.
 *
 * @param url Request url.
 *
 * @returns True if url starts with http{s?} or ws.
 */
function isHttpOrWsRequest(url) {
    return !!url && (url.startsWith('http') || url.startsWith('ws'));
}

/**
 * Rule pattern class.
 *
 * This class parses rule pattern text to simple fields.
 */
class Pattern {
    /**
     * Original pattern text.
     */
    pattern;
    /**
     * Shortcut string.
     */
    shortcut;
    /**
     * If this pattern already prepared indicator.
     */
    prepared;
    /**
     * Parsed hostname.
     */
    hostname;
    /**
     * Parsed regular expression.
     */
    regex;
    /**
     * Invalid regex flag.
     */
    regexInvalid;
    /**
     * Domain specific pattern flag.
     */
    patternDomainSpecific;
    /**
     * If true, pattern and shortcut are the same.
     * In this case, we don't actually need to use `matchPattern`
     * if shortcut was already matched.
     */
    patternShortcut;
    /**
     * If pattern is match-case regex.
     */
    matchcase;
    /**
     * Constructor.
     *
     * @param pattern Pattern.
     * @param matchcase Flag for case-sensitive matching, default is false.
     */
    constructor(pattern, matchcase = false) {
        this.pattern = pattern;
        this.shortcut = simple_regex_BBjA8AEZ.S.extractShortcut(this.pattern);
        this.matchcase = matchcase;
    }
    /**
     * Checks if this rule pattern matches the specified request.
     *
     * @param request Request to check.
     * @param shortcutMatched If true, it means that the request already matches
     * this pattern's shortcut and we don't need to match it again.
     *
     * @returns True if pattern matches.
     */
    matchPattern(request, shortcutMatched) {
        this.prepare();
        if (this.patternShortcut) {
            return shortcutMatched || this.matchShortcut(request.urlLowercase);
        }
        if (this.hostname) {
            // If we have a `||example.org^` rule, it's easier to match
            // against the request's hostname only without matching
            // a regular expression.
            return request.hostname === this.hostname
                || ( // First light check without new string memory allocation
                request.hostname.endsWith(this.hostname)
                    // Strict check
                    && request.hostname.endsWith(`.${this.hostname}`));
        }
        // If the regular expression is invalid, just return false right away.
        if (this.regexInvalid || !this.regex) {
            return false;
        }
        // This is needed for DNS filtering only, not used in browser blocking.
        if (this.shouldMatchHostname(request)) {
            return this.regex.test(request.hostname);
        }
        return this.regex.test(request.url);
    }
    /**
     * Checks if this rule pattern matches the specified relative path string.
     * This method is used in cosmetic rules to implement the $path modifier matching logic.
     *
     * @param path Path to check.
     *
     * @returns True if pattern matches.
     */
    matchPathPattern(path) {
        this.prepare();
        if (this.hostname) {
            return false;
        }
        const pathIsEmptyString = this.pattern === '';
        // No-value $path should match root URL
        if (pathIsEmptyString && path === '/') {
            return true;
        }
        if (!pathIsEmptyString && this.patternShortcut) {
            return this.matchShortcut(path);
        }
        // If the regular expression is invalid, just return false right away.
        if (this.regexInvalid || !this.regex) {
            return false;
        }
        return this.regex.test(path);
    }
    /**
     * Simply checks if shortcut is a substring of the URL.
     *
     * @param str Shortcut to check.
     *
     * @returns True if the shortcut is a substring of the URL.
     */
    matchShortcut(str) {
        return str.indexOf(this.shortcut) >= 0;
    }
    /**
     * Prepares this pattern.
     */
    prepare() {
        if (this.prepared) {
            return;
        }
        this.prepared = true;
        // If shortcut and pattern are the same, we don't need to actually compile
        // a regex and can simply use matchShortcut instead,
        // except for the $match-case modifier
        if (this.pattern === this.shortcut && !this.matchcase) {
            this.patternShortcut = true;
            return;
        }
        // Rules like `/example/*` are rather often in the real-life filters,
        // we might want to process them.
        if (this.pattern.startsWith(this.shortcut)
            && this.pattern.length === this.shortcut.length + 1
            && this.pattern.endsWith('*')) {
            this.patternShortcut = true;
            return;
        }
        if (this.pattern.startsWith(simple_regex_BBjA8AEZ.S.MASK_START_URL)
            && this.pattern.endsWith(simple_regex_BBjA8AEZ.S.MASK_SEPARATOR)
            && this.pattern.indexOf('*') < 0
            && this.pattern.indexOf('/') < 0) {
            this.hostname = this.pattern.slice(2, this.pattern.length - 1);
            return;
        }
        this.compileRegex();
    }
    /**
     * Compiles this pattern regex.
     */
    compileRegex() {
        const regexText = simple_regex_BBjA8AEZ.S.patternToRegexp(this.pattern);
        try {
            let flags = 'i';
            if (this.matchcase) {
                flags = '';
            }
            this.regex = new RegExp(regexText, flags);
        }
        catch (e) {
            this.regexInvalid = true;
        }
    }
    /**
     * Checks if we should match hostnames and not the URL
     * this is important for the cases when we use urlfilter for DNS-level blocking
     * Note, that even though we may work on a DNS-level, we should still sometimes match full URL instead.
     *
     * @param request Request to check.
     *
     * @returns True if the hostname should be matched.
     */
    shouldMatchHostname(request) {
        if (!request.isHostnameRequest) {
            return false;
        }
        return !this.isPatternDomainSpecific();
    }
    /**
     * In case pattern starts with the following it targets some specific domain.
     *
     * @returns True if the pattern targets a specific domain.
     */
    isPatternDomainSpecific() {
        if (this.patternDomainSpecific === undefined) {
            this.patternDomainSpecific = this.pattern.startsWith(simple_regex_BBjA8AEZ.S.MASK_START_URL)
                || this.pattern.startsWith('http://')
                || this.pattern.startsWith('https:/')
                || this.pattern.startsWith('://');
        }
        return this.patternDomainSpecific;
    }
}

/**
 * @file Known CSS / Extended CSS elements.
 */
/**
 * Supported Extended CSS pseudo-classes.
 *
 * These pseudo-classes are not supported by browsers natively, so we need Extended CSS library to support them.
 *
 * Please keep this list sorted alphabetically.
 */
const SUPPORTED_EXT_CSS_PSEUDO_CLASSES = new Set([
    /**
     * Pseudo-classes :is(), and :not() may use native implementation.
     *
     * @see {@link https://github.com/AdguardTeam/ExtendedCss#extended-css-is}
     * @see {@link https://github.com/AdguardTeam/ExtendedCss#extended-css-not}
     */
    /**
     * :has() should also be conditionally considered as extended and should not be in this list,
     * for details check: https://github.com/AdguardTeam/ExtendedCss#extended-css-has,
     * but there is a bug with content blocker in safari:
     * for details check: https://bugs.webkit.org/show_bug.cgi?id=248868.
     *
     * TODO: remove 'has' later.
     */
    '-abp-contains', // alias for 'contains'
    '-abp-has', // alias for 'has'
    'contains',
    'has', // some browsers support 'has' natively
    'has-text', // alias for 'contains'
    'if',
    'if-not',
    'matches-attr',
    'matches-css',
    'matches-css-after', // deprecated, replaced by 'matches-css'
    'matches-css-before', // deprecated, replaced by 'matches-css'
    'matches-property',
    'nth-ancestor',
    'remove',
    'upward',
    'xpath',
]);
/**
 * Supported native CSS pseudo-classes.
 *
 * These pseudo-classes are supported by browsers natively, so we don't need Extended CSS library to support them.
 *
 * The problem with pseudo-classes is that any unknown pseudo-class makes browser ignore the whole CSS rule,
 * which contains a lot more selectors. So, if CSS selector contains a pseudo-class, we should try to validate it.
 * One more problem with pseudo-classes is that they are actively used in uBlock, hence it may mess AG styles.
 *
 * Please keep this list sorted alphabetically.
 */
const SUPPORTED_CSS_PSEUDO_CLASSES = new Set([
    'active', // https://developer.mozilla.org/en-US/docs/Web/CSS/:active
    'checked', // https://developer.mozilla.org/en-US/docs/Web/CSS/:checked
    'disabled', // https://developer.mozilla.org/en-US/docs/Web/CSS/:disabled
    'empty', // https://developer.mozilla.org/en-US/docs/Web/CSS/:empty
    'enabled', // https://developer.mozilla.org/en-US/docs/Web/CSS/:enabled
    'first-child', // https://developer.mozilla.org/en-US/docs/Web/CSS/:first-child
    'first-of-type', // https://developer.mozilla.org/en-US/docs/Web/CSS/:first-of-type
    'focus', // https://developer.mozilla.org/en-US/docs/Web/CSS/:focus
    'has', // https://developer.mozilla.org/en-US/docs/Web/CSS/:has
    'hover', // https://developer.mozilla.org/en-US/docs/Web/CSS/:hover
    'in-range', // https://developer.mozilla.org/en-US/docs/Web/CSS/:in-range
    'invalid', // https://developer.mozilla.org/en-US/docs/Web/CSS/:invalid
    'is', // https://developer.mozilla.org/en-US/docs/Web/CSS/:is
    'lang', // https://developer.mozilla.org/en-US/docs/Web/CSS/:lang
    'last-child', // https://developer.mozilla.org/en-US/docs/Web/CSS/:last-child
    'last-of-type', // https://developer.mozilla.org/en-US/docs/Web/CSS/:last-of-type
    'link', // https://developer.mozilla.org/en-US/docs/Web/CSS/:link
    'not', // https://developer.mozilla.org/en-US/docs/Web/CSS/:not
    'nth-child', // https://developer.mozilla.org/en-US/docs/Web/CSS/:nth-child
    'nth-last-child', // https://developer.mozilla.org/en-US/docs/Web/CSS/:nth-last-child
    'nth-last-of-type', // https://developer.mozilla.org/en-US/docs/Web/CSS/:nth-last-of-type
    'nth-of-type', // https://developer.mozilla.org/en-US/docs/Web/CSS/:nth-of-type
    'only-child', // https://developer.mozilla.org/en-US/docs/Web/CSS/:only-child
    'only-of-type', // https://developer.mozilla.org/en-US/docs/Web/CSS/:only-of-type
    'optional', // https://developer.mozilla.org/en-US/docs/Web/CSS/:optional
    'out-of-range', // https://developer.mozilla.org/en-US/docs/Web/CSS/:out-of-range
    'read-only', // https://developer.mozilla.org/en-US/docs/Web/CSS/:read-only
    'read-write', // https://developer.mozilla.org/en-US/docs/Web/CSS/:read-write
    'required', // https://developer.mozilla.org/en-US/docs/Web/CSS/:required
    'root', // https://developer.mozilla.org/en-US/docs/Web/CSS/:root
    'target', // https://developer.mozilla.org/en-US/docs/Web/CSS/:target
    'valid', // https://developer.mozilla.org/en-US/docs/Web/CSS/:valid
    'visited', // https://developer.mozilla.org/en-US/docs/Web/CSS/:visited
    'where', // https://developer.mozilla.org/en-US/docs/Web/CSS/:where
]);
/**
 * Every Extended CSS pseudo-class should start with this prefix.
 *
 * @see {@link https://github.com/AdguardTeam/ExtendedCss#-backward-compatible-syntax}
 */
const EXT_CSS_ATTRIBUTE_SELECTOR_PREFIX = '-ext-';
/**
 * Supported legacy Extended CSS attribute selectors.
 *
 * Attribute selector way is deprecated and will be removed completely in the future,
 * we replaced it with Extended CSS pseudo-classes. For example, instead of
 * `[-ext-has="a[href]"]` you should use `:has(a[href])`.
 *
 * Please keep this list sorted alphabetically.
 */
const SUPPORTED_EXT_CSS_ATTRIBUTE_SELECTORS = new Set([
    `${EXT_CSS_ATTRIBUTE_SELECTOR_PREFIX}has`,
    `${EXT_CSS_ATTRIBUTE_SELECTOR_PREFIX}contains`,
    `${EXT_CSS_ATTRIBUTE_SELECTOR_PREFIX}has-text`,
    `${EXT_CSS_ATTRIBUTE_SELECTOR_PREFIX}matches-css`,
    `${EXT_CSS_ATTRIBUTE_SELECTOR_PREFIX}matches-css-before`,
    `${EXT_CSS_ATTRIBUTE_SELECTOR_PREFIX}matches-css-after`,
]);
/**
 * Known CSS functions that aren't allowed in CSS injection rules, because they
 * able to load external resources. Please, keep this list sorted.
 */
const FORBIDDEN_CSS_FUNCTIONS = new Set([
    // https://developer.mozilla.org/en-US/docs/Web/CSS/cross-fade
    '-webkit-cross-fade',
    'cross-fade',
    // https://developer.mozilla.org/en-US/docs/Web/CSS/image
    'image',
    // https://developer.mozilla.org/en-US/docs/Web/CSS/image-set
    '-webkit-image-set',
    'image-set',
    // https://developer.mozilla.org/en-US/docs/Web/CSS/url
    'url',
]);

/**
 * Checks if error has message.
 *
 * @param error Error object.
 *
 * @returns If param is error.
 */
function isErrorWithMessage(error) {
    return (typeof error === 'object'
        && error !== null
        && 'message' in error
        && typeof error.message === 'string');
}
/**
 * Converts error to the error with message.
 *
 * @param maybeError Possible error.
 *
 * @returns Error with message.
 */
function toErrorWithMessage(maybeError) {
    if (isErrorWithMessage(maybeError)) {
        return maybeError;
    }
    try {
        return new Error(JSON.stringify(maybeError));
    }
    catch {
        // fallback in case there's an error stringifying the maybeError
        // like with circular references for example.
        return new Error(String(maybeError));
    }
}
/**
 * Converts error object to error with message. This method might be helpful to handle thrown errors.
 *
 * @param error Error object.
 *
 * @returns Message of the error.
 */
function getErrorMessage(error) {
    // Special case: pretty print Zod errors
    if (error instanceof lib/* ZodError */.G) {
        return (0,dist/* fromZodError */.yu)(error).toString();
    }
    return toErrorWithMessage(error).message;
}

/**
 * @file Selector list validator.
 */
/**
 * Does a basic validation of a selector list.
 * Checks for unsupported pseudo-classes and attribute selectors,
 * and determines if the selector is an Extended CSS selector.
 *
 * @param selectorList Selector list to validate.
 *
 * @returns Validation result, see {@link CssValidationResult}.
 *
 * @note This is a basic validation for the most necessary things, it does not guarantee that the CSS is completely
 * valid.
 */
const validateSelectorList = (selectorList) => {
    const result = {
        isValid: true,
        isExtendedCss: false,
    };
    try {
        let prevIsDoubleColon = false;
        let prevToken;
        let prevNonWhitespaceToken;
        (0,csstokenizer/* tokenizeExtended */.jz)(selectorList, (token, start, end) => {
            if ((token === csstokenizer/* TokenType */.ks.Function || token === csstokenizer/* TokenType */.ks.Ident)
                && prevToken === csstokenizer/* TokenType */.ks.Colon
                && !prevIsDoubleColon) {
                // whitespace is NOT allowed between the ':' and the pseudo-class name, like ': active('
                const name = selectorList.slice(start, 
                // function tokens look like 'func(', so we need to remove the last character
                token === csstokenizer/* TokenType */.ks.Function ? end - 1 : end);
                // function name may contain escaped characters, like '\75' instead of 'u', so we need to decode it
                const decodedName = (0,csstokenizer/* decodeIdent */.f0)(name);
                if (SUPPORTED_EXT_CSS_PSEUDO_CLASSES.has(decodedName)) {
                    result.isExtendedCss = true;
                }
                else if (!SUPPORTED_CSS_PSEUDO_CLASSES.has(decodedName)) {
                    throw new Error(`Unsupported pseudo-class: ':${decodedName}'`);
                }
            }
            else if (token === csstokenizer/* TokenType */.ks.Ident && prevNonWhitespaceToken === csstokenizer/* TokenType */.ks.OpenSquareBracket) {
                // whitespace is allowed between the '[' and the attribute name, like '[ attr]'
                const attributeName = selectorList.slice(start, end);
                if (attributeName.startsWith(EXT_CSS_ATTRIBUTE_SELECTOR_PREFIX)) {
                    result.isExtendedCss = true;
                    if (!SUPPORTED_EXT_CSS_ATTRIBUTE_SELECTORS.has(attributeName)) {
                        throw new Error(`Unsupported Extended CSS attribute selector: '${attributeName}'`);
                    }
                }
            }
            else if (token === csstokenizer/* TokenType */.ks.OpenCurlyBracket || token === csstokenizer/* TokenType */.ks.CloseCurlyBracket) {
                throw new Error('Curly brackets are not allowed in selector lists');
            }
            else if (token === csstokenizer/* TokenType */.ks.Comment) {
                throw new Error('Comments are not allowed in selector lists');
            }
            // memorize tokens, we need them later
            if (token === csstokenizer/* TokenType */.ks.Colon) {
                prevIsDoubleColon = prevToken === csstokenizer/* TokenType */.ks.Colon;
            }
            prevToken = token;
            if (token !== csstokenizer/* TokenType */.ks.Whitespace) {
                prevNonWhitespaceToken = token;
            }
        });
    }
    catch (error) {
        result.isValid = false;
        result.errorMessage = getErrorMessage(error);
    }
    return result;
};

/**
 * @file Declaration list validator.
 */
const REMOVE_PROPERTY = 'remove';
const REMOVE_LENGTH = REMOVE_PROPERTY.length;
/**
 * Check if function name is forbidden. If so, throws an error.
 *
 * @param functionName Function name to check.
 *
 * @throws Error if function name is forbidden.
 */
const checkFunctionName = (functionName) => {
    // function name may contain escaped characters, like '\75' instead of 'u', so we need to decode it
    const decodedFunctionName = (0,csstokenizer/* decodeIdent */.f0)(functionName);
    if (FORBIDDEN_CSS_FUNCTIONS.has(decodedFunctionName)) {
        throw new Error(`Using '${decodedFunctionName}()' is not allowed`);
    }
};
/**
 * Does a basic validation of a declaration list.
 * Checks for unsafe resource loading and determines if the declaration list is an Extended CSS declaration list.
 *
 * @param declarationList Declaration list to validate.
 *
 * @returns Validation result, see {@link CssValidationResult}.
 *
 * @note This is a basic validation for the most necessary things, it does not guarantee that the CSS is completely
 * valid.
 */
const validateDeclarationList = (declarationList) => {
    const result = {
        isValid: true,
        isExtendedCss: false,
    };
    try {
        (0,csstokenizer/* tokenizeExtended */.jz)(declarationList, (token, start, end) => {
            switch (token) {
                // Special case: according to CSS specs, sometimes url() is handled as a separate token type
                case csstokenizer/* TokenType */.ks.Url:
                case csstokenizer/* TokenType */.ks.BadUrl:
                    throw new Error("Using 'url()' is not allowed");
                case csstokenizer/* TokenType */.ks.Function:
                    // we need -1 to exclude closing bracket, because function tokens look like 'func('
                    checkFunctionName(declarationList.slice(start, end - 1));
                    break;
                case csstokenizer/* TokenType */.ks.Ident:
                    // do a fast check before getting the substring
                    if (end - start === REMOVE_LENGTH) {
                        // TODO: Improve this check, and check the whole `remove: true` sequence.
                        // Please note that the `remove : true` case also valid.
                        if ((0,csstokenizer/* decodeIdent */.f0)(declarationList.slice(start, end)) === REMOVE_PROPERTY) {
                            result.isExtendedCss = true;
                        }
                    }
                    break;
                case csstokenizer/* TokenType */.ks.Comment:
                    throw new Error('Comments are not allowed in declaration lists');
                default:
                    break;
            }
        });
    }
    catch (error) {
        result.isValid = false;
        result.errorMessage = getErrorMessage(error);
    }
    return result;
};

/* eslint-disable max-classes-per-file */
class ScriptletParams {
    props = null;
    constructor(name, args) {
        if (typeof name !== 'undefined') {
            this.props = {
                name,
                args: args || [],
            };
        }
    }
    get name() {
        return this.props?.name;
    }
    get args() {
        return this.props?.args ?? [];
    }
    toString() {
        const result = [];
        result.push(constants/* ADG_SCRIPTLET_MASK */.x$);
        result.push('(');
        if (this.name) {
            result.push(quotes/* QuoteUtils */.Qj.setStringQuoteType(this.name, quotes/* QuoteType */.XA.Single));
        }
        if (this.args.length) {
            result.push(', ');
            result.push(this.args.map((arg) => quotes/* QuoteUtils */.Qj.setStringQuoteType(arg, quotes/* QuoteType */.XA.Single)).join(', '));
        }
        result.push(')');
        return result.join(simple_regex_BBjA8AEZ.E);
    }
}
/**
 * @typedef {import('./cosmetic-result').CosmeticResult} CosmeticResult
 */
/**
 * Implements a basic cosmetic rule.
 *
 * Cosmetic rules syntax are almost similar and looks like this.
 * ```
 * rule = [domains] "marker" content
 * domains = [domain0, domain1[, ...[, domainN]]]
 * ```
 *
 * The rule type is defined by the `type` property, you can find the list of them
 * in the {@link CosmeticRuleType} enumeration.
 *
 * What matters, though, is what's in the `content` part of it.
 *
 * @example
 * `example.org##.banner` -- element hiding rule
 * `example.org#$#.banner { display: block; }` -- CSS rule
 * `example.org#%#window.x=1;` -- JS rule
 * `example.org#%#//scriptlet('scriptlet-name')` -- Scriptlet rule
 * `example.org$$div[id="test"]` -- HTML filtering rule
 */
class CosmeticRule {
    ruleIndex;
    filterListId;
    content;
    type;
    allowlist = false;
    extendedCss = false;
    /**
     * $domain modifier pattern. It is only set if $domain modifier is specified for this rule.
     */
    domainModifier = null;
    /**
     * $path modifier pattern. It is only set if $path modifier is specified for this rule.
     */
    pathModifier;
    /**
     * $url modifier pattern. It is only set if $url modifier is specified for this rule,
     * but $path and $domain modifiers are not.
     *
     * TODO: add this to test cases.
     */
    urlModifier;
    /**
     * Js script to execute.
     */
    script = undefined;
    /**
     * Object with script code ready to execute and debug, domain values.
     *
     * @private
     */
    scriptData = null;
    /**
     * Object with scriptlet function and params.
     *
     * @private
     */
    scriptletData = null;
    /**
     * Scriptlet parameters.
     */
    scriptletParams;
    /**
     * If the rule contains scriptlet content.
     */
    isScriptlet = false;
    getIndex() {
        return this.ruleIndex;
    }
    getFilterListId() {
        return this.filterListId;
    }
    /**
     * Returns the rule content.
     *
     * @returns The content of the rule.
     */
    getContent() {
        return this.content;
    }
    /**
     * Cosmetic rule type (always present).
     *
     * @returns The type of the cosmetic rule.
     */
    getType() {
        return this.type;
    }
    /**
     * Allowlist means that this rule is meant to disable other rules,
     * i.e. an exception rule.
     *
     * @see {@link https://kb.adguard.com/en/general/how-to-create-your-own-ad-filters#elemhide-exceptions}
     *
     * @returns True if the rule is an allowlist rule, false otherwise.
     */
    isAllowlist() {
        return this.allowlist;
    }
    /**
     * Returns script ready to execute or null
     * Rebuilds scriptlet script if debug or domain params change.
     *
     * @param options Script options.
     *
     * @returns Script code or null.
     */
    getScript(options = {}) {
        const { debug = false, frameUrl } = options;
        const { scriptData } = this;
        if (scriptData && !this.isScriptlet) {
            return scriptData.code;
        }
        if (scriptData && scriptData.debug === debug) {
            if (frameUrl) {
                if (frameUrl === scriptData.frameUrl) {
                    return scriptData.code;
                }
            }
            else {
                return scriptData.code;
            }
        }
        this.initScript(options);
        return this.scriptData?.code ?? null;
    }
    /**
     * Gets list of permitted domains.
     *
     * @returns List of permitted domains or null if no domain modifier is set.
     */
    getPermittedDomains() {
        if (this.domainModifier) {
            return this.domainModifier.getPermittedDomains();
        }
        return null;
    }
    /**
     * Gets list of restricted domains.
     *
     * @returns List of restricted domains or null if no domain modifier is set.
     */
    getRestrictedDomains() {
        if (this.domainModifier) {
            return this.domainModifier.getRestrictedDomains();
        }
        return null;
    }
    /**
     * Returns true if the rule is considered "generic"
     * "generic" means that the rule is not restricted to a limited set of domains
     * Please note that it might be forbidden on some domains, though.
     *
     * @returns True if the rule is generic, false otherwise.
     */
    isGeneric() {
        return !this.domainModifier?.hasPermittedDomains();
    }
    /**
     * Checks if the rule is ExtendedCss.
     *
     * @returns True if the rule is ExtendedCss, false otherwise.
     */
    isExtendedCss() {
        return this.extendedCss;
    }
    /**
     * Processes cosmetic rule modifiers, e.g. `$path`.
     *
     * @see {@link https://adguard.com/kb/general/ad-filtering/create-own-filters/#modifiers-for-non-basic-type-of-rules}
     *
     * @param ruleNode Cosmetic rule node to process.
     *
     * @returns Processed modifiers ({@link ProcessedModifiers}) or `null` if there are no modifiers.
     */
    static processModifiers(ruleNode) {
        // Do nothing if there are no modifiers in the rule node
        if (!ruleNode.modifiers) {
            return null;
        }
        const result = {};
        // We don't allow duplicate modifiers, so we collect them in a set
        const usedModifiers = new Set();
        // Destructure the modifiers array just for convenience
        const { children: modifierNodes } = ruleNode.modifiers;
        // AGTree parser tolerates this case: [$]example.com##.foo
        // However, we should throw an error here if the modifier list is empty
        // (if the modifier list isn't specified at all, then ruleNode.modifiers
        // will be undefined, so we won't get here)
        if (modifierNodes.length < 1) {
            throw new SyntaxError('Modifiers list cannot be be empty');
        }
        for (const modifierNode of modifierNodes) {
            const modifierName = modifierNode.name.value;
            // Check if the modifier is already used
            if (usedModifiers.has(modifierName)) {
                throw new Error(`Duplicated modifier: '${modifierName}'`);
            }
            // Mark the modifier as used by adding it to the set
            usedModifiers.add(modifierName);
            const modifierValue = modifierNode.value?.value || simple_regex_BBjA8AEZ.E;
            // Every modifier should have a value at the moment, so for simplicity we throw an error here if the
            // modifier value is not present.
            // TODO: Improve this when we decide to add modifiers without values
            if (modifierValue.length < 1 && modifierName !== "path" /* CosmeticRuleModifier.Path */) {
                throw new SyntaxError(`'$${modifierName}' modifier should have a value`);
            }
            // Process the modifier based on its name
            switch (modifierName) {
                case "domain" /* CosmeticRuleModifier.Domain */:
                    if (ruleNode.domains.children.length > 0) {
                        throw new SyntaxError(`'$${modifierName}' modifier is not allowed in a domain-specific rule`);
                    }
                    result.domainModifier = new DomainModifier(modifierValue, constants/* PIPE_MODIFIER_SEPARATOR */.fW);
                    break;
                case "path" /* CosmeticRuleModifier.Path */:
                    result.pathModifier = new Pattern(simple_regex_BBjA8AEZ.S.isRegexPattern(modifierValue)
                        // eslint-disable-next-line max-len
                        ? simple_regex_BBjA8AEZ.S.unescapeRegexSpecials(modifierValue, simple_regex_BBjA8AEZ.S.reModifierPatternEscapedSpecialCharacters)
                        : modifierValue);
                    break;
                case "url" /* CosmeticRuleModifier.Url */:
                    if (ruleNode.domains.children.length > 0) {
                        throw new SyntaxError(`'$${modifierName}' modifier is not allowed in a domain-specific rule`);
                    }
                    result.urlModifier = new Pattern(simple_regex_BBjA8AEZ.S.isRegexPattern(modifierValue)
                        // eslint-disable-next-line max-len
                        ? simple_regex_BBjA8AEZ.S.unescapeRegexSpecials(modifierValue, simple_regex_BBjA8AEZ.S.reModifierPatternEscapedSpecialCharacters)
                        : modifierValue);
                    break;
                // Don't allow unknown modifiers
                default:
                    throw new SyntaxError(`'$${modifierName}' modifier is not supported`);
            }
        }
        // $url modifier can't be used with other modifiers
        // TODO: Extend / change this check if we decide to add more such modifiers
        if (result.urlModifier && usedModifiers.size > 1) {
            throw new SyntaxError(`'$${"url" /* CosmeticRuleModifier.Url */}' modifier cannot be used with other modifiers`);
        }
        return result;
    }
    /**
     * Validates cosmetic rule node.
     *
     * @param ruleNode Cosmetic rule node to validate.
     *
     * @returns Validation result {@link ValidationResult}.
     */
    static validate(ruleNode) {
        const result = {
            isValid: true,
            isExtendedCss: false,
        };
        let scriptletName;
        let selectorListValidationResult;
        const { type: ruleType } = ruleNode;
        try {
            // Common validation: every cosmetic rule has a domain list
            if (ruleNode.domains?.children.length) {
                // Iterate over the domain list and check every domain
                for (const { value: domain } of ruleNode.domains.children) {
                    if (!utils_domain/* DomainUtils */.Aw.isValidDomainOrHostname(domain)) {
                        throw new Error(`'${domain}' is not a valid domain name`);
                    }
                }
            }
            // Type-specific validation
            switch (ruleType) {
                case nodes/* CosmeticRuleType */.k9.ElementHidingRule:
                    selectorListValidationResult = validateSelectorList(ruleNode.body.selectorList.value);
                    if (!selectorListValidationResult.isValid) {
                        throw new Error(selectorListValidationResult.errorMessage);
                    }
                    // Detect ExtendedCss and unsupported pseudo-classes
                    result.isExtendedCss = selectorListValidationResult.isExtendedCss;
                    break;
                case nodes/* CosmeticRuleType */.k9.CssInjectionRule:
                    selectorListValidationResult = validateSelectorList(ruleNode.body.selectorList.value);
                    if (!selectorListValidationResult.isValid) {
                        throw new Error(selectorListValidationResult.errorMessage);
                    }
                    // Detect ExtendedCss and unsupported pseudo-classes
                    result.isExtendedCss = selectorListValidationResult.isExtendedCss;
                    // AGTree won't allow the following rule:
                    // `#$#selector { remove: true; padding: 0; }`
                    // because it mixes removal and non-removal declarations.
                    if (ruleNode.body.declarationList) {
                        // eslint-disable-next-line max-len
                        const declarationListValidationResult = validateDeclarationList(ruleNode.body.declarationList.value);
                        if (!declarationListValidationResult.isValid) {
                            throw new Error(declarationListValidationResult.errorMessage);
                        }
                        // If the selector list is not ExtendedCss, then we should set this flag based on the
                        // declaration list validation result
                        if (!result.isExtendedCss) {
                            result.isExtendedCss = declarationListValidationResult.isExtendedCss;
                        }
                    }
                    break;
                case nodes/* CosmeticRuleType */.k9.ScriptletInjectionRule:
                    // Scriptlet name is the first child of the parameter list
                    // eslint-disable-next-line max-len
                    scriptletName = quotes/* QuoteUtils */.Qj.removeQuotes(ruleNode.body.children[0]?.children[0]?.value ?? simple_regex_BBjA8AEZ.E);
                    // Special case: scriptlet name is empty, e.g. '#%#//scriptlet()'
                    if (scriptletName.length === 0) {
                        break;
                    }
                    // Check if the scriptlet name is valid
                    if (!(0,validators/* isValidScriptletName */.GY)(scriptletName)) {
                        throw new Error(`'${scriptletName}' is not a known scriptlet name`);
                    }
                    break;
                case nodes/* CosmeticRuleType */.k9.HtmlFilteringRule:
                    // TODO: Validate HTML filtering rules
                    break;
                case nodes/* CosmeticRuleType */.k9.JsInjectionRule:
                    // TODO: Validate JS injection rules
                    break;
                default:
                    break;
            }
        }
        catch (error) {
            result.isValid = false;
            result.errorMessage = getErrorMessage(error);
        }
        return result;
    }
    /**
     * Checks if the domain list contains any domains, but returns `false` if only
     * the wildcard domain is specified.
     *
     * @param domainListNode Domain list node to check.
     *
     * @returns `true` if the domain list contains any domains, `false` otherwise.
     */
    static isAnyDomainSpecified(domainListNode) {
        if (domainListNode.children.length > 0) {
            // Skip wildcard domain list (*)
            return !(domainListNode.children.length === 1 && domainListNode.children[0].value === simple_regex_BBjA8AEZ.W);
        }
        return false;
    }
    /**
     * Creates an instance of the {@link CosmeticRule}.
     * It parses the rule and extracts the permitted/restricted domains,
     * and also the cosmetic rule's content.
     *
     * Depending on the rule type, the content might be transformed in
     * one of the helper classes, or kept as string when it's appropriate.
     *
     * @param node AST node of the cosmetic rule.
     * @param filterListId ID of the filter list this rule belongs to.
     * @param ruleIndex Line start index in the source filter list; it will be used to find the original rule text
     * in the filtering log when a rule is applied. Default value is {@link RULE_INDEX_NONE} which means that
     * the rule does not have source index.
     *
     * @throws Error if it fails to parse the rule.
     */
    constructor(node, filterListId, ruleIndex = RULE_INDEX_NONE) {
        this.ruleIndex = ruleIndex;
        this.filterListId = filterListId;
        this.allowlist = cosmetic_rule_separator/* CosmeticRuleSeparatorUtils */.m.isException(node.separator.value);
        this.type = node.type;
        this.isScriptlet = node.type === nodes/* CosmeticRuleType */.k9.ScriptletInjectionRule;
        this.content = cosmetic_rule_body_generator/* CosmeticRuleBodyGenerator */.H.generate(node);
        // Store the scriptlet parameters. They will be used later, when we initialize the scriptlet,
        // but at this point we need to store them in order to avoid double parsing
        if (node.type === nodes/* CosmeticRuleType */.k9.ScriptletInjectionRule) {
            // Transform complex node into a simple array of strings
            const params = node.body.children[0]?.children.map((param) => (param === null ? simple_regex_BBjA8AEZ.E : quotes/* QuoteUtils */.Qj.removeQuotesAndUnescape(param.value))) ?? [];
            this.scriptletParams = new ScriptletParams(params[0] ?? '', params.slice(1));
        }
        else {
            this.scriptletParams = new ScriptletParams();
        }
        const validationResult = CosmeticRule.validate(node);
        // We should throw an error if the validation failed for any reason
        if (!validationResult.isValid) {
            throw new SyntaxError(validationResult.errorMessage);
        }
        // Check if the rule is ExtendedCss
        const isExtendedCssSeparator = cosmetic_rule_separator/* CosmeticRuleSeparatorUtils */.m.isExtendedCssMarker(node.separator.value);
        this.extendedCss = isExtendedCssSeparator || validationResult.isExtendedCss;
        // Process cosmetic rule modifiers
        const processedModifiers = CosmeticRule.processModifiers(node);
        if (processedModifiers) {
            if (processedModifiers.domainModifier) {
                this.domainModifier = processedModifiers.domainModifier;
            }
            if (processedModifiers.pathModifier) {
                this.pathModifier = processedModifiers.pathModifier;
            }
            if (processedModifiers.urlModifier) {
                this.urlModifier = processedModifiers.urlModifier;
            }
        }
        // Process domain list, if at least one domain is specified
        const { domains: domainListNode } = node;
        if (CosmeticRule.isAnyDomainSpecified(domainListNode)) {
            this.domainModifier = new DomainModifier(domainListNode, constants/* COMMA_DOMAIN_LIST_SEPARATOR */.oo);
        }
    }
    /**
     * Match returns true if this rule can be used on the specified request.
     *
     * @param request Request to check.
     *
     * @returns True if the rule matches the request, false otherwise.
     */
    match(request) {
        if (!this.domainModifier
            && !this.pathModifier
            && !this.urlModifier) {
            return true;
        }
        if (this.urlModifier) {
            return this.urlModifier.matchPattern(request, false);
        }
        if (this.domainModifier) {
            if (!this.domainModifier.matchDomain(request.hostname)) {
                return false;
            }
        }
        if (this.pathModifier) {
            const path = getRelativeUrl(request.urlLowercase);
            if (path) {
                return this.pathModifier.matchPathPattern(path);
            }
            return false;
        }
        return true;
    }
    /**
     * Returns the scriptlet's data consisting of the scriptlet function and its arguments.
     * This method is supposed to be used in the manifest V3 extension.
     *
     * @returns The scriptlet data or null if not available.
     */
    getScriptletData() {
        if (this.scriptletData) {
            return this.scriptletData;
        }
        this.initScript();
        return this.scriptletData;
    }
    /**
     * Updates this.scriptData and this.scriptletData when it is necessary in a lazy way.
     *
     * @param options Initialization options for the script.
     */
    initScript(options = {}) {
        const { debug = false, frameUrl } = options;
        const ruleContent = this.getContent();
        if (!this.isScriptlet) {
            this.scriptData = {
                code: ruleContent,
            };
            return;
        }
        // A scriptlet without a name can only be an allowlist scriptlet
        // https://github.com/AdguardTeam/Scriptlets/issues/377
        // or it is considered invalid if the scriptlet was invalid.
        // This does not require finding scriptData and scriptletData.
        if (!this.scriptletParams?.name) {
            return;
        }
        const params = {
            args: this.scriptletParams.args,
            engine: config.engine || simple_regex_BBjA8AEZ.E,
            name: this.scriptletParams.name,
            verbose: debug,
            domainName: frameUrl,
            version: config.version || simple_regex_BBjA8AEZ.E,
        };
        this.scriptData = {
            code: scriptlets/* scriptlets */.e.invoke(params) ?? null,
            debug,
            frameUrl,
        };
        this.scriptletData = {
            func: scriptlets/* scriptlets */.e.getScriptletFunction(params.name),
            params,
        };
    }
}

/**
 * @typedef {import('./cosmetic-result').CosmeticResult} CosmeticResult
 */
/**
 * This class stores found cosmetic css rules content in the appropriate collections
 * It is primarily used by the {@link CosmeticResult}.
 */
class CosmeticStylesResult {
    /**
     * Collection of generic rules.
     */
    generic;
    /**
     * Collection of specific rules.
     */
    specific;
    /**
     * Collection of generic ext-css rules.
     */
    genericExtCss;
    /**
     * Collection of specific ext-css rules.
     */
    specificExtCss;
    /**
     * Constructor.
     */
    constructor() {
        this.generic = [];
        this.specific = [];
        this.genericExtCss = [];
        this.specificExtCss = [];
    }
    /**
     * Appends rule to the appropriate collection.
     *
     * @param rule Cosmetic rule.
     */
    append(rule) {
        if (rule.isGeneric()) {
            if (rule.isExtendedCss()) {
                this.genericExtCss.push(rule);
            }
            else {
                this.generic.push(rule);
            }
        }
        else if (rule.isExtendedCss()) {
            this.specificExtCss.push(rule);
        }
        else {
            this.specific.push(rule);
        }
    }
}

/**
 * @typedef {import('./cosmetic-result').CosmeticResult} CosmeticResult
 */
/**
 * This class stores found script rules content in the appropriate collections
 * It is primarily used by the {@link CosmeticResult}.
 */
class CosmeticScriptsResult {
    /**
     * Collection of generic (domain insensitive) rules.
     */
    generic;
    /**
     * Collection of domain specific rules.
     */
    specific;
    /**
     * Constructor.
     */
    constructor() {
        this.generic = [];
        this.specific = [];
    }
    /**
     * Appends rule to appropriate collection.
     *
     * @param rule Cosmetic rule.
     */
    append(rule) {
        if (rule.isGeneric()) {
            this.generic.push(rule);
        }
        else {
            this.specific.push(rule);
        }
    }
    /**
     * Returns collected cosmetic rules — both generic and specific.
     *
     * @returns Array of collected cosmetic rules.
     */
    getRules() {
        return [...this.generic, ...this.specific];
    }
}

/**
 * @typedef {import('./cosmetic-result').CosmeticResult} CosmeticResult
 */
/**
 * This class stores found cosmetic html rules content in the appropriate collections
 * It is primarily used by the {@link CosmeticResult}.
 */
class CosmeticHtmlResult {
    /**
     * Collection of generic rules.
     */
    generic;
    /**
     * Collection of specific rules.
     */
    specific;
    /**
     * Constructor.
     */
    constructor() {
        this.generic = [];
        this.specific = [];
    }
    /**
     * Appends rule to the appropriate collection.
     *
     * @param rule Rule to process.
     */
    append(rule) {
        if (rule.isGeneric()) {
            this.generic.push(rule);
        }
        else {
            this.specific.push(rule);
        }
    }
    /**
     * Returns collected cosmetic **HTML** rules — both generic and specific.
     *
     * @returns Array of collected rules.
     */
    getRules() {
        return [...this.generic, ...this.specific];
    }
}

/**
 * @typedef {import('./cosmetic-engine').CosmeticEngine} CosmeticEngine
 */
/**
 * Cosmetic result is the representation of rules
 * It is primarily used by the {@link CosmeticEngine}.
 */
class CosmeticResult {
    /**
     * Storage of element hiding rules.
     */
    elementHiding;
    /**
     * Storage of CSS rules.
     */
    CSS;
    /**
     * Storage of JS rules.
     */
    JS;
    /**
     * Storage of Html filtering rules.
     */
    Html;
    /**
     * Constructor.
     */
    constructor() {
        this.elementHiding = new CosmeticStylesResult();
        this.CSS = new CosmeticStylesResult();
        this.JS = new CosmeticScriptsResult();
        this.Html = new CosmeticHtmlResult();
    }
    /**
     * Script rules.
     *
     * @returns Array of cosmetic **JavaScript** rules.
     */
    getScriptRules() {
        return this.JS.getRules();
    }
}

/**
 * CosmeticOption is the enumeration of various content script options.
 * Depending on the set of enabled flags the content script will contain different set of settings.
 */
var CosmeticOption;
(function (CosmeticOption) {
    /**
     * If generic elemhide and CSS rules are enabled.
     * Could be disabled by a $generichide rule and $elemhide rule.
     */
    CosmeticOption[CosmeticOption["CosmeticOptionGenericCSS"] = 2] = "CosmeticOptionGenericCSS";
    /**
     * If specific elemhide and CSS rules are enabled.
     * Could be disabled by a $specifichide rule and $elemhide rule.
     */
    CosmeticOption[CosmeticOption["CosmeticOptionSpecificCSS"] = 4] = "CosmeticOptionSpecificCSS";
    /**
     * If JS rules and scriptlets are enabled.
     * Could be disabled by a $jsinject rule.
     */
    CosmeticOption[CosmeticOption["CosmeticOptionJS"] = 8] = "CosmeticOptionJS";
    /**
     * If HTML filtering rules are enabled.
     * Could be disabled by a $content rule.
     */
    CosmeticOption[CosmeticOption["CosmeticOptionHtml"] = 16] = "CosmeticOptionHtml";
    /**
     * TODO: Add support for these flags.
     *
     * They are useful when content script is injected into an iframe.
     * In this case we can check what flags were applied to the top-level frame.
     */
    CosmeticOption[CosmeticOption["CosmeticOptionSourceGenericCSS"] = 32] = "CosmeticOptionSourceGenericCSS";
    CosmeticOption[CosmeticOption["CosmeticOptionSourceCSS"] = 64] = "CosmeticOptionSourceCSS";
    CosmeticOption[CosmeticOption["CosmeticOptionSourceJS"] = 128] = "CosmeticOptionSourceJS";
    /**
     * Everything is enabled.
     */
    CosmeticOption[CosmeticOption["CosmeticOptionAll"] = 30] = "CosmeticOptionAll";
    /**
     * Everything is disabled.
     */
    CosmeticOption[CosmeticOption["CosmeticOptionNone"] = 0] = "CosmeticOptionNone";
})(CosmeticOption || (CosmeticOption = {}));

/**
 * Scanner types enum.
 */
var ScannerType;
(function (ScannerType) {
    /**
     * Scanning for network rules.
     */
    ScannerType[ScannerType["NetworkRules"] = 0] = "NetworkRules";
    /**
     * Scanning for cosmetic rules.
     */
    ScannerType[ScannerType["CosmeticRules"] = 2] = "CosmeticRules";
    /**
     * Scanning for host rules.
     */
    ScannerType[ScannerType["HostRules"] = 4] = "HostRules";
    /**
     * All types of rules.
     */
    ScannerType[ScannerType["All"] = 6] = "All";
})(ScannerType || (ScannerType = {}));

/**
 * @typedef {import('../engine').Engine} Engine
 */
/**
 * CosmeticEngine combines all the cosmetic rules and allows to quickly
 * find all rules matching this or that hostname
 * It is primarily used by the {@link Engine}.
 */
class CosmeticEngine {
    /**
     * Rules storage.
     */
    ruleStorage;
    /**
     * Count of rules added to the engine.
     */
    rulesCount;
    /**
     * Lookup table for elemhide rules.
     */
    elementHidingLookupTable;
    /**
     * Lookup table for css rules.
     */
    cssLookupTable;
    /**
     * Lookup table for js and scriptlets rules.
     */
    jsLookupTable;
    /**
     * Lookup table for html filtering rules.
     */
    htmlLookupTable;
    /**
     * Builds instance of cosmetic engine.
     *
     * @param ruleStorage Rule storage.
     * @param skipStorageScan Create an instance without storage scanning.
     */
    constructor(ruleStorage, skipStorageScan = false) {
        this.ruleStorage = ruleStorage;
        this.rulesCount = 0;
        this.elementHidingLookupTable = new CosmeticLookupTable(ruleStorage);
        this.cssLookupTable = new CosmeticLookupTable(ruleStorage);
        this.jsLookupTable = new CosmeticLookupTable(ruleStorage);
        this.htmlLookupTable = new CosmeticLookupTable(ruleStorage);
        if (skipStorageScan) {
            return;
        }
        const scanner = this.ruleStorage.createRuleStorageScanner(ScannerType.CosmeticRules);
        while (scanner.scan()) {
            const indexedRule = scanner.getRule();
            if (indexedRule
                && indexedRule.rule instanceof CosmeticRule) {
                this.addRule(indexedRule.rule, indexedRule.index);
            }
        }
    }
    /**
     * Adds rules into appropriate tables.
     *
     * @param rule Rule to add.
     * @param storageIdx Index of the rule in the storage.
     */
    addRule(rule, storageIdx) {
        switch (rule.getType()) {
            case nodes/* CosmeticRuleType */.k9.ElementHidingRule: {
                this.elementHidingLookupTable.addRule(rule, storageIdx);
                break;
            }
            case nodes/* CosmeticRuleType */.k9.CssInjectionRule: {
                this.cssLookupTable.addRule(rule, storageIdx);
                break;
            }
            case nodes/* CosmeticRuleType */.k9.ScriptletInjectionRule: {
                this.jsLookupTable.addRule(rule, storageIdx);
                break;
            }
            case nodes/* CosmeticRuleType */.k9.JsInjectionRule: {
                this.jsLookupTable.addRule(rule, storageIdx);
                break;
            }
            case nodes/* CosmeticRuleType */.k9.HtmlFilteringRule: {
                this.htmlLookupTable.addRule(rule, storageIdx);
                break;
            }
        }
        this.rulesCount += 1;
    }
    /**
     * Checks if bitwise mask matches option.
     *
     * @param option Option to match.
     * @param targetOption Target option.
     *
     * @returns True if option matches targetOption.
     */
    static matchOption(option, targetOption) {
        return (option & targetOption) === targetOption;
    }
    /**
     * Prepares cosmetic result by request.
     *
     * @param request Request to match.
     * @param option Mask of enabled cosmetic types.
     *
     * @returns CosmeticResult.
     */
    match(request, option) {
        const includeGeneric = CosmeticEngine.matchOption(option, CosmeticOption.CosmeticOptionGenericCSS);
        const includeSpecific = CosmeticEngine.matchOption(option, CosmeticOption.CosmeticOptionSpecificCSS);
        const includeJs = CosmeticEngine.matchOption(option, CosmeticOption.CosmeticOptionJS);
        const includeHtml = CosmeticEngine.matchOption(option, CosmeticOption.CosmeticOptionHtml);
        const cosmeticResult = new CosmeticResult();
        if (includeGeneric) {
            CosmeticEngine.appendGenericRules(cosmeticResult.elementHiding, this.elementHidingLookupTable, request);
            CosmeticEngine.appendGenericRules(cosmeticResult.CSS, this.cssLookupTable, request);
        }
        if (includeSpecific) {
            CosmeticEngine.appendSpecificRules(cosmeticResult.elementHiding, this.elementHidingLookupTable, request);
            CosmeticEngine.appendSpecificRules(cosmeticResult.CSS, this.cssLookupTable, request);
        }
        if (includeJs) {
            CosmeticEngine.appendGenericRules(cosmeticResult.JS, this.jsLookupTable, request);
            CosmeticEngine.appendSpecificRules(cosmeticResult.JS, this.jsLookupTable, request);
        }
        if (includeHtml) {
            if (includeGeneric) {
                CosmeticEngine.appendGenericRules(cosmeticResult.Html, this.htmlLookupTable, request);
            }
            CosmeticEngine.appendSpecificRules(cosmeticResult.Html, this.htmlLookupTable, request);
        }
        return cosmeticResult;
    }
    /**
     * Selects generic rules and appends rules content to cosmetic result.
     *
     * @param cosmeticResult Cosmetic result.
     * @param lookupTable Lookup table.
     * @param request Request.
     */
    static appendGenericRules(cosmeticResult, lookupTable, request) {
        for (const genericRule of lookupTable.genericRules) {
            if (!lookupTable.isAllowlisted(request, genericRule)
                && genericRule.match(request)) {
                cosmeticResult.append(genericRule, request);
            }
        }
    }
    /**
     * Selects specific rules and appends rules content to cosmetic result.
     *
     * @param cosmeticResult Cosmetic result.
     * @param lookupTable Lookup table.
     * @param request Request.
     */
    static appendSpecificRules(cosmeticResult, lookupTable, request) {
        const hostnameRules = lookupTable.findByHostname(request);
        if (hostnameRules.length > 0) {
            for (const rule of hostnameRules) {
                if (!lookupTable.isAllowlisted(request, rule)) {
                    cosmeticResult.append(rule, request);
                }
            }
        }
    }
}

/**
 * Replace modifier class.
 */
class ReplaceModifier {
    /**
     * Replace option value.
     */
    replaceOption;
    /**
     * Replace option apply function.
     */
    replaceApply;
    /**
     * Constructor.
     *
     * @param value Replace modifier value.
     */
    constructor(value) {
        const parsed = ReplaceModifier.parseReplaceOption(value);
        this.replaceOption = parsed.optionText;
        this.replaceApply = parsed.apply;
    }
    /**
     * Parses replace option.
     *
     * @param option Replace option.
     *
     * @returns Parsed replace option.
     */
    static parseReplaceOption(option) {
        if (!option) {
            return {
                apply: (x) => x,
                optionText: '',
            };
        }
        const parts = (0,simple_regex_BBjA8AEZ.s)(option, '/', '\\', true);
        let modifiers = (parts[2] || '');
        if (modifiers.indexOf('g') < 0) {
            modifiers += 'g';
        }
        const pattern = new RegExp(parts[0], modifiers);
        // unescape replacement alias
        let replacement = parts[1].replace(/\\\$/g, '$');
        replacement = simple_regex_BBjA8AEZ.S.unescapeSpecials(replacement);
        const apply = (input) => input.replace(pattern, replacement);
        return {
            apply,
            optionText: option,
        };
    }
    /**
     * Replace content.
     *
     * @returns The replace option value.
     */
    getValue() {
        return this.replaceOption;
    }
    /**
     * Replace apply function.
     *
     * @returns The function to apply the replacement.
     */
    getApplyFunc() {
        return this.replaceApply;
    }
}

const CSP_HEADER_NAME = 'Content-Security-Policy';
/**
 * Csp modifier class.
 */
class CspModifier {
    /**
     * Csp directive.
     *
     * @returns The CSP directive.
     */
    cspDirective;
    /**
     * Is allowlist rule.
     */
    isAllowlist;
    /**
     * Constructor.
     *
     * @param value Value of the modifier.
     * @param isAllowlist Whether the rule is an allowlist rule or not.
     */
    constructor(value, isAllowlist) {
        this.cspDirective = value;
        this.isAllowlist = isAllowlist;
        this.validateCspDirective();
    }
    /**
     * Csp directive.
     *
     * @returns The CSP directive.
     */
    getValue() {
        return this.cspDirective;
    }
    /**
     * Validates CSP rule.
     */
    validateCspDirective() {
        /**
         * CSP directive may be empty in case of allowlist rule,
         * it means to disable all $csp rules matching the allowlist rule.
         *
         * @see {@link https://github.com/AdguardTeam/AdguardBrowserExtension/issues/685}
         */
        if (!this.isAllowlist && !this.cspDirective) {
            throw new Error('Invalid $CSP rule: CSP directive must not be empty');
        }
        if (this.cspDirective) {
            /**
             * Forbids report-to and report-uri directives.
             *
             * @see {@link https://github.com/AdguardTeam/AdguardBrowserExtension/issues/685#issue-228287090}
             */
            const cspDirective = this.cspDirective.toLowerCase();
            if (cspDirective.indexOf('report-') >= 0) {
                throw new Error(`Forbidden CSP directive: ${cspDirective}`);
            }
        }
    }
}

/**
 * Cookie modifier class.
 *
 * Learn more about it here:
 * https://github.com/AdguardTeam/AdguardBrowserExtension/issues/961.
 */
class CookieModifier {
    /**
     * Cookie `maxAge` name.
     */
    static MAX_AGE = 'maxAge';
    /**
     * Cookie `sameSite` name.
     */
    static SAME_SITE = 'sameSite';
    /**
     * Option value.
     */
    optionValue;
    /**
     * Regexp value.
     */
    regex;
    /**
     * Cookie name.
     */
    cookieName;
    /**
     * Cookie `sameSite` value.
     */
    sameSite;
    /**
     * Cookie `maxAge` value.
     */
    maxAge;
    /**
     * Constructor.
     *
     * @param value Value of the modifier.
     */
    constructor(value) {
        // Save the source text of the option modifier
        this.optionValue = value || '';
        this.regex = null;
        this.cookieName = null;
        this.sameSite = null;
        this.maxAge = null;
        // Parse cookie name/regex
        const parts = this.optionValue.split(/;/);
        if (parts.length < 1) {
            throw new Error(`Cannot parse ${this.optionValue}`);
        }
        const cookieName = parts[0];
        if (cookieName.startsWith('/') && cookieName.endsWith('/')) {
            const pattern = cookieName.substring(1, cookieName.length - 1);
            // Save regex to be used further for matching cookies
            this.regex = new RegExp(pattern);
        }
        else {
            // Match by cookie name
            this.cookieName = cookieName;
        }
        // Parse other cookie options
        if (parts.length > 1) {
            for (let i = 1; i < parts.length; i += 1) {
                const nameValue = parts[i].split('=');
                const optionName = nameValue[0];
                const optionValue = nameValue[1];
                if (optionName === CookieModifier.MAX_AGE) {
                    this.maxAge = parseInt(optionValue, 10);
                }
                else if (optionName === CookieModifier.SAME_SITE) {
                    this.sameSite = optionValue;
                }
                else {
                    throw new Error(`Unknown $cookie option: ${optionName}`);
                }
            }
        }
    }
    /**
     * Gets modifier value.
     *
     * @returns Modifier value.
     */
    getValue() {
        return this.optionValue;
    }
    /**
     * First cookie name.
     *
     * @returns The first cookie name.
     */
    getCookieName() {
        return this.cookieName;
    }
    /**
     * Max age cookie value.
     *
     * @returns The max age cookie value.
     */
    getMaxAge() {
        return this.maxAge;
    }
    /**
     * Same site cookie value.
     *
     * @returns The same site cookie value.
     */
    getSameSite() {
        return this.sameSite;
    }
    /**
     * Checks if cookie with the specified name matches this option.
     *
     * @param name Cookie name.
     *
     * @returns True if matches, false otherwise.
     */
    matches(name) {
        if (!name) {
            return false;
        }
        if (this.regex) {
            return this.regex.test(name);
        }
        if (this.cookieName) {
            return this.cookieName === name;
        }
        // Empty regex and cookieName means that we must match all cookies
        return true;
    }
    /**
     * Checks if cookie rule has an empty $cookie option.
     *
     * @returns True if $cookie option is empty.
     */
    isEmpty() {
        return !this.regex && !this.cookieName;
    }
    /**
     * Checks if the given modifier is an instance of CookieModifier.
     *
     * @param m The modifier to check.
     *
     * @returns True if the modifier is an instance of CookieModifier, false otherwise.
     */
    static isCookieModifier = (m) => {
        return m instanceof CookieModifier;
    };
}

/**
 * Array of all stealth options available, even those which are not supported by browser extension.
 */
var UniversalStealthOption;
(function (UniversalStealthOption) {
    UniversalStealthOption["HideSearchQueries"] = "searchqueries";
    UniversalStealthOption["DoNotTrack"] = "donottrack";
    UniversalStealthOption["ThirdPartyCookies"] = "3p-cookie";
    UniversalStealthOption["FirstPartyCookies"] = "1p-cookie";
    UniversalStealthOption["ThirdPartyCache"] = "3p-cache";
    UniversalStealthOption["ThirdPartyAuth"] = "3p-auth";
    UniversalStealthOption["WebRTC"] = "webrtc";
    UniversalStealthOption["Push"] = "push";
    UniversalStealthOption["Location"] = "location";
    UniversalStealthOption["Flash"] = "flash";
    UniversalStealthOption["Java"] = "java";
    UniversalStealthOption["HideReferrer"] = "referrer";
    UniversalStealthOption["UserAgent"] = "useragent";
    UniversalStealthOption["IP"] = "ip";
    UniversalStealthOption["XClientData"] = "xclientdata";
    UniversalStealthOption["DPI"] = "dpi";
})(UniversalStealthOption || (UniversalStealthOption = {}));
/**
 * List of stealth options, supported by browser extension, which can be disabled by $stealth modifier.
 *
 * Following stealth options are initialized on the engine start
 * and can't be disabled via $stealth modifier:
 * - `Block trackers` and `Remove tracking parameters`, as they are applied by a specific
 *   rule lists, initialized on app start;
 * - `Disabling WebRTC`, as it is not being applied on per-request basis.
 */
var StealthOptionName;
(function (StealthOptionName) {
    StealthOptionName["HideSearchQueries"] = "searchqueries";
    StealthOptionName["DoNotTrack"] = "donottrack";
    StealthOptionName["HideReferrer"] = "referrer";
    StealthOptionName["XClientData"] = "xclientdata";
    StealthOptionName["FirstPartyCookies"] = "1p-cookie";
    StealthOptionName["ThirdPartyCookies"] = "3p-cookie";
})(StealthOptionName || (StealthOptionName = {}));
const StealthModifierOptions = new Set(Object.values(StealthOptionName));
const UniversalStealthOptions = new Set(Object.values(UniversalStealthOption));
const StealthOption = {
    NotSet: 0,
    [StealthOptionName.HideSearchQueries]: 1,
    [StealthOptionName.DoNotTrack]: 1 << 1,
    [StealthOptionName.HideReferrer]: 1 << 2,
    [StealthOptionName.XClientData]: 1 << 3,
    [StealthOptionName.FirstPartyCookies]: 1 << 4,
    [StealthOptionName.ThirdPartyCookies]: 1 << 5,
};
/**
 * Id to create stealth mode rule lists with,
 * e.g cookie rules for `Self-destructing third-party/first-party cookies` options.
 * It is also used to identify such rules when disabling on per-rule basis.
 */
const STEALTH_MODE_FILTER_ID = -1;
/**
 * Stealth modifier class.
 * Rules with $stealth modifier will disable specified stealth options for matched requests.
 *
 * @see {@link https://adguard.com/kb/general/ad-filtering/create-own-filters/#stealth-modifier}
 */
class StealthModifier {
    PIPE_SEPARATOR = '|';
    options = StealthOption.NotSet;
    /**
     * Parses the options string and creates a new stealth modifier instance.
     *
     * @param optionsStr Options string.
     *
     * @throws SyntaxError on inverted stealth options, which are not supported.
     */
    constructor(optionsStr) {
        if (optionsStr.trim().length === 0) {
            return;
        }
        // This prevents parsing invalid syntax as rule without supported options
        if (optionsStr.includes(',')) {
            throw new SyntaxError(`Invalid separator of stealth options used: "${optionsStr}"`);
        }
        const tokens = optionsStr.split(this.PIPE_SEPARATOR);
        for (let i = 0; i < tokens.length; i += 1) {
            const optionName = tokens[i].trim();
            if (optionName === '') {
                continue;
            }
            if (optionName.startsWith('~')) {
                throw new SyntaxError(`Inverted $stealth modifier values are not allowed: "${optionsStr}"`);
            }
            if (!StealthModifier.isValidStealthOption(optionName)) {
                throw new SyntaxError(`Invalid $stealth option in modifier value: "${optionsStr}"`);
            }
            // Skip options which are not supported by browser extension
            if (!StealthModifier.isSupportedStealthOption(optionName)) {
                continue;
            }
            const option = StealthOption[optionName];
            if (this.options & option) {
                logger.debug(`Duplicate $stealth modifier value "${optionName}" in "${optionsStr}"`);
            }
            this.options |= option;
        }
        if (this.options === StealthOption.NotSet) {
            // eslint-disable-next-line max-len
            const msg = `$stealth modifier does not contain any options supported by browser extension: "${optionsStr}"`;
            logger.debug(msg);
        }
    }
    /**
     * Checks if the given string is a valid $stealth option, supported by browser extension.
     *
     * @param option Option name.
     *
     * @returns True if the given string is a valid $stealth option.
     */
    static isSupportedStealthOption = (option) => StealthModifierOptions.has(option);
    /**
     * Checks if the given string is a valid $stealth option.
     *
     * @param option Option name.
     *
     * @returns True if the given string is a valid $stealth option.
     */
    static isValidStealthOption = (option) => UniversalStealthOptions.has(option);
    /**
     * Checks if this stealth modifier has values.
     *
     * @returns True if this stealth modifier has at least one value.
     */
    hasValues() {
        return this.options !== StealthOption.NotSet;
    }
    /**
     * Checks if this stealth modifier is disabling the given stealth option.
     *
     * @param optionName Stealth option name.
     *
     * @returns True if this stealth modifier is disabling the given stealth option.
     */
    hasStealthOption(optionName) {
        const option = StealthOption[optionName];
        return !!(option && this.options & option);
    }
}

/**
 * Redirect modifier class.
 */
class RedirectModifier {
    /**
     * Redirect title.
     */
    redirectTitle;
    /**
     * Is redirecting only blocked requests
     * See $redirect-rule options.
     */
    isRedirectingOnlyBlocked = false;
    /**
     * Constructor.
     *
     * @param value Redirect modifier value.
     * @param isAllowlist Is allowlist rule.
     * @param isRedirectingOnlyBlocked Is redirect-rule modifier.
     */
    constructor(value, isAllowlist, isRedirectingOnlyBlocked = false) {
        RedirectModifier.validate(value, isAllowlist);
        this.redirectTitle = value;
        this.isRedirectingOnlyBlocked = isRedirectingOnlyBlocked;
    }
    /**
     * Redirect title.
     *
     * @returns The redirect title.
     */
    getValue() {
        return this.redirectTitle;
    }
    /**
     * Validates redirect rule.
     *
     * @param redirectTitle The title of the redirect.
     * @param isAllowlist Indicates if the rule is an allowlist rule.
     */
    static validate(redirectTitle, isAllowlist) {
        if (isAllowlist && !redirectTitle) {
            return;
        }
        if (!redirectTitle) {
            throw new SyntaxError('Invalid $redirect rule, redirect value must not be empty');
        }
        if (!(0,validators/* isRedirectResourceCompatibleWithAdg */.td)(redirectTitle)) {
            throw new SyntaxError('$redirect modifier is invalid');
        }
    }
}

/**
 * Query parameters filtering modifier class.
 * Works with `$removeparam` modifier.
 */
class RemoveParamModifier {
    /**
     * Value of the modifier.
     */
    value;
    /**
     * Is modifier valid for MV3 or not.
     *
     * @returns True if the modifier is valid for MV3, false otherwise.
     */
    mv3Valid = true;
    /**
     * RegExp to apply.
     */
    valueRegExp;
    /**
     * Constructor.
     *
     * @param value The value used to initialize the modifier.
     */
    constructor(value) {
        this.value = value;
        let rawValue = value;
        // TODO: Seems like negation not using in valueRegExp
        if (value.startsWith('~')) {
            rawValue = value.substring(1);
            this.mv3Valid = false;
        }
        if (rawValue.startsWith('/')) {
            this.valueRegExp = simple_regex_BBjA8AEZ.S.patternFromString(rawValue);
            this.mv3Valid = false;
        }
        else {
            if (rawValue.includes('|')) {
                throw new Error('Unsupported option in $removeparam: multiple values are not allowed');
            }
            // no need to match "&" in the beginning, because we are splitting by "&"
            // https://github.com/AdguardTeam/AdguardBrowserExtension/issues/3076
            this.valueRegExp = new RegExp(`^${simple_regex_BBjA8AEZ.S.escapeRegexSpecials(rawValue)}=[^&#]*$`, 'g');
        }
    }
    /**
     * Modifier value.
     *
     * @returns The value of the modifier.
     */
    getValue() {
        return this.value;
    }
    /**
     * Is modifier valid for MV3 or not.
     *
     * @returns True if the modifier is valid for MV3, false otherwise.
     */
    getMV3Validity() {
        return this.mv3Valid;
    }
    /**
     * Checks if the given modifier is an instance of RemoveParamModifier.
     *
     * @param m The modifier to check.
     *
     * @returns True if the modifier is an instance of RemoveParamModifier, false otherwise.
     */
    static isRemoveParamModifier = (m) => {
        return m instanceof RemoveParamModifier;
    };
    /**
     * Removes query parameters from url.
     *
     * @param url The URL from which query parameters should be removed.
     *
     * @returns The URL with the query parameters removed.
     */
    removeParameters(url) {
        const sepIndex = url.indexOf('?');
        if (sepIndex < 0) {
            return url;
        }
        if (!this.value) {
            return url.substring(0, sepIndex);
        }
        if (sepIndex === url.length - 1) {
            return url;
        }
        if (this.value.startsWith('~')) {
            return cleanUrlParamByRegExp(url, this.valueRegExp, true);
        }
        return cleanUrlParamByRegExp(url, this.valueRegExp);
    }
}

/**
 * Headers filtering modifier class.
 * Rules with $removeheader modifier are intended to remove headers from HTTP requests and responses.
 */
class RemoveHeaderModifier {
    /**
     * List of forbidden headers.
     */
    static FORBIDDEN_HEADERS = [
        'access-control-allow-origin',
        'access-control-allow-credentials',
        'access-control-allow-headers',
        'access-control-allow-methods',
        'access-control-expose-headers',
        'access-control-max-age',
        'access-control-request-headers',
        'access-control-request-method',
        'origin',
        'timing-allow-origin',
        'allow',
        'cross-origin-embedder-policy',
        'cross-origin-opener-policy',
        'cross-origin-resource-policy',
        'content-security-policy',
        'content-security-policy-report-only',
        'expect-ct',
        'feature-policy',
        'origin-isolation',
        'strict-transport-security',
        'upgrade-insecure-requests',
        'x-content-type-options',
        'x-download-options',
        'x-frame-options',
        'x-permitted-cross-domain-policies',
        'x-powered-by',
        'x-xss-protection',
        'public-key-pins',
        'public-key-pins-report-only',
        'sec-websocket-key',
        'sec-websocket-extensions',
        'sec-websocket-accept',
        'sec-websocket-protocol',
        'sec-websocket-version',
        'p3p',
        'sec-fetch-mode',
        'sec-fetch-dest',
        'sec-fetch-site',
        'sec-fetch-user',
        'referrer-policy',
        'content-type',
        'content-length',
        'accept',
        'accept-encoding',
        'host',
        'connection',
        'transfer-encoding',
        'upgrade',
    ];
    /**
     * Request prefix.
     */
    static REQUEST_PREFIX = 'request:';
    /**
     * Prefixed headers are applied to request headers.
     */
    isRequestModifier;
    /**
     * Effective header name to be removed.
     */
    applicableHeaderName;
    /**
     * Value.
     */
    value;
    /**
     * Is rule valid or not.
     */
    valid;
    /**
     * Constructor.
     *
     * @param value Value of the modifier.
     * @param isAllowlist Whether the rule is an allowlist rule or not.
     */
    constructor(value, isAllowlist) {
        this.value = value.toLowerCase();
        if (!isAllowlist && !this.value) {
            throw new SyntaxError('Invalid $removeheader rule, removeheader value must not be empty');
        }
        this.isRequestModifier = this.value.startsWith(RemoveHeaderModifier.REQUEST_PREFIX);
        const headerName = this.isRequestModifier
            ? this.value.substring(RemoveHeaderModifier.REQUEST_PREFIX.length)
            : this.value;
        // Values with ":" are not supported in MV3 declarative rules, e.g. "$removeheader=dnt:1"
        this.valid = RemoveHeaderModifier.isAllowedHeader(headerName) && !headerName.includes(':');
        this.applicableHeaderName = this.valid ? headerName : null;
    }
    /**
     * Modifier value.
     *
     * @returns The value of the modifier.
     */
    getValue() {
        return this.value;
    }
    /**
     * Modifier validity.
     *
     * @returns True if the rule is valid, false otherwise.
     */
    get isValid() {
        return this.valid;
    }
    /**
     * Checks if the given modifier is an instance of RemoveHeaderModifier.
     *
     * @param m The modifier to check.
     *
     * @returns True if the modifier is an instance of RemoveHeaderModifier, false otherwise.
     */
    static isRemoveHeaderModifier = (m) => {
        return m instanceof RemoveHeaderModifier;
    };
    /**
     * Returns effective header name to be removed.
     *
     * @param isRequestHeaders Flag to determine that the header is a *request* header,
     * otherwise *response* header.
     *
     * @returns The applicable header name if valid, otherwise null.
     */
    getApplicableHeaderName(isRequestHeaders) {
        if (!this.applicableHeaderName) {
            return null;
        }
        if (isRequestHeaders !== this.isRequestModifier) {
            return null;
        }
        return this.applicableHeaderName;
    }
    /**
     * Some headers are forbidden to remove.
     *
     * @param headerName Header name to check.
     *
     * @returns True if the header is allowed to be removed, false otherwise.
     */
    static isAllowedHeader(headerName) {
        return !this.FORBIDDEN_HEADERS.includes(headerName);
    }
}

/**
 * This is a helper class that is used specifically to work with app restrictions.
 *
 * @see {@link https://kb.adguard.com/en/general/how-to-create-your-own-ad-filters#app}
 *
 * @example
 * ```adblock
 * ||baddomain.com^$app=org.example.app
 * ||baddomain.com^$app=org.example.app1|org.example.app2
 * ```
 */
class AppModifier {
    /**
     * List of permitted apps or null.
     */
    permittedApps;
    /**
     * List of restricted apps or null.
     */
    restrictedApps;
    /**
     * Parses the `apps` string.
     *
     * @param apps Apps string.
     *
     * @throws An error if the app string is empty or invalid.
     */
    constructor(apps) {
        if (!apps) {
            throw new SyntaxError('$app modifier cannot be empty');
        }
        const permittedApps = [];
        const restrictedApps = [];
        const parts = apps.split(simple_regex_BBjA8AEZ.a);
        for (let i = 0; i < parts.length; i += 1) {
            let app = parts[i];
            let restricted = false;
            if (app.startsWith('~')) {
                restricted = true;
                app = app.substring(1).trim();
            }
            if (app === '') {
                throw new SyntaxError(`Empty app specified in "${apps}"`);
            }
            if (restricted) {
                restrictedApps.push(app);
            }
            else {
                permittedApps.push(app);
            }
        }
        this.restrictedApps = restrictedApps.length > 0 ? restrictedApps : null;
        this.permittedApps = permittedApps.length > 0 ? permittedApps : null;
    }
}

var HTTPMethod;
(function (HTTPMethod) {
    HTTPMethod["GET"] = "GET";
    HTTPMethod["POST"] = "POST";
    HTTPMethod["PUT"] = "PUT";
    HTTPMethod["DELETE"] = "DELETE";
    HTTPMethod["PATCH"] = "PATCH";
    HTTPMethod["HEAD"] = "HEAD";
    HTTPMethod["OPTIONS"] = "OPTIONS";
    HTTPMethod["CONNECT"] = "CONNECT";
    HTTPMethod["TRACE"] = "TRACE";
})(HTTPMethod || (HTTPMethod = {}));
/**
 * Method modifier class.
 * Rules with $method modifier will be applied only to requests with specified methods.
 *
 * @see {@link https://adguard.com/kb/general/ad-filtering/create-own-filters/#method-modifier}
 */
class MethodModifier {
    /**
     * Request methods separator.
     */
    static PIPE_SEPARATOR = '|';
    /**
     * List of permitted methods or null.
     */
    permittedValues;
    /**
     * List of restricted methods or null.
     */
    restrictedValues;
    /**
     * Constructor.
     *
     * @param methodsStr Value of the modifier.
     */
    constructor(methodsStr) {
        if (methodsStr === '') {
            throw new SyntaxError('$method modifier value cannot be empty');
        }
        const permittedMethods = [];
        const restrictedMethods = [];
        const parts = methodsStr.toUpperCase().split(MethodModifier.PIPE_SEPARATOR);
        for (let i = 0; i < parts.length; i += 1) {
            let method = parts[i].trim();
            let restricted = false;
            if (method.startsWith('~')) {
                restricted = true;
                method = method.substring(1);
            }
            if (!MethodModifier.isHTTPMethod(method)) {
                throw new SyntaxError(`Invalid $method modifier value: ${method}`);
            }
            if (restricted) {
                restrictedMethods.push(method);
            }
            else {
                permittedMethods.push(method);
            }
        }
        if (restrictedMethods.length > 0 && permittedMethods.length > 0) {
            throw new SyntaxError(`Negated values cannot be mixed with non-negated values: ${methodsStr}`);
        }
        this.restrictedValues = restrictedMethods.length > 0 ? restrictedMethods : null;
        this.permittedValues = permittedMethods.length > 0 ? permittedMethods : null;
    }
    static isHTTPMethod = (value) => value in HTTPMethod;
}

/**
 * Header modifier class.
 * The $header modifier allows matching the HTTP response
 * by a specific header with (optionally) a specific value.
 *
 * @see {@link https://adguard.com/kb/general/ad-filtering/create-own-filters/#header-modifier}
 */
class HeaderModifier {
    /**
     * Colon separator.
     */
    COLON_SEPARATOR = ':';
    /**
     * Forward slash regexp marker.
     */
    FORWARD_SLASH = '/';
    /**
     * Header name to match on request.
     */
    header;
    /**
     * Header value to match on request.
     * Empty string if value is not specified, and, in that case,
     * only header name will be matched.
     */
    value;
    /**
     * Constructor.
     *
     * @param headerStr Header modifier value.
     */
    constructor(headerStr) {
        if (headerStr === '') {
            throw new SyntaxError('$header modifier value cannot be empty');
        }
        const separatorIndex = headerStr.indexOf(this.COLON_SEPARATOR);
        if (separatorIndex === -1) {
            this.header = headerStr;
            this.value = null;
            return;
        }
        this.header = headerStr.slice(0, separatorIndex);
        const rawValue = headerStr.slice(separatorIndex + 1);
        if (rawValue === '') {
            throw new SyntaxError(`Invalid $header modifier value: "${headerStr}"`);
        }
        if (rawValue.startsWith(this.FORWARD_SLASH) && rawValue.endsWith(this.FORWARD_SLASH)) {
            this.value = new RegExp(rawValue.slice(1, -1));
        }
        else {
            this.value = rawValue;
        }
    }
    /**
     * Returns header modifier value.
     *
     * @returns Header modifier value.
     */
    getHeaderModifierValue() {
        return {
            header: this.header,
            value: this.value,
        };
    }
}

/**
 * `$to` modifier class.
 * Rules with $to modifier are limited to requests made to the specified domains and their subdomains.
 *
 * @see {@link https://adguard.com/kb/general/ad-filtering/create-own-filters/#to-modifier}
 */
class ToModifier {
    /**
     * Domains separator.
     */
    static PIPE_SEPARATOR = '|';
    /**
     * List of permitted domains or null.
     */
    permittedValues;
    /**
     * List of restricted domains or null.
     */
    restrictedValues;
    /**
     * Constructor.
     *
     * @param domainsStr String with domains separated by `|`.
     */
    constructor(domainsStr) {
        if (!domainsStr) {
            throw new SyntaxError('$to modifier value cannot be empty');
        }
        const permittedDomains = [];
        const restrictedDomains = [];
        const parts = domainsStr.toLowerCase().split(ToModifier.PIPE_SEPARATOR);
        for (let i = 0; i < parts.length; i += 1) {
            let domain = parts[i].trim();
            let restricted = false;
            if (domain.startsWith('~')) {
                restricted = true;
                domain = domain.substring(1);
            }
            if (domain === '') {
                throw new SyntaxError(`Empty domain specified in "${domainsStr}"`);
            }
            if (restricted) {
                restrictedDomains.push(domain);
            }
            else {
                permittedDomains.push(domain);
            }
        }
        this.restrictedValues = restrictedDomains.length > 0 ? restrictedDomains : null;
        this.permittedValues = permittedDomains.length > 0 ? permittedDomains : null;
    }
}

const PERMISSIONS_POLICY_HEADER_NAME = 'Permissions-Policy';
const COMMA_SEPARATOR = ',';
const PIPE_SEPARATOR = '|';
/**
 * Permissions modifier class.
 * Allows setting permission policies, effectively blocking specific page functionality.
 *
 * @see {@link https://adguard.com/kb/general/ad-filtering/create-own-filters/#permissions-modifier}
 */
class PermissionsModifier {
    /**
     * Permission Policy directive.
     */
    permissionPolicyDirective;
    /**
     * Regular expression to apply correct separators.
     * It replaces escaped commas and pipe separators with commas.
     */
    static RE_SEPARATOR_REPLACE = new RegExp(`(\\\\${COMMA_SEPARATOR}|\\${PIPE_SEPARATOR})`, 'g');
    /**
     * Constructor.
     *
     * @param permissionPolicyStr The permission policy string to be set.
     * @param isAllowlist Indicates if the permission policy is for an allowlist.
     */
    constructor(permissionPolicyStr, isAllowlist) {
        this.permissionPolicyDirective = permissionPolicyStr
            .replace(PermissionsModifier.RE_SEPARATOR_REPLACE, COMMA_SEPARATOR);
        PermissionsModifier.validatePermissionPolicyDirective(this.permissionPolicyDirective, isAllowlist);
    }
    /**
     * Returns permission policy allowlist string.
     *
     * @returns Permission policy allowlist string.
     */
    getValue() {
        return this.permissionPolicyDirective;
    }
    /**
     * Validates permission policy directive.
     *
     * @param directive The permission policy directive to validate.
     * @param isAllowlist Indicates if the directive is for an allowlist.
     *
     * @throws SyntaxError on invalid permission policy directive.
     */
    static validatePermissionPolicyDirective(directive, isAllowlist) {
        /**
         * $permissions modifier value may be empty only in case of allowlist rule,
         * it means to disable all $permissions rules matching the rule pattern.
         */
        if (!isAllowlist && !directive) {
            throw new SyntaxError('Invalid $permissions rule: permissions directive must not be empty');
        }
    }
}

/**
 * This is the base class representing double values modifiers.
 */
class BaseValuesModifier {
    /**
     * List of permitted values or null.
     */
    permitted;
    /**
     * List of restricted values or null.
     */
    restricted;
    /**
     * Value.
     */
    value;
    /**
     * Parses the values string.
     *
     * @param values Values string.
     *
     * @throws An error if the string is empty or invalid.
     */
    constructor(values) {
        if (!values) {
            throw new SyntaxError('Modifier cannot be empty');
        }
        this.value = values;
        const permittedValues = [];
        const restrictedValues = [];
        const parts = values.split(simple_regex_BBjA8AEZ.a);
        for (let i = 0; i < parts.length; i += 1) {
            let app = parts[i];
            let restricted = false;
            if (app.startsWith('~')) {
                restricted = true;
                app = app.substring(1).trim();
            }
            if (app === '') {
                throw new SyntaxError(`Empty values specified in "${values}"`);
            }
            if (restricted) {
                restrictedValues.push(app);
            }
            else {
                permittedValues.push(app);
            }
        }
        this.restricted = restrictedValues.length > 0 ? restrictedValues : null;
        this.permitted = permittedValues.length > 0 ? permittedValues : null;
    }
    getPermitted() {
        return this.permitted;
    }
    getRestricted() {
        return this.restricted;
    }
    getValue() {
        return this.value;
    }
    match(value) {
        if (!this.restricted && !this.permitted) {
            return true;
        }
        if (this.restricted && this.restricted.includes(value)) {
            return false;
        }
        if (this.permitted) {
            return this.permitted.includes(value);
        }
        return true;
    }
}

// eslint-disable-next-line max-classes-per-file
/**
 * Netmasks class.
 */
class NetmasksCollection {
    ipv4Masks = [];
    ipv6Masks = [];
    /**
     * Returns true if any of the containing masks contains provided value.
     *
     * @param value Value to check.
     *
     * @returns True if any of the containing masks contains provided value.
     */
    contains(value) {
        if (is_ip.v4(value)) {
            return this.ipv4Masks.some((x) => (0,cidr_tools/* contains */.gR)(x, value));
        }
        return this.ipv6Masks.some((x) => (0,cidr_tools/* contains */.gR)(x, value));
    }
}
/**
 * The client modifier allows specifying clients this rule will be working for.
 * It accepts client names (not ClientIDs), IP addresses, or CIDR ranges.
 */
class ClientModifier extends BaseValuesModifier {
    permittedNetmasks;
    restrictedNetmasks;
    /**
     * Constructor.
     *
     * @param value Value of the modifier.
     */
    constructor(value) {
        super(value);
        const permitted = this.getPermitted();
        if (permitted) {
            this.permitted = ClientModifier.stripValues(permitted);
            this.permittedNetmasks = ClientModifier.parseNetmasks(this.permitted);
        }
        const restricted = this.getRestricted();
        if (restricted) {
            this.restricted = ClientModifier.stripValues(restricted);
            this.restrictedNetmasks = ClientModifier.parseNetmasks(this.restricted);
        }
    }
    /**
     * Unquotes and unescapes string.
     *
     * @param values Values to process.
     *
     * @returns Unquoted and unescaped values.
     */
    static stripValues(values) {
        return values.map((v) => {
            if ((v.startsWith('"') && v.endsWith('"'))
                || (v.startsWith('\'') && v.endsWith('\''))) {
                // eslint-disable-next-line no-param-reassign
                v = v.substr(1, v.length - 2);
            }
            return v.replace(/\\/ig, '');
        });
    }
    /**
     * Checks if this modifier matches provided params.
     *
     * @param clientName Client name.
     * @param clientIP Client IP.
     *
     * @returns True if this modifier matches provided params.
     */
    matchAny(clientName, clientIP) {
        if (this.restricted) {
            if (clientName && this.restricted.includes(clientName)) {
                return false;
            }
            if (clientIP && this.restricted.includes(clientIP)) {
                return false;
            }
            return true;
        }
        if (this.restrictedNetmasks) {
            if (clientIP && this.restrictedNetmasks.contains(clientIP)) {
                return false;
            }
            return true;
        }
        if (this.permitted) {
            if (clientName && this.permitted.includes(clientName)) {
                return true;
            }
            if (clientIP && this.permitted.includes(clientIP)) {
                return true;
            }
        }
        if (this.permittedNetmasks) {
            if (clientIP && this.permittedNetmasks.contains(clientIP)) {
                return true;
            }
        }
        return false;
    }
    /**
     * Parses netmasks from client's strings.
     *
     * @param values Values to parse.
     *
     * @returns Parsed netmasks.
     */
    static parseNetmasks(values) {
        const result = new NetmasksCollection();
        values.forEach((x) => {
            const cidrVersion = is_cidr(x);
            if (cidrVersion === 4) {
                result.ipv4Masks.push(x);
            }
            else if (cidrVersion === 6) {
                result.ipv6Masks.push(x);
            }
        });
        return result;
    }
}

/**
 * The dnsrewrite response modifier allows replacing the content of the response
 * to the DNS request for the matching hosts.
 *
 * TODO: This modifier is not yet implemented.
 *
 * @see {@link https://github.com/AdguardTeam/AdGuardHome/wiki/Hosts-Blocklists#dnsrewrite}
 */
class DnsRewriteModifier {
    /**
     * Value.
     */
    value;
    /**
     * Constructor.
     *
     * @param value Modifier value.
     */
    constructor(value) {
        this.value = value;
    }
    /**
     * Modifier value.
     *
     * @returns The value of the modifier.
     */
    getValue() {
        return this.value;
    }
}

/**
 * The `$dnstype` modifier allows specifying DNS request type on which this rule will be triggered.
 */
class DnsTypeModifier extends BaseValuesModifier {
    /**
     * Constructor.
     *
     * @param value The value used to initialize the modifier.
     */
    constructor(value) {
        super(value);
        if (this.permitted) {
            this.restricted = null;
        }
    }
}

/**
 * The ctag modifier allows to block domains only for specific types of DNS client tags.
 */
class CtagModifier extends BaseValuesModifier {
    /**
     * The list of allowed tags.
     */
    static ALLOWED_TAGS = [
        // By device type:
        'device_audio',
        'device_camera',
        'device_gameconsole',
        'device_laptop',
        'device_nas',
        'device_pc',
        'device_phone',
        'device_printer',
        'device_securityalarm',
        'device_tablet',
        'device_tv',
        'device_other',
        // By operating system:
        'os_android',
        'os_ios',
        'os_linux',
        'os_macos',
        'os_windows',
        'os_other',
        // By user group:
        'user_admin',
        'user_regular',
        'user_child',
    ];
    /**
     * Constructor.
     *
     * @param value Value of the modifier.
     */
    constructor(value) {
        super(value);
        this.validate();
    }
    /**
     * Validates tag values.
     */
    validate() {
        if (!this.getValue()) {
            throw new Error('Invalid rule: Ctag modifier must not be empty');
        }
        const tags = this.permitted ? this.permitted : this.restricted;
        if (tags && tags.some((x) => !CtagModifier.ALLOWED_TAGS.includes(x))) {
            throw new Error('Invalid rule: Invalid ctag modifier');
        }
    }
}

/**
 * Counts the number of bits in the number and returns it.
 *
 * @param a Number to count bits.
 *
 * @returns The number of bits in the number.
 */
function getBitCount(a) {
    let count = 0;
    let n = a;
    while (n > 0) {
        count += n & 1;
        n >>= 1;
    }
    return count;
}
/**
 * Count the number of bits enabled in a number based on a bit mask.
 *
 * @param base Base number to check.
 * @param mask Mask to check.
 *
 * @returns The number of bits enabled in the base number based on the mask.
 *
 * @example
 * countEnabledBits(0b100, 0b110); // 1
 * countEnabledBits(0b111, 0b000); // 0
 */
function countEnabledBits(base, mask) {
    // Get the common bits between the base and the mask
    const common = base & mask;
    // Count the number of bits enabled in the common bits
    return getBitCount(common);
}

/**
 * NetworkRuleOption is the enumeration of various rule options.
 * In order to save memory, we store some options as a flag.
 *
 * @see {@link https://adguard.com/kb/general/ad-filtering/create-own-filters/#basic-rule-modifiers}
 */
var NetworkRuleOption;
(function (NetworkRuleOption) {
    /**
     * No value is set. Syntax sugar to simplify code.
     */
    NetworkRuleOption[NetworkRuleOption["NotSet"] = 0] = "NotSet";
    /**
     * $third-party modifier.
     */
    NetworkRuleOption[NetworkRuleOption["ThirdParty"] = 1] = "ThirdParty";
    /**
     * $match-case modifier.
     */
    NetworkRuleOption[NetworkRuleOption["MatchCase"] = 2] = "MatchCase";
    /**
     * $important modifier.
     */
    NetworkRuleOption[NetworkRuleOption["Important"] = 4] = "Important";
    // Allowlist rules modifiers
    // Each of them can disable part of the functionality
    /**
     * $elemhide modifier.
     */
    NetworkRuleOption[NetworkRuleOption["Elemhide"] = 8] = "Elemhide";
    /**
     * $generichide modifier.
     */
    NetworkRuleOption[NetworkRuleOption["Generichide"] = 16] = "Generichide";
    /**
     * $specifichide modifier.
     */
    NetworkRuleOption[NetworkRuleOption["Specifichide"] = 32] = "Specifichide";
    /**
     * $genericblock modifier.
     */
    NetworkRuleOption[NetworkRuleOption["Genericblock"] = 64] = "Genericblock";
    /**
     * $jsinject modifier.
     */
    NetworkRuleOption[NetworkRuleOption["Jsinject"] = 128] = "Jsinject";
    /**
     * $urlblock modifier.
     */
    NetworkRuleOption[NetworkRuleOption["Urlblock"] = 256] = "Urlblock";
    /**
     * $content modifier.
     */
    NetworkRuleOption[NetworkRuleOption["Content"] = 512] = "Content";
    /**
     * $extension modifier.
     */
    NetworkRuleOption[NetworkRuleOption["Extension"] = 1024] = "Extension";
    /**
     * $stealth modifier.
     */
    NetworkRuleOption[NetworkRuleOption["Stealth"] = 2048] = "Stealth";
    // Other modifiers
    /**
     * $popup modifier.
     */
    NetworkRuleOption[NetworkRuleOption["Popup"] = 4096] = "Popup";
    /**
     * $csp modifier.
     */
    NetworkRuleOption[NetworkRuleOption["Csp"] = 8192] = "Csp";
    /**
     * $replace modifier.
     */
    NetworkRuleOption[NetworkRuleOption["Replace"] = 16384] = "Replace";
    /**
     * $cookie modifier.
     */
    NetworkRuleOption[NetworkRuleOption["Cookie"] = 32768] = "Cookie";
    /**
     * $redirect modifier.
     */
    NetworkRuleOption[NetworkRuleOption["Redirect"] = 65536] = "Redirect";
    /**
     * $badfilter modifier.
     */
    NetworkRuleOption[NetworkRuleOption["Badfilter"] = 131072] = "Badfilter";
    /**
     * $removeparam modifier.
     */
    NetworkRuleOption[NetworkRuleOption["RemoveParam"] = 262144] = "RemoveParam";
    /**
     * $removeheader modifier.
     */
    NetworkRuleOption[NetworkRuleOption["RemoveHeader"] = 524288] = "RemoveHeader";
    /**
     * $jsonprune modifier.
     */
    NetworkRuleOption[NetworkRuleOption["JsonPrune"] = 1048576] = "JsonPrune";
    /**
     * $hls modifier.
     */
    NetworkRuleOption[NetworkRuleOption["Hls"] = 2097152] = "Hls";
    // Compatibility dependent
    /**
     * $network modifier.
     */
    NetworkRuleOption[NetworkRuleOption["Network"] = 4194304] = "Network";
    /**
     * Dns modifiers.
     */
    NetworkRuleOption[NetworkRuleOption["Client"] = 8388608] = "Client";
    NetworkRuleOption[NetworkRuleOption["DnsRewrite"] = 16777216] = "DnsRewrite";
    NetworkRuleOption[NetworkRuleOption["DnsType"] = 33554432] = "DnsType";
    NetworkRuleOption[NetworkRuleOption["Ctag"] = 67108864] = "Ctag";
    /**
     * $method modifier.
     */
    NetworkRuleOption[NetworkRuleOption["Method"] = 134217728] = "Method";
    /**
     * $to modifier.
     */
    NetworkRuleOption[NetworkRuleOption["To"] = 268435456] = "To";
    /**
     * $permissions modifier.
     */
    NetworkRuleOption[NetworkRuleOption["Permissions"] = 536870912] = "Permissions";
    /**
     * $header modifier.
     */
    NetworkRuleOption[NetworkRuleOption["Header"] = 1073741824] = "Header";
})(NetworkRuleOption || (NetworkRuleOption = {}));
/**
 * NetworkRuleOptions is the enumeration of various rule options groups
 * needed for validation.
 */
var NetworkRuleGroupOptions;
(function (NetworkRuleGroupOptions) {
    /**
     * Allowlist-only modifiers.
     */
    NetworkRuleGroupOptions[NetworkRuleGroupOptions["AllowlistOnly"] = 4088] = "AllowlistOnly";
    /**
     * Options supported by host-level network rules.
     */
    NetworkRuleGroupOptions[NetworkRuleGroupOptions["OptionHostLevelRules"] = 125960196] = "OptionHostLevelRules";
    /**
     * Cosmetic option modifiers.
     */
    NetworkRuleGroupOptions[NetworkRuleGroupOptions["CosmeticOption"] = 696] = "CosmeticOption";
    /**
     * Removeparam compatible modifiers.
     *
     * $removeparam rules are compatible only with content type modifiers ($subdocument, $script, $stylesheet, etc)
     * except $document (using by default) and this list of modifiers.
     */
    NetworkRuleGroupOptions[NetworkRuleGroupOptions["RemoveParamCompatibleOptions"] = 393223] = "RemoveParamCompatibleOptions";
    /**
     * Removeheader compatible modifiers.
     *
     * $removeheader rules are compatible only with content type modifiers ($subdocument, $script, $stylesheet, etc)
     * except $document (using by default) and this list of modifiers.
     */
    NetworkRuleGroupOptions[NetworkRuleGroupOptions["RemoveHeaderCompatibleOptions"] = 1074397191] = "RemoveHeaderCompatibleOptions";
    /**
     * Permissions compatible modifiers.
     *
     * $permissions is compatible with the limited list of modifiers: $domain, $important, and $subdocument.
     */
    NetworkRuleGroupOptions[NetworkRuleGroupOptions["PermissionsCompatibleOptions"] = 537001988] = "PermissionsCompatibleOptions";
    /**
     * Header compatible modifiers.
     *
     * $header is compatible with the limited list of modifiers: $csp and $removeheader (on response headers).
     */
    NetworkRuleGroupOptions[NetworkRuleGroupOptions["HeaderCompatibleOptions"] = 1074405380] = "HeaderCompatibleOptions";
})(NetworkRuleGroupOptions || (NetworkRuleGroupOptions = {}));
/**
 * Basic network filtering rule.
 *
 * @see {@link https://kb.adguard.com/en/general/how-to-create-your-own-ad-filters#basic-rules}
 */
class NetworkRule {
    ruleIndex;
    filterListId;
    allowlist;
    pattern;
    /**
     * Domains in denyallow modifier providing exceptions for permitted domains.
     *
     * @see {@link https://github.com/AdguardTeam/CoreLibs/issues/1304}
     */
    denyAllowDomains = null;
    /**
     * Flag with all enabled rule options.
     */
    enabledOptions = NetworkRuleOption.NotSet;
    /**
     * Flag with all disabled rule options.
     */
    disabledOptions = NetworkRuleOption.NotSet;
    /**
     * Flag with all permitted request types.
     */
    permittedRequestTypes = request_type/* RequestType */.Y.NotSet;
    /**
     * Flag with all restricted request types.
     */
    restrictedRequestTypes = request_type/* RequestType */.Y.NotSet;
    /**
     * Rule Advanced modifier.
     */
    advancedModifier = null;
    /**
     * Rule Domain modifier.
     */
    domainModifier = null;
    /**
     * Rule App modifier.
     */
    appModifier = null;
    /**
     * Rule Method modifier.
     */
    methodModifier = null;
    /**
     * Rule header modifier.
     */
    headerModifier = null;
    /**
     * Rule To modifier.
     */
    toModifier = null;
    /**
     * Rule Stealth modifier.
     */
    stealthModifier = null;
    /**
     * Options used by the rule, regardless of whether they are enabled or disabled.
     */
    usedOptionNames = new Set();
    /**
     * Rule priority, which is needed when the engine has to choose between
     * several rules matching the query. This value is calculated based on
     * the rule modifiers enabled or disabled and rounded up
     * to the smallest integer greater than or equal to the calculated weight
     * in the {@link calculatePriorityWeight}.
     *
     * @see https://adguard.com/kb/general/ad-filtering/create-own-filters/#priority-category-1
     */
    priorityWeight = 1;
    /**
     * Rules with base modifiers, from category 1, each of them adds 1
     * to the weight of the rule.
     *
     * @see https://adguard.com/kb/general/ad-filtering/create-own-filters/#priority-category-1
     */
    static CATEGORY_1_OPTIONS_MASK = NetworkRuleOption.ThirdParty
        | NetworkRuleOption.MatchCase
        | NetworkRuleOption.DnsRewrite;
    /**
     * The priority weight used in {@link calculatePriorityWeight} for rules
     * with permitted request types and methods.
     * The value 50 is chosen in order to cover (with a margin) all possible
     * combinations and variations of rules from categories with a lower
     * priority (each of them adds 1 to the rule priority).
     *
     * @see https://adguard.com/kb/general/ad-filtering/create-own-filters/#priority-category-2
     */
    static CategoryTwoWeight = 50;
    /**
     * The priority weight used in {@link calculatePriorityWeight} for rules
     * with allowed domains.
     * The value 100 is chosen to cover all possible combinations and variations
     * of rules from categories with a lower priority, for example a rule with
     * one allowed query type will get priority 100 (50 + 50/1), but for allowed
     * domains with any number of domains we will get at least 101 (for 100
     * domains: 100 + 100/100; for 200 100 + 100/200; or even for 10000:
     * 100 + 100/10000) because the resulting weight is rounded up.
     *
     * @see https://adguard.com/kb/general/ad-filtering/create-own-filters/#priority-category-3
     */
    static CategoryThreeWeight = 100;
    /**
     * The priority weight used in {@link calculatePriorityWeight}
     * for $redirect rules.
     *
     * @see https://adguard.com/kb/general/ad-filtering/create-own-filters/#priority-category-6
     */
    static CategoryFourWeight = 10 ** 3;
    /**
     * The priority weight used in {@link calculatePriorityWeight} for rules
     * with specific exceptions.
     *
     * @see https://adguard.com/kb/general/ad-filtering/create-own-filters/#priority-category-4
     */
    static CategoryFiveWeight = 10 ** 4;
    /**
     * Rules with specific exclusions, from category 4, each of them adds
     * {@link SpecificExceptionsWeight} to the weight of the rule.
     *
     * @see https://adguard.com/kb/general/ad-filtering/create-own-filters/#priority-category-4
     */
    static SPECIFIC_EXCLUSIONS_MASK = NetworkRuleOption.Elemhide
        | NetworkRuleOption.Generichide
        | NetworkRuleOption.Specifichide
        | NetworkRuleOption.Content
        | NetworkRuleOption.Urlblock
        | NetworkRuleOption.Genericblock
        | NetworkRuleOption.Jsinject
        | NetworkRuleOption.Extension;
    /**
     * The priority weight used in {@link calculatePriorityWeight} for rules
     * with allowlist mark '@@'.
     *
     * @see https://adguard.com/kb/general/ad-filtering/create-own-filters/#priority-category-5
     */
    static CategorySixWeight = 10 ** 5;
    /**
     * The priority weight used in {@link calculatePriorityWeight}
     * for $important rules.
     *
     * @see https://adguard.com/kb/general/ad-filtering/create-own-filters/#priority-category-7
     */
    static CategorySevenWeight = 10 ** 6;
    /**
     * Separates the rule pattern from the list of modifiers.
     *
     * ```
     * rule = ["@@"] pattern [ "$" modifiers ]
     * modifiers = [modifier0, modifier1[, ...[, modifierN]]]
     * ```
     */
    static OPTIONS_DELIMITER = network_rule_options/* OPTIONS_DELIMITER */.rE;
    /**
     * A marker that is used in rules of exception.
     * To turn off filtering for a request, start your rule with this marker.
     */
    static MASK_ALLOWLIST = network_rule_options/* MASK_ALLOWLIST */.$4;
    /**
     * Mark that negates options.
     */
    static NOT_MARK = network_rule_options/* NOT_MARK */.IA;
    /**
     * Rule options.
     */
    static OPTIONS = network_rule_options/* NETWORK_RULE_OPTIONS */.RM;
    /**
     * Rule options that can be negated.
     */
    static NEGATABLE_OPTIONS = new Set([
        // General options
        NetworkRule.OPTIONS.FIRST_PARTY,
        NetworkRule.OPTIONS.THIRD_PARTY,
        NetworkRule.OPTIONS.MATCH_CASE,
        NetworkRule.OPTIONS.DOCUMENT,
        NetworkRule.OPTIONS.DOC,
        // Content type options
        NetworkRule.OPTIONS.SCRIPT,
        NetworkRule.OPTIONS.STYLESHEET,
        NetworkRule.OPTIONS.SUBDOCUMENT,
        NetworkRule.OPTIONS.OBJECT,
        NetworkRule.OPTIONS.IMAGE,
        NetworkRule.OPTIONS.XMLHTTPREQUEST,
        NetworkRule.OPTIONS.MEDIA,
        NetworkRule.OPTIONS.FONT,
        NetworkRule.OPTIONS.WEBSOCKET,
        NetworkRule.OPTIONS.OTHER,
        NetworkRule.OPTIONS.PING,
        // Dns modifiers
        NetworkRule.OPTIONS.EXTENSION,
    ]);
    /**
     * Advanced option modifier names.
     */
    static ADVANCED_OPTIONS = new Set([
        NetworkRule.OPTIONS.CSP,
        NetworkRule.OPTIONS.REPLACE,
        NetworkRule.OPTIONS.COOKIE,
        NetworkRule.OPTIONS.REDIRECT,
        NetworkRule.OPTIONS.REDIRECTRULE,
        NetworkRule.OPTIONS.REMOVEPARAM,
        NetworkRule.OPTIONS.REMOVEHEADER,
        NetworkRule.OPTIONS.PERMISSIONS,
        NetworkRule.OPTIONS.CLIENT,
        NetworkRule.OPTIONS.DNSREWRITE,
        NetworkRule.OPTIONS.DNSTYPE,
        NetworkRule.OPTIONS.CTAG,
    ]);
    // TODO: Remove .getText() completely
    ruleText;
    // TODO: Remove .getText() completely
    /**
     * Returns the rule text.
     *
     * @returns The rule text.
     */
    getText() {
        return this.ruleText;
    }
    /**
     * Returns the rule index.
     *
     * @returns Rule index.
     */
    getIndex() {
        return this.ruleIndex;
    }
    /**
     * Returns the identifier of the filter from which the rule was received.
     *
     * @returns Identifier of the filter from which the rule was received.
     */
    getFilterListId() {
        return this.filterListId;
    }
    /**
     * Returns all options that are used in the rule, regardless of whether they are
     * enabled or disabled.
     *
     * @returns Set of option names.
     */
    getUsedOptionNames() {
        return this.usedOptionNames;
    }
    /**
     * Each rule has its own priority, which is necessary when several rules
     * match the request and the filtering system needs to select one of them.
     * Priority is measured as a positive integer.
     * In the case of a conflict between two rules with the same priority value,
     * it is not specified which one of them will be chosen.
     *
     * @returns Rule priority.
     */
    getPriorityWeight() {
        return this.priorityWeight;
    }
    /**
     * Returns rule pattern,
     * which currently is used only in the rule validator module.
     *
     * @returns Rule pattern.
     */
    getPattern() {
        return this.pattern.pattern;
    }
    /**
     * Returns `true` if the rule is "allowlist", e.g. if it disables other
     * rules when the pattern matches the request.
     *
     * @returns True if the rule is an allowlist rule.
     */
    isAllowlist() {
        return this.allowlist;
    }
    /**
     * Checks if the rule is a document-level allowlist rule with $urlblock or
     * $genericblock or $content.
     * This means that the rule is supposed to disable or modify blocking
     * of the page sub-requests.
     * For instance, `@@||example.org^$urlblock` unblocks all sub-requests.
     *
     * @returns True if the rule is a document-level allowlist rule with specific modifiers.
     */
    isDocumentLevelAllowlistRule() {
        if (!this.isAllowlist()) {
            return false;
        }
        return this.isOptionEnabled(NetworkRuleOption.Urlblock)
            || this.isOptionEnabled(NetworkRuleOption.Genericblock)
            || this.isOptionEnabled(NetworkRuleOption.Content);
    }
    /**
     * Checks if the rule completely disables filtering.
     *
     * @returns True if the rule completely disables filtering.
     */
    isFilteringDisabled() {
        if (!this.isAllowlist()) {
            return false;
        }
        return this.isOptionEnabled(NetworkRuleOption.Elemhide)
            && this.isOptionEnabled(NetworkRuleOption.Content)
            && this.isOptionEnabled(NetworkRuleOption.Urlblock)
            && this.isOptionEnabled(NetworkRuleOption.Jsinject);
    }
    /**
     * The longest part of pattern without any special characters.
     * It is used to improve the matching performance.
     *
     * @returns The longest part of the pattern without any special characters.
     */
    getShortcut() {
        return this.pattern.shortcut;
    }
    /**
     * Gets list of permitted domains.
     *
     * @see {@link https://kb.adguard.com/en/general/how-to-create-your-own-ad-filters#domain-modifier}
     *
     * @returns List of permitted domains or null if none.
     */
    getPermittedDomains() {
        if (this.domainModifier) {
            return this.domainModifier.getPermittedDomains();
        }
        return null;
    }
    /**
     * Gets list of restricted domains.
     *
     * @see {@link https://kb.adguard.com/en/general/how-to-create-your-own-ad-filters#domain-modifier}
     *
     * @returns List of restricted domains or null if none.
     */
    getRestrictedDomains() {
        if (this.domainModifier) {
            return this.domainModifier.getRestrictedDomains();
        }
        return null;
    }
    /**
     * Gets list of denyAllow domains.
     *
     * @see {@link https://kb.adguard.com/en/general/how-to-create-your-own-ad-filters#denyallow-modifier}
     *
     * @returns List of denyAllow domains or null if none.
     */
    getDenyAllowDomains() {
        return this.denyAllowDomains;
    }
    /**
     * Get list of permitted $to domains.
     *
     * @see {@link https://kb.adguard.com/en/general/how-to-create-your-own-ad-filters#to-modifier}
     *
     * @returns List of permitted $to domains or null if none.
     */
    getPermittedToDomains() {
        if (this.toModifier) {
            return this.toModifier.permittedValues;
        }
        return null;
    }
    /**
     * Get list of restricted $to domains.
     *
     * @see {@link https://kb.adguard.com/en/general/how-to-create-your-own-ad-filters#to-modifier}
     *
     * @returns List of restricted $to domains or null if none.
     */
    getRestrictedToDomains() {
        if (this.toModifier) {
            return this.toModifier.restrictedValues;
        }
        return null;
    }
    /**
     * Gets list of permitted domains.
     *
     * @see {@link https://kb.adguard.com/en/general/how-to-create-your-own-ad-filters#app}
     *
     * @returns List of permitted domains or null if none.
     */
    getPermittedApps() {
        if (this.appModifier) {
            return this.appModifier.permittedApps;
        }
        return null;
    }
    /**
     * Gets list of restricted domains.
     *
     * @see {@link https://kb.adguard.com/en/general/how-to-create-your-own-ad-filters#app}
     *
     * @returns List of restricted domains or null if none.
     */
    getRestrictedApps() {
        if (this.appModifier) {
            return this.appModifier.restrictedApps;
        }
        return null;
    }
    /**
     * Gets list of permitted methods.
     *
     * @see {@link https://kb.adguard.com/general/how-to-create-your-own-ad-filters#method-modifier}
     *
     * @returns List of permitted methods or null if none.
     */
    getRestrictedMethods() {
        if (this.methodModifier) {
            return this.methodModifier.restrictedValues;
        }
        return null;
    }
    /**
     * Gets list of restricted methods.
     *
     * @see {@link https://kb.adguard.com/general/how-to-create-your-own-ad-filters#method-modifier}
     *
     * @returns List of restricted methods or null if none.
     */
    getPermittedMethods() {
        if (this.methodModifier) {
            return this.methodModifier.permittedValues;
        }
        return null;
    }
    /**
     * Flag with all permitted request types.
     * The value {@link RequestType.NotSet} here means "all request types are allowed".
     *
     * @returns The flag with all permitted request types.
     */
    getPermittedRequestTypes() {
        return this.permittedRequestTypes;
    }
    /**
     * Flag with all restricted request types.
     * The value {@link RequestType.NotSet} here means "no type of request is restricted".
     *
     * @returns The flag with all restricted request types.
     */
    getRestrictedRequestTypes() {
        return this.restrictedRequestTypes;
    }
    /**
     * Advanced modifier.
     *
     * @returns The advanced modifier or null if none.
     */
    getAdvancedModifier() {
        return this.advancedModifier;
    }
    /**
     * Stealth modifier.
     *
     * @returns The stealth modifier or null if none.
     */
    getStealthModifier() {
        return this.stealthModifier;
    }
    /**
     * Advanced modifier value.
     *
     * @returns The advanced modifier value or null if none.
     */
    getAdvancedModifierValue() {
        return this.advancedModifier && this.advancedModifier.getValue();
    }
    /**
     * Retrieves the header modifier value.
     *
     * @returns The header modifier value or null if none.
     */
    getHeaderModifierValue() {
        if (!this.headerModifier) {
            return null;
        }
        return this.headerModifier.getHeaderModifierValue();
    }
    /**
     * Returns true if rule's pattern is a regular expression.
     *
     * @see {@link https://kb.adguard.com/en/general/how-to-create-your-own-ad-filters#regexp-support}
     *
     * @returns True if the rule pattern is a regular expression.
     */
    isRegexRule() {
        return (this.getPattern().startsWith(simple_regex_BBjA8AEZ.S.MASK_REGEX_RULE)
            && this.getPattern().endsWith(simple_regex_BBjA8AEZ.S.MASK_REGEX_RULE));
    }
    /**
     * Checks if this filtering rule matches the specified request.
     *
     * @param request Request to check.
     * @param useShortcut The flag to use this rule shortcut.
     *
     * @returns True if the rule matches the request.
     *
     * In case we use Trie in lookup table, we don't need to use shortcut cause we already check if request's url
     * includes full rule shortcut.
     */
    match(request, useShortcut = true) {
        // Regex rules should not be tested by shortcut
        if (useShortcut && !this.matchShortcut(request)) {
            return false;
        }
        if (this.isOptionEnabled(NetworkRuleOption.Method) && !this.matchMethod(request.method)) {
            return false;
        }
        if (this.isOptionEnabled(NetworkRuleOption.ThirdParty) && !request.thirdParty) {
            return false;
        }
        if (this.isOptionDisabled(NetworkRuleOption.ThirdParty) && request.thirdParty) {
            return false;
        }
        if (!this.matchRequestType(request.requestType)) {
            return false;
        }
        if (!this.matchDomainModifier(request)) {
            return false;
        }
        if (this.isOptionEnabled(NetworkRuleOption.RemoveParam)
            || this.isOptionEnabled(NetworkRuleOption.Permissions)) {
            if (!this.matchRequestTypeExplicit(request.requestType)) {
                return false;
            }
        }
        if (!this.matchDenyAllowDomains(request.hostname)) {
            return false;
        }
        if (this.isOptionEnabled(NetworkRuleOption.To) && !this.matchToModifier(request.hostname)) {
            return false;
        }
        if (!this.matchDnsType(request.dnsType)) {
            return false;
        }
        if (!this.matchClientTags(request.clientTags)) {
            return false;
        }
        if (!this.matchClient(request.clientName, request.clientIP)) {
            return false;
        }
        return this.pattern.matchPattern(request, true);
    }
    /**
     * Simply checks if shortcut is a substring of the URL.
     *
     * @param request Request to check.
     *
     * @returns True if the shortcut is a substring of the URL.
     */
    matchShortcut(request) {
        return request.urlLowercase.indexOf(this.getShortcut()) >= 0;
    }
    /**
     * Check if request matches domain modifier by request referrer (general case) or by request target.
     *
     * In some cases the $domain modifier can match not only the referrer domain, but also the target domain.
     * This happens when the following is true (1 AND ((2 AND 3) OR 4):
     *
     * 1) The request has $document request type (not subdocument)
     * 2) The rule's pattern doesn't match any particular domain(s)
     * 3) The rule's pattern doesn't contain regular expressions
     * 4) The $domain modifier contains only excluded domains (e.g., $domain=~example.org|~example.com).
     *
     * When all these conditions are met, the domain modifier will match both the referrer domain and the target domain.
     *
     * @see {@link https://github.com/AdguardTeam/tsurlfilter/issues/45}
     *
     * @param request The request to check.
     *
     * @returns True if the rule matches the domain modifier.
     */
    matchDomainModifier(request) {
        if (!this.domainModifier) {
            return true;
        }
        const { domainModifier } = this;
        const isDocumentType = request.requestType === request_type/* RequestType */.Y.Document;
        const hasOnlyExcludedDomains = !domainModifier.hasPermittedDomains()
            && domainModifier.hasRestrictedDomains();
        const patternIsRegex = this.isRegexRule();
        const patternIsDomainSpecific = this.pattern.isPatternDomainSpecific();
        const matchesTargetByPatternCondition = !patternIsRegex && !patternIsDomainSpecific;
        if (isDocumentType && (hasOnlyExcludedDomains || matchesTargetByPatternCondition)) {
            // check if matches source hostname if exists or if matches target hostname
            return (request.sourceHostname && domainModifier.matchDomain(request.sourceHostname))
                || domainModifier.matchDomain(request.hostname);
        }
        return domainModifier.matchDomain(request.sourceHostname || '');
    }
    /**
     * Checks if the filtering rule is allowed on this domain.
     *
     * @param domain The request's domain.
     *
     * @returns True if the rule must be applied to the request.
     */
    matchDenyAllowDomains(domain) {
        if (!this.denyAllowDomains) {
            return true;
        }
        if (this.denyAllowDomains.length > 0) {
            if (DomainModifier.isDomainOrSubdomainOfAny(domain, this.denyAllowDomains)) {
                return false;
            }
        }
        return true;
    }
    /**
     * Checks if the request domain matches the specified conditions.
     *
     * @param domain The request's domain.
     *
     * @returns True if the request domain matches the permitted domains and does not match the restricted domains.
     */
    matchToModifier(domain) {
        if (!this.toModifier) {
            return true;
        }
        /**
         * The request's domain must be either explicitly permitted or not be included
         * in the list of restricted domains for the rule to apply.
         */
        const permittedDomains = this.getPermittedToDomains();
        const restrictedDomains = this.getRestrictedToDomains();
        let matches = false;
        if (permittedDomains) {
            matches = DomainModifier.isDomainOrSubdomainOfAny(domain, permittedDomains);
        }
        if (restrictedDomains) {
            matches = !DomainModifier.isDomainOrSubdomainOfAny(domain, restrictedDomains);
        }
        return matches;
    }
    /**
     * Return `true` if this rule matches with the tags associated with a client.
     *
     * @param clientTags Client tags.
     *
     * @returns True if the rule matches the client tags.
     */
    matchClientTags(clientTags) {
        const advancedModifier = this.getAdvancedModifier();
        if (!advancedModifier || !(advancedModifier instanceof CtagModifier)) {
            return true;
        }
        if (!clientTags) {
            return false;
        }
        const cTagsModifier = advancedModifier;
        return clientTags.every((x) => cTagsModifier.match(x));
    }
    /**
     * Returns TRUE if the rule matches with the specified client.
     *
     * @param clientName The name of the client.
     * @param clientIP The IP address of the client.
     *
     * @returns True if the rule matches the client.
     */
    matchClient(clientName, clientIP) {
        const advancedModifier = this.getAdvancedModifier();
        if (!advancedModifier || !(advancedModifier instanceof ClientModifier)) {
            return true;
        }
        if (!clientName && !clientIP) {
            return false;
        }
        const modifier = advancedModifier;
        return modifier.matchAny(clientName, clientIP);
    }
    /**
     * Return `true` if this rule matches with the request DNS type.
     *
     * @param dnstype The DNS type to check.
     *
     * @returns True if the rule matches the DNS type.
     */
    matchDnsType(dnstype) {
        const advancedModifier = this.getAdvancedModifier();
        if (!advancedModifier || !(advancedModifier instanceof DnsTypeModifier)) {
            return true;
        }
        if (!dnstype) {
            return false;
        }
        const modifier = advancedModifier;
        return modifier.match(dnstype);
    }
    /**
     * Checks if the request's type matches the rule properties.
     *
     * @param requestType Request type to check.
     *
     * @returns True if the rule must be applied to the request.
     */
    matchRequestType(requestType) {
        if (this.permittedRequestTypes !== request_type/* RequestType */.Y.NotSet) {
            if ((this.permittedRequestTypes & requestType) !== requestType) {
                return false;
            }
        }
        if (this.restrictedRequestTypes !== request_type/* RequestType */.Y.NotSet) {
            if ((this.restrictedRequestTypes & requestType) === requestType) {
                return false;
            }
        }
        return true;
    }
    /**
     * In case of $removeparam, $permissions modifier,
     * we only allow it to target other content types if the rule has an explicit content-type modifier.
     *
     * @param requestType Request type to check.
     *
     * @returns True if the rule must be applied to the request.
     */
    matchRequestTypeExplicit(requestType) {
        if (this.permittedRequestTypes === request_type/* RequestType */.Y.NotSet
            && this.restrictedRequestTypes === request_type/* RequestType */.Y.NotSet
            && requestType !== request_type/* RequestType */.Y.Document
            && requestType !== request_type/* RequestType */.Y.SubDocument) {
            return false;
        }
        return this.matchRequestType(requestType);
    }
    /**
     * Checks if request's method matches with the rule.
     *
     * @param method Request's method.
     *
     * @returns True, if rule must be applied to the request.
     */
    matchMethod(method) {
        if (!method || !MethodModifier.isHTTPMethod(method)) {
            return false;
        }
        /**
         * Request's method must be either explicitly
         * permitted or not be included in list of restricted methods
         * for the rule to apply.
         */
        const permittedMethods = this.getPermittedMethods();
        if (permittedMethods?.includes(method)) {
            return true;
        }
        const restrictedMethods = this.getRestrictedMethods();
        return !!restrictedMethods && !restrictedMethods.includes(method);
    }
    /**
     * Checks if request's response headers matches with
     * the rule's $header modifier value.
     *
     * @param responseHeadersItems Request's response headers.
     *
     * @returns True, if rule must be applied to the request.
     */
    matchResponseHeaders(responseHeadersItems) {
        if (!responseHeadersItems || responseHeadersItems.length === 0) {
            return false;
        }
        const ruleData = this.getHeaderModifierValue();
        if (!ruleData) {
            return false;
        }
        const { header: ruleHeaderName, value: ruleHeaderValue, } = ruleData;
        return responseHeadersItems.some((responseHeadersItem) => {
            const { name: responseHeaderName, value: responseHeaderValue, } = responseHeadersItem;
            // Header name matching is case-insensitive
            if (ruleHeaderName.toLowerCase() !== responseHeaderName.toLowerCase()) {
                return false;
            }
            if (ruleHeaderValue === null) {
                return true;
            }
            // Unlike header name, header value matching is case-sensitive
            if (typeof ruleHeaderValue === 'string') {
                return ruleHeaderValue === responseHeaderValue;
            }
            if (responseHeaderValue && ruleHeaderValue instanceof RegExp) {
                return ruleHeaderValue.test(responseHeaderValue);
            }
            return false;
        });
    }
    /**
     * Checks if a network rule is too general.
     *
     * @param node AST node of the network rule.
     *
     * @returns True if the rule is too general.
     */
    static isTooGeneral(node) {
        return !(node.modifiers?.children?.length) && node.pattern.value.length < 4;
    }
    /**
     * Creates an instance of the {@link NetworkRule}.
     * It parses this rule and extracts the rule pattern (see {@link SimpleRegex}),
     * and rule modifiers.
     *
     * @param node AST node of the network rule.
     * @param filterListId ID of the filter list this rule belongs to.
     * @param ruleIndex Line start index in the source filter list; it will be used to find the original rule text
     * in the filtering log when a rule is applied. Default value is {@link RULE_INDEX_NONE} which means that
     * the rule does not have source index.
     *
     * @throws Error if it fails to parse the rule.
     */
    constructor(node, filterListId, ruleIndex = RULE_INDEX_NONE) {
        this.ruleIndex = ruleIndex;
        // TODO: Remove this completely
        this.ruleText = rule_generator/* RuleGenerator */.u.generate(node);
        this.filterListId = filterListId;
        this.allowlist = node.exception;
        const pattern = node.pattern.value;
        if (pattern && (0,simple_regex_BBjA8AEZ.h)(pattern)) {
            throw new SyntaxError('Rule has spaces, seems to be an host rule');
        }
        if (node.modifiers?.children?.length) {
            this.loadOptions(node.modifiers);
        }
        if (NetworkRule.isTooGeneral(node)) {
            throw new SyntaxError(`Rule is too general: ${rule_generator/* RuleGenerator */.u.generate(node)}`);
        }
        this.calculatePriorityWeight();
        this.pattern = new Pattern(pattern, this.isOptionEnabled(NetworkRuleOption.MatchCase));
    }
    /**
     * Parses the options string and saves them.
     *
     * @see {@link https://kb.adguard.com/en/general/how-to-create-your-own-ad-filters#basic-rules-modifiers}
     *
     * @param options Modifier list node.
     *
     * @throws An error if there is an unsupported modifier.
     */
    loadOptions(options) {
        for (const option of options.children) {
            let value = simple_regex_BBjA8AEZ.E;
            if (option.value && option.value.value) {
                value = option.value.value;
            }
            this.loadOption(option.name.value, value, option.exception);
            this.usedOptionNames.add(option.name.value);
        }
        this.validateOptions();
    }
    /**
     * Returns true if rule contains (enabled or disabled) specified option.
     * Please note, that options have three state: enabled, disabled, undefined.
     *
     * @param option Rule option to check.
     *
     * @returns True if rule contains (enabled or disabled) specified option.
     */
    hasOption(option) {
        return this.isOptionEnabled(option) || this.isOptionDisabled(option);
    }
    /**
     * Returns true if rule has at least one cosmetic option enabled.
     *
     * @returns True if the rule has at least one cosmetic option enabled.
     */
    hasCosmeticOption() {
        return (this.enabledOptions & NetworkRuleGroupOptions.CosmeticOption) !== 0;
    }
    /**
     * Returns true if the specified option is enabled.
     * Please note, that options have three state: enabled, disabled, undefined.
     *
     * @param option Rule option to check.
     *
     * @returns True if the specified option is enabled.
     */
    isOptionEnabled(option) {
        return (this.enabledOptions & option) === option;
    }
    /**
     * Returns true if one and only option is enabled.
     *
     * @param option Rule option to check.
     *
     * @returns True if the specified option is enabled.
     */
    isSingleOptionEnabled(option) {
        return this.enabledOptions === option;
    }
    /**
     * Returns true if the specified option is disabled.
     * Please note, that options have three state: enabled, disabled, undefined.
     *
     * @param option Rule option to check.
     *
     * @returns True if the specified option is disabled.
     */
    isOptionDisabled(option) {
        return (this.disabledOptions & option) === option;
    }
    /**
     * Checks if the rule has higher priority that the specified rule:
     * `allowlist + $important` > `$important` > `redirect` > `allowlist` > `basic rules`.
     *
     * @param r Rule to compare with.
     *
     * @returns True if the rule has higher priority than `r`.
     */
    isHigherPriority(r) {
        return this.priorityWeight > r.priorityWeight;
    }
    /**
     * Returns true if the rule is considered "generic"
     * "generic" means that the rule is not restricted to a limited set of domains
     * Please note that it might be forbidden on some domains, though.
     *
     * @returns True if the rule is considered "generic".
     */
    isGeneric() {
        return !this.domainModifier?.hasPermittedDomains();
    }
    /**
     * Returns true if this rule negates the specified rule.
     * Only makes sense when this rule has a `badfilter` modifier.
     *
     * @param specifiedRule Rule to check.
     *
     * @returns True if this rule negates the specified rule.
     */
    negatesBadfilter(specifiedRule) {
        if (!this.isOptionEnabled(NetworkRuleOption.Badfilter)) {
            return false;
        }
        if (this.allowlist !== specifiedRule.allowlist) {
            return false;
        }
        if (this.pattern.pattern !== specifiedRule.pattern.pattern) {
            return false;
        }
        if (this.permittedRequestTypes !== specifiedRule.permittedRequestTypes) {
            return false;
        }
        if (this.restrictedRequestTypes !== specifiedRule.restrictedRequestTypes) {
            return false;
        }
        if ((this.enabledOptions ^ NetworkRuleOption.Badfilter) !== specifiedRule.enabledOptions) {
            return false;
        }
        if (this.disabledOptions !== specifiedRule.disabledOptions) {
            return false;
        }
        if (!(0,simple_regex_BBjA8AEZ.b)(this.getRestrictedDomains(), specifiedRule.getRestrictedDomains())) {
            return false;
        }
        if (!(0,simple_regex_BBjA8AEZ.c)(this.getPermittedDomains(), specifiedRule.getPermittedDomains())) {
            return false;
        }
        return true;
    }
    /**
     * Checks if this rule can be used for hosts-level blocking.
     *
     * @returns True if the rule can be used for hosts-level blocking.
     */
    isHostLevelNetworkRule() {
        if (this.domainModifier?.hasPermittedDomains() || this.domainModifier?.hasRestrictedDomains()) {
            return false;
        }
        if (this.permittedRequestTypes !== 0 && this.restrictedRequestTypes !== 0) {
            return false;
        }
        if (this.disabledOptions !== NetworkRuleOption.NotSet) {
            return false;
        }
        if (this.enabledOptions !== NetworkRuleOption.NotSet) {
            return ((this.enabledOptions
                & NetworkRuleGroupOptions.OptionHostLevelRules)
                | (this.enabledOptions
                    ^ NetworkRuleGroupOptions.OptionHostLevelRules)) === NetworkRuleGroupOptions.OptionHostLevelRules;
        }
        return true;
    }
    /**
     * Enables or disables the specified option.
     *
     * @param option Option to enable or disable.
     * @param enabled True to enable, false to disable.
     * @param skipRestrictions Skip options allowlist/blacklist restrictions.
     *
     * @throws An error if the option we're trying to enable cannot be.
     * For instance, you cannot enable $elemhide for blacklist rules.
     */
    setOptionEnabled(option, enabled, skipRestrictions = false) {
        if (!skipRestrictions) {
            if (!this.allowlist && (option & NetworkRuleGroupOptions.AllowlistOnly) === option) {
                throw new SyntaxError(`Modifier ${NetworkRuleOption[option]} cannot be used in blacklist rule`);
            }
        }
        if (enabled) {
            this.enabledOptions |= option;
        }
        else {
            this.disabledOptions |= option;
        }
    }
    /**
     * Permits or forbids the specified request type.
     * "Permits" means that the rule will match **only** the types that are permitted.
     * "Restricts" means that the rule will match **all but restricted**.
     *
     * @param requestType Request type.
     * @param permitted True if it's permitted (whic).
     */
    setRequestType(requestType, permitted) {
        if (permitted) {
            this.permittedRequestTypes |= requestType;
        }
        else {
            this.restrictedRequestTypes |= requestType;
        }
    }
    /**
     * Sets and validates exceptionally allowed domains presented in $denyallow modifier.
     *
     * @param optionValue Denyallow modifier value.
     */
    setDenyAllowDomains(optionValue) {
        const domainModifier = new DomainModifier(optionValue, PIPE_SEPARATOR$1);
        if (domainModifier.restrictedDomains && domainModifier.restrictedDomains.length > 0) {
            throw new SyntaxError('Invalid modifier: $denyallow domains cannot be negated');
        }
        if (domainModifier.permittedDomains) {
            if (domainModifier.permittedDomains.some(DomainModifier.isWildcardOrRegexDomain)) {
                throw new SyntaxError('Invalid modifier: $denyallow does not support wildcards and regex domains');
            }
        }
        this.denyAllowDomains = domainModifier.permittedDomains;
    }
    /**
     * Loads the specified modifier.
     *
     * @see {@link https://kb.adguard.com/en/general/how-to-create-your-own-ad-filters#basic-rules-modifiers}
     *
     * @param optionName Modifier name.
     * @param optionValue Modifier value.
     * @param exception True if the modifier is negated.
     *
     * @throws An error if there is an unsupported modifier.
     */
    loadOption(optionName, optionValue, exception = false) {
        const { OPTIONS, NEGATABLE_OPTIONS } = NetworkRule;
        if (optionName.startsWith(OPTIONS.NOOP)) {
            /**
             * A noop modifier does nothing and can be used to increase some rules readability.
             * It consists of the sequence of underscore characters (_) of any length
             * and can appear in a rule as many times as it's needed.
             */
            if (!optionName.split(OPTIONS.NOOP).some((s) => !!s)) {
                return;
            }
        }
        // TODO: Speed up this by creating a map from names to bit mask positions
        if (exception && !NEGATABLE_OPTIONS.has(optionName)) {
            throw new SyntaxError(`Invalid modifier: '${optionName}' cannot be negated`);
        }
        switch (optionName) {
            // General options
            // $first-party, $~first-party
            case OPTIONS.FIRST_PARTY:
                this.setOptionEnabled(NetworkRuleOption.ThirdParty, exception);
                break;
            // $third-party, $~third-party
            case OPTIONS.THIRD_PARTY:
                this.setOptionEnabled(NetworkRuleOption.ThirdParty, !exception);
                break;
            // $match-case, $~match-case
            case OPTIONS.MATCH_CASE:
                this.setOptionEnabled(NetworkRuleOption.MatchCase, !exception);
                break;
            // $important
            case OPTIONS.IMPORTANT:
                this.setOptionEnabled(NetworkRuleOption.Important, true);
                break;
            // $domain
            case OPTIONS.DOMAIN:
                this.domainModifier = new DomainModifier(optionValue, PIPE_SEPARATOR$1);
                break;
            // $denyallow
            case OPTIONS.DENYALLOW:
                this.setDenyAllowDomains(optionValue);
                break;
            // $method modifier
            case OPTIONS.METHOD: {
                this.setOptionEnabled(NetworkRuleOption.Method, true);
                this.methodModifier = new MethodModifier(optionValue);
                break;
            }
            // $header modifier
            case OPTIONS.HEADER:
                this.setOptionEnabled(NetworkRuleOption.Header, true);
                this.headerModifier = new HeaderModifier(optionValue);
                break;
            // $to modifier
            case OPTIONS.TO: {
                this.setOptionEnabled(NetworkRuleOption.To, true);
                this.toModifier = new ToModifier(optionValue);
                break;
            }
            // Document-level allowlist rules
            // $elemhide
            case OPTIONS.ELEMHIDE:
                this.setOptionEnabled(NetworkRuleOption.Elemhide, true);
                this.setRequestType(request_type/* RequestType */.Y.Document, true);
                this.setRequestType(request_type/* RequestType */.Y.SubDocument, true);
                break;
            // $generichide
            case OPTIONS.GENERICHIDE:
                this.setOptionEnabled(NetworkRuleOption.Generichide, true);
                this.setRequestType(request_type/* RequestType */.Y.Document, true);
                this.setRequestType(request_type/* RequestType */.Y.SubDocument, true);
                break;
            // $specifichide
            case OPTIONS.SPECIFICHIDE:
                this.setOptionEnabled(NetworkRuleOption.Specifichide, true);
                this.setRequestType(request_type/* RequestType */.Y.Document, true);
                this.setRequestType(request_type/* RequestType */.Y.SubDocument, true);
                break;
            // $genericblock
            case OPTIONS.GENERICBLOCK:
                this.setOptionEnabled(NetworkRuleOption.Genericblock, true);
                this.setRequestType(request_type/* RequestType */.Y.Document, true);
                this.setRequestType(request_type/* RequestType */.Y.SubDocument, true);
                break;
            // $jsinject
            case OPTIONS.JSINJECT:
                this.setOptionEnabled(NetworkRuleOption.Jsinject, true);
                this.setRequestType(request_type/* RequestType */.Y.Document, true);
                this.setRequestType(request_type/* RequestType */.Y.SubDocument, true);
                break;
            // $urlblock
            case OPTIONS.URLBLOCK:
                this.setOptionEnabled(NetworkRuleOption.Urlblock, true);
                this.setRequestType(request_type/* RequestType */.Y.Document, true);
                this.setRequestType(request_type/* RequestType */.Y.SubDocument, true);
                break;
            // $content
            case OPTIONS.CONTENT:
                this.setOptionEnabled(NetworkRuleOption.Content, true);
                this.setRequestType(request_type/* RequestType */.Y.Document, true);
                this.setRequestType(request_type/* RequestType */.Y.SubDocument, true);
                break;
            // $document, $doc / $~document, $~doc
            case OPTIONS.DOCUMENT:
            case OPTIONS.DOC:
                if (exception) {
                    this.setRequestType(request_type/* RequestType */.Y.Document, false);
                    break;
                }
                this.setRequestType(request_type/* RequestType */.Y.Document, true);
                // In the case of allowlist rules $document implicitly includes
                // all these modifiers: `$content`, `$elemhide`, `$jsinject`,
                // `$urlblock`.
                if (this.isAllowlist()) {
                    this.setOptionEnabled(NetworkRuleOption.Elemhide, true, true);
                    this.setOptionEnabled(NetworkRuleOption.Jsinject, true, true);
                    this.setOptionEnabled(NetworkRuleOption.Urlblock, true, true);
                    this.setOptionEnabled(NetworkRuleOption.Content, true, true);
                }
                break;
            // $stealth
            case OPTIONS.STEALTH:
                this.setOptionEnabled(NetworkRuleOption.Stealth, true);
                this.stealthModifier = new StealthModifier(optionValue);
                break;
            // $popup
            case OPTIONS.POPUP:
                this.setOptionEnabled(NetworkRuleOption.Popup, true);
                break;
            // Content type options
            // $script, $~script
            case OPTIONS.SCRIPT:
                this.setRequestType(request_type/* RequestType */.Y.Script, !exception);
                break;
            // $stylesheet, $~stylesheet
            case OPTIONS.STYLESHEET:
                this.setRequestType(request_type/* RequestType */.Y.Stylesheet, !exception);
                break;
            // $subdocument, $~subdocument
            case OPTIONS.SUBDOCUMENT:
                this.setRequestType(request_type/* RequestType */.Y.SubDocument, !exception);
                break;
            // $object, $~object
            case OPTIONS.OBJECT:
                this.setRequestType(request_type/* RequestType */.Y.Object, !exception);
                break;
            // $image, $~image
            case OPTIONS.IMAGE:
                this.setRequestType(request_type/* RequestType */.Y.Image, !exception);
                break;
            // $xmlhttprequest, $~xmlhttprequest
            case OPTIONS.XMLHTTPREQUEST:
                this.setRequestType(request_type/* RequestType */.Y.XmlHttpRequest, !exception);
                break;
            // $media, $~media
            case OPTIONS.MEDIA:
                this.setRequestType(request_type/* RequestType */.Y.Media, !exception);
                break;
            // $font, $~font
            case OPTIONS.FONT:
                this.setRequestType(request_type/* RequestType */.Y.Font, !exception);
                break;
            // $websocket, $~websocket
            case OPTIONS.WEBSOCKET:
                this.setRequestType(request_type/* RequestType */.Y.WebSocket, !exception);
                break;
            // $other, $~other
            case OPTIONS.OTHER:
                this.setRequestType(request_type/* RequestType */.Y.Other, !exception);
                break;
            // $ping, $~ping
            case OPTIONS.PING:
                this.setRequestType(request_type/* RequestType */.Y.Ping, !exception);
                break;
            // Special modifiers
            // $badfilter
            case OPTIONS.BADFILTER:
                this.setOptionEnabled(NetworkRuleOption.Badfilter, true);
                break;
            // $csp
            case OPTIONS.CSP:
                this.setOptionEnabled(NetworkRuleOption.Csp, true);
                this.advancedModifier = new CspModifier(optionValue, this.isAllowlist());
                break;
            // $replace
            case OPTIONS.REPLACE:
                this.setOptionEnabled(NetworkRuleOption.Replace, true);
                this.advancedModifier = new ReplaceModifier(optionValue);
                break;
            // $cookie
            case OPTIONS.COOKIE:
                this.setOptionEnabled(NetworkRuleOption.Cookie, true);
                this.advancedModifier = new CookieModifier(optionValue);
                break;
            // $redirect
            case OPTIONS.REDIRECT:
                this.setOptionEnabled(NetworkRuleOption.Redirect, true);
                this.advancedModifier = new RedirectModifier(optionValue, this.isAllowlist());
                break;
            // $redirect-rule
            case OPTIONS.REDIRECTRULE:
                this.setOptionEnabled(NetworkRuleOption.Redirect, true);
                this.advancedModifier = new RedirectModifier(optionValue, this.isAllowlist(), true);
                break;
            // $removeparam
            case OPTIONS.REMOVEPARAM:
                this.setOptionEnabled(NetworkRuleOption.RemoveParam, true);
                this.advancedModifier = new RemoveParamModifier(optionValue);
                break;
            // $removeheader
            case OPTIONS.REMOVEHEADER:
                this.setOptionEnabled(NetworkRuleOption.RemoveHeader, true);
                this.advancedModifier = new RemoveHeaderModifier(optionValue, this.isAllowlist());
                break;
            // $permissions
            case OPTIONS.PERMISSIONS:
                this.setOptionEnabled(NetworkRuleOption.Permissions, true);
                this.advancedModifier = new PermissionsModifier(optionValue, this.isAllowlist());
                break;
            // $jsonprune
            // simple validation of jsonprune rules for compiler
            // https://github.com/AdguardTeam/FiltersCompiler/issues/168
            case OPTIONS.JSONPRUNE:
                if (isCompatibleWith(CompatibilityTypes.Extension)) {
                    throw new SyntaxError('Extension does not support $jsonprune modifier yet');
                }
                this.setOptionEnabled(NetworkRuleOption.JsonPrune, true);
                // TODO: should be properly implemented later
                // https://github.com/AdguardTeam/tsurlfilter/issues/71
                break;
            // $hls
            // simple validation of hls rules for compiler
            // https://github.com/AdguardTeam/FiltersCompiler/issues/169
            case OPTIONS.HLS:
                if (isCompatibleWith(CompatibilityTypes.Extension)) {
                    throw new SyntaxError('Extension does not support $hls modifier yet');
                }
                this.setOptionEnabled(NetworkRuleOption.Hls, true);
                // TODO: should be properly implemented later
                // https://github.com/AdguardTeam/tsurlfilter/issues/72
                break;
            // $referrerpolicy
            // simple validation of referrerpolicy rules for compiler
            // https://github.com/AdguardTeam/FiltersCompiler/issues/191
            case OPTIONS.REFERRERPOLICY:
                if (isCompatibleWith(CompatibilityTypes.Extension)) {
                    throw new SyntaxError('Extension does not support $referrerpolicy modifier');
                }
                // do nothing as $referrerpolicy is supported by CoreLibs-based apps only.
                // it is needed for proper rule conversion performed by FiltersCompiler
                // so rules with $referrerpolicy modifier is not marked as invalid
                break;
            // Dns modifiers
            // $client
            case OPTIONS.CLIENT:
                if (isCompatibleWith(CompatibilityTypes.Extension)) {
                    throw new SyntaxError('Extension doesn\'t support $client modifier');
                }
                this.setOptionEnabled(NetworkRuleOption.Client, true);
                this.advancedModifier = new ClientModifier(optionValue);
                break;
            // $dnsrewrite
            case OPTIONS.DNSREWRITE:
                if (isCompatibleWith(CompatibilityTypes.Extension)) {
                    throw new SyntaxError('Extension doesn\'t support $dnsrewrite modifier');
                }
                this.setOptionEnabled(NetworkRuleOption.DnsRewrite, true);
                this.advancedModifier = new DnsRewriteModifier(optionValue);
                break;
            // $dnstype
            case OPTIONS.DNSTYPE:
                if (isCompatibleWith(CompatibilityTypes.Extension)) {
                    throw new SyntaxError('Extension doesn\'t support $dnstype modifier');
                }
                this.setOptionEnabled(NetworkRuleOption.DnsType, true);
                this.advancedModifier = new DnsTypeModifier(optionValue);
                break;
            // $ctag
            case OPTIONS.CTAG:
                if (isCompatibleWith(CompatibilityTypes.Extension)) {
                    throw new SyntaxError('Extension doesn\'t support $ctag modifier');
                }
                this.setOptionEnabled(NetworkRuleOption.Ctag, true);
                this.advancedModifier = new CtagModifier(optionValue);
                break;
            // $app
            case OPTIONS.APP:
                if (isCompatibleWith(CompatibilityTypes.Extension)) {
                    throw new SyntaxError('Extension doesn\'t support $app modifier');
                }
                this.appModifier = new AppModifier(optionValue);
                break;
            // $network
            case OPTIONS.NETWORK:
                if (isCompatibleWith(CompatibilityTypes.Extension)) {
                    throw new SyntaxError('Extension doesn\'t support $network modifier');
                }
                this.setOptionEnabled(NetworkRuleOption.Network, true);
                break;
            // $extension, $~extension
            case OPTIONS.EXTENSION:
                if (isCompatibleWith(CompatibilityTypes.Extension)) {
                    throw new SyntaxError('Extension doesn\'t support $extension modifier');
                }
                this.setOptionEnabled(NetworkRuleOption.Extension, !exception);
                break;
            // $all
            case OPTIONS.ALL:
                if (this.isAllowlist()) {
                    throw new SyntaxError('Rule with $all modifier can not be allowlist rule');
                }
                // Set all request types
                Object.values(request_type/* RequestType */.Y).forEach((type) => {
                    this.setRequestType(type, true);
                });
                this.setOptionEnabled(NetworkRuleOption.Popup, true);
                break;
            // $empty and $mp4
            // Deprecated in favor of $redirect
            case OPTIONS.EMPTY:
            case OPTIONS.MP4:
                // Do nothing.
                break;
            default: {
                // clear empty values
                const modifierView = [optionName, optionValue]
                    .filter((i) => i)
                    .join('=');
                throw new SyntaxError(`Unknown modifier: ${modifierView}`);
            }
        }
    }
    /**
     * To calculate priority, we've categorized modifiers into different groups.
     * These groups are ranked based on their priority, from lowest to highest.
     * A modifier that significantly narrows the scope of a rule adds more
     * weight to its total priority. Conversely, if a rule applies to a broader
     * range of requests, its priority decreases.
     *
     * It's worth noting that there are cases where a single-parameter modifier
     * has a higher priority than multi-parameter ones. For instance, in
     * the case of `$domain=example.com|example.org`, a rule that includes two
     * domains has a slightly broader effective area than a rule with one
     * specified domain, therefore its priority is lower.
     *
     * The base priority weight of any rule is 1. If the calculated priority
     * is a floating-point number, it will be **rounded up** to the smallest
     * integer greater than or equal to the calculated weight.
     *
     * @see {@link NetworkRule.PermittedRequestTypeWeight}
     * @see {@link NetworkRule.PermittedDomainWeight}
     * @see {@link NetworkRule.SpecificExceptionsWeight}
     * @see {@link NetworkRule.AllowlistRuleWeight}
     * @see {@link NetworkRule.RedirectRuleWeight}
     * @see {@link NetworkRule.ImportantRuleWeight}
     * @see {@link https://adguard.com/kb/general/ad-filtering/create-own-filters/#priority-counting}
     */
    calculatePriorityWeight() {
        // Base modifiers, category 1.
        this.priorityWeight += countEnabledBits(this.enabledOptions, NetworkRule.CATEGORY_1_OPTIONS_MASK);
        this.priorityWeight += countEnabledBits(this.disabledOptions, NetworkRule.CATEGORY_1_OPTIONS_MASK);
        /**
         * When dealing with a negated domain, app, method, or content-type,
         * we add a point for the existence of the modifier itself, regardless
         * of the quantity of negated domains or content-types. This is because
         * the rule's scope is already infinitely broad. Put simply,
         * by prohibiting multiple domains, content-types, methods or apps,
         * the scope of the rule becomes only minimally smaller.
         */
        if (this.denyAllowDomains && this.denyAllowDomains.length > 0) {
            this.priorityWeight += 1;
        }
        const { domainModifier } = this;
        if (domainModifier?.hasRestrictedDomains()) {
            this.priorityWeight += 1;
        }
        if (this.methodModifier?.restrictedValues && this.methodModifier.restrictedValues.length > 0) {
            this.priorityWeight += 1;
        }
        if (this.restrictedRequestTypes !== request_type/* RequestType */.Y.NotSet) {
            this.priorityWeight += 1;
        }
        // $to modifier is basically a replacement for a regular expression
        // See https://github.com/AdguardTeam/KnowledgeBase/pull/196#discussion_r1221401215
        if (this.toModifier) {
            this.priorityWeight += 1;
        }
        /**
         * Category 2: permitted request types, methods, headers, $popup.
         * Specified content-types add `50 + 50 / number_of_content_types`,
         * for example: `||example.com^$image,script` will add
         * `50 + 50 / 2 = 50 + 25 = 75` to the total weight of the rule.
         * The `$popup` also belongs to this category, because it implicitly
         * adds the modifier `$document`.
         * Similarly, specific exceptions add `$document,subdocument`.
         *
         * @see {@link https://adguard.com/kb/general/ad-filtering/create-own-filters/#priority-category-2}
         */
        if (this.permittedRequestTypes !== request_type/* RequestType */.Y.NotSet) {
            const numberOfPermittedRequestTypes = getBitCount(this.permittedRequestTypes);
            // More permitted request types mean less priority weight.
            const relativeWeight = NetworkRule.CategoryTwoWeight / numberOfPermittedRequestTypes;
            this.priorityWeight += NetworkRule.CategoryTwoWeight + relativeWeight;
        }
        if (this.methodModifier?.permittedValues && this.methodModifier.permittedValues.length > 0) {
            // More permitted request methods mean less priority weight.
            const relativeWeight = NetworkRule.CategoryTwoWeight / this.methodModifier.permittedValues.length;
            this.priorityWeight += NetworkRule.CategoryTwoWeight + relativeWeight;
        }
        if (this.headerModifier) {
            // $header modifier in the rule adds 50
            this.priorityWeight += NetworkRule.CategoryTwoWeight;
        }
        /**
         * Category 3: permitted domains.
         * Specified domains through `$domain` and specified applications
         * through `$app` add `100 + 100 / number_domains (or number_applications)`,
         * for example:
         * `||example.com^$domain=example.com|example.org|example.net`
         * will add `100 + 100 / 3 = 134.3 = 134` or
         * `||example.com^$app=org.example.app1|org.example.app2`
         * will add `100 + 100 / 2 = 151`.
         */
        if (domainModifier?.hasPermittedDomains()) {
            // More permitted domains mean less priority weight.
            const relativeWeight = NetworkRule.CategoryThreeWeight / domainModifier.getPermittedDomains().length;
            this.priorityWeight += NetworkRule.CategoryThreeWeight + relativeWeight;
        }
        // Category 4: redirect rules.
        if (this.isOptionEnabled(NetworkRuleOption.Redirect)) {
            this.priorityWeight += NetworkRule.CategoryFourWeight;
        }
        // Category 5: specific exceptions.
        this.priorityWeight += NetworkRule.CategoryFiveWeight * countEnabledBits(this.enabledOptions, NetworkRule.SPECIFIC_EXCLUSIONS_MASK);
        // Category 6: allowlist rules.
        if (this.isAllowlist()) {
            this.priorityWeight += NetworkRule.CategorySixWeight;
        }
        // Category 7: important rules.
        if (this.isOptionEnabled(NetworkRuleOption.Important)) {
            this.priorityWeight += NetworkRule.CategorySevenWeight;
        }
        // Round up to avoid overlap between different categories of rules.
        this.priorityWeight = Math.ceil(this.priorityWeight);
    }
    /**
     * Validates rule options.
     */
    validateOptions() {
        if (this.advancedModifier instanceof RemoveParamModifier) {
            this.validateRemoveParamRule();
        }
        else if (this.advancedModifier instanceof RemoveHeaderModifier) {
            this.validateRemoveHeaderRule();
        }
        else if (this.advancedModifier instanceof PermissionsModifier) {
            this.validatePermissionsRule();
        }
        else if (this.headerModifier instanceof HeaderModifier) {
            this.validateHeaderRule();
        }
        else if (this.toModifier !== null) {
            this.validateToRule();
        }
        else if (this.denyAllowDomains !== null) {
            this.validateDenyallowRule();
        }
    }
    /**
     * $header rules are not compatible with any other
     * modifiers except for $important, $csp, $removeheader, $badfilter.
     * The rules with any other modifiers are considered invalid and will be discarded.
     */
    validateHeaderRule() {
        if ((this.enabledOptions | NetworkRuleGroupOptions.HeaderCompatibleOptions)
            !== NetworkRuleGroupOptions.HeaderCompatibleOptions) {
            throw new SyntaxError('$header rules are not compatible with some other modifiers');
        }
        if (this.advancedModifier && this.isOptionEnabled(NetworkRuleOption.RemoveHeader)) {
            const removeHeaderValue = this.getAdvancedModifierValue();
            if (!removeHeaderValue || removeHeaderValue.includes('request:')) {
                const message = '$header rules are only compatible with response headers removal of $removeheader.';
                throw new SyntaxError(message);
            }
        }
    }
    /**
     * $permissions rules are not compatible with any other
     * modifiers except $domain, $important, and $subdocument.
     * The rules with any other modifiers are considered invalid and will be discarded.
     */
    validatePermissionsRule() {
        if ((this.enabledOptions | NetworkRuleGroupOptions.PermissionsCompatibleOptions)
            !== NetworkRuleGroupOptions.PermissionsCompatibleOptions) {
            throw new SyntaxError('$permissions rules are not compatible with some other modifiers');
        }
    }
    /**
     * $removeparam rules are not compatible with any other modifiers except $domain,
     * $third-party, $app, $important, $match-case and permitted content type modifiers ($script, $stylesheet, etc).
     * The rules with any other modifiers are considered invalid and will be discarded.
     */
    validateRemoveParamRule() {
        if ((this.enabledOptions | NetworkRuleGroupOptions.RemoveParamCompatibleOptions)
            !== NetworkRuleGroupOptions.RemoveParamCompatibleOptions) {
            throw new SyntaxError('$removeparam rules are not compatible with some other modifiers');
        }
    }
    /**
     * $removeheader rules are not compatible with any other modifiers except $domain,
     * $third-party, $app, $important, $match-case and permitted content type modifiers ($script, $stylesheet, etc).
     * The rules with any other modifiers are considered invalid and will be discarded.
     */
    validateRemoveHeaderRule() {
        if ((this.enabledOptions | NetworkRuleGroupOptions.RemoveHeaderCompatibleOptions)
            !== NetworkRuleGroupOptions.RemoveHeaderCompatibleOptions) {
            throw new SyntaxError('$removeheader rules are not compatible with some other modifiers');
        }
        if (this.headerModifier && this.isOptionEnabled(NetworkRuleOption.Header)) {
            const removeHeaderValue = this.getAdvancedModifierValue();
            if (!removeHeaderValue || removeHeaderValue.includes('request:')) {
                const message = 'Request headers removal of $removeheaders is not compatible with $header rules.';
                throw new SyntaxError(message);
            }
        }
    }
    /**
     * $to rules are not compatible $denyallow - these rules considered invalid
     * and will be discarded.
     */
    validateToRule() {
        if (this.denyAllowDomains) {
            throw new SyntaxError('modifier $to is not compatible with $denyallow modifier');
        }
    }
    /**
     * $denyallow rules are not compatible $to - these rules considered invalid
     * and will be discarded.
     */
    validateDenyallowRule() {
        if (this.toModifier) {
            throw new SyntaxError('modifier $to is not compatible with $denyallow modifier');
        }
    }
}

/**
 * MatchingResult contains all the rules matching a web request, and provides methods
 * that define how a web request should be processed.
 */
class MatchingResult {
    /**
     * BasicRule - a rule matching the request.
     * It could lead to one of the following:
     * block the request
     * unblock the request (a regular allowlist rule or a document-level allowlist rule)
     * modify the way cosmetic rules work for this request
     * modify the response (see $redirect rules).
     */
    basicRule;
    /**
     * Rule matching the request's referrer and having on of the following modifiers:
     * - $document — this one basically disables everything;
     * - $urlblock — disables network-level rules (not cosmetic);
     * - $genericblock — disables generic network-level rules.
     *
     * Other document-level modifiers like $jsinject or $content will be ignored here as they don't do anything.
     */
    documentRule;
    /**
     * Set of rules modifying the response's content-security-policy
     * See $csp modifier.
     */
    cspRules;
    /**
     * Set of rules modifying the request's and response's cookies
     * See $cookie modifier.
     */
    cookieRules;
    /**
     * Set of rules modifying the response's content
     * See $replace modifier.
     */
    replaceRules;
    /**
     * Set of rules redirecting request
     * See $redirect and $redirect-rule modifiers.
     */
    redirectRules;
    /**
     * RemoveParam rules - a set of rules modifying url query parameters
     * See $removeparam modifier.
     */
    removeParamRules;
    /**
     * RemoveHeader rules - a set of rules modifying headers
     * See $removeheader modifier.
     */
    removeHeaderRules;
    /**
     * Permissions rules - a set of rules modifying permissions policy
     * See $permissions modifier.
     */
    permissionsRules;
    /**
     * Headers rules - a set of rules for blocking rules by headers.
     */
    headerRules;
    /**
     * Stealth rules - a set of allowlist rules with $stealth modifier,
     * that negates stealth mode features.
     *
     * Note that the stealth rule can be received from both rules and sourceRules.
     *
     * @see {@link https://kb.adguard.com/en/general/how-to-create-your-own-ad-filters#stealth-modifier}
     */
    stealthRules;
    /**
     * CosmeticExceptionRule - a rule that disables cosmetic rules for the document or subdocument.
     * It is moved to it's own filed to not interfere with applying network blocking rules.
     */
    cosmeticExceptionRule;
    /**
     * PopupRule - this is a rule that specified which way should be used
     * to blocking document request: close the tab or open dummy blocking page.
     * We should store it separately from other blocking rules, because $popup
     * has an intersection by use cases with $all.
     *
     * @see {@link https://kb.adguard.com/en/general/how-to-create-your-own-ad-filters#popup-modifier}
     */
    popupRule;
    /**
     * Creates an instance of the MatchingResult struct and fills it with the rules.
     *
     * @param rules A list of network rules that match the request.
     * @param sourceRule A rule that matches the document that is a source
     * of the request, i.e. document-level exclusions.
     */
    constructor(rules, sourceRule) {
        this.basicRule = null;
        this.documentRule = null;
        this.cspRules = null;
        this.cookieRules = null;
        this.replaceRules = null;
        this.removeParamRules = null;
        this.removeHeaderRules = null;
        this.redirectRules = null;
        this.stealthRules = null;
        this.permissionsRules = null;
        this.headerRules = null;
        this.popupRule = null;
        this.cosmeticExceptionRule = null;
        // eslint-disable-next-line no-param-reassign
        rules = MatchingResult.removeBadfilterRules(rules);
        if (sourceRule) {
            this.documentRule = sourceRule;
        }
        // Second - check if blocking rules (generic or all of them) are allowed
        // generic blocking rules are allowed by default
        let genericAllowed = true;
        // basic blocking rules are allowed by default
        let basicAllowed = true;
        if (this.documentRule) {
            if (this.documentRule.isOptionEnabled(NetworkRuleOption.Urlblock)) {
                basicAllowed = false;
            }
            else if (this.documentRule.isOptionEnabled(NetworkRuleOption.Genericblock)) {
                genericAllowed = false;
            }
        }
        // Iterate through the list of rules and fill the MatchingResult
        for (const rule of rules) {
            if (rule.hasCosmeticOption()) {
                if (!this.cosmeticExceptionRule || rule.isHigherPriority(this.cosmeticExceptionRule)) {
                    this.cosmeticExceptionRule = rule;
                }
                /**
                 * Some rules include both cosmetic options and network modifiers,
                 * and affect both network and cosmetic engines matching.
                 *
                 * Such rules should also compete for `basicRule` slot down below,
                 * e.g `@@||example.org$document` and `@@||nhk.or.jp^$content`.
                 *
                 * Cosmetic options rules that don't contain such modifiers should only affect cosmetic engine.
                 */
                if (!rule.isOptionEnabled(NetworkRuleOption.Urlblock)
                    && !rule.isOptionEnabled(NetworkRuleOption.Genericblock)
                    && !rule.isOptionEnabled(NetworkRuleOption.Content)) {
                    continue;
                }
            }
            if (rule.isOptionEnabled(NetworkRuleOption.Cookie)) {
                (this.cookieRules ??= []).push(rule);
                continue;
            }
            if (rule.isOptionEnabled(NetworkRuleOption.Replace)) {
                (this.replaceRules ??= []).push(rule);
                continue;
            }
            if (rule.isOptionEnabled(NetworkRuleOption.RemoveParam)) {
                (this.removeParamRules ??= []).push(rule);
                continue;
            }
            if (rule.isOptionEnabled(NetworkRuleOption.RemoveHeader)) {
                (this.removeHeaderRules ??= []).push(rule);
                continue;
            }
            if (rule.isOptionEnabled(NetworkRuleOption.Redirect)) {
                (this.redirectRules ??= []).push(rule);
                continue;
            }
            if (rule.isOptionEnabled(NetworkRuleOption.Csp)) {
                (this.cspRules ??= []).push(rule);
                continue;
            }
            if (rule.isOptionEnabled(NetworkRuleOption.Stealth)) {
                (this.stealthRules ??= []).push(rule);
                continue;
            }
            if (rule.isOptionEnabled(NetworkRuleOption.Permissions)) {
                (this.permissionsRules ??= []).push(rule);
                continue;
            }
            if (rule.isOptionEnabled(NetworkRuleOption.Header)) {
                (this.headerRules ??= []).push(rule);
                continue;
            }
            if (rule.isOptionEnabled(NetworkRuleOption.Popup)
                // This check needed to split $all rules from $popup rules
                && (rule.getPermittedRequestTypes() & request_type/* RequestType */.Y.Document) !== request_type/* RequestType */.Y.Document) {
                this.popupRule = rule;
                continue;
            }
            // Check blocking rules against $genericblock / $urlblock
            if (!rule.isAllowlist() && this.documentRule?.isHigherPriority(rule)) {
                if (!basicAllowed) {
                    continue;
                }
                if (!genericAllowed && rule.isGeneric()) {
                    continue;
                }
            }
            if (!this.basicRule || rule.isHigherPriority(this.basicRule)) {
                this.basicRule = rule;
            }
        }
    }
    /**
     * Returns popup rule.
     *
     * @returns The popup rule or null if not found.
     */
    getPopupRule() {
        return this.popupRule;
    }
    /**
     * GetBasicResult returns a rule that should be applied to the web request.
     *
     * Possible outcomes are:
     * - returns nil -- allow the request;
     * - returns an allowlist rule -- allow the request;
     * - returns a blocking rule -- block the request;
     * - returns a redirect rule -- redirect the request.
     *
     * @returns Basic result rule.
     */
    getBasicResult() {
        let basic = this.basicRule;
        // e.g. @@||example.com^$generichide
        if (this.cosmeticExceptionRule && (!basic || this.cosmeticExceptionRule.isHigherPriority(basic))) {
            return this.cosmeticExceptionRule;
        }
        if (!basic) {
            // Only document-level frame rule would be returned as a basic result,
            // cause only those rules could block or modify page sub-requests.
            // Other frame rules (generichide, elemhide etc) will be used in getCosmeticOption function.
            if (this.documentRule && this.documentRule.isDocumentLevelAllowlistRule()) {
                basic = this.documentRule;
            }
        }
        // https://kb.adguard.com/en/general/how-to-create-your-own-ad-filters#replace-modifier
        // https://adguard.com/kb/general/ad-filtering/create-own-filters/#priority-category-extra
        // $replace rules have a higher priority than other basic rules (including exception rules).
        // So if a request corresponds to two different rules one of which has the $replace modifier,
        // this rule will be applied.
        if (this.replaceRules) {
            const isReplaceOrContent = basic?.isOptionEnabled(NetworkRuleOption.Replace)
                || basic?.isOptionEnabled(NetworkRuleOption.Content);
            // If basic rule is an exception with $replace or $content modifier,
            // then basic rule will disable $replace rules.
            if (basic?.isAllowlist() && isReplaceOrContent) {
                return basic;
            }
            // Otherwise null is returned to allow the request, because we need
            // to get response first to then apply the $replace rules to
            // the response.
            return null;
        }
        // Redirect rules have a high priority
        // https://kb.adguard.com/en/general/how-to-create-your-own-ad-filters#redirect-modifier
        // https://adguard.com/kb/general/ad-filtering/create-own-filters/#priority-category-6
        const redirectRule = this.getRedirectRule();
        if (redirectRule && (!basic || !basic.isHigherPriority(redirectRule))) {
            return redirectRule;
        }
        if (!basic) {
            return this.popupRule;
        }
        return basic;
    }
    /**
     * Returns a single stealth rule, that is corresponding to the given option.
     * If no option is given, returns a rule that disables stealth completely if any.
     *
     * @param stealthOption Stealth option name.
     *
     * @returns Stealth rule or null.
     */
    getStealthRule(stealthOption) {
        if (!this.stealthRules) {
            return null;
        }
        return this.stealthRules.find((r) => {
            const stealthModifier = r.getStealthModifier();
            if (!stealthModifier) {
                logger.debug(`Stealth rule without stealth modifier: ${r}`);
                return false;
            }
            if (stealthOption) {
                return stealthModifier.hasStealthOption(stealthOption);
            }
            // $stealth rules without values are globally disabling stealth mode
            return !stealthModifier.hasValues();
        }) ?? null;
    }
    /**
     * Returns a single rule with $header modifier,
     * that should be applied to the web request, if any.
     *
     * Function is intended to be called on onHeadersReceived event as an alternative to getBasicResult,
     * it returns only a blocking or allowlist rule without modifiers which could modify the request.
     * Request modifying rules with $header modifier are handled in a corresponding service.
     *
     * TODO: filterAdvancedModifierRules may not be optimal for sorting rules with $header modifier,
     * as $header is not an advanced modifier.
     *
     * @param responseHeaders Response headers.
     *
     * @returns Header result rule or null.
     */
    getResponseHeadersResult(responseHeaders) {
        if (!responseHeaders || responseHeaders.length === 0) {
            return null;
        }
        const { basicRule, documentRule } = this;
        let { headerRules } = this;
        if (!headerRules) {
            return null;
        }
        if (!basicRule) {
            if (documentRule && documentRule.isDocumentLevelAllowlistRule()) {
                return null;
            }
        }
        else if (basicRule.isAllowlist()) {
            return null;
        }
        headerRules = headerRules.filter((rule) => rule.matchResponseHeaders(responseHeaders));
        // Handle allowlist rules with $header modifier,
        // filtering out blocking rules which are allowlisted
        const rules = MatchingResult.filterAdvancedModifierRules(headerRules, (bRule) => ((aRule) => {
            const bHeaderData = bRule.getHeaderModifierValue();
            const aHeaderData = aRule.getHeaderModifierValue();
            return bHeaderData?.header === aHeaderData?.header
                && bHeaderData?.value?.toString() === aHeaderData?.value?.toString();
        }));
        return MatchingResult.getHighestPriorityRule(rules);
    }
    /**
     * Returns a bit-flag with the list of cosmetic options.
     *
     * @returns Cosmetic option mask.
     */
    getCosmeticOption() {
        const { basicRule, documentRule, cosmeticExceptionRule } = this;
        let rule = cosmeticExceptionRule || basicRule;
        // We choose a non-empty rule and the one of the two with the higher
        // priority in order to accurately calculate cosmetic options.
        if ((!rule && documentRule) || (rule && documentRule?.isHigherPriority(rule))) {
            rule = documentRule;
        }
        if (!rule || !rule.isAllowlist()) {
            return CosmeticOption.CosmeticOptionAll;
        }
        let option = CosmeticOption.CosmeticOptionAll;
        if (rule.isOptionEnabled(NetworkRuleOption.Elemhide)) {
            option ^= CosmeticOption.CosmeticOptionGenericCSS;
            option ^= CosmeticOption.CosmeticOptionSpecificCSS;
        }
        if (rule.isOptionEnabled(NetworkRuleOption.Generichide)) {
            option ^= CosmeticOption.CosmeticOptionGenericCSS;
        }
        if (rule.isOptionEnabled(NetworkRuleOption.Specifichide)) {
            option ^= CosmeticOption.CosmeticOptionSpecificCSS;
        }
        if (rule.isOptionEnabled(NetworkRuleOption.Jsinject)) {
            option ^= CosmeticOption.CosmeticOptionJS;
        }
        if (rule.isOptionEnabled(NetworkRuleOption.Content)) {
            option ^= CosmeticOption.CosmeticOptionHtml;
        }
        return option;
    }
    /**
     * Return an array of replace rules.
     *
     * @returns An array of replace rules.
     */
    getReplaceRules() {
        if (!this.replaceRules) {
            return [];
        }
        // TODO: Look up for allowlist $content rule
        return MatchingResult.filterAdvancedModifierRules(this.replaceRules, (rule) => ((x) => x.getAdvancedModifierValue() === rule.getAdvancedModifierValue()));
    }
    /**
     * Filters array of rules according to allowlist rules contained.
     * Empty advanced modifier allowlists everything.
     *
     * This function result will be called for testing if rule `x` allowlists rule `r`.
     *
     * @param rules Array of rules.
     * @param allowlistPredicate Allowlist criteria.
     *
     * @returns Filtered array of rules.
     */
    static filterAdvancedModifierRules(rules, allowlistPredicate) {
        const blockingRules = [];
        const allowlistRules = [];
        for (const rule of rules) {
            if (rule.isAllowlist()) {
                allowlistRules.push(rule);
            }
            else {
                blockingRules.push(rule);
            }
        }
        if (blockingRules.length === 0) {
            return [];
        }
        if (allowlistRules.length === 0) {
            return blockingRules;
        }
        if (allowlistRules.length > 0) {
            const allowlistRuleWithEmptyOption = allowlistRules
                .find((allowlistRule) => allowlistRule.getAdvancedModifierValue() === '');
            const result = [];
            blockingRules.forEach((blockRule) => {
                if (allowlistRuleWithEmptyOption
                    && !blockRule.isHigherPriority(allowlistRuleWithEmptyOption)) {
                    result.push(allowlistRuleWithEmptyOption);
                    return;
                }
                const allowlistingRule = allowlistRules.find((a) => {
                    return !blockRule.isHigherPriority(a) && allowlistPredicate.call(this, blockRule)(a);
                });
                if (allowlistingRule) {
                    result.push(allowlistingRule);
                }
                else {
                    result.push(blockRule);
                }
            });
            return result.filter((item, pos) => result.indexOf(item) === pos);
        }
        return blockingRules;
    }
    /**
     * Returns an array of csp rules.
     *
     * @returns An array of csp rules.
     */
    getCspRules() {
        if (!this.cspRules) {
            return [];
        }
        const blockingRules = [];
        const allowlistedRulesByDirective = new Map();
        for (const rule of this.cspRules) {
            if (rule.isAllowlist()) {
                if (!rule.getAdvancedModifierValue()) { // Global allowlist rule
                    return [rule];
                }
                MatchingResult.putWithPriority(rule, undefined, allowlistedRulesByDirective);
            }
            else {
                blockingRules.push(rule);
            }
        }
        const rulesByDirective = new Map();
        // Collect allowlist and blocking CSP rules in one array
        blockingRules.forEach((rule) => {
            if (rule.getAdvancedModifierValue()) {
                const allowlistRule = allowlistedRulesByDirective.get(rule.getAdvancedModifierValue());
                MatchingResult.putWithPriority(rule, allowlistRule, rulesByDirective);
            }
        });
        return Array.from(rulesByDirective.values());
    }
    /**
     * Checks if a network rule is sub document rule.
     *
     * @param rule Rule to check.
     *
     * @returns `true` if the rule is sub document rule.
     */
    static isSubDocumentRule(rule) {
        return (rule.getPermittedRequestTypes() & request_type/* RequestType */.Y.SubDocument) === request_type/* RequestType */.Y.SubDocument;
    }
    /**
     * Returns an array of permission policy rules.
     *
     * @returns An array of permission policy rules.
     */
    getPermissionsPolicyRules() {
        if (!this.permissionsRules) {
            return [];
        }
        const allowlistRules = [];
        const blockingRules = [];
        let globalAllowlistRule = null;
        let globalSubDocAllowlistRule = null;
        for (let i = 0; i < this.permissionsRules.length; i += 1) {
            const rule = this.permissionsRules[i];
            if (rule.isAllowlist()) {
                // Global allowlist rule, where $permissions modifier doesn't have a value
                if (!rule.getAdvancedModifierValue()) {
                    if (MatchingResult.isSubDocumentRule(rule)) {
                        if (!globalSubDocAllowlistRule) {
                            // e.g. @@||example.com^$subdocument,permissions
                            globalSubDocAllowlistRule = rule;
                        }
                    }
                    else if (!globalAllowlistRule) {
                        // e.g. @@||example.com^$permissions
                        globalAllowlistRule = rule;
                    }
                }
                else {
                    allowlistRules.push(rule);
                }
            }
            else {
                blockingRules.push(rule);
            }
        }
        if (globalAllowlistRule) {
            return [globalAllowlistRule];
        }
        const result = new Set();
        blockingRules.forEach((rule) => {
            if (MatchingResult.isSubDocumentRule(rule) && globalSubDocAllowlistRule) {
                result.add(globalSubDocAllowlistRule);
                return;
            }
            const allowlistRule = allowlistRules.find((a) => !rule.isHigherPriority(a) && rule.getAdvancedModifierValue() === a.getAdvancedModifierValue()
                && MatchingResult.isSubDocumentRule(a) === MatchingResult.isSubDocumentRule(rule));
            if (allowlistRule) {
                result.add(allowlistRule);
            }
            else {
                result.add(rule);
            }
        });
        return Array.from(result);
    }
    /**
     * Returns a redirect rule or null if redirect rules are empty.
     * $redirect-rule is only returned if there's a blocking rule also matching
     * this request.
     *
     * @returns Redirect rule or null if not found.
     */
    getRedirectRule() {
        if (!this.redirectRules) {
            return null;
        }
        // Apply allowlist $redirect rules.
        let result = MatchingResult.filterAdvancedModifierRules(this.redirectRules, (rule) => ((x) => x.getAdvancedModifierValue() === rule.getAdvancedModifierValue()));
        // Filters only not allowlist rules.
        result = result.filter((r) => !r.isAllowlist());
        // Splits $redirect and $redirect-rule into separate arrays.
        const conditionalRedirectRules = [];
        const allWeatherRedirectRules = [];
        result.forEach((rule) => {
            const redirectModifier = rule.getAdvancedModifier();
            if (redirectModifier.isRedirectingOnlyBlocked) {
                conditionalRedirectRules.push(rule);
            }
            else {
                allWeatherRedirectRules.push(rule);
            }
        });
        if (allWeatherRedirectRules.length > 0) {
            return MatchingResult.getHighestPriorityRule(allWeatherRedirectRules);
        }
        if (conditionalRedirectRules.length > 0 && this.basicRule && !this.basicRule.isAllowlist()) {
            return MatchingResult.getHighestPriorityRule(conditionalRedirectRules);
        }
        return null;
    }
    /**
     * Returns an array of cookie rules.
     *
     * @returns An array of cookie rules.
     */
    getCookieRules() {
        if (!this.cookieRules) {
            return [];
        }
        const basic = this.getBasicResult();
        if (basic?.isAllowlist() && basic.isOptionEnabled(NetworkRuleOption.Urlblock)) {
            return [];
        }
        const allowlistPredicate = (rule) => ((allowlistRule) => {
            const allowlistRuleCookieModifier = allowlistRule.getAdvancedModifier();
            const ruleCookieModifier = rule.getAdvancedModifier();
            if (allowlistRule.getAdvancedModifierValue() === rule.getAdvancedModifierValue()) {
                return true;
            }
            // Matches by cookie name
            if (allowlistRuleCookieModifier.matches(ruleCookieModifier.getCookieName())) {
                return true;
            }
            return false;
        });
        let filtered = MatchingResult.filterAdvancedModifierRules(this.cookieRules, allowlistPredicate);
        // Cookie rule may also be disabled by a stealth rule with corresponding `1p-cookie` or `3p-cookie` value
        // If corresponding $stealth rule is found, such cookie rule does not get into resulting array
        filtered = filtered.filter((cookieRule) => {
            if (cookieRule.getFilterListId() !== STEALTH_MODE_FILTER_ID) {
                return true;
            }
            if (cookieRule.isOptionEnabled(NetworkRuleOption.ThirdParty)) {
                return !this.getStealthRule(StealthOptionName.ThirdPartyCookies);
            }
            return !this.getStealthRule(StealthOptionName.FirstPartyCookies);
        });
        return filtered.concat([...this.cookieRules.filter((r) => r.isAllowlist())]);
    }
    /**
     * Returns an array of removeparam rules.
     *
     * @returns Array of removeparam rules.
     */
    getRemoveParamRules() {
        if (!this.removeParamRules) {
            return [];
        }
        return MatchingResult.filterAdvancedModifierRules(this.removeParamRules, 
        // eslint-disable-next-line arrow-body-style
        (rule) => ((x) => {
            return x.isHigherPriority(rule) && x.getAdvancedModifierValue() === rule.getAdvancedModifierValue();
        }));
    }
    /**
     * Returns an array of removeheader rules.
     *
     * @returns An array of removeheader rules.
     */
    getRemoveHeaderRules() {
        if (!this.removeHeaderRules) {
            return [];
        }
        if (this.basicRule
            && this.basicRule.isAllowlist()
            && this.basicRule.isOptionEnabled(NetworkRuleOption.Urlblock)) {
            return [];
        }
        return MatchingResult.filterAdvancedModifierRules(this.removeHeaderRules, (rule) => ((x) => x.getAdvancedModifierValue() === rule.getAdvancedModifierValue()));
    }
    /**
     * Decides which rule should be put into the given map.
     * Compares priorities of the two given rules with the equal CSP directive and the rule that may already in the map.
     *
     * @param rule CSP rule (not null).
     * @param allowlistRule CSP allowlist rule (may be null).
     * @param map Rules mapped by csp directive.
     */
    // eslint-disable-next-line max-len
    static putWithPriority(rule, allowlistRule, map) {
        const cspDirective = rule.getAdvancedModifierValue();
        const currentRule = cspDirective ? map.get(cspDirective) : null;
        let newRule = rule;
        if (currentRule && !rule.isHigherPriority(currentRule)) {
            newRule = currentRule;
        }
        if (allowlistRule && allowlistRule.isHigherPriority(newRule)) {
            newRule = allowlistRule;
        }
        map.set(cspDirective, newRule);
    }
    /**
     * Looks if there are any matching $badfilter rules and removes
     * matching bad filters from the array (see the $badfilter description for more info).
     *
     * @param rules Rules to filter.
     *
     * @returns Filtered rules.
     */
    static removeBadfilterRules(rules) {
        const badfilterRules = [];
        for (const rule of rules) {
            if (rule.isOptionEnabled(NetworkRuleOption.Badfilter)) {
                badfilterRules.push(rule);
            }
        }
        if (badfilterRules.length > 0) {
            return rules.filter((rule) => {
                if (rule.isOptionEnabled(NetworkRuleOption.Badfilter)) {
                    return false;
                }
                const isRuleNegated = badfilterRules.some((badfilter) => badfilter.negatesBadfilter(rule));
                return !isRuleNegated;
            });
        }
        return rules;
    }
    /**
     * Returns the highest priority rule from the given array.
     *
     * @param rules Array of network rules.
     *
     * @returns Hightest priority rule or null if the array is empty.
     */
    static getHighestPriorityRule(rules) {
        if (rules.length === 0) {
            return null;
        }
        return rules.sort((a, b) => (b.isHigherPriority(a) ? 1 : -1))[0];
    }
}

/**
 * Prefix tree implementation.
 */
class TrieNode {
    /**
     * This node's children could be
     * - undefined in case of no children
     * - an instance of TrieNode in case of lonely child
     * - a map where key is a character code and value is it's trie node.
     */
    children;
    /**
     * Character code of this TrieNode.
     */
    code;
    /**
     * Data, attached to this trie node. When trie traversal is being done,
     * data from all trie nodes is collected.
     */
    data;
    /**
     * Creates an instance of a TrieNode with the specified char code.
     *
     * @param code The character code for this TrieNode.
     */
    constructor(code) {
        this.code = code;
    }
    /**
     * Attaches data to this TrieNode.
     *
     * @param data The data to attach to this TrieNode.
     */
    attach(data) {
        if (!this.data) {
            this.data = [];
        }
        this.data.push(data);
    }
    /**
     * Adds the specified string to the Trie and attaches data to it.
     *
     * @param str String to add.
     * @param data Data to attach to the leaf node.
     */
    add(str, data) {
        // eslint-disable-next-line @typescript-eslint/no-this-alias
        let root = this;
        for (let i = 0; i < str.length; i += 1) {
            const c = str.charCodeAt(i);
            let next = root.getChild(c);
            if (!next) {
                next = root.addChild(c);
            }
            root = next;
        }
        root.attach(data);
    }
    /**
     * Traverses this TrieNode and it's children using the specified search string.
     * This method collects all the data that's attached on the way and returns as
     * a result.
     *
     * @param str String to check.
     * @param start Index in str where to start traversing from.
     *
     * @returns An array of numbers collected from the trie nodes.
     */
    traverse(str, start) {
        const result = [];
        // eslint-disable-next-line @typescript-eslint/no-this-alias
        let current = this;
        for (let i = start; i < str.length; i += 1) {
            const c = str.charCodeAt(i);
            const next = current.getChild(c);
            if (!next) {
                break;
            }
            if (next.data) {
                result.push(...next.data);
            }
            current = next;
        }
        return result;
    }
    /**
     * Traverses this TrieNode and it's children using the specified search string and all substrings.
     *
     * @param str String to check.
     * @param len Max length to check.
     *
     * @returns Array of numbers collected from the trie nodes.
     */
    traverseAll(str, len) {
        const data = [];
        for (let i = 0; i <= len; i += 1) {
            const result = this.traverse(str, i);
            if (result) {
                data.push(...result);
            }
        }
        return data;
    }
    /**
     * Returns a child node with the specified character code or
     * undefined if not found.
     *
     * @param code Character code.
     *
     * @returns Child node or undefined.
     */
    getChild(code) {
        const { children } = this;
        if (!children) {
            return undefined;
        }
        if (children instanceof TrieNode) {
            if (children.code === code) {
                return children;
            }
            return undefined;
        }
        return children.get(code);
    }
    /**
     * Adds a new child node with the specified character code.
     *
     * @param code Character code.
     *
     * @returns The newly created TrieNode.
     */
    addChild(code) {
        const node = new TrieNode(code);
        if (!this.children) {
            this.children = node;
        }
        else if (this.children instanceof TrieNode) {
            const oldNode = this.children;
            this.children = new Map();
            this.children.set(oldNode.code, oldNode);
            this.children.set(code, node);
        }
        else {
            this.children.set(code, node);
        }
        return node;
    }
}

/**
 * Look up table with underlying prefix tree.
 */
class TrieLookupTable {
    /**
     * Count of rules added to this lookup table.
     */
    rulesCount = 0;
    /**
     * Storage for the network filtering rules.
     */
    ruleStorage;
    /**
     * Trie that stores rules' shortcuts.
     */
    trie;
    /**
     * Creates a new instance of the TrieLookupTable.
     *
     * @param storage Rules storage. We store "rule indexes" in the lookup table which
     * can be used to retrieve the full rules from the storage.
     */
    constructor(storage) {
        this.ruleStorage = storage;
        this.trie = new TrieNode(0);
    }
    /**
     * Finds all matching rules from the shortcuts lookup table.
     *
     * @param request Request to check.
     *
     * @returns Array of matching rules.
     */
    matchAll(request) {
        const rulesIndexes = this.traverse(request);
        return this.matchRules(request, rulesIndexes);
    }
    /**
     * Tries to add the rule to the lookup table.
     * Returns true if it was added.
     *
     * @param rule Rule to add.
     * @param storageIdx Index of the rule in the storage.
     *
     * @returns True if the rule was added.
     */
    addRule(rule, storageIdx) {
        const shortcut = rule.getShortcut();
        if (!shortcut || TrieLookupTable.isAnyURLShortcut(shortcut)
            || shortcut.length < simple_regex_BBjA8AEZ.S.MIN_SHORTCUT_LENGTH) {
            return false;
        }
        this.trie.add(shortcut, storageIdx);
        this.rulesCount += 1;
        return true;
    }
    /**
     * Returns total rules count.
     *
     * @returns Total rules count.
     */
    getRulesCount() {
        return this.rulesCount;
    }
    /**
     * For specified request finds matching rules from rules indexes array.
     *
     * @param request Request to check.
     * @param rulesIndexes Array of rules indexes.
     *
     * @returns Array of matching rules.
     */
    matchRules(request, rulesIndexes) {
        if (!rulesIndexes) {
            return [];
        }
        const result = [];
        for (let j = 0; j < rulesIndexes.length; j += 1) {
            const idx = rulesIndexes[j];
            const rule = this.ruleStorage.retrieveNetworkRule(idx);
            if (rule && rule.match(request, false)) {
                result.push(rule);
            }
        }
        return result;
    }
    /**
     * Traverses trie.
     *
     * @param request Request to check.
     *
     * @returns Array of numbers collected from the trie nodes.
     */
    traverse(request) {
        return this.trie.traverseAll(request.urlLowercase, request.urlLowercase.length);
    }
    /**
     * Checks if the rule potentially matches too many URLs.
     * We'd better use another type of lookup table for this kind of rules.
     *
     * @param shortcut Shortcut to check.
     *
     * @returns True if the rule potentially matches too many URLs.
     */
    static isAnyURLShortcut(shortcut) {
        // The numbers are basically ("PROTO://".length + 1)
        if (shortcut.length < 6 && shortcut.indexOf('ws:') === 0) {
            return true;
        }
        if (shortcut.length < 7 && shortcut.indexOf('|ws') === 0) {
            return true;
        }
        if (shortcut.length < 9 && shortcut.indexOf('http') === 0) {
            return true;
        }
        return !!(shortcut.length < 10 && shortcut.indexOf('|http') === 0);
    }
}

/**
 * Domain lookup table. Key is the domain name hash.
 */
class DomainsLookupTable {
    /**
     * Count of rules added to this lookup table.
     */
    rulesCount = 0;
    /**
     * Domain lookup table. Key is the domain name hash.
     */
    domainsLookupTable = new Map();
    /**
     * Storage for the network filtering rules.
     */
    ruleStorage;
    /**
     * Creates a new instance.
     *
     * @param storage Rules storage. We store "rule indexes" in the lookup table which
     * can be used to retrieve the full rules from the storage.
     */
    constructor(storage) {
        this.ruleStorage = storage;
    }
    /**
     * Implements the ILookupTable interface for DomainsLookupTable.
     *
     * @param rule Rule to add.
     * @param storageIdx Index of the rule in the storage.
     *
     * @returns True if the rule was added.
     */
    addRule(rule, storageIdx) {
        const permittedDomains = rule.getPermittedDomains();
        if (!permittedDomains || permittedDomains.length === 0) {
            return false;
        }
        if (permittedDomains.some(DomainModifier.isWildcardOrRegexDomain)) {
            return false;
        }
        permittedDomains.forEach((domain) => {
            const hash = (0,simple_regex_BBjA8AEZ.f)(domain);
            // Add the rule to the lookup table
            let rulesIndexes = this.domainsLookupTable.get(hash);
            if (!rulesIndexes) {
                rulesIndexes = [];
            }
            rulesIndexes.push(storageIdx);
            this.domainsLookupTable.set(hash, rulesIndexes);
        });
        this.rulesCount += 1;
        return true;
    }
    /**
     * Implements the ILookupTable interface method.
     *
     * @returns The count of rules added to this lookup table.
     */
    getRulesCount() {
        return this.rulesCount;
    }
    /**
     * Implements the ILookupTable interface method.
     *
     * @param request Request to check.
     *
     * @returns Array of matching network rules.
     */
    matchAll(request) {
        const result = [];
        if (!request.sourceHostname) {
            return result;
        }
        const domains = request.subdomains;
        if (request.hostname !== request.sourceHostname) {
            domains.push(...request.sourceSubdomains);
        }
        for (let i = 0; i < domains.length; i += 1) {
            const hash = (0,simple_regex_BBjA8AEZ.f)(domains[i]);
            const rulesIndexes = this.domainsLookupTable.get(hash);
            if (rulesIndexes) {
                for (let j = 0; j < rulesIndexes.length; j += 1) {
                    const rule = this.ruleStorage.retrieveNetworkRule(rulesIndexes[j]);
                    if (rule && rule.match(request)) {
                        result.push(rule);
                    }
                }
            }
        }
        return result;
    }
}

/**
 * Hostname lookup table.
 * For specific kind of rules like '||hostname^' and '||hostname/path' more simple algorithm with hashes is faster.
 */
class HostnameLookupTable {
    /**
     * Count of rules added to this lookup table.
     */
    rulesCount = 0;
    /**
     * Domain lookup table. Key is the domain name hash.
     */
    hostnameLookupTable = new Map();
    /**
     * Storage for the network filtering rules.
     */
    ruleStorage;
    /**
     * Creates a new instance.
     *
     * @param storage Rules storage. We store "rule indexes" in the lookup table which
     * can be used to retrieve the full rules from the storage.
     */
    constructor(storage) {
        this.ruleStorage = storage;
    }
    /**
     * Implements the ILookupTable interface for DomainsLookupTable.
     *
     * @param rule Rule to add.
     * @param storageIdx Index of the rule in the storage.
     *
     * @returns True if the rule was added.
     */
    addRule(rule, storageIdx) {
        const pattern = rule.getPattern();
        let hostname = '';
        // Pattern: '||example.org^'
        if (pattern.startsWith(simple_regex_BBjA8AEZ.S.MASK_START_URL) && pattern.endsWith(simple_regex_BBjA8AEZ.S.MASK_SEPARATOR)) {
            hostname = pattern.slice(simple_regex_BBjA8AEZ.S.MASK_START_URL.length, pattern.length - simple_regex_BBjA8AEZ.S.MASK_SEPARATOR.length);
        }
        // Pattern: '||example.org/path'
        if (pattern.startsWith(simple_regex_BBjA8AEZ.S.MASK_START_URL) && pattern.indexOf(simple_regex_BBjA8AEZ.S.MASK_BACKSLASH) !== -1) {
            const end = pattern.indexOf(simple_regex_BBjA8AEZ.S.MASK_BACKSLASH);
            hostname = pattern.slice(simple_regex_BBjA8AEZ.S.MASK_START_URL.length, end);
        }
        if (!HostnameLookupTable.isValidHostname(hostname)) {
            return false;
        }
        const hash = (0,simple_regex_BBjA8AEZ.f)(hostname);
        let rulesIndexes = this.hostnameLookupTable.get(hash);
        if (!rulesIndexes) {
            rulesIndexes = new Array();
            this.hostnameLookupTable.set(hash, rulesIndexes);
        }
        rulesIndexes.push(storageIdx);
        this.rulesCount += 1;
        return true;
    }
    /**
     * Implements the ILookupTable interface method.
     *
     * @returns The count of rules added to this lookup table.
     */
    getRulesCount() {
        return this.rulesCount;
    }
    /**
     * Implements the ILookupTable interface method.
     *
     * @param request The request to match against.
     *
     * @returns An array of matching network rules.
     */
    matchAll(request) {
        const result = [];
        const domains = request.subdomains;
        for (let i = 0; i < domains.length; i += 1) {
            const hash = (0,simple_regex_BBjA8AEZ.f)(domains[i]);
            const rulesIndexes = this.hostnameLookupTable.get(hash);
            if (rulesIndexes) {
                for (let j = 0; j < rulesIndexes.length; j += 1) {
                    const rule = this.ruleStorage.retrieveNetworkRule(rulesIndexes[j]);
                    if (rule && rule.match(request)) {
                        result.push(rule);
                    }
                }
            }
        }
        return result;
    }
    /**
     * Checks if this hostname string is valid.
     *
     * @param hostname Hostname to check.
     *
     * @returns True if the hostname is valid.
     */
    static isValidHostname(hostname) {
        if (!hostname) {
            return false;
        }
        if (hostname.indexOf(simple_regex_BBjA8AEZ.S.MASK_ANY_CHARACTER) !== -1) {
            return false;
        }
        if (hostname.indexOf('.') < 0 || hostname.endsWith('.')) {
            return false;
        }
        return true;
    }
}

/**
 * Sequence scan lookup table of rules for which we could not find a shortcut
 * and could not place it to the shortcuts lookup table.
 * In common case of rule there is always a way to just check a rule.match().
 */
class SeqScanLookupTable {
    /**
     * Count of rules added to this lookup table.
     */
    rulesCount = 0;
    /**
     * Rules for which we could not find a shortcut and could not place it to the shortcuts lookup table.
     */
    rules = [];
    /**
     * Implements the ILookupTable interface for SeqScanLookupTable.
     *
     * @param rule Rule to add.
     *
     * @returns True if the rule was added.
     */
    addRule(rule) {
        if (!this.rules.includes(rule)) {
            this.rules.push(rule);
            this.rulesCount += 1;
            return true;
        }
        return false;
    }
    /**
     * Implements the ILookupTable interface method.
     *
     * @returns Count of rules added to this lookup table.
     */
    getRulesCount() {
        return this.rulesCount;
    }
    /**
     * Implements the ILookupTable interface method.
     *
     * @param request Request to check.
     *
     * @returns Array of matching rules.
     */
    matchAll(request) {
        const result = [];
        for (let i = 0; i < this.rules.length; i += 1) {
            const r = this.rules[i];
            if (r.match(request)) {
                result.push(r);
            }
        }
        return result;
    }
}

/**
 * NetworkEngine is the engine that supports quick search over network rules.
 */
class NetworkEngine {
    /**
     * Count of rules added to the engine.
     */
    rulesCount;
    /**
     * Storage for the network filtering rules.
     */
    ruleStorage;
    /**
     * Domain lookup table. Key is the domain name hash.
     */
    domainsLookupTable;
    /**
     * Lookup table that relies on the rule shortcuts to speed up the search.
     */
    shortcutsLookupTable;
    /**
     * Lookup table for rules like `||hostname^` or `||hostname/path`.
     */
    hostnameLookupTable;
    /**
     * Rules for which we could not find a shortcut and could not place it to the shortcuts lookup table.
     */
    seqScanLookupTable;
    /**
     * Builds an instance of the network engine.
     *
     * @param storage An object for a rules storage.
     * @param skipStorageScan Create an instance without storage scanning.
     */
    constructor(storage, skipStorageScan = false) {
        this.ruleStorage = storage;
        this.rulesCount = 0;
        this.domainsLookupTable = new DomainsLookupTable(storage);
        this.hostnameLookupTable = new HostnameLookupTable(storage);
        this.shortcutsLookupTable = new TrieLookupTable(storage);
        this.seqScanLookupTable = new SeqScanLookupTable();
        if (skipStorageScan) {
            return;
        }
        const scanner = this.ruleStorage.createRuleStorageScanner(ScannerType.NetworkRules);
        while (scanner.scan()) {
            const indexedRule = scanner.getRule();
            if (indexedRule
                && indexedRule.rule instanceof NetworkRule) {
                this.addRule(indexedRule.rule, indexedRule.index);
            }
        }
    }
    /**
     * Match searches over all filtering rules loaded to the engine.
     * It returns rule if a match was found alongside the matching rule.
     *
     * @param request Request to check.
     *
     * @returns Rule matching request or null if no match was found.
     */
    match(request) {
        const networkRules = this.matchAll(request);
        if (networkRules.length === 0) {
            return null;
        }
        const result = new MatchingResult(networkRules, null);
        return result.getBasicResult();
    }
    /**
     * Finds all rules matching the specified request regardless of the rule types
     * It will find both allowlist and blacklist rules.
     *
     * @param request Request to check.
     *
     * @returns Array of matching rules.
     */
    matchAll(request) {
        // First check by shortcuts
        const result = this.hostnameLookupTable.matchAll(request);
        result.push(...(this.shortcutsLookupTable.matchAll(request)));
        result.push(...(this.domainsLookupTable.matchAll(request)));
        result.push(...(this.seqScanLookupTable.matchAll(request)));
        return result;
    }
    /**
     * Adds rule to the network engine.
     *
     * @param rule Rule to add.
     * @param storageIdx Storage index of the rule.
     */
    addRule(rule, storageIdx) {
        if (!this.hostnameLookupTable.addRule(rule, storageIdx)) {
            if (!this.shortcutsLookupTable.addRule(rule, storageIdx)) {
                if (!this.domainsLookupTable.addRule(rule, storageIdx)) {
                    this.seqScanLookupTable.addRule(rule, storageIdx);
                }
            }
        }
        this.rulesCount += 1;
    }
}

/**
 * Implements a host rule.
 *
 * HostRule is a structure for simple host-level rules (i.e. /etc/hosts syntax).
 * More details: http://man7.org/linux/man-pages/man5/hosts.5.html.
 * It also supports "just domain" syntax. In this case, the IP will be set to `0.0.0.0`.
 *
 * Rules syntax looks like this.
 * ```
 * IP_address canonical_hostname [aliases...]
 * ```
 *
 * Examples:
 * `192.168.1.13 bar.mydomain.org bar` -- ipv4
 * `ff02::1 ip6-allnodes` -- ipv6
 * `::1 localhost ip6-localhost ip6-loopback` -- ipv6 aliases
 * `example.org` -- "just domain" syntax.
 *
 * @returns True if this rule can be used on the specified hostname.
 */
class HostRule {
    ruleIndex;
    filterListId;
    hostnames = [];
    ip = '';
    invalid = false;
    /**
     * Constructor.
     *
     * Parses the rule and creates a new HostRule instance.
     *
     * @param node Original rule text.
     * @param filterListId ID of the filter list this rule belongs to.
     * @param ruleIndex Index of the rule.
     *
     * @throws Error if it fails to parse the rule.
     */
    constructor(node, filterListId, ruleIndex = RULE_INDEX_NONE) {
        this.ruleIndex = ruleIndex;
        this.filterListId = filterListId;
        this.ip = node.ip.value;
        if (node.hostnames.children.length === 0) {
            this.invalid = true;
            return;
        }
        this.hostnames = node.hostnames.children.map((hostname) => hostname.value);
    }
    /**
     * Match returns true if this rule can be used on the specified hostname.
     *
     * @param hostname Hostname to check.
     *
     * @returns True if the hostname matches one of the hostnames in the rule.
     */
    match(hostname) {
        return this.hostnames.includes(hostname);
    }
    /**
     * Returns list id.
     *
     * @returns The filter list ID.
     */
    getFilterListId() {
        return this.filterListId;
    }
    /**
     * Returns rule index.
     *
     * @returns The rule index.
     */
    getIndex() {
        return this.ruleIndex;
    }
    /**
     * Returns ip address.
     *
     * @returns IP address.
     */
    getIp() {
        return this.ip;
    }
    /**
     * Returns hostnames.
     *
     * @returns Array of hostnames.
     */
    getHostnames() {
        return this.hostnames;
    }
    /**
     * Checks if the rule is invalid.
     *
     * @returns True if the rule is invalid.
     */
    isInvalid() {
        return this.invalid;
    }
}

/**
 * Request represents a web request with all it's necessary properties.
 */
class Request {
    /**
     * Max url length for matching
     * Some urls are really long and slow down matching, so we cut them to this length.
     */
    static MAX_URL_MATCH_LENGTH = 2000;
    /**
     * Request type.
     */
    requestType;
    /**
     * True if request is third-party.
     * Third-party basically means that Domain != SourceDomain.
     * It can be null in the case when there is no sourceUrl at all.
     */
    thirdParty;
    /**
     * Original request URL.
     */
    url;
    /**
     * Request identifier.
     */
    requestId;
    /**
     * Status code.
     */
    statusCode;
    /**
     * Method name.
     */
    method;
    /**
     * Request tab identifier.
     */
    tabId;
    /**
     * The same request URL, but in lower case and shortened.
     * It is necessary to use lower-cased URL in several places,
     * that's why we keep it in the object.
     */
    urlLowercase;
    /**
     * Request's hostname.
     */
    hostname;
    /**
     * Request's domain (eTLD+1).
     */
    domain;
    /**
     * Source URL. Can be empty.
     */
    sourceUrl;
    /**
     * Source hostname. Can be empty.
     */
    sourceHostname;
    /**
     * Source domain (eTLD+1). Can be empty.
     */
    sourceDomain;
    /**
     * The request is for a given Hostname, and not for a URL, and we don't really know what protocol it is.
     * This can be true for DNS requests, or for HTTP CONNECT, or SNI matching.
     */
    isHostnameRequest = false;
    /**
     * List of subdomains parsed from hostname.
     */
    subdomains;
    /**
     * List of source subdomains parsed from source hostname.
     */
    sourceSubdomains;
    /**
     * List of client tags.
     */
    clientTags;
    /**
     * DNS type.
     */
    dnsType;
    /**
     * Client name.
     */
    clientName;
    /**
     * Client IP.
     */
    clientIP;
    /**
     * Creates an instance of a Request.
     *
     * @param url Request URL.
     * @param sourceUrl Source URL.
     * @param requestType Request type.
     * @param method Request method.
     *
     * @throws
     */
    constructor(url, sourceUrl, requestType, method) {
        if (typeof url !== 'string' || !isHttpOrWsRequest(url)) {
            throw new TypeError(`Invalid request url: ${url}`);
        }
        this.url = url;
        this.requestType = requestType;
        this.method = method;
        this.urlLowercase = Request.compactUrl(url).toLowerCase();
        this.sourceUrl = Request.compactUrl(sourceUrl);
        const tldResult = (0,es6/* parse */.qg)(url);
        // We suppose that request always has a hostname and a domain.
        this.hostname = tldResult.hostname;
        this.domain = tldResult.domain;
        this.subdomains = Request.getSubdomains(tldResult);
        let sourceTldResult;
        if (sourceUrl) {
            sourceTldResult = (0,es6/* parse */.qg)(sourceUrl);
            this.sourceHostname = sourceTldResult.hostname;
            this.sourceDomain = sourceTldResult.domain;
            this.sourceSubdomains = Request.getSubdomains(sourceTldResult);
        }
        else {
            this.sourceHostname = null;
            this.sourceDomain = null;
            this.sourceSubdomains = [];
        }
        if (this.sourceDomain) {
            this.thirdParty = this.domain !== this.sourceDomain;
        }
        else if (sourceTldResult && sourceTldResult.isIp) {
            this.thirdParty = this.hostname !== this.sourceHostname;
        }
        else {
            this.thirdParty = null;
        }
    }
    /**
     * We cut the url in performance purposes.
     *
     * @param url The URL to be compacted.
     *
     * @returns The compacted URL or null if the input URL is null.
     */
    static compactUrl(url) {
        let compacted = url;
        if (compacted && compacted.length > Request.MAX_URL_MATCH_LENGTH) {
            compacted = compacted.substring(0, Request.MAX_URL_MATCH_LENGTH);
        }
        return compacted;
    }
    /**
     * Splits subdomains and returns all subdomains (including the hostname itself).
     *
     * @param tldResult Result of `tldts.parse()`.
     *
     * @returns Array of subdomains.
     */
    static getSubdomains(tldResult) {
        const { domain, hostname, subdomain, publicSuffix, } = tldResult;
        const subdomainsResult = [];
        if (!domain) {
            if (hostname) {
                subdomainsResult.push(hostname);
                return subdomainsResult;
            }
            return [];
        }
        if (publicSuffix) {
            subdomainsResult.push(publicSuffix);
            // Extract subdomains from complex suffixes
            // https://github.com/AdguardTeam/AdguardBrowserExtension/issues/2037
            // https://github.com/AdguardTeam/tsurlfilter/issues/57
            for (let i = 0; i < publicSuffix.length; i += 1) {
                if (publicSuffix[i] === '.') {
                    subdomainsResult.push(publicSuffix.slice(i + 1));
                }
            }
        }
        subdomainsResult.push(domain);
        if (!subdomain) {
            return subdomainsResult;
        }
        const parts = subdomain.split('.');
        let incrementDomain = domain;
        for (let i = parts.length - 1; i >= 0; i -= 1) {
            incrementDomain = `${parts[i]}.${incrementDomain}`;
            subdomainsResult.push(incrementDomain);
        }
        return subdomainsResult;
    }
}

/**
 * DnsResult contains a network rule and host rules matching request.
 */
class DnsResult {
    /**
     * BasicRule - a network rule matching the request.
     */
    basicRule = null;
    /**
     * Host rules.
     */
    hostRules = [];
}

/**
 * DNSEngine combines host rules and network rules and is supposed to quickly find
 * matching rules for hostnames.
 * First, it looks over network rules and returns first rule found.
 * Then, if nothing found, it looks up the host rules.
 */
class DnsEngine {
    /**
     * Count of rules added to the engine.
     */
    rulesCount;
    /**
     * Storage.
     */
    ruleStorage;
    /**
     * Lookup table. Key is the hostname hash.
     */
    lookupTable;
    /**
     * Network engine instance.
     */
    networkEngine;
    /**
     * Builds an instance of dns engine.
     *
     * @param storage Rule storage.
     */
    constructor(storage) {
        this.ruleStorage = storage;
        this.rulesCount = 0;
        this.lookupTable = new Map();
        this.networkEngine = new NetworkEngine(storage, true);
        const scanner = this.ruleStorage.createRuleStorageScanner(ScannerType.HostRules);
        while (scanner.scan()) {
            const indexedRule = scanner.getRule();
            if (indexedRule) {
                if (indexedRule.rule instanceof HostRule) {
                    this.addRule(indexedRule.rule, indexedRule.index);
                }
                else if (indexedRule.rule instanceof NetworkRule
                    && indexedRule.rule.isHostLevelNetworkRule()) {
                    this.networkEngine.addRule(indexedRule.rule, indexedRule.index);
                }
            }
        }
    }
    /**
     * Match searches over all filtering and host rules loaded to the engine.
     *
     * @param hostname To check.
     *
     * @returns Dns result object.
     */
    match(hostname) {
        const result = new DnsResult();
        if (!hostname) {
            return result;
        }
        const url = `http://${hostname}/`;
        const request = new Request(url, url, RequestType.Document);
        request.isHostnameRequest = true;
        const networkRule = this.networkEngine.match(request);
        if (networkRule) {
            // Network rules always have higher priority
            result.basicRule = networkRule;
            return result;
        }
        const hash = fastHash(hostname);
        const rulesIndexes = this.lookupTable.get(hash);
        if (rulesIndexes) {
            for (let j = 0; j < rulesIndexes.length; j += 1) {
                const rule = this.ruleStorage.retrieveHostRule(rulesIndexes[j]);
                if (rule && rule.match(hostname)) {
                    result.hostRules.push(rule);
                }
            }
        }
        return result;
    }
    /**
     * Adds rule to engine.
     *
     * @param rule Rule to add.
     * @param storageIdx Storage index of the rule.
     */
    addRule(rule, storageIdx) {
        rule.getHostnames().forEach((hostname) => {
            const hash = fastHash(hostname);
            // Add the rule to the lookup table
            let rulesIndexes = this.lookupTable.get(hash);
            if (!rulesIndexes) {
                rulesIndexes = [];
            }
            rulesIndexes.push(storageIdx);
            this.lookupTable.set(hash, rulesIndexes);
        });
        this.rulesCount += 1;
    }
}

/* eslint-disable no-await-in-loop */
/* eslint-disable no-promise-executor-return */
/**
 * Engine represents the filtering engine with all the loaded rules.
 */
class Engine {
    /**
     * Request's cache size
     * Used as both source rules and others limit.
     * The value is based on benchmark runs.
     */
    static REQUEST_CACHE_SIZE = 500;
    /**
     * Basic filtering rules engine.
     */
    networkEngine;
    /**
     * Cosmetic rules engine.
     */
    cosmeticEngine;
    /**
     * Rules storage.
     */
    ruleStorage;
    /**
     * Request results cache.
     */
    resultCache;
    /**
     * Creates an instance of an Engine
     * Parses the filtering rules and creates a filtering engine of them.
     *
     * @param ruleStorage Storage.
     * @param skipStorageScan Create an instance without storage scanning.
     *
     * @throws
     */
    constructor(ruleStorage, skipStorageScan = false) {
        this.ruleStorage = ruleStorage;
        this.networkEngine = new NetworkEngine(ruleStorage, skipStorageScan);
        this.cosmeticEngine = new CosmeticEngine(ruleStorage, skipStorageScan);
        this.resultCache = new esm/* LRUCache */.q({ max: Engine.REQUEST_CACHE_SIZE });
    }
    /**
     * Loads rules to engine.
     */
    loadRules() {
        const scanner = this.ruleStorage.createRuleStorageScanner(ScannerType.NetworkRules | ScannerType.CosmeticRules);
        while (scanner.scan()) {
            this.addRule(scanner.getRule());
        }
    }
    /**
     * Async loads rules to engine.
     *
     * @param chunkSize Size of rules chunk to load at a time.
     */
    async loadRulesAsync(chunkSize) {
        const scanner = this.ruleStorage.createRuleStorageScanner(ScannerType.NetworkRules | ScannerType.CosmeticRules);
        let counter = 0;
        while (scanner.scan()) {
            counter += 1;
            if (counter >= chunkSize) {
                counter = 0;
                /**
                 * In some cases UI thread becomes blocked while adding rules to engine,
                 * that't why we create filter rules using chunks of the specified length
                 * Rules creation is rather slow operation so we should
                 * use setTimeout calls to give UI thread some time.
                 */
                await new Promise((resolve) => setTimeout(resolve, 1));
            }
            this.addRule(scanner.getRule());
        }
    }
    /**
     * Matches the specified request against the filtering engine and returns the matching result.
     *
     * @param request Request to check.
     * @param frameRule Source document rule or null.
     *
     * @returns Matching result.
     */
    matchRequest(request, frameRule = null) {
        let cacheKey = `${request.url}#${request.sourceHostname}#${request.requestType}`;
        if (request.method) {
            cacheKey += `#${request.method}`;
        }
        /**
         * Add frame url text to the key to avoid caching,
         * because allowlist rules are not stored in the engine. AG-12694.
         */
        if (frameRule) {
            cacheKey += `#${frameRule.getIndex()}`;
        }
        const res = this.resultCache.get(cacheKey);
        if (res) {
            return res;
        }
        const networkRules = this.networkEngine.matchAll(request);
        const result = new MatchingResult(networkRules, frameRule);
        this.resultCache.set(cacheKey, result);
        return result;
    }
    /**
     * Matches current frame and returns document-level allowlist rule if found.
     *
     * @param frameUrl The URL of the frame to match.
     *
     * @returns Document-level allowlist rule if found, otherwise null.
     */
    matchFrame(frameUrl) {
        const sourceRequest = new Request(frameUrl, '', request_type/* RequestType */.Y.Document);
        let sourceRules = this.networkEngine.matchAll(sourceRequest);
        sourceRules = MatchingResult.removeBadfilterRules(sourceRules);
        let result = null;
        sourceRules.forEach((r) => {
            if (r.isDocumentLevelAllowlistRule()) {
                if (!result || r.isHigherPriority(result)) {
                    result = r;
                }
            }
        });
        return result;
    }
    /**
     * Gets cosmetic result for the specified hostname and cosmetic options.
     *
     * @param request Host to check.
     * @param option Mask of enabled cosmetic types.
     *
     * @returns Cosmetic result.
     */
    getCosmeticResult(request, option) {
        return this.cosmeticEngine.match(request, option);
    }
    /**
     * Gets rules count.
     *
     * @returns The total number of rules.
     */
    getRulesCount() {
        return this.networkEngine.rulesCount + this.cosmeticEngine.rulesCount;
    }
    /**
     * Adds rules to engines.
     *
     * @param indexedRule Rule to add.
     */
    addRule(indexedRule) {
        if (indexedRule) {
            if (indexedRule.rule instanceof NetworkRule) {
                this.networkEngine.addRule(indexedRule.rule, indexedRule.index);
            }
            else if (indexedRule.rule instanceof CosmeticRule) {
                this.cosmeticEngine.addRule(indexedRule.rule, indexedRule.index);
            }
        }
    }
    /**
     * Retrieves a rule node by its filter list identifier and rule index.
     *
     * If there's no rule by that index or the rule structure is invalid, it will return null.
     *
     * @param filterId Filter list identifier.
     * @param ruleIndex Rule index.
     *
     * @returns Rule node or `null`.
     */
    retrieveRuleNode(filterId, ruleIndex) {
        return this.ruleStorage.retrieveRuleNode(filterId, ruleIndex);
    }
}

/**
 * Source map.
 *
 * @note Since serialized rule nodes are not store original rule text, we need this source map between the
 * serialized filter list and the raw filter list.
 */
const filterListSourceMapValidator = lib/* record */.g1(
/**
 * Rule start index in the converted list's byte buffer.
 */
lib/* string */.Yj(), 
/**
 * Rule start index in the raw converted list.
 */
lib/* number */.ai());

/**
 * Helper function to get the rule source text from the source string by its line start index.
 *
 * @param lineStartIndex Rule start index.
 * @param source Raw filter list source.
 *
 * @returns Rule string or null if the rule couldn't be found.
 */
const getRuleSourceText = (lineStartIndex, source) => {
    // note: checking for LF is enough, because we transform source before storing it, and it's always LF
    let [lineEndIndex] = findNextLineBreakIndex(source, lineStartIndex);
    // If the line end index is not found, we assume that the rule is the last line in the source.
    if (lineEndIndex === -1) {
        lineEndIndex = source.length;
    }
    // If the rule start index is equal to or greater than the rule end index, we return null,
    // and the rule is considered not found.
    if (lineStartIndex >= lineEndIndex) {
        return null;
    }
    const ruleSourceText = source.slice(lineStartIndex, lineEndIndex);
    // WARNING!
    // Potential memory leak mitigation for substring operation due to V8 optimizations:
    // When extracting a substring with rule.slice(), there's a concern in some JS environments
    // that the resulting substring might retain a hidden reference to the entire original 'rule' string.
    // This could prevent the garbage collector (GC) from freeing the memory allocated for filter rules.
    // This hidden reference occurs because the substring might not create a new string but rather
    // a view into the original, keeping it in memory longer than necessary.
    // And we receive a memory leak here because we store parsed tags from first N lines of the filter rules
    // which have references to the original large string with filter rules.
    // To ensure that the original large string can be garbage collected, and only the necessary
    // substring is retained, we explicitly force a copy of the substring via split and join,
    // thereby breaking the direct reference to the original string and allowing the GC to free the memory
    // for filter rules when they are no longer in use.
    return ruleSourceText.split('').join('');
};
/**
 * Helper function to get the rule source index (line start index in the source) from the source map by the rule index.
 *
 * @param ruleIdx Rule index.
 * @param sourceMap Source map.
 *
 * @returns Rule source index or RULE_INDEX_NONE (-1).
 *
 * @note Similar to `Array.prototype.indexOf`, we return -1 if the rule index is not found.
 */
const getRuleSourceIndex = (ruleIdx, sourceMap) => {
    return sourceMap[ruleIdx] ?? RULE_INDEX_NONE;
};

/**
 * BufferReader is a class responsible for reading content from serialized rules.
 */
class BufferReader {
    /**
     * Input byte buffer.
     */
    buffer;
    /**
     * Current position of the reader.
     */
    currentIndex = 0;
    /**
     * Constructor of a BufferReader.
     *
     * @param buffer Uint8Array that contains a UTF-8 encoded string.
     */
    constructor(buffer) {
        this.buffer = buffer;
        this.currentIndex = this.buffer.currentOffset;
    }
    /**
     * Reads the next line in the buffer.
     *
     * @returns Text or null on end.
     */
    readNext() {
        // If the next byte is 0, it means that there's nothing to read.
        if (this.buffer.peekUint8() === 0) {
            return null;
        }
        let ruleNode;
        rule_deserializer/* RuleDeserializer */.Y.deserialize(this.buffer, ruleNode = {});
        this.currentIndex = this.buffer.currentOffset;
        if (ruleNode.category) {
            return ruleNode;
        }
        return null;
    }
    /**
     * Returns the current position of this reader or -1 if there's nothing to
     * read.
     *
     * @returns - The current position or -1 if there's nothing to read.
     */
    getCurrentPos() {
        return this.currentIndex;
    }
    /** @inheritdoc */
    getDataLength() {
        return this.buffer.capacity;
    }
}

/**
 * List identifier max value.
 * We use "number" type for storage indexes, so we have some limits for list
 * identifiers.
 * We use line number for rule index, so if we save 11 ranks for rules, then we
 * have 6 ranks left for list ids. Check RuleStorageScanner class for more info.
 */
const LIST_ID_MAX_VALUE = 10 ** 6;

/**
 * Helper function to create an allowlist rule node for a given domain.
 *
 * @param domain Domain to create an allowlist rule for.
 *
 * @returns Allowlist rule node or null.
 */
const createAllowlistRuleNode = (domain) => {
    const domainToUse = domain.startsWith('www.') ? domain.substring(4) : domain;
    if (!domainToUse) {
        return null;
    }
    let pattern;
    // Special case: Wildcard TLD + N domain
    if (domainToUse.startsWith('*.')) {
        pattern = `${simple_regex_BBjA8AEZ.S.MASK_START_URL}${domainToUse.slice(2)}`;
    }
    else {
        // In other cases we use regexp to match domain and it`s 'www' subdomain strictly.
        let regexp = '';
        // transform allowlist domain special characters
        for (let i = 0; i < domainToUse.length; i += 1) {
            const char = domainToUse[i];
            // transform wildcard to regexp equivalent
            if (char === '*') {
                regexp += '.*';
                // escape domain separator
            }
            else if (char === '.') {
                regexp += String.raw `\.`;
            }
            else {
                regexp += char;
            }
        }
        pattern = String.raw `///(www\.)?${regexp}/`;
    }
    const node = {
        category: nodes/* RuleCategory */.$O.Network,
        type: nodes/* NetworkRuleType */.vY.NetworkRule,
        syntax: adblockers/* AdblockSyntax */.Y.Common,
        exception: true,
        pattern: {
            type: 'Value',
            value: pattern,
        },
        modifiers: {
            type: 'ModifierList',
            children: [
                {
                    type: 'Modifier',
                    name: {
                        type: 'Value',
                        value: 'document',
                    },
                },
                {
                    type: 'Modifier',
                    name: {
                        type: 'Value',
                        value: 'important',
                    },
                },
            ],
        },
    };
    return node;
};

/**
 * Rule builder class.
 */
class RuleFactory {
    /**
     * Creates rule of suitable class from text string
     * It returns null if the line is empty or if it is a comment.
     *
     * TODO: Pack `ignore*` parameters and `silent` into one object with flags.
     *
     * @param node Rule node.
     * @param filterListId List id.
     * @param ruleIndex Line start index in the source filter list; it will be used to find the original rule text
     * in the filtering log when a rule is applied. Default value is {@link RULE_INDEX_NONE} which means that
     * the rule does not have source index.
     * @param ignoreNetwork Do not create network rules.
     * @param ignoreCosmetic Do not create cosmetic rules.
     * @param ignoreHost Do not create host rules.
     * @param silent Log the error for `true`, otherwise throw an exception on
     * a rule creation.
     *
     * @returns IRule object or null.
     *
     * @throws Error when `silent` flag is passed as false on rule creation error.
     */
    static createRule(node, filterListId, ruleIndex = RULE_INDEX_NONE, ignoreNetwork = false, ignoreCosmetic = false, ignoreHost = true, silent = true) {
        try {
            switch (node.category) {
                case nodes/* RuleCategory */.$O.Invalid:
                case nodes/* RuleCategory */.$O.Empty:
                case nodes/* RuleCategory */.$O.Comment:
                    return null;
                case nodes/* RuleCategory */.$O.Cosmetic:
                    if (ignoreCosmetic) {
                        return null;
                    }
                    return new CosmeticRule(node, filterListId, ruleIndex);
                case nodes/* RuleCategory */.$O.Network:
                    if (node.type === nodes/* NetworkRuleType */.vY.HostRule) {
                        if (ignoreHost) {
                            return null;
                        }
                        return new HostRule(node, filterListId, ruleIndex);
                    }
                    if (ignoreNetwork) {
                        return null;
                    }
                    return new NetworkRule(node, filterListId, ruleIndex);
                default:
                    // should not happen in normal operation
                    return null;
            }
        }
        catch (e) {
            let msg = `"${getErrorMessage(e)}" in the rule: `;
            try {
                msg += `"${rule_generator/* RuleGenerator */.u.generate(node)}"`;
            }
            catch (generateError) {
                msg += `"${JSON.stringify(node)}" (generate error: ${getErrorMessage(generateError)})`;
            }
            if (silent) {
                logger.info(`Error: ${msg}`);
            }
            else {
                throw new Error(msg);
            }
        }
        return null;
    }
    /**
     * Creates allowlist rule for domain.
     *
     * @param domain Domain name.
     * @param filterListId List id.
     * @param ruleIndex Line start index in the source filter list.
     *
     * @returns Allowlist rule or null.
     */
    static createAllowlistRule(domain, filterListId, ruleIndex = RULE_INDEX_NONE) {
        const node = createAllowlistRuleNode(domain);
        if (!node) {
            return null;
        }
        return new NetworkRule(node, filterListId, ruleIndex);
    }
}

/**
 * Rule scanner provides the functionality for reading rules from a filter list.
 */
// TODO: Change string filter list to byte buffer.
class RuleScanner {
    /**
     * Filter list ID.
     */
    listId;
    /**
     * True if we should ignore cosmetic rules.
     */
    ignoreCosmetic;
    /**
     * True if we should ignore javascript cosmetic rules.
     */
    ignoreJS;
    /**
     * True if we should ignore unsafe rules, like $removeheader.
     */
    ignoreUnsafe;
    /**
     * True if we should ignore network rules.
     */
    ignoreNetwork;
    /**
     * True if we should ignore host filtering rules.
     */
    ignoreHost;
    /**
     * Underlying reader object.
     */
    reader;
    /**
     * Current rule.
     */
    currentRule = null;
    /**
     * Index of the beginning of the current rule (basically, a line number).
     */
    currentRuleIndex = 0;
    /**
     * Constructor of a RuleScanner object.
     *
     * @param reader Source of the filtering rules.
     * @param listId Filter list ID.
     * @param configuration Scanner configuration object.
     */
    constructor(reader, listId, configuration) {
        this.reader = reader;
        this.listId = listId;
        this.ignoreCosmetic = !!configuration.ignoreCosmetic
            || ((configuration.scannerType & ScannerType.CosmeticRules) !== ScannerType.CosmeticRules);
        this.ignoreNetwork = (configuration.scannerType & ScannerType.NetworkRules) !== ScannerType.NetworkRules;
        this.ignoreHost = (configuration.scannerType & ScannerType.HostRules) !== ScannerType.HostRules;
        this.ignoreJS = !!configuration.ignoreJS;
        this.ignoreUnsafe = !!configuration.ignoreUnsafe;
    }
    /**
     * Scan advances the RuleScanner to the next rule, which will then be
     * available through the getRule() method.
     *
     * @returns - False when the scan stops, either by reaching the end of the
     * input or an error. If there's a rule available, returns true.
     */
    scan() {
        let lineIndex = this.reader.getCurrentPos();
        let line = this.readNext();
        while (line) {
            if (!this.isIgnored(line)) {
                const rule = RuleFactory.createRule(line, this.listId, lineIndex, this.ignoreNetwork, this.ignoreCosmetic, this.ignoreHost);
                this.currentRule = rule;
                this.currentRuleIndex = lineIndex;
                return true;
            }
            lineIndex = this.reader.getCurrentPos();
            line = this.readNext();
        }
        return false;
    }
    /**
     * @returns - The most recent rule generated by a call to scan(), and the
     * index of this rule's text.
     */
    getRule() {
        if (this.currentRule) {
            return new IndexedRule(this.currentRule, this.currentRuleIndex);
        }
        return null;
    }
    /**
     * Get filter list id.
     *
     * @returns List id.
     */
    getListId() {
        return this.listId;
    }
    /**
     * Get the length of the data read by the scanner.
     *
     * @returns Data length.
     */
    getDataLength() {
        return this.reader.getDataLength();
    }
    /**
     * Reads the next line and returns it.
     *
     * @returns - Next line string or null.
     */
    readNext() {
        return this.reader.readNext();
    }
    /**
     * Checks if the rule should be ignored by this scanner.
     *
     * @param rule Rule to check.
     *
     * @returns - True if the rule should be ignored.
     */
    isIgnored(rule) {
        if (!this.ignoreCosmetic && !this.ignoreJS && !this.ignoreUnsafe) {
            return false;
        }
        if (rule.category === nodes/* RuleCategory */.$O.Cosmetic) {
            if (this.ignoreCosmetic) {
                return true;
            }
            // Ignore JS type rules.
            // TODO: in the future we may allow CSS rules and Scriptlets (except
            // for "trusted" scriptlets).
            if (this.ignoreJS
                && (rule.type === nodes/* CosmeticRuleType */.k9.JsInjectionRule
                    || rule.type === nodes/* CosmeticRuleType */.k9.ScriptletInjectionRule)) {
                return true;
            }
        }
        if (this.ignoreUnsafe) {
            if (rule.category === nodes/* RuleCategory */.$O.Network && rule.type === nodes/* NetworkRuleType */.vY.NetworkRule) {
                if (rule.modifiers?.children?.some((modifier) => NetworkRule.ADVANCED_OPTIONS.has(modifier.name.value))) {
                    return true;
                }
            }
        }
        return false;
    }
}

/**
 * BufferRuleList represents a string-based rule list. It keeps the original
 * rule list as a byte array with UTF-8 encoded characters. This approach
 * allows saving on the memory used by tsurlfilter compared to StringRuleList.
 */
class BufferRuleList {
    /**
     * Rule list ID.
     */
    id;
    /**
     * String with filtering rules (one per line) encoded as a
     * UTF-8 array.
     */
    rulesBuffer;
    /**
     * Whether to ignore cosmetic rules or not.
     */
    ignoreCosmetic;
    /**
     * Whether to ignore javascript cosmetic rules or not.
     */
    ignoreJS;
    /**
     * Whether to ignore unsafe (e.g. $removeheader) rules or not.
     */
    ignoreUnsafe;
    /**
     * Source map for the filter list.
     */
    sourceMap;
    /**
     * Text decoder that is used to read strings from the internal buffer of
     * UTF-8 encoded characters.
     */
    static decoder = new TextDecoder('utf-8');
    /**
     * Constructor of BufferRuleList.
     *
     * @param listId List identifier.
     * @param inputRules String with filtering rules (one per line).
     * @param ignoreCosmetic (Optional) True to ignore cosmetic rules.
     * @param ignoreJS (Optional) True to ignore JS rules.
     * @param ignoreUnsafe (Optional) True to ignore unsafe rules.
     * @param sourceMap (Optional) Source map for the filter list.
     */
    constructor(listId, inputRules, ignoreCosmetic, ignoreJS, ignoreUnsafe, sourceMap) {
        if (listId >= LIST_ID_MAX_VALUE) {
            throw new Error(`Invalid list identifier, it must be less than ${LIST_ID_MAX_VALUE}`);
        }
        this.id = listId;
        this.rulesBuffer = new input_byte_buffer/* InputByteBuffer */.N(inputRules);
        this.ignoreCosmetic = !!ignoreCosmetic;
        this.ignoreJS = !!ignoreJS;
        this.ignoreUnsafe = !!ignoreUnsafe;
        this.sourceMap = sourceMap ?? {};
    }
    /**
     * Close does nothing as here's nothing to close in the BufferRuleList.
     */
    // eslint-disable-next-line class-methods-use-this
    close() {
        // Empty
    }
    /**
     * @returns The rule list identifier.
     */
    getId() {
        return this.id;
    }
    /**
     * Creates a new rules scanner that reads the list contents.
     *
     * @param scannerType The type of scanner to create.
     *
     * @returns Scanner object.
     */
    newScanner(scannerType) {
        const reader = new BufferReader(this.rulesBuffer.createCopyWithOffset(0));
        return new RuleScanner(reader, this.id, {
            scannerType,
            ignoreCosmetic: this.ignoreCosmetic,
            ignoreJS: this.ignoreJS,
            ignoreUnsafe: this.ignoreUnsafe,
        });
    }
    /**
     * Retrieves a rule node by its index.
     *
     * If there's no rule by that index or the rule is invalid, it will return
     * null.
     *
     * @param ruleIdx Rule index.
     *
     * @returns Rule node or `null`.
     */
    retrieveRuleNode(ruleIdx) {
        try {
            const ruleNode = {};
            const copy = this.rulesBuffer.createCopyWithOffset(ruleIdx);
            rule_deserializer/* RuleDeserializer */.Y.deserialize(copy, ruleNode);
            return ruleNode;
        }
        catch (e) {
            // fall through
        }
        return null;
    }
    /**
     * @inheritdoc
     */
    retrieveRuleSourceIndex(ruleIdx) {
        return getRuleSourceIndex(ruleIdx, this.sourceMap);
    }
}

// TODO: Consider moving this file to the `@adguard/agtree` package
/**
 * AGTree parser options for the preprocessor.
 */
const PREPROCESSOR_AGTREE_OPTIONS = {
    ...options/* defaultParserOptions */.n,
    includeRaws: false,
    isLocIncluded: false,
    ignoreComments: false,
    // TODO: Add support for host rules + in the converter
    parseHostRules: false,
};
/**
 * Utility class for pre-processing filter lists before they are used by the AdGuard filtering engine.
 *
 * Concept:
 *
 * Right after a filter list is downloaded, we iterate over its rules and do the following:
 *   1. Parse rule text to AST (Abstract Syntax Tree) (if possible).
 *   2. Convert rule node to AdGuard format (if possible / needed).
 *
 * During this conversion, we also produce two maps:
 *    - Source map:     For performance reasons, we don't store the original rule text in the AST.
 *                      We store AST in a binary serialized format.
 *                      This source map is used to map the rule start index from the serialized filter list to
 *                      its start index in the raw filter list (converted filter list). This is needed to show
 *                      the exact applied rule in the filtering log. This rule text maybe a converted rule,
 *                      but in this case, we can get its original rule text from the conversion map
 *                      (for filtering engine, only the converted filter list is needed).
 *    - Conversion map: Maps the converted rule text to its original rule text. This is needed to show the
 *                      original rule text in the filtering log if a converted rule is applied.
 */
class FilterListPreprocessor {
    /**
     * Processes the raw filter list and converts it to the AdGuard format.
     *
     * @param filterList Raw filter list to convert.
     * @param parseHosts If true, the preprocessor will parse host rules.
     *
     * @returns A {@link PreprocessedFilterList} object which contains the converted filter list,
     * the mapping between the original and converted rules, and the source map.
     */
    static preprocess(filterList, parseHosts = false) {
        const filterListLength = filterList.length;
        const sourceMap = {};
        const conversionMap = {};
        const rawFilterList = [];
        const convertedFilterList = new OutputByteBuffer();
        const firstLineBreakData = (0,simple_regex_BBjA8AEZ.d)(filterList);
        let inputOffset = 0;
        let outputOffset = 0;
        let previousLineBreak = firstLineBreakData[1] > 0
            ? filterList.slice(firstLineBreakData[0], firstLineBreakData[0] + firstLineBreakData[1])
            : simple_regex_BBjA8AEZ.L;
        while (inputOffset < filterListLength) {
            const [lineBreakIndex, lineBreakLength] = (0,simple_regex_BBjA8AEZ.d)(filterList, inputOffset);
            const ruleText = filterList.slice(inputOffset, lineBreakIndex);
            const lineBreak = filterList.slice(lineBreakIndex, lineBreakIndex + lineBreakLength);
            // parse and convert can throw an error, so we need to catch them
            try {
                const ruleNode = rule_parser/* RuleParser */.G.parse(ruleText, {
                    ...PREPROCESSOR_AGTREE_OPTIONS,
                    parseHostRules: parseHosts,
                });
                if (ruleNode.category === nodes/* RuleCategory */.$O.Empty || ruleNode.category === nodes/* RuleCategory */.$O.Comment) {
                    // Add empty lines and comments as is to the converted filter list,
                    // but not to the output byte buffer / source map.
                    rawFilterList.push(ruleText);
                    rawFilterList.push(lineBreak);
                    outputOffset += ruleText.length + lineBreakLength;
                    inputOffset = lineBreakIndex + lineBreakLength;
                    previousLineBreak = lineBreak;
                    continue;
                }
                const conversionResult = rule/* RuleConverter */.b.convertToAdg(ruleNode);
                if (conversionResult.isConverted) {
                    // Maybe the rule is the last line without a line break in the input filter list
                    // but we need to convert it to multiple rules.
                    // In this case, we should use the last used line break before the conversion.
                    const convertedRulesLineBreak = lineBreakLength > 0 ? lineBreak : previousLineBreak;
                    const numberOfConvertedRules = conversionResult.result.length;
                    // Note: 1 rule can be converted to multiple rules
                    for (let i = 0; i < conversionResult.result.length; i += 1) {
                        const convertedRuleNode = conversionResult.result[i];
                        // In this case we should generate the rule text from the AST, because its converted,
                        // i.e. it's not the same as the original rule text.
                        const convertedRuleText = rule_generator/* RuleGenerator */.u.generate(convertedRuleNode);
                        rawFilterList.push(convertedRuleText);
                        rawFilterList.push(i === numberOfConvertedRules - 1 ? lineBreak : convertedRulesLineBreak);
                        const bufferOffset = convertedFilterList.currentOffset;
                        // Store the converted rules and the mapping between the original and converted rules
                        conversionMap[outputOffset] = ruleText;
                        sourceMap[bufferOffset] = outputOffset;
                        RuleSerializer.serialize(convertedRuleNode, convertedFilterList);
                        outputOffset += convertedRuleText.length + (i === numberOfConvertedRules - 1
                            ? lineBreakLength
                            : convertedRulesLineBreak.length);
                    }
                }
                else {
                    // If the rule is not converted, we should store the original rule text in the raw filter list.
                    rawFilterList.push(ruleText);
                    rawFilterList.push(lineBreak);
                    const bufferOffset = convertedFilterList.currentOffset;
                    // Store the converted rules and the mapping between the original and converted rules
                    sourceMap[bufferOffset] = outputOffset;
                    RuleSerializer.serialize(ruleNode, convertedFilterList);
                    outputOffset += ruleText.length + lineBreakLength;
                }
            }
            catch (error) {
                // TODO: Integrate Logger library to be able to set log level AG-40234
                // Log issues just as an info AG-37460
                logger.info(`Failed to process rule: '${ruleText}' due to ${getErrorMessage(error)}`);
                // Add invalid rules as is to the converted filter list,
                // but not to the output byte buffer / source map.
                rawFilterList.push(ruleText);
                rawFilterList.push(lineBreak);
                outputOffset += ruleText.length + lineBreakLength;
            }
            // Move to the next line
            inputOffset = lineBreakIndex + lineBreakLength;
            previousLineBreak = lineBreak;
        }
        return {
            filterList: convertedFilterList.getChunks(),
            rawFilterList: rawFilterList.join(simple_regex_BBjA8AEZ.E),
            conversionMap,
            sourceMap,
        };
    }
    /**
     * A "lightweight" version of the preprocess method. This method is necessary because, in the rulesets,
     * we store the converted raw list and the conversion map, but not the entire preprocessed filter list.
     * This method helps us regenerate the serialized filter list and the source map fields with less overhead
     * compared to the full preprocess method.
     *
     * @param preprocessedFilterList Preprocessed filter list,
     * which contains the raw filter list and the conversion map.
     * @param parseHosts If true, the preprocessor will parse host rules.
     *
     * @returns Preprocessed filter list with the "filterList" and "sourceMap" fields.
     */
    static preprocessLightweight(preprocessedFilterList, parseHosts = false) {
        const { rawFilterList, conversionMap } = preprocessedFilterList;
        const { length } = rawFilterList;
        const sourceMap = {};
        const filterList = new OutputByteBuffer();
        let inputOffset = 0;
        let outputOffset = 0;
        while (inputOffset < length) {
            const [lineBreakIndex, lineBreakLength] = (0,simple_regex_BBjA8AEZ.d)(rawFilterList, inputOffset);
            const ruleText = rawFilterList.slice(inputOffset, lineBreakIndex);
            try {
                const ruleNode = rule_parser/* RuleParser */.G.parse(ruleText, {
                    ...PREPROCESSOR_AGTREE_OPTIONS,
                    parseHostRules: parseHosts,
                });
                // Ignore empty lines and comments from the binary filter list
                if (ruleNode.category !== nodes/* RuleCategory */.$O.Empty && ruleNode.category !== nodes/* RuleCategory */.$O.Comment) {
                    const bufferOffset = filterList.currentOffset;
                    sourceMap[bufferOffset] = outputOffset;
                    RuleSerializer.serialize(ruleNode, filterList);
                }
            }
            catch (error) {
                // TODO: Integrate Logger library to be able to set log level AG-40234
                // Log issues just as an info AG-37460
                logger.info(`Failed to process rule: '${ruleText}' due to ${getErrorMessage(error)}`);
            }
            outputOffset += ruleText.length + lineBreakLength;
            // Move to the next line
            inputOffset = lineBreakIndex + lineBreakLength;
        }
        return {
            // TODO: consider returning an empty array if the filter list is empty
            filterList: filterList.getChunks(),
            rawFilterList,
            conversionMap,
            sourceMap,
        };
    }
    /**
     * Gets the original filter list text from the preprocessed filter list.
     *
     * @param preprocessedFilterList Preprocessed filter list.
     *
     * @returns Original filter list text.
     */
    static getOriginalFilterListText(preprocessedFilterList) {
        const { rawFilterList, conversionMap } = preprocessedFilterList;
        const { length } = rawFilterList;
        const result = [];
        let offset = 0;
        let prevLineStart = -1;
        let lineBreakIndex = -1;
        let lineBreakLength = 0;
        while (offset < length) {
            [lineBreakIndex, lineBreakLength] = (0,simple_regex_BBjA8AEZ.d)(rawFilterList, offset);
            const lineBreak = rawFilterList.slice(lineBreakIndex, lineBreakIndex + lineBreakLength);
            const originalRule = conversionMap[offset];
            // One rule can be converted to multiple rules - in this case we should put the original rule text only once
            // If there is such a case, these rules follow one after the other
            if (!(originalRule && originalRule === conversionMap[prevLineStart])) {
                result.push(originalRule ?? rawFilterList.slice(offset, lineBreakIndex));
                result.push(lineBreak);
            }
            prevLineStart = offset;
            offset = lineBreakIndex + lineBreakLength;
        }
        // Add an empty rule if final new line is present
        if (lineBreakLength > 0) {
            result.push(simple_regex_BBjA8AEZ.E);
        }
        return result.join(simple_regex_BBjA8AEZ.E);
    }
    /**
     * Gets the original rules from the preprocessed filter list.
     *
     * @param preprocessedFilterList Preprocessed filter list.
     *
     * @returns Array of original rules.
     */
    static getOriginalRules(preprocessedFilterList) {
        const { rawFilterList, conversionMap } = preprocessedFilterList;
        const { length } = rawFilterList;
        const result = [];
        let offset = 0;
        let prevLineStart = -1;
        let lineBreakIndex = -1;
        let lineBreakLength = 0;
        while (offset < length) {
            [lineBreakIndex, lineBreakLength] = (0,simple_regex_BBjA8AEZ.d)(rawFilterList, offset);
            const originalRule = conversionMap[offset];
            // One rule can be converted to multiple rules - in this case we should put the original rule text only once
            // If there is such a case, these rules follow one after the other
            if (!(originalRule && originalRule === conversionMap[prevLineStart])) {
                result.push(originalRule ?? rawFilterList.slice(offset, lineBreakIndex));
            }
            prevLineStart = offset;
            offset = lineBreakIndex + lineBreakLength;
        }
        // Add an empty rule if final new line is present
        if (lineBreakLength > 0) {
            result.push(simple_regex_BBjA8AEZ.E);
        }
        return result;
    }
    /**
     * Creates an empty preprocessed filter list.
     *
     * @returns An empty preprocessed filter list.
     *
     * @note It gives the same result as the {@link preprocess} method with an empty filter list:
     * ```ts
     * FilterListPreprocessor.preprocess('');
     * ```
     */
    static createEmptyPreprocessedFilterList() {
        // Note: need to use OutputByteBuffer, because it writes the schema version to the buffer
        const buffer = new OutputByteBuffer();
        return {
            // TODO: consider returning an empty array
            filterList: buffer.getChunks(),
            rawFilterList: '',
            conversionMap: {},
            sourceMap: {},
        };
    }
}

/**
 * Validator for filter list conversion map.
 *
 * @note This is only needed to show the original rule text in the filtering log if a converted rule is applied.
 */
const filterListConversionMapValidator = lib/* record */.g1(
/**
 * Converted rule line start offset.
 */
lib/* string */.Yj(), 
/**
 * Original rule text.
 */
lib/* string */.Yj());
/**
 * Validator for filter list chunks.
 */
const filterListChunksValidator = lib/* array */.YO(lib/* custom */.Ie((val) => val instanceof Uint8Array));
/**
 * Validator for preprocessed filter list.
 */
const preprocessedFilterListValidator = lib/* object */.Ik({
    /**
     * Raw processed filter list.
     */
    rawFilterList: lib/* string */.Yj(),
    /**
     * Processed filter list, but in a serialized form.
     */
    filterList: filterListChunksValidator,
    /**
     * Map of converted rules to original rules.
     */
    conversionMap: filterListConversionMapValidator,
    /**
     * Source map.
     */
    sourceMap: filterListSourceMapValidator,
});

/**
 * RuleStorageScanner scans multiple RuleScanner instances.
 * The storage index is built from the rule position in the list
 * + cumulative offset value of filter lists.
 */
class RuleStorageScanner {
    /**
     * Current scanner.
     */
    currentScanner = null;
    /**
     * Index of the current scanner.
     */
    currentScannerIdx = -1;
    /**
     * Rule position in the concatenated filter lists data.
     */
    storageOffset = 0;
    /**
     * Constructor.
     *
     * @param scanners List of scanners.
     */
    constructor(scanners) {
        this.scanners = scanners;
        this.listOffsetEntriesCursor = 0;
        this.listOffsetKeys = new Int32Array(scanners.length);
        this.listOffsetValues = new Uint32Array(scanners.length);
    }
    /**
     * Scan advances the RuleStorageScanner to the next rule, which will then be available
     * through the Rule method. It returns false when the scan stops, either by
     * reaching the end of the input or an error.
     *
     * @returns True if there is some result.
     */
    scan() {
        const scannersLength = this.scanners.length;
        if (scannersLength === 0) {
            return false;
        }
        if (!this.currentScanner) {
            this.currentScannerIdx = 0;
            this.currentScanner = this.scanners[this.currentScannerIdx];
            this.setListOffset(this.currentScanner.getListId(), this.storageOffset);
        }
        while (this.currentScannerIdx < scannersLength) {
            if (this.currentScanner.scan()) {
                return true;
            }
            // Accumulate the length of the current scanner before moving to the next one
            this.storageOffset += this.currentScanner.getDataLength();
            // Move to the next scanner
            this.currentScannerIdx += 1;
            // Check if there's a next scanner
            if (this.currentScannerIdx < this.scanners.length) {
                this.currentScanner = this.scanners[this.currentScannerIdx];
                this.setListOffset(this.currentScanner.getListId(), this.storageOffset);
            }
        }
        return false;
    }
    /**
     * Rule returns the most recent rule generated by a call to Scan, and the index of this rule.
     * See ruleListIdxToStorageIdx for more information on what this index is.
     *
     * @returns The most recent rule and its index, or null if no rule is available.
     */
    getRule() {
        if (!this.currentScanner) {
            return null;
        }
        const rule = this.currentScanner.getRule();
        if (!rule) {
            return null;
        }
        const offset = this.getListOffset(rule.rule.getFilterListId());
        const index = offset + rule.index;
        return new IndexedStorageRule(rule.rule, index);
    }
    /**
     * Match storage index with range of filter list offset
     * and return list id and local filter list position.
     *
     * @param storageIdx Rule position in concatenated filter lists data.
     *
     * @returns Tuple of list id and local filter list position.
     */
    getIds(storageIdx) {
        const listOffsetEntriesLength = this.listOffsetKeys.length;
        if (listOffsetEntriesLength === 1) {
            return [this.listOffsetKeys[0], storageIdx - this.listOffsetValues[0]];
        }
        for (let i = 0; i < listOffsetEntriesLength - 1; i += 1) {
            const offset = this.listOffsetValues[i];
            const nextOffset = this.listOffsetValues[i + 1];
            if (storageIdx >= offset && storageIdx < nextOffset) {
                return [this.listOffsetKeys[i], storageIdx - offset];
            }
        }
        return [
            this.listOffsetKeys[listOffsetEntriesLength - 1],
            storageIdx - this.listOffsetValues[listOffsetEntriesLength - 1],
        ];
    }
    /**
     * Push listID and offset to the {@link listOffsetEntries}.
     *
     * @param listId Filter list id.
     * @param offset Filter list offset position in the storage.
     */
    setListOffset(listId, offset) {
        this.listOffsetKeys[this.listOffsetEntriesCursor] = listId;
        this.listOffsetValues[this.listOffsetEntriesCursor] = offset;
        this.listOffsetEntriesCursor += 1;
    }
    /**
     * Gets filter list offset by list id.
     *
     * @param listId Filter list id.
     *
     * @returns Offset position in the storage.
     *
     * @throws Error if listId is not found.
     */
    getListOffset(listId) {
        const idx = this.listOffsetKeys.indexOf(listId);
        if (idx !== -1) {
            return this.listOffsetValues[idx];
        }
        throw new Error(`listId ${listId} not found in the storage`);
    }
}

/**
 * RuleStorage is an abstraction that combines several rule lists
 * It can be scanned using RuleStorageScanner, and also it allows
 * retrieving rules by its index.
 *
 * The idea is to keep rules in a serialized format (even original format in the case of FileRuleList)
 * and create them in a lazy manner only when we really need them. When the filtering engine is
 * being initialized, we need to scan the rule lists once in order to fill up the lookup tables.
 * We use rule indexes as a unique rule identifier instead of the rule itself.
 * The rule is created (see RetrieveRule) only when there's a chance that it's needed.
 *
 * Rule index is an int64 value that actually consists of two int32 values:
 * One is the rule list identifier, and the second is the index of the rule inside of that list.
 */
class RuleStorage {
    /**
     * Lists is an array of rules lists which can be accessed using this RuleStorage.
     */
    lists;
    /**
     * Map with rule lists. Map key is the list ID.
     */
    listsMap;
    /**
     * Cache with the rules which are stored inside this cache instance..
     */
    cache;
    /**
     * Constructor.
     *
     * @param lists Rule lists array.
     *
     * @throws Error on duplicate lists.
     */
    constructor(lists) {
        this.lists = lists;
        this.listsMap = new Map();
        this.cache = new Map();
        this.lists.forEach((list) => {
            const filterListId = list.getId();
            if (this.listsMap.get(filterListId)) {
                throw new Error(`Duplicate list ID: ${filterListId}`);
            }
            this.listsMap.set(filterListId, list);
        });
    }
    /**
     * Retrieves a rule node by its filter list identifier and rule index.
     *
     * If there's no rule by that index or the rule structure is invalid, it will return null.
     *
     * @param filterId Filter list identifier.
     * @param ruleIndex Rule index.
     *
     * @returns Rule node or `null`.
     */
    retrieveRuleNode(filterId, ruleIndex) {
        if (!this.listsMap.has(filterId)) {
            return null;
        }
        return this.listsMap.get(filterId).retrieveRuleNode(ruleIndex);
    }
    /**
     * Creates a new instance of RuleStorageScanner.
     * It can be used to read and parse all the storage contents.
     *
     * @param scannerType The type of scanner to create.
     *
     * @returns Scanner instance.
     */
    createRuleStorageScanner(scannerType) {
        const scanners = this.lists.map((list) => list.newScanner(scannerType));
        this.scanner = new RuleStorageScanner(scanners);
        return this.scanner;
    }
    /**
     * Looks for the filtering rule in this storage.
     *
     * @param storageIdx The lookup index that you can get from the rule storage scanner.
     * @param ignoreHost Rules could be retrieved as host rules.
     *
     * @returns The rule or null if not found or an error occurs.
     */
    retrieveRule(storageIdx, ignoreHost = true) {
        const rule = this.cache.get(storageIdx);
        if (rule) {
            return rule;
        }
        const [listId, ruleId] = this.scanner.getIds(storageIdx);
        const list = this.listsMap.get(listId);
        if (!list) {
            logger.warn(`Failed to retrieve list ${listId}, should not happen in normal operation`);
            return null;
        }
        const ruleNode = list.retrieveRuleNode(ruleId);
        if (!ruleNode) {
            logger.warn(`Failed to retrieve rule ${ruleId}, should not happen in normal operation`);
            return null;
        }
        const result = RuleFactory.createRule(ruleNode, listId, ruleId, false, false, ignoreHost);
        if (result) {
            this.cache.set(storageIdx, result);
        }
        return result;
    }
    /**
     * Retrieves a network rule from the storage.
     *
     * @param storageIdx Storage index of the rule.
     *
     * @returns The rule or nil in any other case (not found or error).
     */
    retrieveNetworkRule(storageIdx) {
        const rule = this.retrieveRule(storageIdx);
        if (!rule) {
            return null;
        }
        if (rule instanceof NetworkRule) {
            return rule;
        }
        return null;
    }
    /**
     * Retrieves a host rule from the storage.
     *
     * @param storageIdx Storage index of the rule.
     *
     * @returns The rule or nil in any other case (not found or error).
     */
    retrieveHostRule(storageIdx) {
        const rule = this.retrieveRule(storageIdx, false);
        if (!rule) {
            return null;
        }
        if (rule instanceof HostRule) {
            return rule;
        }
        return null;
    }
    /**
     * Returns the size of the cache.
     *
     * @returns The size of the cache.
     */
    getCacheSize() {
        return this.cache.size;
    }
}

const FILTER_PREFIX = 'filter_';
/**
 * Extracts the filter ID from a given filter name.
 *
 * @param filterName The filter name in the format `filter_{filterId}.txt`.
 *
 * @returns The extracted filter ID, or null if the filter name does not match the expected format.
 */
const getIdFromFilterName = (filterName) => {
    const match = filterName.match(new RegExp(`${FILTER_PREFIX}(\\d+)\\.txt`));
    if (!match) {
        return null;
    }
    return parseInt(match[1], 10);
};

/**
 * Fetches a resource from the given URL and returns its content as text.
 *
 * @param url The URL of the resource to fetch.
 *
 * @returns A promise that resolves to the fetched content as a string.
 *
 * @throws If the request fails.
 */
const fetchExtensionResourceText = async (url) => {
    return fetch(url).then((response) => response.text());
};

/**
 * Creates a list of allowlist rules for a given list ID and domains.
 *
 * @param listId List ID.
 * @param domains List of domains to create allowlist rules for.
 *
 * @returns BufferRuleList instance.
 */
const createAllowlistRuleList = (listId, domains) => {
    const buffer = new OutputByteBuffer();
    domains.forEach((domain) => {
        const rule = createAllowlistRuleNode(domain);
        if (rule) {
            RuleSerializer.serialize(rule, buffer);
        }
    });
    return new BufferRuleList(listId, buffer.getChunks());
};

/**
 * Module with miscellaneous syntax utils exposed in API.
 */
class RuleSyntaxUtils {
    static DUMMY_FILTER_ID = (/* unused pure expression or super */ null && (0));
    /**
     * Checks if rule can be matched by domain.
     *
     * @param node Rule node.
     * @param domain Domain to check.
     *
     * @returns True if the rule can be matched by the domain, false otherwise.
     */
    static isRuleForDomain(node, domain) {
        const rule = RuleFactory.createRule(node, this.DUMMY_FILTER_ID);
        if (!rule) {
            return false;
        }
        const permittedDomains = rule.getPermittedDomains();
        return !!permittedDomains
            && DomainModifier.isDomainOrSubdomainOfAny(domain, permittedDomains);
    }
    /**
     * Checks if rule can be matched by URL.
     *
     * @param node Rule node.
     * @param url URL to check.
     *
     * @returns True if the rule can be matched by the URL, false otherwise.
     */
    static isRuleForUrl(node, url) {
        const domain = getHostname(url);
        if (!domain) {
            return false;
        }
        return this.isRuleForDomain(node, domain);
    }
}




/***/ }),

/***/ 99626:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   $4: () => (/* binding */ MASK_ALLOWLIST),
/* harmony export */   IA: () => (/* binding */ NOT_MARK),
/* harmony export */   RM: () => (/* binding */ NETWORK_RULE_OPTIONS),
/* harmony export */   rE: () => (/* binding */ OPTIONS_DELIMITER)
/* harmony export */ });
/* unused harmony export ESCAPE_CHARACTER */
const NETWORK_RULE_OPTIONS = {
    THIRD_PARTY: 'third-party',
    FIRST_PARTY: 'first-party',
    MATCH_CASE: 'match-case',
    IMPORTANT: 'important',
    DOMAIN: 'domain',
    DENYALLOW: 'denyallow',
    ELEMHIDE: 'elemhide',
    GENERICHIDE: 'generichide',
    SPECIFICHIDE: 'specifichide',
    GENERICBLOCK: 'genericblock',
    JSINJECT: 'jsinject',
    URLBLOCK: 'urlblock',
    CONTENT: 'content',
    DOCUMENT: 'document',
    DOC: 'doc',
    STEALTH: 'stealth',
    POPUP: 'popup',
    EMPTY: 'empty',
    MP4: 'mp4',
    SCRIPT: 'script',
    STYLESHEET: 'stylesheet',
    SUBDOCUMENT: 'subdocument',
    OBJECT: 'object',
    IMAGE: 'image',
    XMLHTTPREQUEST: 'xmlhttprequest',
    MEDIA: 'media',
    FONT: 'font',
    WEBSOCKET: 'websocket',
    OTHER: 'other',
    PING: 'ping',
    BADFILTER: 'badfilter',
    CSP: 'csp',
    REPLACE: 'replace',
    COOKIE: 'cookie',
    REDIRECT: 'redirect',
    REDIRECTRULE: 'redirect-rule',
    REMOVEPARAM: 'removeparam',
    REMOVEHEADER: 'removeheader',
    JSONPRUNE: 'jsonprune',
    HLS: 'hls',
    REFERRERPOLICY: 'referrerpolicy',
    APP: 'app',
    NETWORK: 'network',
    EXTENSION: 'extension',
    NOOP: '_',
    CLIENT: 'client',
    DNSREWRITE: 'dnsrewrite',
    DNSTYPE: 'dnstype',
    CTAG: 'ctag',
    HEADER: 'header',
    METHOD: 'method',
    TO: 'to',
    PERMISSIONS: 'permissions',
    ALL: 'all',
};
const OPTIONS_DELIMITER = '$';
const MASK_ALLOWLIST = '@@';
const NOT_MARK = '~';
const ESCAPE_CHARACTER = '\\';




/***/ }),

/***/ 30070:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Y: () => (/* binding */ RequestType)
/* harmony export */ });
/**
 * RequestType is the request types enumeration.
 * Important: the enumeration is marked as const to avoid side effects when
 * importing it into an extension.
 */
const RequestType = {
    /**
     * No value is set. Syntax sugar to simplify code.
     */
    NotSet: 0,
    /**
     * Main frame.
     */
    Document: 1,
    /**
     * (iframe) $subdocument.
     */
    SubDocument: 2, // 1 << 1
    /**
     * (javascript, etc) $script.
     */
    Script: 4, // 1 << 2
    /**
     * (css) $stylesheet.
     */
    Stylesheet: 8, // 1 << 3
    /**
     * (flash, etc) $object.
     */
    Object: 16, // 1 << 4
    /**
     * (any image) $image.
     */
    Image: 32, // 1 << 5
    /**
     * (ajax/fetch) $xmlhttprequest.
     */
    XmlHttpRequest: 64, // 1 << 6
    /**
     * (video/music) $media.
     */
    Media: 128, // 1 << 7
    /**
     * (any custom font) $font.
     */
    Font: 256, // 1 << 8
    /**
     * (a websocket connection) $websocket.
     */
    WebSocket: 512, // 1 << 9
    /**
     * (navigator.sendBeacon()) $ping.
     */
    Ping: 1024, // 1 << 10
    /**
     * Csp_report.
     */
    CspReport: 2048, // 1 << 11
    /**
     * Any other request type.
     */
    Other: 4096, // 1 << 12
};




/***/ }),

/***/ 87070:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   E: () => (/* binding */ EMPTY_STRING),
/* harmony export */   L: () => (/* binding */ LF),
/* harmony export */   S: () => (/* binding */ SimpleRegex),
/* harmony export */   W: () => (/* binding */ WILDCARD),
/* harmony export */   a: () => (/* binding */ SEPARATOR),
/* harmony export */   b: () => (/* binding */ stringArraysEquals),
/* harmony export */   c: () => (/* binding */ stringArraysHaveIntersection),
/* harmony export */   d: () => (/* binding */ findNextLineBreakIndex),
/* harmony export */   f: () => (/* binding */ fastHash),
/* harmony export */   h: () => (/* binding */ hasSpaces),
/* harmony export */   i: () => (/* binding */ isString),
/* harmony export */   j: () => (/* binding */ indexOfAny),
/* harmony export */   r: () => (/* binding */ replaceAll),
/* harmony export */   s: () => (/* binding */ splitByDelimiterWithEscapeCharacter),
/* harmony export */   u: () => (/* binding */ unescapeChar)
/* harmony export */ });
/* unused harmony exports e, g, k, l, m, n */
var ErrorStatusCodes;
(function (ErrorStatusCodes) {
    ErrorStatusCodes[ErrorStatusCodes["ComplexRegex"] = 1001] = "ComplexRegex";
    ErrorStatusCodes[ErrorStatusCodes["RuleLimit"] = 1002] = "RuleLimit";
    ErrorStatusCodes[ErrorStatusCodes["RegexpRuleLimit"] = 1003] = "RegexpRuleLimit";
    ErrorStatusCodes[ErrorStatusCodes["RemoveparamRegexpIsNotSupported"] = 1004] = "RemoveparamRegexpIsNotSupported";
    ErrorStatusCodes[ErrorStatusCodes["RemoveparamInversionIsNotSupported"] = 1005] = "RemoveparamInversionIsNotSupported";
})(ErrorStatusCodes || (ErrorStatusCodes = {}));
const EMPTY_STRING = '';
const SEPARATOR = '|';
const SPACE = ' ';
const WILDCARD = '*';
const LF = '\n';
const CR = '\r';
const FF = '\f';

/**
 * Splits the string by the delimiter, ignoring escaped delimiters
 * and without tokenizing.
 * Works for plain strings that don't include string representation of
 * complex entities, e.g $replace modifier values.
 *
 * @param string String to split.
 * @param delimiter Delimiter.
 * @param escapeCharacter Escape character.
 * @param preserveEmptyTokens If true, preserve empty parts.
 * @param shouldUnescape If true, unescape characters.
 *
 * @returns Array of string parts.
 */
function splitByDelimiterWithEscapeCharacter(string, delimiter, escapeCharacter, preserveEmptyTokens, shouldUnescape = true) {
    if (!string) {
        return [];
    }
    if (string.startsWith(delimiter)) {
        // eslint-disable-next-line no-param-reassign
        string = string.substring(1);
    }
    let words = [];
    if (!string.includes(escapeCharacter)) {
        words = string.split(delimiter);
        if (!preserveEmptyTokens) {
            words = words.filter((word) => !!word);
        }
        return words;
    }
    let chars = [];
    const makeWord = () => {
        const word = chars.join('');
        words.push(word);
        chars = [];
    };
    for (let i = 0; i < string.length; i += 1) {
        const char = string.charAt(i);
        const isLastChar = i === (string.length - 1);
        if (char === delimiter) {
            const isEscapedChar = i > 0 && string[i - 1] === escapeCharacter;
            if (isEscapedChar) {
                if (shouldUnescape) {
                    chars.splice(chars.length - 1, 1);
                }
                chars.push(char);
            }
            else {
                makeWord();
            }
            if (isLastChar) {
                makeWord();
            }
        }
        else if (isLastChar) {
            chars.push(char);
            makeWord();
        }
        else {
            chars.push(char);
        }
    }
    if (!preserveEmptyTokens) {
        words = words.filter((word) => !!word);
    }
    return words;
}
/**
 * Checks if the specified string starts with a substr at the specified index.
 *
 * @param str String to check.
 * @param startIndex Index to start checking from.
 * @param substr Substring to check.
 *
 * @returns Boolean true if it does start.
 */
function startsAtIndexWith(str, startIndex, substr) {
    if (str.length - startIndex < substr.length) {
        return false;
    }
    for (let i = 0; i < substr.length; i += 1) {
        if (str.charAt(startIndex + i) !== substr.charAt(i)) {
            return false;
        }
    }
    return true;
}
/**
 * Checks if `str` has unquoted `substr`.
 *
 * @param str String to check.
 * @param substr Substring to check.
 *
 * @returns True if str has unquoted substr.
 */
function hasUnquotedSubstring(str, substr) {
    const quotes = ['"', "'", '/'];
    if (!str.includes(substr)) {
        return false;
    }
    // eslint-disable-next-line @typescript-eslint/no-use-before-define
    if (indexOfAny(str, quotes) === -1) {
        return true;
    }
    const stack = [];
    for (let i = 0; i < str.length; i += 1) {
        const cursor = str[i];
        if (stack.length === 0) {
            if (startsAtIndexWith(str, i, substr)) {
                return true;
            }
        }
        if (quotes.indexOf(cursor) >= 0
            && (i === 0 || str[i - 1] !== '\\')) {
            const last = stack.pop();
            if (!last) {
                stack.push(cursor);
            }
            else if (last !== cursor) {
                stack.push(last);
                stack.push(cursor);
            }
        }
    }
    return false;
}
/**
 * `djb2` hash algorithm.
 *
 * NOTE: This version uses some bit operands to exclude overflow MAX_SAFE_INTEGER
 * (and moreover, exclude overflow 2^32).
 *
 * @see {@link https://gist.github.com/eplawless/52813b1d8ad9af510d85?permalink_comment_id=3367765#gistcomment-3367765}
 *
 * @param str String to get hash.
 *
 * @returns Hash.
 */
function fastHash(str) {
    if (str.length === 0) {
        return 0;
    }
    let hash = 5381;
    for (let i = 0; i < str.length; i += 1) {
        hash = hash * 33 ^ str.charCodeAt(i);
    }
    return hash >>> 0;
}
/**
 * Look for any symbol from "chars" array starting at "start" index or from the start of the string.
 *
 * @param str   String to search.
 * @param chars Chars to search for.
 * @param start Start index (optional, inclusive).
 *
 * @returns Int Index of the element found or -1 if not.
 */
function indexOfAny(str, chars, start = 0) {
    if (str.length <= start) {
        return -1;
    }
    for (let i = start; i < str.length; i += 1) {
        const c = str.charAt(i);
        if (chars.indexOf(c) > -1) {
            return i;
        }
    }
    return -1;
}
/**
 * Replaces all occurrences of find with replace in str.
 *
 * @param str The string in which to replace all occurrences of the find string.
 * @param find The substring to find in the string.
 * @param replace The substring to replace the find string with.
 *
 * @returns The string with all occurrences of find replaced by replace.
 */
function replaceAll(str, find, replace) {
    if (!str) {
        return str;
    }
    return str.split(find).join(replace);
}
/**
 * Checks if arrays are equal.
 *
 * @param left Array.
 * @param right Array.
 *
 * @returns {boolean} True on equality.
 */
function stringArraysEquals(left, right) {
    if (!left || !right) {
        return !left && !right;
    }
    if (left.length !== right.length) {
        return false;
    }
    for (let i = 0; i < left.length; i += 1) {
        if (left[i] !== right[i]) {
            return false;
        }
    }
    return true;
}
/**
 * Checks if arrays have an intersection.
 *
 * @param left Array.
 * @param right Array.
 *
 * @returns {boolean} True on equality.
 */
function stringArraysHaveIntersection(left, right) {
    if (!left || !right) {
        return true;
    }
    for (let i = 0; i < left.length; i += 1) {
        if (right.includes(left[i])) {
            return true;
        }
    }
    return false;
}
/**
 * Checks if string contains spaces.
 *
 * @param str String to check.
 *
 * @returns `true` if string contains spaces, `false` otherwise.
 */
function hasSpaces(str) {
    return str.includes(SPACE);
}
/**
 * Check if the given value is a string.
 *
 * @param value Value to check.
 *
 * @returns `true` if value is a string, `false` otherwise.
 */
function isString(value) {
    return typeof value === 'string';
}
/**
 * Unescapes the specified character in the string.
 *
 * @param str String to escape.
 * @param char Character to escape.
 *
 * @returns The string with the specified character unescaped.
 */
function unescapeChar(str, char) {
    return str.replace(`\\${char}`, char);
}
/**
 * Finds the next line break index in the string starting from the specified index.
 * Supports LF, CR, FF and CRLF line breaks.
 *
 * @param str String to search in.
 * @param startIndex  Start index. Default is 0.
 *
 * @returns A tuple with the line break index and the line break length.
 * If the line break is not found, returns the string length and 0.
 */
function findNextLineBreakIndex(str, startIndex = 0) {
    const { length } = str;
    let offset = startIndex;
    while (offset < length) {
        const char = str[offset];
        if (char === LF || char === FF) {
            return [offset, 1];
        }
        if (char === CR) {
            return str[offset + 1] === LF ? [offset, 2] : [offset, 1];
        }
        offset += 1;
    }
    return [length, 0];
}
/**
 * Finds the next occurrence of a specified character in a string that is not preceded by an escape (`\`).
 *
 * @param str The input string to search within.
 * @param char The character to find in the string.
 * @param [startIndex] The index to start searching from.
 *
 * @returns The index of the next unescaped occurrence of the character, or the length of the string if not found.
 */
const findNextUnescapedIndex = (str, char, startIndex = 0) => {
    let i = str.indexOf(char, startIndex);
    while (i !== -1 && str[i - 1] === '\\') {
        i = str.indexOf(char, i + 1);
    }
    return i === -1 ? str.length : i;
};
/**
 * Determines whether a given Unicode code point corresponds to a numeric digit (0-9).
 *
 * @param codePoint The Unicode code point to check.
 *
 * @returns `true` if the code point represents a numeric character (0-9), otherwise `false`.
 */
const isNumber = (codePoint) => {
    return codePoint >= 48 && codePoint <= 57;
};
/**
 * Determines whether a given Unicode code point corresponds to an alphabetical letter (a-z, A-Z).
 *
 * @param codePoint The Unicode code point to check.
 *
 * @returns `true` if the code point represents an alphabetic character, otherwise `false`.
 */
const isAlpha = (codePoint) => {
    const codePointLower = codePoint | 0x20;
    return codePointLower >= 97 && codePointLower <= 122;
};
/**
 * Determines whether a given Unicode code point corresponds to an alphanumeric character (a-z, A-Z, 0-9).
 *
 * @param codePoint The Unicode code point to check.
 *
 * @returns `true` if the code point represents an alphanumeric character, otherwise `false`.
 */
const isAlphaNumeric = (codePoint) => {
    return isAlpha(codePoint) || isNumber(codePoint);
};

/* eslint-disable prefer-regex-literals */
// https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/regexp
// should be escaped . * + ? ^ $ { } ( ) | [ ] / \
// except of * | ^
const specialCharacters = ['.', '+', '?', '$', '{', '}', '(', ')', '[', ']', '/', '\\'];
const reSpecialCharacters = new RegExp(`[${specialCharacters.join('\\')}]`, 'g');
const reSpecialCharactersFull = /[.*+?^${}()|[\]\\]/g;
const reEscapedSpecialCharactersFull = /\\[.*+?^${}()|[\]\\]/g;
const protocolMarker = String.raw `:\/\/`;
// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Grammar_and_types#using_special_characters_in_strings
const escapeSequence = {
    n: '\n',
    r: '\r',
    t: '\t',
    b: '\b',
    f: '\f',
    v: '\v',
};
/**
 * Class with static helper methods for working with basic filtering rules patterns.
 *
 * @see {@link https://kb.adguard.com/en/general/how-to-create-your-own-ad-filters#basic-rules}
 *
 * @returns The escaped string.
 */
class SimpleRegex {
    /**
     * Matching the beginning of an address. With this character you don't
     * have to specify a particular protocol and subdomain in address mask.
     * It means, `||` stands for `http://*.`, `https://*.`, `ws://*.`, `wss://*.` at once.
     */
    static MASK_START_URL = '||';
    /**
     * REGEX_START_URL corresponds to MASK_START_URL.
     */
    static REGEX_START_URL = '^(http|https|ws|wss)://([a-z0-9-_.]+\\.)?';
    /**
     * A pointer to the beginning or the end of address. The value depends on the
     * character placement in the mask. For example, a rule `swf|` corresponds
     * to `http://example.com/annoyingflash.swf`, but not to `http://example.com/swf/index.html`.
     * `|http://example.org` corresponds to `http://example.org`,
     * but not to `http://domain.com?url=http://example.org`.
     */
    static MASK_PIPE = '|';
    /**
     * REGEX_END_STRING corresponds to MASK_PIPE if it is in the end of a pattern.
     */
    static REGEX_END_STRING = '$';
    /**
     * REGEX_START_STRING corresponds to MASK_PIPE if it is in the beginning of a pattern.
     */
    static REGEX_START_STRING = '^';
    /**
     * Separator character mark. Separator character is any character,
     * but a letter, a digit, or one of the following: _ - .
     */
    static MASK_SEPARATOR = '^';
    /**
     * REGEX_SEPARATOR corresponds to MASK_SEPARATOR.
     */
    static REGEX_SEPARATOR = '([^ a-zA-Z0-9.%_-]|$)';
    /**
     * This is a wildcard character. It is used to represent "any set of characters".
     * This can also be an empty string or a string of any length.
     */
    static MASK_ANY_CHARACTER = '*';
    /**
     * Path separator.
     */
    static MASK_BACKSLASH = '/';
    /**
     * REGEX_ANY_CHARACTER corresponds to MASK_ANY_CHARACTER.
     */
    static REGEX_ANY_CHARACTER = '.*';
    /**
     * Enclose regex in two backslashes to mark a regex rule.
     *
     * @see {@link https://kb.adguard.com/en/general/how-to-create-your-own-ad-filters#regular-expressions-support}
     */
    static MASK_REGEX_RULE = '/';
    /**
     *  Regex for matching special characters in modifier regex pattern.
     */
    static reModifierPatternSpecialCharacters = /[[\],\\]/g;
    /**
     * Regex for matching escaped special characters in modifier regex pattern.
     */
    static reModifierPatternEscapedSpecialCharacters = /\\[[\],\\]/g;
    /**
     * If string starts with exclamation mark "!" we consider it as comment.
     */
    static MASK_COMMENT = '!';
    /**
     * Min length of rule shortcut
     * This value has been picked as a result of performance experiments.
     */
    static MIN_SHORTCUT_LENGTH = 3;
    /**
     * Min length of generic rule shortcut.
     */
    static MIN_GENERIC_RULE_LENGTH = 4;
    /**
     * Regex with basic matching pattern special characters.
     */
    static rePatternSpecialCharacters = new RegExp('[*^|]');
    /**
     * Extracts the shortcut from the rule's pattern.
     * Shortcut is the longest substring of the pattern that does not contain
     * any special characters.
     *
     * Please note, that the shortcut is always lower-case!
     *
     * @param pattern Network rule's pattern.
     *
     * @returns The shortcut or the empty string if we could not extract any.
     */
    static extractShortcut(pattern) {
        if (pattern.startsWith(this.MASK_REGEX_RULE) && pattern.endsWith(this.MASK_REGEX_RULE)) {
            return this.extractRegexpShortcut(pattern);
        }
        return this.extractBasicShortcut(pattern);
    }
    /**
     * Searches for the longest substring of the pattern that
     * does not contain any special characters: `*`, `^`, `|`.
     *
     * @param pattern Network rule's pattern.
     *
     * @returns The shortcut or the empty string.
     */
    static extractBasicShortcut(pattern) {
        let longest = '';
        const parts = pattern.split(this.rePatternSpecialCharacters);
        for (const part of parts) {
            if (part.length > longest.length) {
                longest = part;
            }
        }
        return (longest || '').toLowerCase();
    }
    /**
     * Extracts the longest substring from the provided regex pattern that does not
     * contain any special regex symbols or constructs that invalidate it for use
     * as a quick match shortcut.
     * The pattern is expected to be enclosed in forward slashes (e.g., `/example/`),
     * and may optionally contain a protocol marker (`://`),
     * which is ignored to prevent trivial matches like "http".
     *
     * This method discards many complex regex features (e.g., groups, character
     * classes, certain escaped sequences) when forming the shortcut, and always
     * returns the result in lower-case. If no valid substring is found, it returns
     * an empty string.
     *
     * @param pattern The input regex pattern, including the enclosing slashes.
     * For example: `/https?:\\/\\/example\\.com/`.
     *
     * @returns The longest valid substring usable as a shortcut, or an empty string if none is found.
     */
    static extractRegexpShortcut(pattern) {
        const { length } = pattern;
        if (!pattern
            // length should be at least 3: "/x/", "//" does not make sense
            || length < 3
            // regex pattern should start and end with '/'
            || pattern[0] !== '/'
            || pattern[length - 1] !== '/') {
            return '';
        }
        const protocolIndex = pattern.indexOf(protocolMarker);
        /**
         * `i` is our primary index into the pattern;
         * we skip the initial `/` or jump after the protocol marker `://`.
         */
        let i = protocolIndex !== -1
            ? protocolIndex + protocolMarker.length
            : 1;
        let longestToken = '';
        let longestTokenInGroup = '';
        let currentToken = '';
        /**
         * Resets `currentToken` and updates `longestTokenInGroup` if `currentToken` is longer.
         */
        const resetCurrentToken = () => {
            if (currentToken.length > longestTokenInGroup.length) {
                longestTokenInGroup = currentToken;
            }
            currentToken = '';
        };
        /**
         * Resets `longestTokenInGroup` and updates `longestToken` if `longestTokenInGroup` is longer.
         */
        const resetGroupToken = () => {
            if (longestTokenInGroup.length > longestToken.length) {
                longestToken = longestTokenInGroup;
            }
            longestTokenInGroup = '';
        };
        /**
         * Track parenthesis group nesting.
         */
        let groupBalance = 0;
        /**
         * Skip everything up to the closing parenthesis for the current group
         * (including nested groups).
         * This method moves `i` to the position of the closing parenthesis.
         */
        const ignoreCurrentGroup = () => {
            // Ignoring group means we should drop the current token
            currentToken = '';
            longestTokenInGroup = '';
            const startBalance = groupBalance;
            while (i < length) {
                // If `(` is not escaped, increment group count
                if (pattern[i] === '(' && pattern[i - 1] !== '\\') {
                    groupBalance += 1;
                }
                // If `)` is not escaped, decrement group count
                if (pattern[i] === ')' && pattern[i - 1] !== '\\') {
                    groupBalance -= 1;
                    // Once we return to the level before this group started, stop
                    if (groupBalance < startBalance) {
                        break;
                    }
                }
                i += 1;
            }
        };
        while (i < length) {
            const char = pattern[i];
            // 1) Handle escaped sequences
            if (char === '\\') {
                // Skip the backslash
                i += 1;
                const escaped = pattern[i];
                switch (escaped) {
                    // Ignore predefined character classes: \d, \D, \s, \S, \w, \W
                    case 'd':
                    case 'D':
                    case 's':
                    case 'S':
                    case 'w':
                    case 'W':
                    // Ignore special characters: \t, \r, \n, \v, \f, \b, \0
                    // eslint-disable-next-line no-fallthrough
                    case 't':
                    case 'r':
                    case 'n':
                    case 'v':
                    case 'f':
                    case 'b':
                    case '0':
                        resetCurrentToken();
                        i += 1;
                        continue;
                    // Ignore control characters: \cX — control character X
                    case 'c':
                        resetCurrentToken();
                        // skip 'c' and the following character
                        i += 2;
                        continue;
                    // Ignore \xhh
                    case 'x':
                        resetCurrentToken();
                        // skip 'x' and the following 2 characters
                        i += 3;
                        continue;
                    // Ignore \uhhhh
                    case 'u':
                        resetCurrentToken();
                        // skip 'u' and the following 4 characters
                        i += 5;
                        continue;
                    // Ignore named backreference: \k<...>
                    case 'k':
                        resetCurrentToken();
                        // skip 'k'
                        i += 1;
                        if (pattern[i] === '<') {
                            // Skip until the closing '>'
                            i = findNextUnescapedIndex(pattern, '>', i) + 1;
                        }
                        continue;
                    // Special case: add escaped '.' or '/' to the current token
                    case '.':
                    case '/':
                        currentToken += escaped;
                        i += 1;
                        continue;
                    default:
                        resetCurrentToken();
                        i += 1;
                        continue;
                }
            }
            // 2) Handle "regular" characters (i.e., not after a backslash)
            switch (char) {
                // Ignore custom character classes, like [xyz], [^xyz], [\b], [a-z], etc.
                case '[':
                    resetCurrentToken();
                    i = findNextUnescapedIndex(pattern, ']', i) + 1;
                    continue;
                // Ignore disjunctions (alternations), like a|b|c
                // Note: shortcut should be present in all possible tested strings,
                // this is why we ignore disjunctions
                case '|':
                    ignoreCurrentGroup();
                    continue;
                // Ignore specific quantifiers, like x{n}, x{n,}, x{n,m}
                case '{':
                    resetCurrentToken();
                    i = findNextUnescapedIndex(pattern, '}', i) + 1;
                    continue;
                // Handle group open
                case '(':
                    resetCurrentToken();
                    resetGroupToken();
                    groupBalance += 1;
                    // Skip `(`
                    i += 1;
                    // Ignore negative lookahead: (?!...) and negative lookbehind: (?<!...)
                    // Negative lookbehind and lookahead contain data that should not be present in the tested strings,
                    // this is why we ignore them
                    if (pattern.indexOf('?!', i) === i || pattern.indexOf('?<!', i) === i) {
                        ignoreCurrentGroup();
                    }
                    // Ignore name section from named groups: (?<...>
                    if (pattern.indexOf('?<', i) === i) {
                        // Skip until the closing '>'
                        i = findNextUnescapedIndex(pattern, '>', i + 2) + 1;
                    }
                    continue;
                // Handle group close
                case ')':
                    resetCurrentToken();
                    resetGroupToken();
                    groupBalance -= 1;
                    // Skip `)`
                    i += 1;
                    continue;
                // Handle special regex symbols: . * + ? ^ $ /
                case '.':
                case '*':
                case '+':
                case '?':
                case '^':
                case '$':
                case '/':
                    resetCurrentToken();
                    i += 1;
                    continue;
                default:
                    // For performance, let's check if it's a valid token char
                    // Note: isValidRegexpShortcutChar checks for alphanumeric or
                    // escaped '.' or '/'
                    if (isAlphaNumeric(char.charCodeAt(0))) {
                        currentToken += char;
                    }
                    else {
                        // If it's not a valid char for a shortcut, reset
                        resetCurrentToken();
                    }
                    i += 1;
                    break;
            }
        }
        // Finalize the last token
        resetCurrentToken();
        resetGroupToken();
        return longestToken.toLowerCase();
    }
    /**
     * PatternToRegexp is a helper method for creating regular expressions from the simple
     * wildcard-based syntax which is used in basic filters.
     *
     * @see {@link https://kb.adguard.com/en/general/how-to-create-your-own-ad-filters#basic-rules}
     *
     * @param pattern Basic rule pattern.
     *
     * @returns Regular expression.
     */
    static patternToRegexp(pattern) {
        if (pattern === this.MASK_START_URL
            || pattern === this.MASK_PIPE
            || pattern === this.MASK_ANY_CHARACTER
            || pattern === '') {
            return this.REGEX_ANY_CHARACTER;
        }
        if (pattern.startsWith(this.MASK_REGEX_RULE) && pattern.endsWith(this.MASK_REGEX_RULE)) {
            // This is a regex rule, just remove the regex markers
            return pattern.substring(this.MASK_REGEX_RULE.length, pattern.length - this.MASK_REGEX_RULE.length);
        }
        // Escape special characters except of * | ^
        let regex = pattern.replace(reSpecialCharacters, '\\$&');
        // Now escape "|" characters but avoid escaping them in the special places
        if (regex.startsWith(this.MASK_START_URL)) {
            regex = regex.substring(0, this.MASK_START_URL.length)
                + replaceAll(regex.substring(this.MASK_START_URL.length, regex.length - this.MASK_PIPE.length), this.MASK_PIPE, `\\${this.MASK_PIPE}`)
                + regex.substring(regex.length - this.MASK_PIPE.length);
        }
        else {
            regex = regex.substring(0, this.MASK_PIPE.length)
                + replaceAll(regex.substring(this.MASK_PIPE.length, regex.length - this.MASK_PIPE.length), this.MASK_PIPE, `\\${this.MASK_PIPE}`)
                + regex.substring(regex.length - this.MASK_PIPE.length);
        }
        // Replace special URL masks
        regex = replaceAll(regex, this.MASK_ANY_CHARACTER, this.REGEX_ANY_CHARACTER);
        regex = replaceAll(regex, this.MASK_SEPARATOR, this.REGEX_SEPARATOR);
        // Replace start URL and pipes
        if (regex.startsWith(this.MASK_START_URL)) {
            regex = this.REGEX_START_URL + regex.substring(this.MASK_START_URL.length);
        }
        else if (regex.startsWith(this.MASK_PIPE)) {
            regex = this.REGEX_START_STRING + regex.substring(this.MASK_PIPE.length);
        }
        if (regex.endsWith(this.MASK_PIPE)) {
            regex = regex.substring(0, regex.length - this.MASK_PIPE.length) + this.REGEX_END_STRING;
        }
        return regex;
    }
    /**
     * Creates RegExp object from string in '/reg_exp/gi' format.
     *
     * @param str The string to escape.
     *
     * @returns The created RegExp object.
     */
    static patternFromString(str) {
        const parts = splitByDelimiterWithEscapeCharacter(str, '/', '\\', true);
        let modifiers = (parts[1] || '');
        if (modifiers.indexOf('g') < 0) {
            modifiers += 'g';
        }
        return new RegExp(parts[0], modifiers);
    }
    /**
     * Escapes characters with special meaning inside a regular expression.
     *
     * @param str The string to escape.
     * @param searchPattern Pattern for detecting special characters. Optional.
     *
     * @returns The escaped string.
     */
    static escapeRegexSpecials(str, searchPattern = reSpecialCharactersFull) {
        return str.replace(searchPattern, '\\$&');
    }
    /**
     * Unescapes characters with special meaning inside a regular expression.
     *
     * @param str The string to unescape.
     * @param searchPattern Pattern for detecting special characters. Optional.
     *
     * @returns The unescaped string.
     */
    static unescapeRegexSpecials(str, searchPattern = reEscapedSpecialCharactersFull) {
        return str.replace(searchPattern, (match) => match.substring(1));
    }
    /**
     * Check if pattern is Regex.
     *
     * @param str The string to check.
     *
     * @returns True if the string is a regex pattern, false otherwise.
     */
    static isRegexPattern(str) {
        return str.startsWith('/') && str.endsWith('/');
    }
    /**
     * Unescapes special characters in a string.
     *
     * @see {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Grammar_and_types#using_special_characters_in_strings}
     *
     * @param str The string to unescape.
     *
     * @returns The unescaped string.
     */
    static unescapeSpecials(str) {
        const keys = Object.keys(escapeSequence).join('|');
        const regex = new RegExp(`\\\\(${keys})`, 'g');
        return str.replace(regex, (match, group) => {
            return escapeSequence[group];
        });
    }
}




/***/ }),

/***/ 47562:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  gR: () => (/* binding */ contains)
});

// UNUSED EXPORTS: default, exclude, expand, isIP, merge, normalize, overlap, parse

;// ./node_modules/.pnpm/ip-regex@5.0.0/node_modules/ip-regex/index.js
const word = '[a-fA-F\\d:]';

const boundry = options => options && options.includeBoundaries
	? `(?:(?<=\\s|^)(?=${word})|(?<=${word})(?=\\s|$))`
	: '';

const v4 = '(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}';

const v6segment = '[a-fA-F\\d]{1,4}';

const v6 = `
(?:
(?:${v6segment}:){7}(?:${v6segment}|:)|                                    // 1:2:3:4:5:6:7::  1:2:3:4:5:6:7:8
(?:${v6segment}:){6}(?:${v4}|:${v6segment}|:)|                             // 1:2:3:4:5:6::    1:2:3:4:5:6::8   1:2:3:4:5:6::8  1:2:3:4:5:6::1.2.3.4
(?:${v6segment}:){5}(?::${v4}|(?::${v6segment}){1,2}|:)|                   // 1:2:3:4:5::      1:2:3:4:5::7:8   1:2:3:4:5::8    1:2:3:4:5::7:1.2.3.4
(?:${v6segment}:){4}(?:(?::${v6segment}){0,1}:${v4}|(?::${v6segment}){1,3}|:)| // 1:2:3:4::        1:2:3:4::6:7:8   1:2:3:4::8      1:2:3:4::6:7:1.2.3.4
(?:${v6segment}:){3}(?:(?::${v6segment}){0,2}:${v4}|(?::${v6segment}){1,4}|:)| // 1:2:3::          1:2:3::5:6:7:8   1:2:3::8        1:2:3::5:6:7:1.2.3.4
(?:${v6segment}:){2}(?:(?::${v6segment}){0,3}:${v4}|(?::${v6segment}){1,5}|:)| // 1:2::            1:2::4:5:6:7:8   1:2::8          1:2::4:5:6:7:1.2.3.4
(?:${v6segment}:){1}(?:(?::${v6segment}){0,4}:${v4}|(?::${v6segment}){1,6}|:)| // 1::              1::3:4:5:6:7:8   1::8            1::3:4:5:6:7:1.2.3.4
(?::(?:(?::${v6segment}){0,5}:${v4}|(?::${v6segment}){1,7}|:))             // ::2:3:4:5:6:7:8  ::2:3:4:5:6:7:8  ::8             ::1.2.3.4
)(?:%[0-9a-zA-Z]{1,})?                                             // %eth0            %1
`.replace(/\s*\/\/.*$/gm, '').replace(/\n/g, '').trim();

// Pre-compile only the exact regexes because adding a global flag make regexes stateful
const v46Exact = new RegExp(`(?:^${v4}$)|(?:^${v6}$)`);
const v4exact = new RegExp(`^${v4}$`);
const v6exact = new RegExp(`^${v6}$`);

const ipRegex = options => options && options.exact
	? v46Exact
	: new RegExp(`(?:${boundry(options)}${v4}${boundry(options)})|(?:${boundry(options)}${v6}${boundry(options)})`, 'g');

ipRegex.v4 = options => options && options.exact ? v4exact : new RegExp(`${boundry(options)}${v4}${boundry(options)}`, 'g');
ipRegex.v6 = options => options && options.exact ? v6exact : new RegExp(`${boundry(options)}${v6}${boundry(options)}`, 'g');

/* harmony default export */ const ip_regex = (ipRegex);

;// ./node_modules/.pnpm/cidr-regex@4.0.3/node_modules/cidr-regex/index.js


const defaultOpts = {exact: false};
const v4str = `${ip_regex.v4().source}\\/(3[0-2]|[12]?[0-9])`;
const v6str = `${ip_regex.v6().source}\\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])`;

// pre-compile only the exact regexes as global flag makes regex objects stateful
const cidr_regex_v4exact = new RegExp(`^${v4str}$`);
const cidr_regex_v6exact = new RegExp(`^${v6str}$`);
const v46exact = new RegExp(`(?:^${v4str}$)|(?:^${v6str}$)`);

const cidrRegex = ({exact} = defaultOpts) => exact ? v46exact : new RegExp(`(?:${v4str})|(?:${v6str})`, "g");
const cidr_regex_v4 = cidrRegex.v4 = ({exact} = defaultOpts) => exact ? cidr_regex_v4exact : new RegExp(v4str, "g");
const cidr_regex_v6 = cidrRegex.v6 = ({exact} = defaultOpts) => exact ? cidr_regex_v6exact : new RegExp(v6str, "g");
/* harmony default export */ const cidr_regex = (cidrRegex);

// EXTERNAL MODULE: ./node_modules/.pnpm/string-natural-compare@3.0.1/node_modules/string-natural-compare/natural-compare.js
var natural_compare = __webpack_require__(34156);
;// ./node_modules/.pnpm/ip-bigint@7.3.0/node_modules/ip-bigint/index.js
const max4 = 2n ** 32n - 1n;
const max6 = 2n ** 128n - 1n;

function parseIp(ip) {
  const version = ipVersion(ip);
  if (!version) throw new Error(`Invalid IP address: ${ip}`);

  let number = 0n;
  let exp = 0n;
  const res = Object.create(null);

  if (version === 4) {
    for (const n of ip.split(".").map(BigInt).reverse()) {
      number += n * (2n ** exp);
      exp += 8n;
    }
  } else {
    if (ip.includes(".")) {
      res.ipv4mapped = true;
      ip = ip.split(":").map(part => {
        if (part.includes(".")) {
          const digits = part.split(".").map(str => Number(str).toString(16).padStart(2, "0"));
          return `${digits[0]}${digits[1]}:${digits[2]}${digits[3]}`;
        } else {
          return part;
        }
      }).join(":");
    }

    if (ip.includes("%")) {
      let scopeid;
      [, ip, scopeid] = /(.+)%(.+)/.exec(ip);
      res.scopeid = scopeid;
    }

    const parts = ip.split(":");
    const index = parts.indexOf("");

    if (index !== -1) {
      while (parts.length < 8) {
        parts.splice(index, 0, "");
      }
    }

    for (const n of parts.map(part => BigInt(parseInt(part || 0, 16))).reverse()) {
      number += n * (2n ** exp);
      exp += 16n;
    }
  }

  res.number = number;
  res.version = version;
  return res;
}

function stringifyIp({number, version, ipv4mapped, scopeid} = {}, {compress = true, hexify = false} = {}) {
  if (typeof number !== "bigint") throw new Error(`Expected a BigInt`);
  if (![4, 6].includes(version)) throw new Error(`Invalid version: ${version}`);
  if (number < 0n || number > (version === 4 ? max4 : max6)) throw new Error(`Invalid number: ${number}`);

  let step = version === 4 ? 24n : 112n;
  const stepReduction = version === 4 ? 8n : 16n;
  let remain = number;
  const parts = [];

  while (step > 0n) {
    const divisor = 2n ** step;
    parts.push(remain / divisor);
    remain = number % divisor;
    step -= stepReduction;
  }
  parts.push(remain);

  if (version === 4) {
    return parts.join(".");
  } else {
    let ip = "";
    if (ipv4mapped && !hexify) {
      for (const [index, num] of parts.entries()) {
        if (index < 6) {
          ip += `${num.toString(16)}:`;
        } else {
          ip += `${String(num >> 8n)}.${String(num & 255n)}${index === 6 ? "." : ""}`;
        }
      }
      if (compress) {
        ip = compressIPv6(ip.split(":"));
      }
    } else {
      if (compress) {
        ip = compressIPv6(parts.map(n => n.toString(16)));
      } else {
        ip = parts.map(n => n.toString(16)).join(":");
      }
    }

    if (scopeid) {
      ip = `${ip}%${scopeid}`;
    }

    return ip;
  }
}

function normalizeIp(ip, {compress = true, hexify = false} = {}) {
  return stringifyIp(parseIp(ip), {compress, hexify});
}

// take the longest or first sequence of "0" segments and replace it with "::"
function compressIPv6(parts) {
  let longest, current;
  for (const [index, part] of parts.entries()) {
    if (part === "0") {
      if (!current) {
        current = new Set([index]);
      } else {
        current.add(index);
      }
    } else {
      if (current) {
        if (!longest) {
          longest = current;
        } else if (current.size > longest.size) {
          longest = current;
        }
        current = null;
      }
    }
  }
  if ((!longest && current) || (current && current.size > longest.size)) {
    longest = current;
  }

  for (const index of longest || []) {
    parts[index] = ":";
  }

  return parts.filter(Boolean).join(":").replace(/:{2,}/, "::");
}

function ipVersion(ip) {
  return ip.includes(":") ? 6 : ip.includes(".") ? 4 : 0;
}

;// ./node_modules/.pnpm/cidr-tools@6.4.2/node_modules/cidr-tools/index.js





const bits = {
  4: 32,
  6: 128,
};

const uniq = arr => Array.from(new Set(arr));

function isIP(ip) {
  if (ip_regex.v4({exact: true}).test(ip)) return 4;
  if (ip_regex.v6({exact: true}).test(ip)) return 6;
  return 0;
}

function isCidr(ip) {
  if (cidr_regex.v4({exact: true}).test(ip)) return 4;
  if (cidr_regex.v6({exact: true}).test(ip)) return 6;
  return 0;
}

function doNormalize(cidr, {compress = true, hexify = false} = {}) {
  const {start, prefix, single, version} = parse(cidr);
  if (!single) { // cidr
    // set network address to first address
    const ip = normalizeIp(stringifyIp({number: start, version}), {compress, hexify});
    return `${ip}/${prefix}`;
  } else { // single ip
    return normalizeIp(cidr, {compress, hexify});
  }
}

function normalize(cidr, {compress = true, hexify = false} = {}) {
  if (Array.isArray(cidr)) {
    return cidr.map(entry => normalize(entry, {compress, hexify}));
  } else {
    return doNormalize(cidr, {compress, hexify});
  }
}

function parse(str) {
  const cidrVersion = isCidr(str);
  const parsed = Object.create(null);
  parsed.single = false;

  if (cidrVersion) {
    parsed.cidr = str;
    parsed.version = cidrVersion;
  } else {
    const version = isIP(str);
    if (version) {
      parsed.cidr = `${str}/${bits[version]}`;
      parsed.version = version;
      parsed.single = true;
    } else {
      throw new Error(`Network is not a CIDR or IP: ${str}`);
    }
  }

  const [ip, prefix] = parsed.cidr.split("/");
  parsed.prefix = prefix;
  const {number, version} = parseIp(ip);
  const numBits = bits[version];
  const ipBits = number.toString(2).padStart(numBits, "0");
  const prefixLen = Number(numBits - prefix);
  const startBits = ipBits.substring(0, numBits - prefixLen);
  parsed.start = BigInt(`0b${startBits}${"0".repeat(prefixLen)}`);
  parsed.end = BigInt(`0b${startBits}${"1".repeat(prefixLen)}`);
  return parsed;
}

// returns whether networks fully or partially overlap
function doNetsOverlap(a, b) {
  //    aaa
  // bbb
  if (a.start > b.end) return false; // a starts after b

  // aaa
  //    bbb
  if (b.start > a.end) return false; // b starts after a

  return true;
}

// returns whether network a fully contains network b;
function netContains(a, b) {
  //  aaa
  // bbbb
  if (b.start < a.start) return false; // a starts after b

  // aaa
  // bbbb
  if (b.end > a.end) return false; // b starts after a

  return true;
}

// exclude b from a and return remainder cidrs
function excludeNets(a, b, v) {
  const parts = [];

  // compareTo returns negative if left is less than right

  //       aaa
  //   bbb
  //   aaa
  //       bbb
  if (a.start > b.end || a.end < b.start) {
    return [a.cidr];
  }

  //   aaa
  //   bbb
  if (a.start === b.start && a.end === b.end) {
    return [];
  }

  //   aa
  //  bbbb
  if (a.start > b.start && a.end < b.end) {
    return [];
  }

  // aaaa
  //   bbbb
  // aaaa
  //   bb
  if (a.start < b.start && a.end <= b.end) {
    parts.push({start: a.start, end: b.start - 1n});
  }

  //    aaa
  //   bbb
  //   aaaa
  //   bbb
  if (a.start >= b.start && a.end > b.end) {
    parts.push({start: b.end + 1n, end: a.end});
  }

  //  aaaa
  //   bb
  if (a.start < b.start && a.end > b.end) {
    parts.push(
      {start: a.start, end: b.start - 1n},
      {start: b.end + 1n, end: a.end},
    );
  }

  const remaining = [];
  for (const part of parts) {
    for (const subpart of subparts(part)) {
      remaining.push(formatPart(subpart, v));
    }
  }

  return merge(remaining);
}

function biggestPowerOfTwo(num) {
  if (num === 0n) return 0n;
  return 2n ** BigInt(String(num.toString(2).length - 1));
}

function subparts(part) {
  // special case for when part is length 1
  if ((part.end - part.start) === 1n) {
    if (part.end % 2n === 0n) {
      return [{start: part.start, end: part.start}, {start: part.end, end: part.end}];
    } else {
      return [{start: part.start, end: part.end}];
    }
  }

  const size = diff(part.end, part.start);
  let biggest = biggestPowerOfTwo(size);

  let start, end;
  if (size === biggest && part.start + size === part.end) {
    return [part];
  } else if (part.start % biggest === 0n) {
    // start is matching on the size-defined boundary - ex: 0-12, use 0-8
    start = part.start;
    end = start + biggest - 1n;
  } else {
    start = (part.end / biggest) * biggest;

    // start is not matching on the size-defined boundary - 4-16, use 8-16
    if ((start + biggest - 1n) > part.end) {
      // divide will floor to nearest integer
      start = ((part.end / biggest) - 1n) * biggest;

      while (start < part.start) {
        biggest /= 2n;
        start = ((part.end / biggest) - 1n) * biggest;
      }

      end = start + biggest - 1n;
    } else {
      start = (part.end / biggest) * biggest;
      end = start + biggest - 1n;
    }
  }

  let parts = [{start, end}];

  // additional subnets on left side
  if (start !== part.start) {
    parts = parts.concat(subparts({start: part.start, end: start - 1n}));
  }

  // additional subnets on right side
  if (end !== part.end) {
    parts = parts.concat(subparts({start: end + 1n, end: part.end}));
  }

  return parts;
}

function diff(a, b) {
  if (typeof a !== "bigint") a = BigInt(a);
  if (typeof b !== "bigint") b = BigInt(b);
  a += 1n;
  return a - b;
}

function formatPart(part, v) {
  const ip = normalize(stringifyIp({
    number: BigInt(part.start.toString()),
    version: v,
  }));
  const zeroes = diff(part.end, part.start).toString(2);
  const prefix = bits[v] - (zeroes.match(/0/g) || []).length;
  return `${ip}/${prefix}`;
}

function mapNets(nets) {
  const maps = {4: {}, 6: {}};
  for (const {start, end, version: v} of nets) {
    if (!maps[v][start]) maps[v][start] = {};
    if (!maps[v][end]) maps[v][end] = {};

    if (maps[v][start].start) {
      maps[v][start].start += 1;
    } else {
      maps[v][start].start = 1;
    }

    if (maps[v][end].end) {
      maps[v][end].end += 1;
    } else {
      maps[v][end].end = 1;
    }
  }
  return maps;
}

function merge(nets) {
  nets = uniq((Array.isArray(nets) ? nets : [nets]).map(parse));
  const maps = mapNets(nets);

  const merged = {4: [], 6: []};
  const start = {4: null, 6: null};
  const end = {4: null, 6: null};

  for (const v of [4, 6]) {
    const numbers = Object.keys(maps[v]).sort(natural_compare);
    let depth = 0;

    for (const [index, number] of numbers.entries()) {
      const marker = maps[v][number];

      if (start[v] === null && marker.start) {
        start[v] = BigInt(number);
      }
      if (marker.end) {
        end[v] = BigInt(number);
      }

      if (marker.start) depth += marker.start;
      if (marker.end) depth -= marker.end;

      if (marker.end && depth === 0 && ((numbers[index + 1] - numbers[index]) > 1)) {
        for (const sub of subparts({start: start[v], end: end[v]})) {
          merged[v].push(formatPart(sub, v));
        }
        start[v] = null;
        end[v] = null;
      } else if (index === (numbers.length - 1)) {
        for (const sub of subparts({start: start[v], end: end[v]})) {
          merged[v].push(formatPart(sub, v));
        }
      }
    }
  }

  return [...merged[4].sort(natural_compare), ...merged[6].sort(natural_compare)];
}

function exclude(basenets, exclnets) {
  basenets = uniq(Array.isArray(basenets) ? basenets : [basenets]);
  exclnets = uniq(Array.isArray(exclnets) ? exclnets : [exclnets]);

  basenets = merge(basenets);
  exclnets = merge(exclnets);

  const bases = {4: [], 6: []};
  const excls = {4: [], 6: []};

  for (const basenet of basenets) {
    bases[isCidr(basenet)].push(basenet);
  }

  for (const exclnet of exclnets) {
    excls[isCidr(exclnet)].push(exclnet);
  }

  for (const v of [4, 6]) {
    for (const exclcidr of excls[v]) {
      for (const [index, basecidr] of bases[v].entries()) {
        const base = parse(basecidr);
        const excl = parse(exclcidr);
        const remainders = excludeNets(base, excl, v);
        if (base.cidr !== remainders.toString()) {
          bases[v] = bases[v].concat(remainders);
          bases[v].splice(index, 1);
        }
      }
    }
  }

  return bases[4].concat(bases[6]);
}

function expand(nets) {
  nets = uniq(Array.isArray(nets) ? nets : [nets]);

  const ips = [];
  for (const net of merge(nets)) {
    const {start, end, version} = parse(net);
    for (let number = start; number <= end; number++) {
      ips.push(stringifyIp({number, version}));
    }
  }
  return ips.map(normalize);
}

function overlap(a, b) {
  const aNets = uniq(Array.isArray(a) ? a : [a]);
  const bNets = uniq(Array.isArray(b) ? b : [b]);

  for (const a of aNets) {
    const aParsed = parse(a);
    for (const b of bNets) {
      const bParsed = parse(b);

      // version mismatch
      if (aParsed.version !== bParsed.version) {
        continue;
      }

      if (doNetsOverlap(aParsed, bParsed)) {
        return true;
      }
    }
  }

  return false;
}

function contains(a, b) {
  const aNets = uniq(Array.isArray(a) ? a : [a]);
  const bNets = uniq(Array.isArray(b) ? b : [b]);

  const numExpected = bNets.length;
  let numFound = 0;
  for (const a of aNets) {
    const aParsed = parse(a);
    for (const b of bNets) {
      const bParsed = parse(b);

      // version mismatch
      if (aParsed.version !== bParsed.version) {
        continue;
      }

      if (netContains(aParsed, bParsed)) {
        numFound++;
        continue;
      }
    }
  }

  return numFound === numExpected;
}

/* harmony default export */ const cidr_tools = ({
  merge,
  exclude,
  expand,
  overlap,
  contains,
  normalize,
  parse,
});


/***/ }),

/***/ 38037:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   q: () => (/* binding */ LRUCache)
/* harmony export */ });
/**
 * @module LRUCache
 */
const perf = typeof performance === 'object' &&
    performance &&
    typeof performance.now === 'function'
    ? performance
    : Date;
const warned = new Set();
/* c8 ignore start */
const PROCESS = (typeof process === 'object' && !!process ? process : {});
/* c8 ignore start */
const emitWarning = (msg, type, code, fn) => {
    typeof PROCESS.emitWarning === 'function'
        ? PROCESS.emitWarning(msg, type, code, fn)
        : console.error(`[${code}] ${type}: ${msg}`);
};
let AC = globalThis.AbortController;
let AS = globalThis.AbortSignal;
/* c8 ignore start */
if (typeof AC === 'undefined') {
    //@ts-ignore
    AS = class AbortSignal {
        onabort;
        _onabort = [];
        reason;
        aborted = false;
        addEventListener(_, fn) {
            this._onabort.push(fn);
        }
    };
    //@ts-ignore
    AC = class AbortController {
        constructor() {
            warnACPolyfill();
        }
        signal = new AS();
        abort(reason) {
            if (this.signal.aborted)
                return;
            //@ts-ignore
            this.signal.reason = reason;
            //@ts-ignore
            this.signal.aborted = true;
            //@ts-ignore
            for (const fn of this.signal._onabort) {
                fn(reason);
            }
            this.signal.onabort?.(reason);
        }
    };
    let printACPolyfillWarning = PROCESS.env?.LRU_CACHE_IGNORE_AC_WARNING !== '1';
    const warnACPolyfill = () => {
        if (!printACPolyfillWarning)
            return;
        printACPolyfillWarning = false;
        emitWarning('AbortController is not defined. If using lru-cache in ' +
            'node 14, load an AbortController polyfill from the ' +
            '`node-abort-controller` package. A minimal polyfill is ' +
            'provided for use by LRUCache.fetch(), but it should not be ' +
            'relied upon in other contexts (eg, passing it to other APIs that ' +
            'use AbortController/AbortSignal might have undesirable effects). ' +
            'You may disable this with LRU_CACHE_IGNORE_AC_WARNING=1 in the env.', 'NO_ABORT_CONTROLLER', 'ENOTSUP', warnACPolyfill);
    };
}
/* c8 ignore stop */
const shouldWarn = (code) => !warned.has(code);
const TYPE = Symbol('type');
const isPosInt = (n) => n && n === Math.floor(n) && n > 0 && isFinite(n);
/* c8 ignore start */
// This is a little bit ridiculous, tbh.
// The maximum array length is 2^32-1 or thereabouts on most JS impls.
// And well before that point, you're caching the entire world, I mean,
// that's ~32GB of just integers for the next/prev links, plus whatever
// else to hold that many keys and values.  Just filling the memory with
// zeroes at init time is brutal when you get that big.
// But why not be complete?
// Maybe in the future, these limits will have expanded.
const getUintArray = (max) => !isPosInt(max)
    ? null
    : max <= Math.pow(2, 8)
        ? Uint8Array
        : max <= Math.pow(2, 16)
            ? Uint16Array
            : max <= Math.pow(2, 32)
                ? Uint32Array
                : max <= Number.MAX_SAFE_INTEGER
                    ? ZeroArray
                    : null;
/* c8 ignore stop */
class ZeroArray extends Array {
    constructor(size) {
        super(size);
        this.fill(0);
    }
}
class Stack {
    heap;
    length;
    // private constructor
    static #constructing = false;
    static create(max) {
        const HeapCls = getUintArray(max);
        if (!HeapCls)
            return [];
        Stack.#constructing = true;
        const s = new Stack(max, HeapCls);
        Stack.#constructing = false;
        return s;
    }
    constructor(max, HeapCls) {
        /* c8 ignore start */
        if (!Stack.#constructing) {
            throw new TypeError('instantiate Stack using Stack.create(n)');
        }
        /* c8 ignore stop */
        this.heap = new HeapCls(max);
        this.length = 0;
    }
    push(n) {
        this.heap[this.length++] = n;
    }
    pop() {
        return this.heap[--this.length];
    }
}
/**
 * Default export, the thing you're using this module to get.
 *
 * The `K` and `V` types define the key and value types, respectively. The
 * optional `FC` type defines the type of the `context` object passed to
 * `cache.fetch()` and `cache.memo()`.
 *
 * Keys and values **must not** be `null` or `undefined`.
 *
 * All properties from the options object (with the exception of `max`,
 * `maxSize`, `fetchMethod`, `memoMethod`, `dispose` and `disposeAfter`) are
 * added as normal public members. (The listed options are read-only getters.)
 *
 * Changing any of these will alter the defaults for subsequent method calls.
 */
class LRUCache {
    // options that cannot be changed without disaster
    #max;
    #maxSize;
    #dispose;
    #disposeAfter;
    #fetchMethod;
    #memoMethod;
    /**
     * {@link LRUCache.OptionsBase.ttl}
     */
    ttl;
    /**
     * {@link LRUCache.OptionsBase.ttlResolution}
     */
    ttlResolution;
    /**
     * {@link LRUCache.OptionsBase.ttlAutopurge}
     */
    ttlAutopurge;
    /**
     * {@link LRUCache.OptionsBase.updateAgeOnGet}
     */
    updateAgeOnGet;
    /**
     * {@link LRUCache.OptionsBase.updateAgeOnHas}
     */
    updateAgeOnHas;
    /**
     * {@link LRUCache.OptionsBase.allowStale}
     */
    allowStale;
    /**
     * {@link LRUCache.OptionsBase.noDisposeOnSet}
     */
    noDisposeOnSet;
    /**
     * {@link LRUCache.OptionsBase.noUpdateTTL}
     */
    noUpdateTTL;
    /**
     * {@link LRUCache.OptionsBase.maxEntrySize}
     */
    maxEntrySize;
    /**
     * {@link LRUCache.OptionsBase.sizeCalculation}
     */
    sizeCalculation;
    /**
     * {@link LRUCache.OptionsBase.noDeleteOnFetchRejection}
     */
    noDeleteOnFetchRejection;
    /**
     * {@link LRUCache.OptionsBase.noDeleteOnStaleGet}
     */
    noDeleteOnStaleGet;
    /**
     * {@link LRUCache.OptionsBase.allowStaleOnFetchAbort}
     */
    allowStaleOnFetchAbort;
    /**
     * {@link LRUCache.OptionsBase.allowStaleOnFetchRejection}
     */
    allowStaleOnFetchRejection;
    /**
     * {@link LRUCache.OptionsBase.ignoreFetchAbort}
     */
    ignoreFetchAbort;
    // computed properties
    #size;
    #calculatedSize;
    #keyMap;
    #keyList;
    #valList;
    #next;
    #prev;
    #head;
    #tail;
    #free;
    #disposed;
    #sizes;
    #starts;
    #ttls;
    #hasDispose;
    #hasFetchMethod;
    #hasDisposeAfter;
    /**
     * Do not call this method unless you need to inspect the
     * inner workings of the cache.  If anything returned by this
     * object is modified in any way, strange breakage may occur.
     *
     * These fields are private for a reason!
     *
     * @internal
     */
    static unsafeExposeInternals(c) {
        return {
            // properties
            starts: c.#starts,
            ttls: c.#ttls,
            sizes: c.#sizes,
            keyMap: c.#keyMap,
            keyList: c.#keyList,
            valList: c.#valList,
            next: c.#next,
            prev: c.#prev,
            get head() {
                return c.#head;
            },
            get tail() {
                return c.#tail;
            },
            free: c.#free,
            // methods
            isBackgroundFetch: (p) => c.#isBackgroundFetch(p),
            backgroundFetch: (k, index, options, context) => c.#backgroundFetch(k, index, options, context),
            moveToTail: (index) => c.#moveToTail(index),
            indexes: (options) => c.#indexes(options),
            rindexes: (options) => c.#rindexes(options),
            isStale: (index) => c.#isStale(index),
        };
    }
    // Protected read-only members
    /**
     * {@link LRUCache.OptionsBase.max} (read-only)
     */
    get max() {
        return this.#max;
    }
    /**
     * {@link LRUCache.OptionsBase.maxSize} (read-only)
     */
    get maxSize() {
        return this.#maxSize;
    }
    /**
     * The total computed size of items in the cache (read-only)
     */
    get calculatedSize() {
        return this.#calculatedSize;
    }
    /**
     * The number of items stored in the cache (read-only)
     */
    get size() {
        return this.#size;
    }
    /**
     * {@link LRUCache.OptionsBase.fetchMethod} (read-only)
     */
    get fetchMethod() {
        return this.#fetchMethod;
    }
    get memoMethod() {
        return this.#memoMethod;
    }
    /**
     * {@link LRUCache.OptionsBase.dispose} (read-only)
     */
    get dispose() {
        return this.#dispose;
    }
    /**
     * {@link LRUCache.OptionsBase.disposeAfter} (read-only)
     */
    get disposeAfter() {
        return this.#disposeAfter;
    }
    constructor(options) {
        const { max = 0, ttl, ttlResolution = 1, ttlAutopurge, updateAgeOnGet, updateAgeOnHas, allowStale, dispose, disposeAfter, noDisposeOnSet, noUpdateTTL, maxSize = 0, maxEntrySize = 0, sizeCalculation, fetchMethod, memoMethod, noDeleteOnFetchRejection, noDeleteOnStaleGet, allowStaleOnFetchRejection, allowStaleOnFetchAbort, ignoreFetchAbort, } = options;
        if (max !== 0 && !isPosInt(max)) {
            throw new TypeError('max option must be a nonnegative integer');
        }
        const UintArray = max ? getUintArray(max) : Array;
        if (!UintArray) {
            throw new Error('invalid max value: ' + max);
        }
        this.#max = max;
        this.#maxSize = maxSize;
        this.maxEntrySize = maxEntrySize || this.#maxSize;
        this.sizeCalculation = sizeCalculation;
        if (this.sizeCalculation) {
            if (!this.#maxSize && !this.maxEntrySize) {
                throw new TypeError('cannot set sizeCalculation without setting maxSize or maxEntrySize');
            }
            if (typeof this.sizeCalculation !== 'function') {
                throw new TypeError('sizeCalculation set to non-function');
            }
        }
        if (memoMethod !== undefined &&
            typeof memoMethod !== 'function') {
            throw new TypeError('memoMethod must be a function if defined');
        }
        this.#memoMethod = memoMethod;
        if (fetchMethod !== undefined &&
            typeof fetchMethod !== 'function') {
            throw new TypeError('fetchMethod must be a function if specified');
        }
        this.#fetchMethod = fetchMethod;
        this.#hasFetchMethod = !!fetchMethod;
        this.#keyMap = new Map();
        this.#keyList = new Array(max).fill(undefined);
        this.#valList = new Array(max).fill(undefined);
        this.#next = new UintArray(max);
        this.#prev = new UintArray(max);
        this.#head = 0;
        this.#tail = 0;
        this.#free = Stack.create(max);
        this.#size = 0;
        this.#calculatedSize = 0;
        if (typeof dispose === 'function') {
            this.#dispose = dispose;
        }
        if (typeof disposeAfter === 'function') {
            this.#disposeAfter = disposeAfter;
            this.#disposed = [];
        }
        else {
            this.#disposeAfter = undefined;
            this.#disposed = undefined;
        }
        this.#hasDispose = !!this.#dispose;
        this.#hasDisposeAfter = !!this.#disposeAfter;
        this.noDisposeOnSet = !!noDisposeOnSet;
        this.noUpdateTTL = !!noUpdateTTL;
        this.noDeleteOnFetchRejection = !!noDeleteOnFetchRejection;
        this.allowStaleOnFetchRejection = !!allowStaleOnFetchRejection;
        this.allowStaleOnFetchAbort = !!allowStaleOnFetchAbort;
        this.ignoreFetchAbort = !!ignoreFetchAbort;
        // NB: maxEntrySize is set to maxSize if it's set
        if (this.maxEntrySize !== 0) {
            if (this.#maxSize !== 0) {
                if (!isPosInt(this.#maxSize)) {
                    throw new TypeError('maxSize must be a positive integer if specified');
                }
            }
            if (!isPosInt(this.maxEntrySize)) {
                throw new TypeError('maxEntrySize must be a positive integer if specified');
            }
            this.#initializeSizeTracking();
        }
        this.allowStale = !!allowStale;
        this.noDeleteOnStaleGet = !!noDeleteOnStaleGet;
        this.updateAgeOnGet = !!updateAgeOnGet;
        this.updateAgeOnHas = !!updateAgeOnHas;
        this.ttlResolution =
            isPosInt(ttlResolution) || ttlResolution === 0
                ? ttlResolution
                : 1;
        this.ttlAutopurge = !!ttlAutopurge;
        this.ttl = ttl || 0;
        if (this.ttl) {
            if (!isPosInt(this.ttl)) {
                throw new TypeError('ttl must be a positive integer if specified');
            }
            this.#initializeTTLTracking();
        }
        // do not allow completely unbounded caches
        if (this.#max === 0 && this.ttl === 0 && this.#maxSize === 0) {
            throw new TypeError('At least one of max, maxSize, or ttl is required');
        }
        if (!this.ttlAutopurge && !this.#max && !this.#maxSize) {
            const code = 'LRU_CACHE_UNBOUNDED';
            if (shouldWarn(code)) {
                warned.add(code);
                const msg = 'TTL caching without ttlAutopurge, max, or maxSize can ' +
                    'result in unbounded memory consumption.';
                emitWarning(msg, 'UnboundedCacheWarning', code, LRUCache);
            }
        }
    }
    /**
     * Return the number of ms left in the item's TTL. If item is not in cache,
     * returns `0`. Returns `Infinity` if item is in cache without a defined TTL.
     */
    getRemainingTTL(key) {
        return this.#keyMap.has(key) ? Infinity : 0;
    }
    #initializeTTLTracking() {
        const ttls = new ZeroArray(this.#max);
        const starts = new ZeroArray(this.#max);
        this.#ttls = ttls;
        this.#starts = starts;
        this.#setItemTTL = (index, ttl, start = perf.now()) => {
            starts[index] = ttl !== 0 ? start : 0;
            ttls[index] = ttl;
            if (ttl !== 0 && this.ttlAutopurge) {
                const t = setTimeout(() => {
                    if (this.#isStale(index)) {
                        this.#delete(this.#keyList[index], 'expire');
                    }
                }, ttl + 1);
                // unref() not supported on all platforms
                /* c8 ignore start */
                if (t.unref) {
                    t.unref();
                }
                /* c8 ignore stop */
            }
        };
        this.#updateItemAge = index => {
            starts[index] = ttls[index] !== 0 ? perf.now() : 0;
        };
        this.#statusTTL = (status, index) => {
            if (ttls[index]) {
                const ttl = ttls[index];
                const start = starts[index];
                /* c8 ignore next */
                if (!ttl || !start)
                    return;
                status.ttl = ttl;
                status.start = start;
                status.now = cachedNow || getNow();
                const age = status.now - start;
                status.remainingTTL = ttl - age;
            }
        };
        // debounce calls to perf.now() to 1s so we're not hitting
        // that costly call repeatedly.
        let cachedNow = 0;
        const getNow = () => {
            const n = perf.now();
            if (this.ttlResolution > 0) {
                cachedNow = n;
                const t = setTimeout(() => (cachedNow = 0), this.ttlResolution);
                // not available on all platforms
                /* c8 ignore start */
                if (t.unref) {
                    t.unref();
                }
                /* c8 ignore stop */
            }
            return n;
        };
        this.getRemainingTTL = key => {
            const index = this.#keyMap.get(key);
            if (index === undefined) {
                return 0;
            }
            const ttl = ttls[index];
            const start = starts[index];
            if (!ttl || !start) {
                return Infinity;
            }
            const age = (cachedNow || getNow()) - start;
            return ttl - age;
        };
        this.#isStale = index => {
            const s = starts[index];
            const t = ttls[index];
            return !!t && !!s && (cachedNow || getNow()) - s > t;
        };
    }
    // conditionally set private methods related to TTL
    #updateItemAge = () => { };
    #statusTTL = () => { };
    #setItemTTL = () => { };
    /* c8 ignore stop */
    #isStale = () => false;
    #initializeSizeTracking() {
        const sizes = new ZeroArray(this.#max);
        this.#calculatedSize = 0;
        this.#sizes = sizes;
        this.#removeItemSize = index => {
            this.#calculatedSize -= sizes[index];
            sizes[index] = 0;
        };
        this.#requireSize = (k, v, size, sizeCalculation) => {
            // provisionally accept background fetches.
            // actual value size will be checked when they return.
            if (this.#isBackgroundFetch(v)) {
                return 0;
            }
            if (!isPosInt(size)) {
                if (sizeCalculation) {
                    if (typeof sizeCalculation !== 'function') {
                        throw new TypeError('sizeCalculation must be a function');
                    }
                    size = sizeCalculation(v, k);
                    if (!isPosInt(size)) {
                        throw new TypeError('sizeCalculation return invalid (expect positive integer)');
                    }
                }
                else {
                    throw new TypeError('invalid size value (must be positive integer). ' +
                        'When maxSize or maxEntrySize is used, sizeCalculation ' +
                        'or size must be set.');
                }
            }
            return size;
        };
        this.#addItemSize = (index, size, status) => {
            sizes[index] = size;
            if (this.#maxSize) {
                const maxSize = this.#maxSize - sizes[index];
                while (this.#calculatedSize > maxSize) {
                    this.#evict(true);
                }
            }
            this.#calculatedSize += sizes[index];
            if (status) {
                status.entrySize = size;
                status.totalCalculatedSize = this.#calculatedSize;
            }
        };
    }
    #removeItemSize = _i => { };
    #addItemSize = (_i, _s, _st) => { };
    #requireSize = (_k, _v, size, sizeCalculation) => {
        if (size || sizeCalculation) {
            throw new TypeError('cannot set size without setting maxSize or maxEntrySize on cache');
        }
        return 0;
    };
    *#indexes({ allowStale = this.allowStale } = {}) {
        if (this.#size) {
            for (let i = this.#tail; true;) {
                if (!this.#isValidIndex(i)) {
                    break;
                }
                if (allowStale || !this.#isStale(i)) {
                    yield i;
                }
                if (i === this.#head) {
                    break;
                }
                else {
                    i = this.#prev[i];
                }
            }
        }
    }
    *#rindexes({ allowStale = this.allowStale } = {}) {
        if (this.#size) {
            for (let i = this.#head; true;) {
                if (!this.#isValidIndex(i)) {
                    break;
                }
                if (allowStale || !this.#isStale(i)) {
                    yield i;
                }
                if (i === this.#tail) {
                    break;
                }
                else {
                    i = this.#next[i];
                }
            }
        }
    }
    #isValidIndex(index) {
        return (index !== undefined &&
            this.#keyMap.get(this.#keyList[index]) === index);
    }
    /**
     * Return a generator yielding `[key, value]` pairs,
     * in order from most recently used to least recently used.
     */
    *entries() {
        for (const i of this.#indexes()) {
            if (this.#valList[i] !== undefined &&
                this.#keyList[i] !== undefined &&
                !this.#isBackgroundFetch(this.#valList[i])) {
                yield [this.#keyList[i], this.#valList[i]];
            }
        }
    }
    /**
     * Inverse order version of {@link LRUCache.entries}
     *
     * Return a generator yielding `[key, value]` pairs,
     * in order from least recently used to most recently used.
     */
    *rentries() {
        for (const i of this.#rindexes()) {
            if (this.#valList[i] !== undefined &&
                this.#keyList[i] !== undefined &&
                !this.#isBackgroundFetch(this.#valList[i])) {
                yield [this.#keyList[i], this.#valList[i]];
            }
        }
    }
    /**
     * Return a generator yielding the keys in the cache,
     * in order from most recently used to least recently used.
     */
    *keys() {
        for (const i of this.#indexes()) {
            const k = this.#keyList[i];
            if (k !== undefined &&
                !this.#isBackgroundFetch(this.#valList[i])) {
                yield k;
            }
        }
    }
    /**
     * Inverse order version of {@link LRUCache.keys}
     *
     * Return a generator yielding the keys in the cache,
     * in order from least recently used to most recently used.
     */
    *rkeys() {
        for (const i of this.#rindexes()) {
            const k = this.#keyList[i];
            if (k !== undefined &&
                !this.#isBackgroundFetch(this.#valList[i])) {
                yield k;
            }
        }
    }
    /**
     * Return a generator yielding the values in the cache,
     * in order from most recently used to least recently used.
     */
    *values() {
        for (const i of this.#indexes()) {
            const v = this.#valList[i];
            if (v !== undefined &&
                !this.#isBackgroundFetch(this.#valList[i])) {
                yield this.#valList[i];
            }
        }
    }
    /**
     * Inverse order version of {@link LRUCache.values}
     *
     * Return a generator yielding the values in the cache,
     * in order from least recently used to most recently used.
     */
    *rvalues() {
        for (const i of this.#rindexes()) {
            const v = this.#valList[i];
            if (v !== undefined &&
                !this.#isBackgroundFetch(this.#valList[i])) {
                yield this.#valList[i];
            }
        }
    }
    /**
     * Iterating over the cache itself yields the same results as
     * {@link LRUCache.entries}
     */
    [Symbol.iterator]() {
        return this.entries();
    }
    /**
     * A String value that is used in the creation of the default string
     * description of an object. Called by the built-in method
     * `Object.prototype.toString`.
     */
    [Symbol.toStringTag] = 'LRUCache';
    /**
     * Find a value for which the supplied fn method returns a truthy value,
     * similar to `Array.find()`. fn is called as `fn(value, key, cache)`.
     */
    find(fn, getOptions = {}) {
        for (const i of this.#indexes()) {
            const v = this.#valList[i];
            const value = this.#isBackgroundFetch(v)
                ? v.__staleWhileFetching
                : v;
            if (value === undefined)
                continue;
            if (fn(value, this.#keyList[i], this)) {
                return this.get(this.#keyList[i], getOptions);
            }
        }
    }
    /**
     * Call the supplied function on each item in the cache, in order from most
     * recently used to least recently used.
     *
     * `fn` is called as `fn(value, key, cache)`.
     *
     * If `thisp` is provided, function will be called in the `this`-context of
     * the provided object, or the cache if no `thisp` object is provided.
     *
     * Does not update age or recenty of use, or iterate over stale values.
     */
    forEach(fn, thisp = this) {
        for (const i of this.#indexes()) {
            const v = this.#valList[i];
            const value = this.#isBackgroundFetch(v)
                ? v.__staleWhileFetching
                : v;
            if (value === undefined)
                continue;
            fn.call(thisp, value, this.#keyList[i], this);
        }
    }
    /**
     * The same as {@link LRUCache.forEach} but items are iterated over in
     * reverse order.  (ie, less recently used items are iterated over first.)
     */
    rforEach(fn, thisp = this) {
        for (const i of this.#rindexes()) {
            const v = this.#valList[i];
            const value = this.#isBackgroundFetch(v)
                ? v.__staleWhileFetching
                : v;
            if (value === undefined)
                continue;
            fn.call(thisp, value, this.#keyList[i], this);
        }
    }
    /**
     * Delete any stale entries. Returns true if anything was removed,
     * false otherwise.
     */
    purgeStale() {
        let deleted = false;
        for (const i of this.#rindexes({ allowStale: true })) {
            if (this.#isStale(i)) {
                this.#delete(this.#keyList[i], 'expire');
                deleted = true;
            }
        }
        return deleted;
    }
    /**
     * Get the extended info about a given entry, to get its value, size, and
     * TTL info simultaneously. Returns `undefined` if the key is not present.
     *
     * Unlike {@link LRUCache#dump}, which is designed to be portable and survive
     * serialization, the `start` value is always the current timestamp, and the
     * `ttl` is a calculated remaining time to live (negative if expired).
     *
     * Always returns stale values, if their info is found in the cache, so be
     * sure to check for expirations (ie, a negative {@link LRUCache.Entry#ttl})
     * if relevant.
     */
    info(key) {
        const i = this.#keyMap.get(key);
        if (i === undefined)
            return undefined;
        const v = this.#valList[i];
        const value = this.#isBackgroundFetch(v)
            ? v.__staleWhileFetching
            : v;
        if (value === undefined)
            return undefined;
        const entry = { value };
        if (this.#ttls && this.#starts) {
            const ttl = this.#ttls[i];
            const start = this.#starts[i];
            if (ttl && start) {
                const remain = ttl - (perf.now() - start);
                entry.ttl = remain;
                entry.start = Date.now();
            }
        }
        if (this.#sizes) {
            entry.size = this.#sizes[i];
        }
        return entry;
    }
    /**
     * Return an array of [key, {@link LRUCache.Entry}] tuples which can be
     * passed to {@link LRUCache#load}.
     *
     * The `start` fields are calculated relative to a portable `Date.now()`
     * timestamp, even if `performance.now()` is available.
     *
     * Stale entries are always included in the `dump`, even if
     * {@link LRUCache.OptionsBase.allowStale} is false.
     *
     * Note: this returns an actual array, not a generator, so it can be more
     * easily passed around.
     */
    dump() {
        const arr = [];
        for (const i of this.#indexes({ allowStale: true })) {
            const key = this.#keyList[i];
            const v = this.#valList[i];
            const value = this.#isBackgroundFetch(v)
                ? v.__staleWhileFetching
                : v;
            if (value === undefined || key === undefined)
                continue;
            const entry = { value };
            if (this.#ttls && this.#starts) {
                entry.ttl = this.#ttls[i];
                // always dump the start relative to a portable timestamp
                // it's ok for this to be a bit slow, it's a rare operation.
                const age = perf.now() - this.#starts[i];
                entry.start = Math.floor(Date.now() - age);
            }
            if (this.#sizes) {
                entry.size = this.#sizes[i];
            }
            arr.unshift([key, entry]);
        }
        return arr;
    }
    /**
     * Reset the cache and load in the items in entries in the order listed.
     *
     * The shape of the resulting cache may be different if the same options are
     * not used in both caches.
     *
     * The `start` fields are assumed to be calculated relative to a portable
     * `Date.now()` timestamp, even if `performance.now()` is available.
     */
    load(arr) {
        this.clear();
        for (const [key, entry] of arr) {
            if (entry.start) {
                // entry.start is a portable timestamp, but we may be using
                // node's performance.now(), so calculate the offset, so that
                // we get the intended remaining TTL, no matter how long it's
                // been on ice.
                //
                // it's ok for this to be a bit slow, it's a rare operation.
                const age = Date.now() - entry.start;
                entry.start = perf.now() - age;
            }
            this.set(key, entry.value, entry);
        }
    }
    /**
     * Add a value to the cache.
     *
     * Note: if `undefined` is specified as a value, this is an alias for
     * {@link LRUCache#delete}
     *
     * Fields on the {@link LRUCache.SetOptions} options param will override
     * their corresponding values in the constructor options for the scope
     * of this single `set()` operation.
     *
     * If `start` is provided, then that will set the effective start
     * time for the TTL calculation. Note that this must be a previous
     * value of `performance.now()` if supported, or a previous value of
     * `Date.now()` if not.
     *
     * Options object may also include `size`, which will prevent
     * calling the `sizeCalculation` function and just use the specified
     * number if it is a positive integer, and `noDisposeOnSet` which
     * will prevent calling a `dispose` function in the case of
     * overwrites.
     *
     * If the `size` (or return value of `sizeCalculation`) for a given
     * entry is greater than `maxEntrySize`, then the item will not be
     * added to the cache.
     *
     * Will update the recency of the entry.
     *
     * If the value is `undefined`, then this is an alias for
     * `cache.delete(key)`. `undefined` is never stored in the cache.
     */
    set(k, v, setOptions = {}) {
        if (v === undefined) {
            this.delete(k);
            return this;
        }
        const { ttl = this.ttl, start, noDisposeOnSet = this.noDisposeOnSet, sizeCalculation = this.sizeCalculation, status, } = setOptions;
        let { noUpdateTTL = this.noUpdateTTL } = setOptions;
        const size = this.#requireSize(k, v, setOptions.size || 0, sizeCalculation);
        // if the item doesn't fit, don't do anything
        // NB: maxEntrySize set to maxSize by default
        if (this.maxEntrySize && size > this.maxEntrySize) {
            if (status) {
                status.set = 'miss';
                status.maxEntrySizeExceeded = true;
            }
            // have to delete, in case something is there already.
            this.#delete(k, 'set');
            return this;
        }
        let index = this.#size === 0 ? undefined : this.#keyMap.get(k);
        if (index === undefined) {
            // addition
            index = (this.#size === 0
                ? this.#tail
                : this.#free.length !== 0
                    ? this.#free.pop()
                    : this.#size === this.#max
                        ? this.#evict(false)
                        : this.#size);
            this.#keyList[index] = k;
            this.#valList[index] = v;
            this.#keyMap.set(k, index);
            this.#next[this.#tail] = index;
            this.#prev[index] = this.#tail;
            this.#tail = index;
            this.#size++;
            this.#addItemSize(index, size, status);
            if (status)
                status.set = 'add';
            noUpdateTTL = false;
        }
        else {
            // update
            this.#moveToTail(index);
            const oldVal = this.#valList[index];
            if (v !== oldVal) {
                if (this.#hasFetchMethod && this.#isBackgroundFetch(oldVal)) {
                    oldVal.__abortController.abort(new Error('replaced'));
                    const { __staleWhileFetching: s } = oldVal;
                    if (s !== undefined && !noDisposeOnSet) {
                        if (this.#hasDispose) {
                            this.#dispose?.(s, k, 'set');
                        }
                        if (this.#hasDisposeAfter) {
                            this.#disposed?.push([s, k, 'set']);
                        }
                    }
                }
                else if (!noDisposeOnSet) {
                    if (this.#hasDispose) {
                        this.#dispose?.(oldVal, k, 'set');
                    }
                    if (this.#hasDisposeAfter) {
                        this.#disposed?.push([oldVal, k, 'set']);
                    }
                }
                this.#removeItemSize(index);
                this.#addItemSize(index, size, status);
                this.#valList[index] = v;
                if (status) {
                    status.set = 'replace';
                    const oldValue = oldVal && this.#isBackgroundFetch(oldVal)
                        ? oldVal.__staleWhileFetching
                        : oldVal;
                    if (oldValue !== undefined)
                        status.oldValue = oldValue;
                }
            }
            else if (status) {
                status.set = 'update';
            }
        }
        if (ttl !== 0 && !this.#ttls) {
            this.#initializeTTLTracking();
        }
        if (this.#ttls) {
            if (!noUpdateTTL) {
                this.#setItemTTL(index, ttl, start);
            }
            if (status)
                this.#statusTTL(status, index);
        }
        if (!noDisposeOnSet && this.#hasDisposeAfter && this.#disposed) {
            const dt = this.#disposed;
            let task;
            while ((task = dt?.shift())) {
                this.#disposeAfter?.(...task);
            }
        }
        return this;
    }
    /**
     * Evict the least recently used item, returning its value or
     * `undefined` if cache is empty.
     */
    pop() {
        try {
            while (this.#size) {
                const val = this.#valList[this.#head];
                this.#evict(true);
                if (this.#isBackgroundFetch(val)) {
                    if (val.__staleWhileFetching) {
                        return val.__staleWhileFetching;
                    }
                }
                else if (val !== undefined) {
                    return val;
                }
            }
        }
        finally {
            if (this.#hasDisposeAfter && this.#disposed) {
                const dt = this.#disposed;
                let task;
                while ((task = dt?.shift())) {
                    this.#disposeAfter?.(...task);
                }
            }
        }
    }
    #evict(free) {
        const head = this.#head;
        const k = this.#keyList[head];
        const v = this.#valList[head];
        if (this.#hasFetchMethod && this.#isBackgroundFetch(v)) {
            v.__abortController.abort(new Error('evicted'));
        }
        else if (this.#hasDispose || this.#hasDisposeAfter) {
            if (this.#hasDispose) {
                this.#dispose?.(v, k, 'evict');
            }
            if (this.#hasDisposeAfter) {
                this.#disposed?.push([v, k, 'evict']);
            }
        }
        this.#removeItemSize(head);
        // if we aren't about to use the index, then null these out
        if (free) {
            this.#keyList[head] = undefined;
            this.#valList[head] = undefined;
            this.#free.push(head);
        }
        if (this.#size === 1) {
            this.#head = this.#tail = 0;
            this.#free.length = 0;
        }
        else {
            this.#head = this.#next[head];
        }
        this.#keyMap.delete(k);
        this.#size--;
        return head;
    }
    /**
     * Check if a key is in the cache, without updating the recency of use.
     * Will return false if the item is stale, even though it is technically
     * in the cache.
     *
     * Check if a key is in the cache, without updating the recency of
     * use. Age is updated if {@link LRUCache.OptionsBase.updateAgeOnHas} is set
     * to `true` in either the options or the constructor.
     *
     * Will return `false` if the item is stale, even though it is technically in
     * the cache. The difference can be determined (if it matters) by using a
     * `status` argument, and inspecting the `has` field.
     *
     * Will not update item age unless
     * {@link LRUCache.OptionsBase.updateAgeOnHas} is set.
     */
    has(k, hasOptions = {}) {
        const { updateAgeOnHas = this.updateAgeOnHas, status } = hasOptions;
        const index = this.#keyMap.get(k);
        if (index !== undefined) {
            const v = this.#valList[index];
            if (this.#isBackgroundFetch(v) &&
                v.__staleWhileFetching === undefined) {
                return false;
            }
            if (!this.#isStale(index)) {
                if (updateAgeOnHas) {
                    this.#updateItemAge(index);
                }
                if (status) {
                    status.has = 'hit';
                    this.#statusTTL(status, index);
                }
                return true;
            }
            else if (status) {
                status.has = 'stale';
                this.#statusTTL(status, index);
            }
        }
        else if (status) {
            status.has = 'miss';
        }
        return false;
    }
    /**
     * Like {@link LRUCache#get} but doesn't update recency or delete stale
     * items.
     *
     * Returns `undefined` if the item is stale, unless
     * {@link LRUCache.OptionsBase.allowStale} is set.
     */
    peek(k, peekOptions = {}) {
        const { allowStale = this.allowStale } = peekOptions;
        const index = this.#keyMap.get(k);
        if (index === undefined ||
            (!allowStale && this.#isStale(index))) {
            return;
        }
        const v = this.#valList[index];
        // either stale and allowed, or forcing a refresh of non-stale value
        return this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v;
    }
    #backgroundFetch(k, index, options, context) {
        const v = index === undefined ? undefined : this.#valList[index];
        if (this.#isBackgroundFetch(v)) {
            return v;
        }
        const ac = new AC();
        const { signal } = options;
        // when/if our AC signals, then stop listening to theirs.
        signal?.addEventListener('abort', () => ac.abort(signal.reason), {
            signal: ac.signal,
        });
        const fetchOpts = {
            signal: ac.signal,
            options,
            context,
        };
        const cb = (v, updateCache = false) => {
            const { aborted } = ac.signal;
            const ignoreAbort = options.ignoreFetchAbort && v !== undefined;
            if (options.status) {
                if (aborted && !updateCache) {
                    options.status.fetchAborted = true;
                    options.status.fetchError = ac.signal.reason;
                    if (ignoreAbort)
                        options.status.fetchAbortIgnored = true;
                }
                else {
                    options.status.fetchResolved = true;
                }
            }
            if (aborted && !ignoreAbort && !updateCache) {
                return fetchFail(ac.signal.reason);
            }
            // either we didn't abort, and are still here, or we did, and ignored
            const bf = p;
            if (this.#valList[index] === p) {
                if (v === undefined) {
                    if (bf.__staleWhileFetching) {
                        this.#valList[index] = bf.__staleWhileFetching;
                    }
                    else {
                        this.#delete(k, 'fetch');
                    }
                }
                else {
                    if (options.status)
                        options.status.fetchUpdated = true;
                    this.set(k, v, fetchOpts.options);
                }
            }
            return v;
        };
        const eb = (er) => {
            if (options.status) {
                options.status.fetchRejected = true;
                options.status.fetchError = er;
            }
            return fetchFail(er);
        };
        const fetchFail = (er) => {
            const { aborted } = ac.signal;
            const allowStaleAborted = aborted && options.allowStaleOnFetchAbort;
            const allowStale = allowStaleAborted || options.allowStaleOnFetchRejection;
            const noDelete = allowStale || options.noDeleteOnFetchRejection;
            const bf = p;
            if (this.#valList[index] === p) {
                // if we allow stale on fetch rejections, then we need to ensure that
                // the stale value is not removed from the cache when the fetch fails.
                const del = !noDelete || bf.__staleWhileFetching === undefined;
                if (del) {
                    this.#delete(k, 'fetch');
                }
                else if (!allowStaleAborted) {
                    // still replace the *promise* with the stale value,
                    // since we are done with the promise at this point.
                    // leave it untouched if we're still waiting for an
                    // aborted background fetch that hasn't yet returned.
                    this.#valList[index] = bf.__staleWhileFetching;
                }
            }
            if (allowStale) {
                if (options.status && bf.__staleWhileFetching !== undefined) {
                    options.status.returnedStale = true;
                }
                return bf.__staleWhileFetching;
            }
            else if (bf.__returned === bf) {
                throw er;
            }
        };
        const pcall = (res, rej) => {
            const fmp = this.#fetchMethod?.(k, v, fetchOpts);
            if (fmp && fmp instanceof Promise) {
                fmp.then(v => res(v === undefined ? undefined : v), rej);
            }
            // ignored, we go until we finish, regardless.
            // defer check until we are actually aborting,
            // so fetchMethod can override.
            ac.signal.addEventListener('abort', () => {
                if (!options.ignoreFetchAbort ||
                    options.allowStaleOnFetchAbort) {
                    res(undefined);
                    // when it eventually resolves, update the cache.
                    if (options.allowStaleOnFetchAbort) {
                        res = v => cb(v, true);
                    }
                }
            });
        };
        if (options.status)
            options.status.fetchDispatched = true;
        const p = new Promise(pcall).then(cb, eb);
        const bf = Object.assign(p, {
            __abortController: ac,
            __staleWhileFetching: v,
            __returned: undefined,
        });
        if (index === undefined) {
            // internal, don't expose status.
            this.set(k, bf, { ...fetchOpts.options, status: undefined });
            index = this.#keyMap.get(k);
        }
        else {
            this.#valList[index] = bf;
        }
        return bf;
    }
    #isBackgroundFetch(p) {
        if (!this.#hasFetchMethod)
            return false;
        const b = p;
        return (!!b &&
            b instanceof Promise &&
            b.hasOwnProperty('__staleWhileFetching') &&
            b.__abortController instanceof AC);
    }
    async fetch(k, fetchOptions = {}) {
        const { 
        // get options
        allowStale = this.allowStale, updateAgeOnGet = this.updateAgeOnGet, noDeleteOnStaleGet = this.noDeleteOnStaleGet, 
        // set options
        ttl = this.ttl, noDisposeOnSet = this.noDisposeOnSet, size = 0, sizeCalculation = this.sizeCalculation, noUpdateTTL = this.noUpdateTTL, 
        // fetch exclusive options
        noDeleteOnFetchRejection = this.noDeleteOnFetchRejection, allowStaleOnFetchRejection = this.allowStaleOnFetchRejection, ignoreFetchAbort = this.ignoreFetchAbort, allowStaleOnFetchAbort = this.allowStaleOnFetchAbort, context, forceRefresh = false, status, signal, } = fetchOptions;
        if (!this.#hasFetchMethod) {
            if (status)
                status.fetch = 'get';
            return this.get(k, {
                allowStale,
                updateAgeOnGet,
                noDeleteOnStaleGet,
                status,
            });
        }
        const options = {
            allowStale,
            updateAgeOnGet,
            noDeleteOnStaleGet,
            ttl,
            noDisposeOnSet,
            size,
            sizeCalculation,
            noUpdateTTL,
            noDeleteOnFetchRejection,
            allowStaleOnFetchRejection,
            allowStaleOnFetchAbort,
            ignoreFetchAbort,
            status,
            signal,
        };
        let index = this.#keyMap.get(k);
        if (index === undefined) {
            if (status)
                status.fetch = 'miss';
            const p = this.#backgroundFetch(k, index, options, context);
            return (p.__returned = p);
        }
        else {
            // in cache, maybe already fetching
            const v = this.#valList[index];
            if (this.#isBackgroundFetch(v)) {
                const stale = allowStale && v.__staleWhileFetching !== undefined;
                if (status) {
                    status.fetch = 'inflight';
                    if (stale)
                        status.returnedStale = true;
                }
                return stale ? v.__staleWhileFetching : (v.__returned = v);
            }
            // if we force a refresh, that means do NOT serve the cached value,
            // unless we are already in the process of refreshing the cache.
            const isStale = this.#isStale(index);
            if (!forceRefresh && !isStale) {
                if (status)
                    status.fetch = 'hit';
                this.#moveToTail(index);
                if (updateAgeOnGet) {
                    this.#updateItemAge(index);
                }
                if (status)
                    this.#statusTTL(status, index);
                return v;
            }
            // ok, it is stale or a forced refresh, and not already fetching.
            // refresh the cache.
            const p = this.#backgroundFetch(k, index, options, context);
            const hasStale = p.__staleWhileFetching !== undefined;
            const staleVal = hasStale && allowStale;
            if (status) {
                status.fetch = isStale ? 'stale' : 'refresh';
                if (staleVal && isStale)
                    status.returnedStale = true;
            }
            return staleVal ? p.__staleWhileFetching : (p.__returned = p);
        }
    }
    async forceFetch(k, fetchOptions = {}) {
        const v = await this.fetch(k, fetchOptions);
        if (v === undefined)
            throw new Error('fetch() returned undefined');
        return v;
    }
    memo(k, memoOptions = {}) {
        const memoMethod = this.#memoMethod;
        if (!memoMethod) {
            throw new Error('no memoMethod provided to constructor');
        }
        const { context, forceRefresh, ...options } = memoOptions;
        const v = this.get(k, options);
        if (!forceRefresh && v !== undefined)
            return v;
        const vv = memoMethod(k, v, {
            options,
            context,
        });
        this.set(k, vv, options);
        return vv;
    }
    /**
     * Return a value from the cache. Will update the recency of the cache
     * entry found.
     *
     * If the key is not found, get() will return `undefined`.
     */
    get(k, getOptions = {}) {
        const { allowStale = this.allowStale, updateAgeOnGet = this.updateAgeOnGet, noDeleteOnStaleGet = this.noDeleteOnStaleGet, status, } = getOptions;
        const index = this.#keyMap.get(k);
        if (index !== undefined) {
            const value = this.#valList[index];
            const fetching = this.#isBackgroundFetch(value);
            if (status)
                this.#statusTTL(status, index);
            if (this.#isStale(index)) {
                if (status)
                    status.get = 'stale';
                // delete only if not an in-flight background fetch
                if (!fetching) {
                    if (!noDeleteOnStaleGet) {
                        this.#delete(k, 'expire');
                    }
                    if (status && allowStale)
                        status.returnedStale = true;
                    return allowStale ? value : undefined;
                }
                else {
                    if (status &&
                        allowStale &&
                        value.__staleWhileFetching !== undefined) {
                        status.returnedStale = true;
                    }
                    return allowStale ? value.__staleWhileFetching : undefined;
                }
            }
            else {
                if (status)
                    status.get = 'hit';
                // if we're currently fetching it, we don't actually have it yet
                // it's not stale, which means this isn't a staleWhileRefetching.
                // If it's not stale, and fetching, AND has a __staleWhileFetching
                // value, then that means the user fetched with {forceRefresh:true},
                // so it's safe to return that value.
                if (fetching) {
                    return value.__staleWhileFetching;
                }
                this.#moveToTail(index);
                if (updateAgeOnGet) {
                    this.#updateItemAge(index);
                }
                return value;
            }
        }
        else if (status) {
            status.get = 'miss';
        }
    }
    #connect(p, n) {
        this.#prev[n] = p;
        this.#next[p] = n;
    }
    #moveToTail(index) {
        // if tail already, nothing to do
        // if head, move head to next[index]
        // else
        //   move next[prev[index]] to next[index] (head has no prev)
        //   move prev[next[index]] to prev[index]
        // prev[index] = tail
        // next[tail] = index
        // tail = index
        if (index !== this.#tail) {
            if (index === this.#head) {
                this.#head = this.#next[index];
            }
            else {
                this.#connect(this.#prev[index], this.#next[index]);
            }
            this.#connect(this.#tail, index);
            this.#tail = index;
        }
    }
    /**
     * Deletes a key out of the cache.
     *
     * Returns true if the key was deleted, false otherwise.
     */
    delete(k) {
        return this.#delete(k, 'delete');
    }
    #delete(k, reason) {
        let deleted = false;
        if (this.#size !== 0) {
            const index = this.#keyMap.get(k);
            if (index !== undefined) {
                deleted = true;
                if (this.#size === 1) {
                    this.#clear(reason);
                }
                else {
                    this.#removeItemSize(index);
                    const v = this.#valList[index];
                    if (this.#isBackgroundFetch(v)) {
                        v.__abortController.abort(new Error('deleted'));
                    }
                    else if (this.#hasDispose || this.#hasDisposeAfter) {
                        if (this.#hasDispose) {
                            this.#dispose?.(v, k, reason);
                        }
                        if (this.#hasDisposeAfter) {
                            this.#disposed?.push([v, k, reason]);
                        }
                    }
                    this.#keyMap.delete(k);
                    this.#keyList[index] = undefined;
                    this.#valList[index] = undefined;
                    if (index === this.#tail) {
                        this.#tail = this.#prev[index];
                    }
                    else if (index === this.#head) {
                        this.#head = this.#next[index];
                    }
                    else {
                        const pi = this.#prev[index];
                        this.#next[pi] = this.#next[index];
                        const ni = this.#next[index];
                        this.#prev[ni] = this.#prev[index];
                    }
                    this.#size--;
                    this.#free.push(index);
                }
            }
        }
        if (this.#hasDisposeAfter && this.#disposed?.length) {
            const dt = this.#disposed;
            let task;
            while ((task = dt?.shift())) {
                this.#disposeAfter?.(...task);
            }
        }
        return deleted;
    }
    /**
     * Clear the cache entirely, throwing away all values.
     */
    clear() {
        return this.#clear('delete');
    }
    #clear(reason) {
        for (const index of this.#rindexes({ allowStale: true })) {
            const v = this.#valList[index];
            if (this.#isBackgroundFetch(v)) {
                v.__abortController.abort(new Error('deleted'));
            }
            else {
                const k = this.#keyList[index];
                if (this.#hasDispose) {
                    this.#dispose?.(v, k, reason);
                }
                if (this.#hasDisposeAfter) {
                    this.#disposed?.push([v, k, reason]);
                }
            }
        }
        this.#keyMap.clear();
        this.#valList.fill(undefined);
        this.#keyList.fill(undefined);
        if (this.#ttls && this.#starts) {
            this.#ttls.fill(0);
            this.#starts.fill(0);
        }
        if (this.#sizes) {
            this.#sizes.fill(0);
        }
        this.#head = 0;
        this.#tail = 0;
        this.#free.length = 0;
        this.#calculatedSize = 0;
        this.#size = 0;
        if (this.#hasDisposeAfter && this.#disposed) {
            const dt = this.#disposed;
            let task;
            while ((task = dt?.shift())) {
                this.#disposeAfter?.(...task);
            }
        }
    }
}


/***/ }),

/***/ 51851:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   yu: () => (/* binding */ fromZodError)
/* harmony export */ });
/* unused harmony exports ValidationError, createMessageBuilder, errorMap, fromError, fromZodIssue, isValidationError, isValidationErrorLike, isZodErrorLike, toValidationError */
/* harmony import */ var zod__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(69509);
// lib/isZodErrorLike.ts
function isZodErrorLike(err) {
  return err instanceof Error && err.name === "ZodError" && "issues" in err && Array.isArray(err.issues);
}

// lib/ValidationError.ts
var ValidationError = class extends Error {
  name;
  details;
  constructor(message, options) {
    super(message, options);
    this.name = "ZodValidationError";
    this.details = getIssuesFromErrorOptions(options);
  }
  toString() {
    return this.message;
  }
};
function getIssuesFromErrorOptions(options) {
  if (options) {
    const cause = options.cause;
    if (isZodErrorLike(cause)) {
      return cause.issues;
    }
  }
  return [];
}

// lib/isValidationError.ts
function isValidationError(err) {
  return err instanceof ValidationError;
}

// lib/isValidationErrorLike.ts
function isValidationErrorLike(err) {
  return err instanceof Error && err.name === "ZodValidationError";
}

// lib/fromZodIssue.ts


// lib/MessageBuilder.ts


// lib/utils/NonEmptyArray.ts
function isNonEmptyArray(value) {
  return value.length !== 0;
}

// lib/utils/joinPath.ts
var identifierRegex = /[$_\p{ID_Start}][$\u200c\u200d\p{ID_Continue}]*/u;
function joinPath(path) {
  if (path.length === 1) {
    return path[0].toString();
  }
  return path.reduce((acc, item) => {
    if (typeof item === "number") {
      return acc + "[" + item.toString() + "]";
    }
    if (item.includes('"')) {
      return acc + '["' + escapeQuotes(item) + '"]';
    }
    if (!identifierRegex.test(item)) {
      return acc + '["' + item + '"]';
    }
    const separator = acc.length === 0 ? "" : ".";
    return acc + separator + item;
  }, "");
}
function escapeQuotes(str) {
  return str.replace(/"/g, '\\"');
}

// lib/config.ts
var ISSUE_SEPARATOR = "; ";
var MAX_ISSUES_IN_MESSAGE = 99;
var PREFIX = "Validation error";
var PREFIX_SEPARATOR = ": ";
var UNION_SEPARATOR = ", or ";

// lib/MessageBuilder.ts
function createMessageBuilder(props = {}) {
  const {
    issueSeparator = ISSUE_SEPARATOR,
    unionSeparator = UNION_SEPARATOR,
    prefixSeparator = PREFIX_SEPARATOR,
    prefix = PREFIX,
    includePath = true,
    maxIssuesInMessage = MAX_ISSUES_IN_MESSAGE
  } = props;
  return (issues) => {
    const message = issues.slice(0, maxIssuesInMessage).map(
      (issue) => getMessageFromZodIssue({
        issue,
        issueSeparator,
        unionSeparator,
        includePath
      })
    ).join(issueSeparator);
    return prefixMessage(message, prefix, prefixSeparator);
  };
}
function getMessageFromZodIssue(props) {
  const { issue, issueSeparator, unionSeparator, includePath } = props;
  if (issue.code === zod__WEBPACK_IMPORTED_MODULE_0__/* .ZodIssueCode */ .eq.invalid_union) {
    return issue.unionErrors.reduce((acc, zodError) => {
      const newIssues = zodError.issues.map(
        (issue2) => getMessageFromZodIssue({
          issue: issue2,
          issueSeparator,
          unionSeparator,
          includePath
        })
      ).join(issueSeparator);
      if (!acc.includes(newIssues)) {
        acc.push(newIssues);
      }
      return acc;
    }, []).join(unionSeparator);
  }
  if (issue.code === zod__WEBPACK_IMPORTED_MODULE_0__/* .ZodIssueCode */ .eq.invalid_arguments) {
    return [
      issue.message,
      ...issue.argumentsError.issues.map(
        (issue2) => getMessageFromZodIssue({
          issue: issue2,
          issueSeparator,
          unionSeparator,
          includePath
        })
      )
    ].join(issueSeparator);
  }
  if (issue.code === zod__WEBPACK_IMPORTED_MODULE_0__/* .ZodIssueCode */ .eq.invalid_return_type) {
    return [
      issue.message,
      ...issue.returnTypeError.issues.map(
        (issue2) => getMessageFromZodIssue({
          issue: issue2,
          issueSeparator,
          unionSeparator,
          includePath
        })
      )
    ].join(issueSeparator);
  }
  if (includePath && isNonEmptyArray(issue.path)) {
    if (issue.path.length === 1) {
      const identifier = issue.path[0];
      if (typeof identifier === "number") {
        return `${issue.message} at index ${identifier}`;
      }
    }
    return `${issue.message} at "${joinPath(issue.path)}"`;
  }
  return issue.message;
}
function prefixMessage(message, prefix, prefixSeparator) {
  if (prefix !== null) {
    if (message.length > 0) {
      return [prefix, message].join(prefixSeparator);
    }
    return prefix;
  }
  if (message.length > 0) {
    return message;
  }
  return PREFIX;
}

// lib/fromZodIssue.ts
function fromZodIssue(issue, options = {}) {
  const messageBuilder = createMessageBuilderFromOptions(options);
  const message = messageBuilder([issue]);
  return new ValidationError(message, { cause: new zod2.ZodError([issue]) });
}
function createMessageBuilderFromOptions(options) {
  if ("messageBuilder" in options) {
    return options.messageBuilder;
  }
  return createMessageBuilder(options);
}

// lib/errorMap.ts
var errorMap = (issue, ctx) => {
  const error = fromZodIssue({
    ...issue,
    // fallback to the default error message
    // when issue does not have a message
    message: issue.message ?? ctx.defaultError
  });
  return {
    message: error.message
  };
};

// lib/fromZodError.ts
function fromZodError(zodError, options = {}) {
  if (!isZodErrorLike(zodError)) {
    throw new TypeError(
      `Invalid zodError param; expected instance of ZodError. Did you mean to use the "${fromError.name}" method instead?`
    );
  }
  return fromZodErrorWithoutRuntimeCheck(zodError, options);
}
function fromZodErrorWithoutRuntimeCheck(zodError, options = {}) {
  const zodIssues = zodError.errors;
  let message;
  if (isNonEmptyArray(zodIssues)) {
    const messageBuilder = createMessageBuilderFromOptions2(options);
    message = messageBuilder(zodIssues);
  } else {
    message = zodError.message;
  }
  return new ValidationError(message, { cause: zodError });
}
function createMessageBuilderFromOptions2(options) {
  if ("messageBuilder" in options) {
    return options.messageBuilder;
  }
  return createMessageBuilder(options);
}

// lib/toValidationError.ts
var toValidationError = (options = {}) => (err) => {
  if (isZodErrorLike(err)) {
    return fromZodErrorWithoutRuntimeCheck(err, options);
  }
  if (err instanceof Error) {
    return new ValidationError(err.message, { cause: err });
  }
  return new ValidationError("Unknown error");
};

// lib/fromError.ts
function fromError(err, options = {}) {
  return toValidationError(options)(err);
}

//# sourceMappingURL=index.mjs.map

/***/ }),

/***/ 69509:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Ay: () => (/* binding */ z),
/* harmony export */   G: () => (/* binding */ ZodError),
/* harmony export */   Ie: () => (/* binding */ custom),
/* harmony export */   Ik: () => (/* binding */ objectType),
/* harmony export */   L5: () => (/* binding */ unknownType),
/* harmony export */   YO: () => (/* binding */ arrayType),
/* harmony export */   Yj: () => (/* binding */ stringType),
/* harmony export */   ai: () => (/* binding */ numberType),
/* harmony export */   eq: () => (/* binding */ ZodIssueCode),
/* harmony export */   g1: () => (/* binding */ recordType),
/* harmony export */   z: () => (/* binding */ z),
/* harmony export */   zM: () => (/* binding */ booleanType)
/* harmony export */ });
/* unused harmony exports BRAND, DIRTY, EMPTY_PATH, INVALID, NEVER, OK, ParseStatus, Schema, ZodAny, ZodArray, ZodBigInt, ZodBoolean, ZodBranded, ZodCatch, ZodDate, ZodDefault, ZodDiscriminatedUnion, ZodEffects, ZodEnum, ZodFirstPartyTypeKind, ZodFunction, ZodIntersection, ZodLazy, ZodLiteral, ZodMap, ZodNaN, ZodNativeEnum, ZodNever, ZodNull, ZodNullable, ZodNumber, ZodObject, ZodOptional, ZodParsedType, ZodPipeline, ZodPromise, ZodRecord, ZodSchema, ZodSet, ZodString, ZodSymbol, ZodTransformer, ZodTuple, ZodType, ZodUndefined, ZodUnion, ZodUnknown, ZodVoid, addIssueToContext, any, bigint, coerce, date, defaultErrorMap, discriminatedUnion, effect, enum, function, getErrorMap, getParsedType, instanceof, intersection, isAborted, isAsync, isDirty, isValid, late, lazy, literal, makeIssue, map, nan, nativeEnum, never, null, nullable, objectUtil, oboolean, onumber, optional, ostring, pipeline, preprocess, promise, quotelessJson, set, setErrorMap, strictObject, symbol, transformer, tuple, undefined, union, util, void */
var util;
(function (util) {
    util.assertEqual = (val) => val;
    function assertIs(_arg) { }
    util.assertIs = assertIs;
    function assertNever(_x) {
        throw new Error();
    }
    util.assertNever = assertNever;
    util.arrayToEnum = (items) => {
        const obj = {};
        for (const item of items) {
            obj[item] = item;
        }
        return obj;
    };
    util.getValidEnumValues = (obj) => {
        const validKeys = util.objectKeys(obj).filter((k) => typeof obj[obj[k]] !== "number");
        const filtered = {};
        for (const k of validKeys) {
            filtered[k] = obj[k];
        }
        return util.objectValues(filtered);
    };
    util.objectValues = (obj) => {
        return util.objectKeys(obj).map(function (e) {
            return obj[e];
        });
    };
    util.objectKeys = typeof Object.keys === "function" // eslint-disable-line ban/ban
        ? (obj) => Object.keys(obj) // eslint-disable-line ban/ban
        : (object) => {
            const keys = [];
            for (const key in object) {
                if (Object.prototype.hasOwnProperty.call(object, key)) {
                    keys.push(key);
                }
            }
            return keys;
        };
    util.find = (arr, checker) => {
        for (const item of arr) {
            if (checker(item))
                return item;
        }
        return undefined;
    };
    util.isInteger = typeof Number.isInteger === "function"
        ? (val) => Number.isInteger(val) // eslint-disable-line ban/ban
        : (val) => typeof val === "number" && isFinite(val) && Math.floor(val) === val;
    function joinValues(array, separator = " | ") {
        return array
            .map((val) => (typeof val === "string" ? `'${val}'` : val))
            .join(separator);
    }
    util.joinValues = joinValues;
    util.jsonStringifyReplacer = (_, value) => {
        if (typeof value === "bigint") {
            return value.toString();
        }
        return value;
    };
})(util || (util = {}));
var objectUtil;
(function (objectUtil) {
    objectUtil.mergeShapes = (first, second) => {
        return {
            ...first,
            ...second, // second overwrites first
        };
    };
})(objectUtil || (objectUtil = {}));
const ZodParsedType = util.arrayToEnum([
    "string",
    "nan",
    "number",
    "integer",
    "float",
    "boolean",
    "date",
    "bigint",
    "symbol",
    "function",
    "undefined",
    "null",
    "array",
    "object",
    "unknown",
    "promise",
    "void",
    "never",
    "map",
    "set",
]);
const getParsedType = (data) => {
    const t = typeof data;
    switch (t) {
        case "undefined":
            return ZodParsedType.undefined;
        case "string":
            return ZodParsedType.string;
        case "number":
            return isNaN(data) ? ZodParsedType.nan : ZodParsedType.number;
        case "boolean":
            return ZodParsedType.boolean;
        case "function":
            return ZodParsedType.function;
        case "bigint":
            return ZodParsedType.bigint;
        case "symbol":
            return ZodParsedType.symbol;
        case "object":
            if (Array.isArray(data)) {
                return ZodParsedType.array;
            }
            if (data === null) {
                return ZodParsedType.null;
            }
            if (data.then &&
                typeof data.then === "function" &&
                data.catch &&
                typeof data.catch === "function") {
                return ZodParsedType.promise;
            }
            if (typeof Map !== "undefined" && data instanceof Map) {
                return ZodParsedType.map;
            }
            if (typeof Set !== "undefined" && data instanceof Set) {
                return ZodParsedType.set;
            }
            if (typeof Date !== "undefined" && data instanceof Date) {
                return ZodParsedType.date;
            }
            return ZodParsedType.object;
        default:
            return ZodParsedType.unknown;
    }
};

const ZodIssueCode = util.arrayToEnum([
    "invalid_type",
    "invalid_literal",
    "custom",
    "invalid_union",
    "invalid_union_discriminator",
    "invalid_enum_value",
    "unrecognized_keys",
    "invalid_arguments",
    "invalid_return_type",
    "invalid_date",
    "invalid_string",
    "too_small",
    "too_big",
    "invalid_intersection_types",
    "not_multiple_of",
    "not_finite",
]);
const quotelessJson = (obj) => {
    const json = JSON.stringify(obj, null, 2);
    return json.replace(/"([^"]+)":/g, "$1:");
};
class ZodError extends Error {
    constructor(issues) {
        super();
        this.issues = [];
        this.addIssue = (sub) => {
            this.issues = [...this.issues, sub];
        };
        this.addIssues = (subs = []) => {
            this.issues = [...this.issues, ...subs];
        };
        const actualProto = new.target.prototype;
        if (Object.setPrototypeOf) {
            // eslint-disable-next-line ban/ban
            Object.setPrototypeOf(this, actualProto);
        }
        else {
            this.__proto__ = actualProto;
        }
        this.name = "ZodError";
        this.issues = issues;
    }
    get errors() {
        return this.issues;
    }
    format(_mapper) {
        const mapper = _mapper ||
            function (issue) {
                return issue.message;
            };
        const fieldErrors = { _errors: [] };
        const processError = (error) => {
            for (const issue of error.issues) {
                if (issue.code === "invalid_union") {
                    issue.unionErrors.map(processError);
                }
                else if (issue.code === "invalid_return_type") {
                    processError(issue.returnTypeError);
                }
                else if (issue.code === "invalid_arguments") {
                    processError(issue.argumentsError);
                }
                else if (issue.path.length === 0) {
                    fieldErrors._errors.push(mapper(issue));
                }
                else {
                    let curr = fieldErrors;
                    let i = 0;
                    while (i < issue.path.length) {
                        const el = issue.path[i];
                        const terminal = i === issue.path.length - 1;
                        if (!terminal) {
                            curr[el] = curr[el] || { _errors: [] };
                            // if (typeof el === "string") {
                            //   curr[el] = curr[el] || { _errors: [] };
                            // } else if (typeof el === "number") {
                            //   const errorArray: any = [];
                            //   errorArray._errors = [];
                            //   curr[el] = curr[el] || errorArray;
                            // }
                        }
                        else {
                            curr[el] = curr[el] || { _errors: [] };
                            curr[el]._errors.push(mapper(issue));
                        }
                        curr = curr[el];
                        i++;
                    }
                }
            }
        };
        processError(this);
        return fieldErrors;
    }
    toString() {
        return this.message;
    }
    get message() {
        return JSON.stringify(this.issues, util.jsonStringifyReplacer, 2);
    }
    get isEmpty() {
        return this.issues.length === 0;
    }
    flatten(mapper = (issue) => issue.message) {
        const fieldErrors = {};
        const formErrors = [];
        for (const sub of this.issues) {
            if (sub.path.length > 0) {
                fieldErrors[sub.path[0]] = fieldErrors[sub.path[0]] || [];
                fieldErrors[sub.path[0]].push(mapper(sub));
            }
            else {
                formErrors.push(mapper(sub));
            }
        }
        return { formErrors, fieldErrors };
    }
    get formErrors() {
        return this.flatten();
    }
}
ZodError.create = (issues) => {
    const error = new ZodError(issues);
    return error;
};

const errorMap = (issue, _ctx) => {
    let message;
    switch (issue.code) {
        case ZodIssueCode.invalid_type:
            if (issue.received === ZodParsedType.undefined) {
                message = "Required";
            }
            else {
                message = `Expected ${issue.expected}, received ${issue.received}`;
            }
            break;
        case ZodIssueCode.invalid_literal:
            message = `Invalid literal value, expected ${JSON.stringify(issue.expected, util.jsonStringifyReplacer)}`;
            break;
        case ZodIssueCode.unrecognized_keys:
            message = `Unrecognized key(s) in object: ${util.joinValues(issue.keys, ", ")}`;
            break;
        case ZodIssueCode.invalid_union:
            message = `Invalid input`;
            break;
        case ZodIssueCode.invalid_union_discriminator:
            message = `Invalid discriminator value. Expected ${util.joinValues(issue.options)}`;
            break;
        case ZodIssueCode.invalid_enum_value:
            message = `Invalid enum value. Expected ${util.joinValues(issue.options)}, received '${issue.received}'`;
            break;
        case ZodIssueCode.invalid_arguments:
            message = `Invalid function arguments`;
            break;
        case ZodIssueCode.invalid_return_type:
            message = `Invalid function return type`;
            break;
        case ZodIssueCode.invalid_date:
            message = `Invalid date`;
            break;
        case ZodIssueCode.invalid_string:
            if (typeof issue.validation === "object") {
                if ("includes" in issue.validation) {
                    message = `Invalid input: must include "${issue.validation.includes}"`;
                    if (typeof issue.validation.position === "number") {
                        message = `${message} at one or more positions greater than or equal to ${issue.validation.position}`;
                    }
                }
                else if ("startsWith" in issue.validation) {
                    message = `Invalid input: must start with "${issue.validation.startsWith}"`;
                }
                else if ("endsWith" in issue.validation) {
                    message = `Invalid input: must end with "${issue.validation.endsWith}"`;
                }
                else {
                    util.assertNever(issue.validation);
                }
            }
            else if (issue.validation !== "regex") {
                message = `Invalid ${issue.validation}`;
            }
            else {
                message = "Invalid";
            }
            break;
        case ZodIssueCode.too_small:
            if (issue.type === "array")
                message = `Array must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `more than`} ${issue.minimum} element(s)`;
            else if (issue.type === "string")
                message = `String must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `over`} ${issue.minimum} character(s)`;
            else if (issue.type === "number")
                message = `Number must be ${issue.exact
                    ? `exactly equal to `
                    : issue.inclusive
                        ? `greater than or equal to `
                        : `greater than `}${issue.minimum}`;
            else if (issue.type === "date")
                message = `Date must be ${issue.exact
                    ? `exactly equal to `
                    : issue.inclusive
                        ? `greater than or equal to `
                        : `greater than `}${new Date(Number(issue.minimum))}`;
            else
                message = "Invalid input";
            break;
        case ZodIssueCode.too_big:
            if (issue.type === "array")
                message = `Array must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `less than`} ${issue.maximum} element(s)`;
            else if (issue.type === "string")
                message = `String must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `under`} ${issue.maximum} character(s)`;
            else if (issue.type === "number")
                message = `Number must be ${issue.exact
                    ? `exactly`
                    : issue.inclusive
                        ? `less than or equal to`
                        : `less than`} ${issue.maximum}`;
            else if (issue.type === "bigint")
                message = `BigInt must be ${issue.exact
                    ? `exactly`
                    : issue.inclusive
                        ? `less than or equal to`
                        : `less than`} ${issue.maximum}`;
            else if (issue.type === "date")
                message = `Date must be ${issue.exact
                    ? `exactly`
                    : issue.inclusive
                        ? `smaller than or equal to`
                        : `smaller than`} ${new Date(Number(issue.maximum))}`;
            else
                message = "Invalid input";
            break;
        case ZodIssueCode.custom:
            message = `Invalid input`;
            break;
        case ZodIssueCode.invalid_intersection_types:
            message = `Intersection results could not be merged`;
            break;
        case ZodIssueCode.not_multiple_of:
            message = `Number must be a multiple of ${issue.multipleOf}`;
            break;
        case ZodIssueCode.not_finite:
            message = "Number must be finite";
            break;
        default:
            message = _ctx.defaultError;
            util.assertNever(issue);
    }
    return { message };
};

let overrideErrorMap = errorMap;
function setErrorMap(map) {
    overrideErrorMap = map;
}
function getErrorMap() {
    return overrideErrorMap;
}

const makeIssue = (params) => {
    const { data, path, errorMaps, issueData } = params;
    const fullPath = [...path, ...(issueData.path || [])];
    const fullIssue = {
        ...issueData,
        path: fullPath,
    };
    let errorMessage = "";
    const maps = errorMaps
        .filter((m) => !!m)
        .slice()
        .reverse();
    for (const map of maps) {
        errorMessage = map(fullIssue, { data, defaultError: errorMessage }).message;
    }
    return {
        ...issueData,
        path: fullPath,
        message: issueData.message || errorMessage,
    };
};
const EMPTY_PATH = [];
function addIssueToContext(ctx, issueData) {
    const issue = makeIssue({
        issueData: issueData,
        data: ctx.data,
        path: ctx.path,
        errorMaps: [
            ctx.common.contextualErrorMap,
            ctx.schemaErrorMap,
            getErrorMap(),
            errorMap, // then global default map
        ].filter((x) => !!x),
    });
    ctx.common.issues.push(issue);
}
class ParseStatus {
    constructor() {
        this.value = "valid";
    }
    dirty() {
        if (this.value === "valid")
            this.value = "dirty";
    }
    abort() {
        if (this.value !== "aborted")
            this.value = "aborted";
    }
    static mergeArray(status, results) {
        const arrayValue = [];
        for (const s of results) {
            if (s.status === "aborted")
                return INVALID;
            if (s.status === "dirty")
                status.dirty();
            arrayValue.push(s.value);
        }
        return { status: status.value, value: arrayValue };
    }
    static async mergeObjectAsync(status, pairs) {
        const syncPairs = [];
        for (const pair of pairs) {
            syncPairs.push({
                key: await pair.key,
                value: await pair.value,
            });
        }
        return ParseStatus.mergeObjectSync(status, syncPairs);
    }
    static mergeObjectSync(status, pairs) {
        const finalObject = {};
        for (const pair of pairs) {
            const { key, value } = pair;
            if (key.status === "aborted")
                return INVALID;
            if (value.status === "aborted")
                return INVALID;
            if (key.status === "dirty")
                status.dirty();
            if (value.status === "dirty")
                status.dirty();
            if (typeof value.value !== "undefined" || pair.alwaysSet) {
                finalObject[key.value] = value.value;
            }
        }
        return { status: status.value, value: finalObject };
    }
}
const INVALID = Object.freeze({
    status: "aborted",
});
const DIRTY = (value) => ({ status: "dirty", value });
const OK = (value) => ({ status: "valid", value });
const isAborted = (x) => x.status === "aborted";
const isDirty = (x) => x.status === "dirty";
const isValid = (x) => x.status === "valid";
const isAsync = (x) => typeof Promise !== "undefined" && x instanceof Promise;

var errorUtil;
(function (errorUtil) {
    errorUtil.errToObj = (message) => typeof message === "string" ? { message } : message || {};
    errorUtil.toString = (message) => typeof message === "string" ? message : message === null || message === void 0 ? void 0 : message.message;
})(errorUtil || (errorUtil = {}));

class ParseInputLazyPath {
    constructor(parent, value, path, key) {
        this._cachedPath = [];
        this.parent = parent;
        this.data = value;
        this._path = path;
        this._key = key;
    }
    get path() {
        if (!this._cachedPath.length) {
            if (this._key instanceof Array) {
                this._cachedPath.push(...this._path, ...this._key);
            }
            else {
                this._cachedPath.push(...this._path, this._key);
            }
        }
        return this._cachedPath;
    }
}
const handleResult = (ctx, result) => {
    if (isValid(result)) {
        return { success: true, data: result.value };
    }
    else {
        if (!ctx.common.issues.length) {
            throw new Error("Validation failed but no issues detected.");
        }
        return {
            success: false,
            get error() {
                if (this._error)
                    return this._error;
                const error = new ZodError(ctx.common.issues);
                this._error = error;
                return this._error;
            },
        };
    }
};
function processCreateParams(params) {
    if (!params)
        return {};
    const { errorMap, invalid_type_error, required_error, description } = params;
    if (errorMap && (invalid_type_error || required_error)) {
        throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
    }
    if (errorMap)
        return { errorMap: errorMap, description };
    const customMap = (iss, ctx) => {
        if (iss.code !== "invalid_type")
            return { message: ctx.defaultError };
        if (typeof ctx.data === "undefined") {
            return { message: required_error !== null && required_error !== void 0 ? required_error : ctx.defaultError };
        }
        return { message: invalid_type_error !== null && invalid_type_error !== void 0 ? invalid_type_error : ctx.defaultError };
    };
    return { errorMap: customMap, description };
}
class ZodType {
    constructor(def) {
        /** Alias of safeParseAsync */
        this.spa = this.safeParseAsync;
        this._def = def;
        this.parse = this.parse.bind(this);
        this.safeParse = this.safeParse.bind(this);
        this.parseAsync = this.parseAsync.bind(this);
        this.safeParseAsync = this.safeParseAsync.bind(this);
        this.spa = this.spa.bind(this);
        this.refine = this.refine.bind(this);
        this.refinement = this.refinement.bind(this);
        this.superRefine = this.superRefine.bind(this);
        this.optional = this.optional.bind(this);
        this.nullable = this.nullable.bind(this);
        this.nullish = this.nullish.bind(this);
        this.array = this.array.bind(this);
        this.promise = this.promise.bind(this);
        this.or = this.or.bind(this);
        this.and = this.and.bind(this);
        this.transform = this.transform.bind(this);
        this.brand = this.brand.bind(this);
        this.default = this.default.bind(this);
        this.catch = this.catch.bind(this);
        this.describe = this.describe.bind(this);
        this.pipe = this.pipe.bind(this);
        this.isNullable = this.isNullable.bind(this);
        this.isOptional = this.isOptional.bind(this);
    }
    get description() {
        return this._def.description;
    }
    _getType(input) {
        return getParsedType(input.data);
    }
    _getOrReturnCtx(input, ctx) {
        return (ctx || {
            common: input.parent.common,
            data: input.data,
            parsedType: getParsedType(input.data),
            schemaErrorMap: this._def.errorMap,
            path: input.path,
            parent: input.parent,
        });
    }
    _processInputParams(input) {
        return {
            status: new ParseStatus(),
            ctx: {
                common: input.parent.common,
                data: input.data,
                parsedType: getParsedType(input.data),
                schemaErrorMap: this._def.errorMap,
                path: input.path,
                parent: input.parent,
            },
        };
    }
    _parseSync(input) {
        const result = this._parse(input);
        if (isAsync(result)) {
            throw new Error("Synchronous parse encountered promise.");
        }
        return result;
    }
    _parseAsync(input) {
        const result = this._parse(input);
        return Promise.resolve(result);
    }
    parse(data, params) {
        const result = this.safeParse(data, params);
        if (result.success)
            return result.data;
        throw result.error;
    }
    safeParse(data, params) {
        var _a;
        const ctx = {
            common: {
                issues: [],
                async: (_a = params === null || params === void 0 ? void 0 : params.async) !== null && _a !== void 0 ? _a : false,
                contextualErrorMap: params === null || params === void 0 ? void 0 : params.errorMap,
            },
            path: (params === null || params === void 0 ? void 0 : params.path) || [],
            schemaErrorMap: this._def.errorMap,
            parent: null,
            data,
            parsedType: getParsedType(data),
        };
        const result = this._parseSync({ data, path: ctx.path, parent: ctx });
        return handleResult(ctx, result);
    }
    async parseAsync(data, params) {
        const result = await this.safeParseAsync(data, params);
        if (result.success)
            return result.data;
        throw result.error;
    }
    async safeParseAsync(data, params) {
        const ctx = {
            common: {
                issues: [],
                contextualErrorMap: params === null || params === void 0 ? void 0 : params.errorMap,
                async: true,
            },
            path: (params === null || params === void 0 ? void 0 : params.path) || [],
            schemaErrorMap: this._def.errorMap,
            parent: null,
            data,
            parsedType: getParsedType(data),
        };
        const maybeAsyncResult = this._parse({ data, path: ctx.path, parent: ctx });
        const result = await (isAsync(maybeAsyncResult)
            ? maybeAsyncResult
            : Promise.resolve(maybeAsyncResult));
        return handleResult(ctx, result);
    }
    refine(check, message) {
        const getIssueProperties = (val) => {
            if (typeof message === "string" || typeof message === "undefined") {
                return { message };
            }
            else if (typeof message === "function") {
                return message(val);
            }
            else {
                return message;
            }
        };
        return this._refinement((val, ctx) => {
            const result = check(val);
            const setError = () => ctx.addIssue({
                code: ZodIssueCode.custom,
                ...getIssueProperties(val),
            });
            if (typeof Promise !== "undefined" && result instanceof Promise) {
                return result.then((data) => {
                    if (!data) {
                        setError();
                        return false;
                    }
                    else {
                        return true;
                    }
                });
            }
            if (!result) {
                setError();
                return false;
            }
            else {
                return true;
            }
        });
    }
    refinement(check, refinementData) {
        return this._refinement((val, ctx) => {
            if (!check(val)) {
                ctx.addIssue(typeof refinementData === "function"
                    ? refinementData(val, ctx)
                    : refinementData);
                return false;
            }
            else {
                return true;
            }
        });
    }
    _refinement(refinement) {
        return new ZodEffects({
            schema: this,
            typeName: ZodFirstPartyTypeKind.ZodEffects,
            effect: { type: "refinement", refinement },
        });
    }
    superRefine(refinement) {
        return this._refinement(refinement);
    }
    optional() {
        return ZodOptional.create(this, this._def);
    }
    nullable() {
        return ZodNullable.create(this, this._def);
    }
    nullish() {
        return this.nullable().optional();
    }
    array() {
        return ZodArray.create(this, this._def);
    }
    promise() {
        return ZodPromise.create(this, this._def);
    }
    or(option) {
        return ZodUnion.create([this, option], this._def);
    }
    and(incoming) {
        return ZodIntersection.create(this, incoming, this._def);
    }
    transform(transform) {
        return new ZodEffects({
            ...processCreateParams(this._def),
            schema: this,
            typeName: ZodFirstPartyTypeKind.ZodEffects,
            effect: { type: "transform", transform },
        });
    }
    default(def) {
        const defaultValueFunc = typeof def === "function" ? def : () => def;
        return new ZodDefault({
            ...processCreateParams(this._def),
            innerType: this,
            defaultValue: defaultValueFunc,
            typeName: ZodFirstPartyTypeKind.ZodDefault,
        });
    }
    brand() {
        return new ZodBranded({
            typeName: ZodFirstPartyTypeKind.ZodBranded,
            type: this,
            ...processCreateParams(this._def),
        });
    }
    catch(def) {
        const catchValueFunc = typeof def === "function" ? def : () => def;
        return new ZodCatch({
            ...processCreateParams(this._def),
            innerType: this,
            catchValue: catchValueFunc,
            typeName: ZodFirstPartyTypeKind.ZodCatch,
        });
    }
    describe(description) {
        const This = this.constructor;
        return new This({
            ...this._def,
            description,
        });
    }
    pipe(target) {
        return ZodPipeline.create(this, target);
    }
    isOptional() {
        return this.safeParse(undefined).success;
    }
    isNullable() {
        return this.safeParse(null).success;
    }
}
const cuidRegex = /^c[^\s-]{8,}$/i;
const cuid2Regex = /^[a-z][a-z0-9]*$/;
const ulidRegex = /[0-9A-HJKMNP-TV-Z]{26}/;
const uuidRegex = /^([a-f0-9]{8}-[a-f0-9]{4}-[1-5][a-f0-9]{3}-[a-f0-9]{4}-[a-f0-9]{12}|00000000-0000-0000-0000-000000000000)$/i;
// from https://stackoverflow.com/a/46181/1550155
// old version: too slow, didn't support unicode
// const emailRegex = /^((([a-z]|\d|[!#\$%&'\*\+\-\/=\?\^_`{\|}~]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])+(\.([a-z]|\d|[!#\$%&'\*\+\-\/=\?\^_`{\|}~]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])+)*)|((\x22)((((\x20|\x09)*(\x0d\x0a))?(\x20|\x09)+)?(([\x01-\x08\x0b\x0c\x0e-\x1f\x7f]|\x21|[\x23-\x5b]|[\x5d-\x7e]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(\\([\x01-\x09\x0b\x0c\x0d-\x7f]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]))))*(((\x20|\x09)*(\x0d\x0a))?(\x20|\x09)+)?(\x22)))@((([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.)+(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))$/i;
//old email regex
// const emailRegex = /^(([^<>()[\].,;:\s@"]+(\.[^<>()[\].,;:\s@"]+)*)|(".+"))@((?!-)([^<>()[\].,;:\s@"]+\.)+[^<>()[\].,;:\s@"]{1,})[^-<>()[\].,;:\s@"]$/i;
// eslint-disable-next-line
const emailRegex = /^(([^<>()[\]\\.,;:\s@\"]+(\.[^<>()[\]\\.,;:\s@\"]+)*)|(\".+\"))@((\[(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\])|(\[IPv6:(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))\])|([A-Za-z0-9]([A-Za-z0-9-]*[A-Za-z0-9])*(\.[A-Za-z]{2,})+))$/;
// from https://thekevinscott.com/emojis-in-javascript/#writing-a-regular-expression
const emojiRegex = /^(\p{Extended_Pictographic}|\p{Emoji_Component})+$/u;
const ipv4Regex = /^(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))$/;
const ipv6Regex = /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/;
// Adapted from https://stackoverflow.com/a/3143231
const datetimeRegex = (args) => {
    if (args.precision) {
        if (args.offset) {
            return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{${args.precision}}(([+-]\\d{2}(:?\\d{2})?)|Z)$`);
        }
        else {
            return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{${args.precision}}Z$`);
        }
    }
    else if (args.precision === 0) {
        if (args.offset) {
            return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(([+-]\\d{2}(:?\\d{2})?)|Z)$`);
        }
        else {
            return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}Z$`);
        }
    }
    else {
        if (args.offset) {
            return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?(([+-]\\d{2}(:?\\d{2})?)|Z)$`);
        }
        else {
            return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?Z$`);
        }
    }
};
function isValidIP(ip, version) {
    if ((version === "v4" || !version) && ipv4Regex.test(ip)) {
        return true;
    }
    if ((version === "v6" || !version) && ipv6Regex.test(ip)) {
        return true;
    }
    return false;
}
class ZodString extends ZodType {
    constructor() {
        super(...arguments);
        this._regex = (regex, validation, message) => this.refinement((data) => regex.test(data), {
            validation,
            code: ZodIssueCode.invalid_string,
            ...errorUtil.errToObj(message),
        });
        /**
         * @deprecated Use z.string().min(1) instead.
         * @see {@link ZodString.min}
         */
        this.nonempty = (message) => this.min(1, errorUtil.errToObj(message));
        this.trim = () => new ZodString({
            ...this._def,
            checks: [...this._def.checks, { kind: "trim" }],
        });
        this.toLowerCase = () => new ZodString({
            ...this._def,
            checks: [...this._def.checks, { kind: "toLowerCase" }],
        });
        this.toUpperCase = () => new ZodString({
            ...this._def,
            checks: [...this._def.checks, { kind: "toUpperCase" }],
        });
    }
    _parse(input) {
        if (this._def.coerce) {
            input.data = String(input.data);
        }
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.string) {
            const ctx = this._getOrReturnCtx(input);
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_type,
                expected: ZodParsedType.string,
                received: ctx.parsedType,
            }
            //
            );
            return INVALID;
        }
        const status = new ParseStatus();
        let ctx = undefined;
        for (const check of this._def.checks) {
            if (check.kind === "min") {
                if (input.data.length < check.value) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.too_small,
                        minimum: check.value,
                        type: "string",
                        inclusive: true,
                        exact: false,
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "max") {
                if (input.data.length > check.value) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.too_big,
                        maximum: check.value,
                        type: "string",
                        inclusive: true,
                        exact: false,
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "length") {
                const tooBig = input.data.length > check.value;
                const tooSmall = input.data.length < check.value;
                if (tooBig || tooSmall) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    if (tooBig) {
                        addIssueToContext(ctx, {
                            code: ZodIssueCode.too_big,
                            maximum: check.value,
                            type: "string",
                            inclusive: true,
                            exact: true,
                            message: check.message,
                        });
                    }
                    else if (tooSmall) {
                        addIssueToContext(ctx, {
                            code: ZodIssueCode.too_small,
                            minimum: check.value,
                            type: "string",
                            inclusive: true,
                            exact: true,
                            message: check.message,
                        });
                    }
                    status.dirty();
                }
            }
            else if (check.kind === "email") {
                if (!emailRegex.test(input.data)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        validation: "email",
                        code: ZodIssueCode.invalid_string,
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "emoji") {
                if (!emojiRegex.test(input.data)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        validation: "emoji",
                        code: ZodIssueCode.invalid_string,
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "uuid") {
                if (!uuidRegex.test(input.data)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        validation: "uuid",
                        code: ZodIssueCode.invalid_string,
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "cuid") {
                if (!cuidRegex.test(input.data)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        validation: "cuid",
                        code: ZodIssueCode.invalid_string,
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "cuid2") {
                if (!cuid2Regex.test(input.data)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        validation: "cuid2",
                        code: ZodIssueCode.invalid_string,
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "ulid") {
                if (!ulidRegex.test(input.data)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        validation: "ulid",
                        code: ZodIssueCode.invalid_string,
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "url") {
                try {
                    new URL(input.data);
                }
                catch (_a) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        validation: "url",
                        code: ZodIssueCode.invalid_string,
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "regex") {
                check.regex.lastIndex = 0;
                const testResult = check.regex.test(input.data);
                if (!testResult) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        validation: "regex",
                        code: ZodIssueCode.invalid_string,
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "trim") {
                input.data = input.data.trim();
            }
            else if (check.kind === "includes") {
                if (!input.data.includes(check.value, check.position)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.invalid_string,
                        validation: { includes: check.value, position: check.position },
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "toLowerCase") {
                input.data = input.data.toLowerCase();
            }
            else if (check.kind === "toUpperCase") {
                input.data = input.data.toUpperCase();
            }
            else if (check.kind === "startsWith") {
                if (!input.data.startsWith(check.value)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.invalid_string,
                        validation: { startsWith: check.value },
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "endsWith") {
                if (!input.data.endsWith(check.value)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.invalid_string,
                        validation: { endsWith: check.value },
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "datetime") {
                const regex = datetimeRegex(check);
                if (!regex.test(input.data)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.invalid_string,
                        validation: "datetime",
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "ip") {
                if (!isValidIP(input.data, check.version)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        validation: "ip",
                        code: ZodIssueCode.invalid_string,
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else {
                util.assertNever(check);
            }
        }
        return { status: status.value, value: input.data };
    }
    _addCheck(check) {
        return new ZodString({
            ...this._def,
            checks: [...this._def.checks, check],
        });
    }
    email(message) {
        return this._addCheck({ kind: "email", ...errorUtil.errToObj(message) });
    }
    url(message) {
        return this._addCheck({ kind: "url", ...errorUtil.errToObj(message) });
    }
    emoji(message) {
        return this._addCheck({ kind: "emoji", ...errorUtil.errToObj(message) });
    }
    uuid(message) {
        return this._addCheck({ kind: "uuid", ...errorUtil.errToObj(message) });
    }
    cuid(message) {
        return this._addCheck({ kind: "cuid", ...errorUtil.errToObj(message) });
    }
    cuid2(message) {
        return this._addCheck({ kind: "cuid2", ...errorUtil.errToObj(message) });
    }
    ulid(message) {
        return this._addCheck({ kind: "ulid", ...errorUtil.errToObj(message) });
    }
    ip(options) {
        return this._addCheck({ kind: "ip", ...errorUtil.errToObj(options) });
    }
    datetime(options) {
        var _a;
        if (typeof options === "string") {
            return this._addCheck({
                kind: "datetime",
                precision: null,
                offset: false,
                message: options,
            });
        }
        return this._addCheck({
            kind: "datetime",
            precision: typeof (options === null || options === void 0 ? void 0 : options.precision) === "undefined" ? null : options === null || options === void 0 ? void 0 : options.precision,
            offset: (_a = options === null || options === void 0 ? void 0 : options.offset) !== null && _a !== void 0 ? _a : false,
            ...errorUtil.errToObj(options === null || options === void 0 ? void 0 : options.message),
        });
    }
    regex(regex, message) {
        return this._addCheck({
            kind: "regex",
            regex: regex,
            ...errorUtil.errToObj(message),
        });
    }
    includes(value, options) {
        return this._addCheck({
            kind: "includes",
            value: value,
            position: options === null || options === void 0 ? void 0 : options.position,
            ...errorUtil.errToObj(options === null || options === void 0 ? void 0 : options.message),
        });
    }
    startsWith(value, message) {
        return this._addCheck({
            kind: "startsWith",
            value: value,
            ...errorUtil.errToObj(message),
        });
    }
    endsWith(value, message) {
        return this._addCheck({
            kind: "endsWith",
            value: value,
            ...errorUtil.errToObj(message),
        });
    }
    min(minLength, message) {
        return this._addCheck({
            kind: "min",
            value: minLength,
            ...errorUtil.errToObj(message),
        });
    }
    max(maxLength, message) {
        return this._addCheck({
            kind: "max",
            value: maxLength,
            ...errorUtil.errToObj(message),
        });
    }
    length(len, message) {
        return this._addCheck({
            kind: "length",
            value: len,
            ...errorUtil.errToObj(message),
        });
    }
    get isDatetime() {
        return !!this._def.checks.find((ch) => ch.kind === "datetime");
    }
    get isEmail() {
        return !!this._def.checks.find((ch) => ch.kind === "email");
    }
    get isURL() {
        return !!this._def.checks.find((ch) => ch.kind === "url");
    }
    get isEmoji() {
        return !!this._def.checks.find((ch) => ch.kind === "emoji");
    }
    get isUUID() {
        return !!this._def.checks.find((ch) => ch.kind === "uuid");
    }
    get isCUID() {
        return !!this._def.checks.find((ch) => ch.kind === "cuid");
    }
    get isCUID2() {
        return !!this._def.checks.find((ch) => ch.kind === "cuid2");
    }
    get isULID() {
        return !!this._def.checks.find((ch) => ch.kind === "ulid");
    }
    get isIP() {
        return !!this._def.checks.find((ch) => ch.kind === "ip");
    }
    get minLength() {
        let min = null;
        for (const ch of this._def.checks) {
            if (ch.kind === "min") {
                if (min === null || ch.value > min)
                    min = ch.value;
            }
        }
        return min;
    }
    get maxLength() {
        let max = null;
        for (const ch of this._def.checks) {
            if (ch.kind === "max") {
                if (max === null || ch.value < max)
                    max = ch.value;
            }
        }
        return max;
    }
}
ZodString.create = (params) => {
    var _a;
    return new ZodString({
        checks: [],
        typeName: ZodFirstPartyTypeKind.ZodString,
        coerce: (_a = params === null || params === void 0 ? void 0 : params.coerce) !== null && _a !== void 0 ? _a : false,
        ...processCreateParams(params),
    });
};
// https://stackoverflow.com/questions/3966484/why-does-modulus-operator-return-fractional-number-in-javascript/31711034#31711034
function floatSafeRemainder(val, step) {
    const valDecCount = (val.toString().split(".")[1] || "").length;
    const stepDecCount = (step.toString().split(".")[1] || "").length;
    const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
    const valInt = parseInt(val.toFixed(decCount).replace(".", ""));
    const stepInt = parseInt(step.toFixed(decCount).replace(".", ""));
    return (valInt % stepInt) / Math.pow(10, decCount);
}
class ZodNumber extends ZodType {
    constructor() {
        super(...arguments);
        this.min = this.gte;
        this.max = this.lte;
        this.step = this.multipleOf;
    }
    _parse(input) {
        if (this._def.coerce) {
            input.data = Number(input.data);
        }
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.number) {
            const ctx = this._getOrReturnCtx(input);
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_type,
                expected: ZodParsedType.number,
                received: ctx.parsedType,
            });
            return INVALID;
        }
        let ctx = undefined;
        const status = new ParseStatus();
        for (const check of this._def.checks) {
            if (check.kind === "int") {
                if (!util.isInteger(input.data)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.invalid_type,
                        expected: "integer",
                        received: "float",
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "min") {
                const tooSmall = check.inclusive
                    ? input.data < check.value
                    : input.data <= check.value;
                if (tooSmall) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.too_small,
                        minimum: check.value,
                        type: "number",
                        inclusive: check.inclusive,
                        exact: false,
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "max") {
                const tooBig = check.inclusive
                    ? input.data > check.value
                    : input.data >= check.value;
                if (tooBig) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.too_big,
                        maximum: check.value,
                        type: "number",
                        inclusive: check.inclusive,
                        exact: false,
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "multipleOf") {
                if (floatSafeRemainder(input.data, check.value) !== 0) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.not_multiple_of,
                        multipleOf: check.value,
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "finite") {
                if (!Number.isFinite(input.data)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.not_finite,
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else {
                util.assertNever(check);
            }
        }
        return { status: status.value, value: input.data };
    }
    gte(value, message) {
        return this.setLimit("min", value, true, errorUtil.toString(message));
    }
    gt(value, message) {
        return this.setLimit("min", value, false, errorUtil.toString(message));
    }
    lte(value, message) {
        return this.setLimit("max", value, true, errorUtil.toString(message));
    }
    lt(value, message) {
        return this.setLimit("max", value, false, errorUtil.toString(message));
    }
    setLimit(kind, value, inclusive, message) {
        return new ZodNumber({
            ...this._def,
            checks: [
                ...this._def.checks,
                {
                    kind,
                    value,
                    inclusive,
                    message: errorUtil.toString(message),
                },
            ],
        });
    }
    _addCheck(check) {
        return new ZodNumber({
            ...this._def,
            checks: [...this._def.checks, check],
        });
    }
    int(message) {
        return this._addCheck({
            kind: "int",
            message: errorUtil.toString(message),
        });
    }
    positive(message) {
        return this._addCheck({
            kind: "min",
            value: 0,
            inclusive: false,
            message: errorUtil.toString(message),
        });
    }
    negative(message) {
        return this._addCheck({
            kind: "max",
            value: 0,
            inclusive: false,
            message: errorUtil.toString(message),
        });
    }
    nonpositive(message) {
        return this._addCheck({
            kind: "max",
            value: 0,
            inclusive: true,
            message: errorUtil.toString(message),
        });
    }
    nonnegative(message) {
        return this._addCheck({
            kind: "min",
            value: 0,
            inclusive: true,
            message: errorUtil.toString(message),
        });
    }
    multipleOf(value, message) {
        return this._addCheck({
            kind: "multipleOf",
            value: value,
            message: errorUtil.toString(message),
        });
    }
    finite(message) {
        return this._addCheck({
            kind: "finite",
            message: errorUtil.toString(message),
        });
    }
    safe(message) {
        return this._addCheck({
            kind: "min",
            inclusive: true,
            value: Number.MIN_SAFE_INTEGER,
            message: errorUtil.toString(message),
        })._addCheck({
            kind: "max",
            inclusive: true,
            value: Number.MAX_SAFE_INTEGER,
            message: errorUtil.toString(message),
        });
    }
    get minValue() {
        let min = null;
        for (const ch of this._def.checks) {
            if (ch.kind === "min") {
                if (min === null || ch.value > min)
                    min = ch.value;
            }
        }
        return min;
    }
    get maxValue() {
        let max = null;
        for (const ch of this._def.checks) {
            if (ch.kind === "max") {
                if (max === null || ch.value < max)
                    max = ch.value;
            }
        }
        return max;
    }
    get isInt() {
        return !!this._def.checks.find((ch) => ch.kind === "int" ||
            (ch.kind === "multipleOf" && util.isInteger(ch.value)));
    }
    get isFinite() {
        let max = null, min = null;
        for (const ch of this._def.checks) {
            if (ch.kind === "finite" ||
                ch.kind === "int" ||
                ch.kind === "multipleOf") {
                return true;
            }
            else if (ch.kind === "min") {
                if (min === null || ch.value > min)
                    min = ch.value;
            }
            else if (ch.kind === "max") {
                if (max === null || ch.value < max)
                    max = ch.value;
            }
        }
        return Number.isFinite(min) && Number.isFinite(max);
    }
}
ZodNumber.create = (params) => {
    return new ZodNumber({
        checks: [],
        typeName: ZodFirstPartyTypeKind.ZodNumber,
        coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
        ...processCreateParams(params),
    });
};
class ZodBigInt extends ZodType {
    constructor() {
        super(...arguments);
        this.min = this.gte;
        this.max = this.lte;
    }
    _parse(input) {
        if (this._def.coerce) {
            input.data = BigInt(input.data);
        }
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.bigint) {
            const ctx = this._getOrReturnCtx(input);
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_type,
                expected: ZodParsedType.bigint,
                received: ctx.parsedType,
            });
            return INVALID;
        }
        let ctx = undefined;
        const status = new ParseStatus();
        for (const check of this._def.checks) {
            if (check.kind === "min") {
                const tooSmall = check.inclusive
                    ? input.data < check.value
                    : input.data <= check.value;
                if (tooSmall) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.too_small,
                        type: "bigint",
                        minimum: check.value,
                        inclusive: check.inclusive,
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "max") {
                const tooBig = check.inclusive
                    ? input.data > check.value
                    : input.data >= check.value;
                if (tooBig) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.too_big,
                        type: "bigint",
                        maximum: check.value,
                        inclusive: check.inclusive,
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "multipleOf") {
                if (input.data % check.value !== BigInt(0)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.not_multiple_of,
                        multipleOf: check.value,
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else {
                util.assertNever(check);
            }
        }
        return { status: status.value, value: input.data };
    }
    gte(value, message) {
        return this.setLimit("min", value, true, errorUtil.toString(message));
    }
    gt(value, message) {
        return this.setLimit("min", value, false, errorUtil.toString(message));
    }
    lte(value, message) {
        return this.setLimit("max", value, true, errorUtil.toString(message));
    }
    lt(value, message) {
        return this.setLimit("max", value, false, errorUtil.toString(message));
    }
    setLimit(kind, value, inclusive, message) {
        return new ZodBigInt({
            ...this._def,
            checks: [
                ...this._def.checks,
                {
                    kind,
                    value,
                    inclusive,
                    message: errorUtil.toString(message),
                },
            ],
        });
    }
    _addCheck(check) {
        return new ZodBigInt({
            ...this._def,
            checks: [...this._def.checks, check],
        });
    }
    positive(message) {
        return this._addCheck({
            kind: "min",
            value: BigInt(0),
            inclusive: false,
            message: errorUtil.toString(message),
        });
    }
    negative(message) {
        return this._addCheck({
            kind: "max",
            value: BigInt(0),
            inclusive: false,
            message: errorUtil.toString(message),
        });
    }
    nonpositive(message) {
        return this._addCheck({
            kind: "max",
            value: BigInt(0),
            inclusive: true,
            message: errorUtil.toString(message),
        });
    }
    nonnegative(message) {
        return this._addCheck({
            kind: "min",
            value: BigInt(0),
            inclusive: true,
            message: errorUtil.toString(message),
        });
    }
    multipleOf(value, message) {
        return this._addCheck({
            kind: "multipleOf",
            value,
            message: errorUtil.toString(message),
        });
    }
    get minValue() {
        let min = null;
        for (const ch of this._def.checks) {
            if (ch.kind === "min") {
                if (min === null || ch.value > min)
                    min = ch.value;
            }
        }
        return min;
    }
    get maxValue() {
        let max = null;
        for (const ch of this._def.checks) {
            if (ch.kind === "max") {
                if (max === null || ch.value < max)
                    max = ch.value;
            }
        }
        return max;
    }
}
ZodBigInt.create = (params) => {
    var _a;
    return new ZodBigInt({
        checks: [],
        typeName: ZodFirstPartyTypeKind.ZodBigInt,
        coerce: (_a = params === null || params === void 0 ? void 0 : params.coerce) !== null && _a !== void 0 ? _a : false,
        ...processCreateParams(params),
    });
};
class ZodBoolean extends ZodType {
    _parse(input) {
        if (this._def.coerce) {
            input.data = Boolean(input.data);
        }
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.boolean) {
            const ctx = this._getOrReturnCtx(input);
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_type,
                expected: ZodParsedType.boolean,
                received: ctx.parsedType,
            });
            return INVALID;
        }
        return OK(input.data);
    }
}
ZodBoolean.create = (params) => {
    return new ZodBoolean({
        typeName: ZodFirstPartyTypeKind.ZodBoolean,
        coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
        ...processCreateParams(params),
    });
};
class ZodDate extends ZodType {
    _parse(input) {
        if (this._def.coerce) {
            input.data = new Date(input.data);
        }
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.date) {
            const ctx = this._getOrReturnCtx(input);
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_type,
                expected: ZodParsedType.date,
                received: ctx.parsedType,
            });
            return INVALID;
        }
        if (isNaN(input.data.getTime())) {
            const ctx = this._getOrReturnCtx(input);
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_date,
            });
            return INVALID;
        }
        const status = new ParseStatus();
        let ctx = undefined;
        for (const check of this._def.checks) {
            if (check.kind === "min") {
                if (input.data.getTime() < check.value) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.too_small,
                        message: check.message,
                        inclusive: true,
                        exact: false,
                        minimum: check.value,
                        type: "date",
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "max") {
                if (input.data.getTime() > check.value) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.too_big,
                        message: check.message,
                        inclusive: true,
                        exact: false,
                        maximum: check.value,
                        type: "date",
                    });
                    status.dirty();
                }
            }
            else {
                util.assertNever(check);
            }
        }
        return {
            status: status.value,
            value: new Date(input.data.getTime()),
        };
    }
    _addCheck(check) {
        return new ZodDate({
            ...this._def,
            checks: [...this._def.checks, check],
        });
    }
    min(minDate, message) {
        return this._addCheck({
            kind: "min",
            value: minDate.getTime(),
            message: errorUtil.toString(message),
        });
    }
    max(maxDate, message) {
        return this._addCheck({
            kind: "max",
            value: maxDate.getTime(),
            message: errorUtil.toString(message),
        });
    }
    get minDate() {
        let min = null;
        for (const ch of this._def.checks) {
            if (ch.kind === "min") {
                if (min === null || ch.value > min)
                    min = ch.value;
            }
        }
        return min != null ? new Date(min) : null;
    }
    get maxDate() {
        let max = null;
        for (const ch of this._def.checks) {
            if (ch.kind === "max") {
                if (max === null || ch.value < max)
                    max = ch.value;
            }
        }
        return max != null ? new Date(max) : null;
    }
}
ZodDate.create = (params) => {
    return new ZodDate({
        checks: [],
        coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
        typeName: ZodFirstPartyTypeKind.ZodDate,
        ...processCreateParams(params),
    });
};
class ZodSymbol extends ZodType {
    _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.symbol) {
            const ctx = this._getOrReturnCtx(input);
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_type,
                expected: ZodParsedType.symbol,
                received: ctx.parsedType,
            });
            return INVALID;
        }
        return OK(input.data);
    }
}
ZodSymbol.create = (params) => {
    return new ZodSymbol({
        typeName: ZodFirstPartyTypeKind.ZodSymbol,
        ...processCreateParams(params),
    });
};
class ZodUndefined extends ZodType {
    _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.undefined) {
            const ctx = this._getOrReturnCtx(input);
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_type,
                expected: ZodParsedType.undefined,
                received: ctx.parsedType,
            });
            return INVALID;
        }
        return OK(input.data);
    }
}
ZodUndefined.create = (params) => {
    return new ZodUndefined({
        typeName: ZodFirstPartyTypeKind.ZodUndefined,
        ...processCreateParams(params),
    });
};
class ZodNull extends ZodType {
    _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.null) {
            const ctx = this._getOrReturnCtx(input);
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_type,
                expected: ZodParsedType.null,
                received: ctx.parsedType,
            });
            return INVALID;
        }
        return OK(input.data);
    }
}
ZodNull.create = (params) => {
    return new ZodNull({
        typeName: ZodFirstPartyTypeKind.ZodNull,
        ...processCreateParams(params),
    });
};
class ZodAny extends ZodType {
    constructor() {
        super(...arguments);
        // to prevent instances of other classes from extending ZodAny. this causes issues with catchall in ZodObject.
        this._any = true;
    }
    _parse(input) {
        return OK(input.data);
    }
}
ZodAny.create = (params) => {
    return new ZodAny({
        typeName: ZodFirstPartyTypeKind.ZodAny,
        ...processCreateParams(params),
    });
};
class ZodUnknown extends ZodType {
    constructor() {
        super(...arguments);
        // required
        this._unknown = true;
    }
    _parse(input) {
        return OK(input.data);
    }
}
ZodUnknown.create = (params) => {
    return new ZodUnknown({
        typeName: ZodFirstPartyTypeKind.ZodUnknown,
        ...processCreateParams(params),
    });
};
class ZodNever extends ZodType {
    _parse(input) {
        const ctx = this._getOrReturnCtx(input);
        addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.never,
            received: ctx.parsedType,
        });
        return INVALID;
    }
}
ZodNever.create = (params) => {
    return new ZodNever({
        typeName: ZodFirstPartyTypeKind.ZodNever,
        ...processCreateParams(params),
    });
};
class ZodVoid extends ZodType {
    _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.undefined) {
            const ctx = this._getOrReturnCtx(input);
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_type,
                expected: ZodParsedType.void,
                received: ctx.parsedType,
            });
            return INVALID;
        }
        return OK(input.data);
    }
}
ZodVoid.create = (params) => {
    return new ZodVoid({
        typeName: ZodFirstPartyTypeKind.ZodVoid,
        ...processCreateParams(params),
    });
};
class ZodArray extends ZodType {
    _parse(input) {
        const { ctx, status } = this._processInputParams(input);
        const def = this._def;
        if (ctx.parsedType !== ZodParsedType.array) {
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_type,
                expected: ZodParsedType.array,
                received: ctx.parsedType,
            });
            return INVALID;
        }
        if (def.exactLength !== null) {
            const tooBig = ctx.data.length > def.exactLength.value;
            const tooSmall = ctx.data.length < def.exactLength.value;
            if (tooBig || tooSmall) {
                addIssueToContext(ctx, {
                    code: tooBig ? ZodIssueCode.too_big : ZodIssueCode.too_small,
                    minimum: (tooSmall ? def.exactLength.value : undefined),
                    maximum: (tooBig ? def.exactLength.value : undefined),
                    type: "array",
                    inclusive: true,
                    exact: true,
                    message: def.exactLength.message,
                });
                status.dirty();
            }
        }
        if (def.minLength !== null) {
            if (ctx.data.length < def.minLength.value) {
                addIssueToContext(ctx, {
                    code: ZodIssueCode.too_small,
                    minimum: def.minLength.value,
                    type: "array",
                    inclusive: true,
                    exact: false,
                    message: def.minLength.message,
                });
                status.dirty();
            }
        }
        if (def.maxLength !== null) {
            if (ctx.data.length > def.maxLength.value) {
                addIssueToContext(ctx, {
                    code: ZodIssueCode.too_big,
                    maximum: def.maxLength.value,
                    type: "array",
                    inclusive: true,
                    exact: false,
                    message: def.maxLength.message,
                });
                status.dirty();
            }
        }
        if (ctx.common.async) {
            return Promise.all([...ctx.data].map((item, i) => {
                return def.type._parseAsync(new ParseInputLazyPath(ctx, item, ctx.path, i));
            })).then((result) => {
                return ParseStatus.mergeArray(status, result);
            });
        }
        const result = [...ctx.data].map((item, i) => {
            return def.type._parseSync(new ParseInputLazyPath(ctx, item, ctx.path, i));
        });
        return ParseStatus.mergeArray(status, result);
    }
    get element() {
        return this._def.type;
    }
    min(minLength, message) {
        return new ZodArray({
            ...this._def,
            minLength: { value: minLength, message: errorUtil.toString(message) },
        });
    }
    max(maxLength, message) {
        return new ZodArray({
            ...this._def,
            maxLength: { value: maxLength, message: errorUtil.toString(message) },
        });
    }
    length(len, message) {
        return new ZodArray({
            ...this._def,
            exactLength: { value: len, message: errorUtil.toString(message) },
        });
    }
    nonempty(message) {
        return this.min(1, message);
    }
}
ZodArray.create = (schema, params) => {
    return new ZodArray({
        type: schema,
        minLength: null,
        maxLength: null,
        exactLength: null,
        typeName: ZodFirstPartyTypeKind.ZodArray,
        ...processCreateParams(params),
    });
};
function deepPartialify(schema) {
    if (schema instanceof ZodObject) {
        const newShape = {};
        for (const key in schema.shape) {
            const fieldSchema = schema.shape[key];
            newShape[key] = ZodOptional.create(deepPartialify(fieldSchema));
        }
        return new ZodObject({
            ...schema._def,
            shape: () => newShape,
        });
    }
    else if (schema instanceof ZodArray) {
        return new ZodArray({
            ...schema._def,
            type: deepPartialify(schema.element),
        });
    }
    else if (schema instanceof ZodOptional) {
        return ZodOptional.create(deepPartialify(schema.unwrap()));
    }
    else if (schema instanceof ZodNullable) {
        return ZodNullable.create(deepPartialify(schema.unwrap()));
    }
    else if (schema instanceof ZodTuple) {
        return ZodTuple.create(schema.items.map((item) => deepPartialify(item)));
    }
    else {
        return schema;
    }
}
class ZodObject extends ZodType {
    constructor() {
        super(...arguments);
        this._cached = null;
        /**
         * @deprecated In most cases, this is no longer needed - unknown properties are now silently stripped.
         * If you want to pass through unknown properties, use `.passthrough()` instead.
         */
        this.nonstrict = this.passthrough;
        // extend<
        //   Augmentation extends ZodRawShape,
        //   NewOutput extends util.flatten<{
        //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation
        //       ? Augmentation[k]["_output"]
        //       : k extends keyof Output
        //       ? Output[k]
        //       : never;
        //   }>,
        //   NewInput extends util.flatten<{
        //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation
        //       ? Augmentation[k]["_input"]
        //       : k extends keyof Input
        //       ? Input[k]
        //       : never;
        //   }>
        // >(
        //   augmentation: Augmentation
        // ): ZodObject<
        //   extendShape<T, Augmentation>,
        //   UnknownKeys,
        //   Catchall,
        //   NewOutput,
        //   NewInput
        // > {
        //   return new ZodObject({
        //     ...this._def,
        //     shape: () => ({
        //       ...this._def.shape(),
        //       ...augmentation,
        //     }),
        //   }) as any;
        // }
        /**
         * @deprecated Use `.extend` instead
         *  */
        this.augment = this.extend;
    }
    _getCached() {
        if (this._cached !== null)
            return this._cached;
        const shape = this._def.shape();
        const keys = util.objectKeys(shape);
        return (this._cached = { shape, keys });
    }
    _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.object) {
            const ctx = this._getOrReturnCtx(input);
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_type,
                expected: ZodParsedType.object,
                received: ctx.parsedType,
            });
            return INVALID;
        }
        const { status, ctx } = this._processInputParams(input);
        const { shape, keys: shapeKeys } = this._getCached();
        const extraKeys = [];
        if (!(this._def.catchall instanceof ZodNever &&
            this._def.unknownKeys === "strip")) {
            for (const key in ctx.data) {
                if (!shapeKeys.includes(key)) {
                    extraKeys.push(key);
                }
            }
        }
        const pairs = [];
        for (const key of shapeKeys) {
            const keyValidator = shape[key];
            const value = ctx.data[key];
            pairs.push({
                key: { status: "valid", value: key },
                value: keyValidator._parse(new ParseInputLazyPath(ctx, value, ctx.path, key)),
                alwaysSet: key in ctx.data,
            });
        }
        if (this._def.catchall instanceof ZodNever) {
            const unknownKeys = this._def.unknownKeys;
            if (unknownKeys === "passthrough") {
                for (const key of extraKeys) {
                    pairs.push({
                        key: { status: "valid", value: key },
                        value: { status: "valid", value: ctx.data[key] },
                    });
                }
            }
            else if (unknownKeys === "strict") {
                if (extraKeys.length > 0) {
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.unrecognized_keys,
                        keys: extraKeys,
                    });
                    status.dirty();
                }
            }
            else if (unknownKeys === "strip") ;
            else {
                throw new Error(`Internal ZodObject error: invalid unknownKeys value.`);
            }
        }
        else {
            // run catchall validation
            const catchall = this._def.catchall;
            for (const key of extraKeys) {
                const value = ctx.data[key];
                pairs.push({
                    key: { status: "valid", value: key },
                    value: catchall._parse(new ParseInputLazyPath(ctx, value, ctx.path, key) //, ctx.child(key), value, getParsedType(value)
                    ),
                    alwaysSet: key in ctx.data,
                });
            }
        }
        if (ctx.common.async) {
            return Promise.resolve()
                .then(async () => {
                const syncPairs = [];
                for (const pair of pairs) {
                    const key = await pair.key;
                    syncPairs.push({
                        key,
                        value: await pair.value,
                        alwaysSet: pair.alwaysSet,
                    });
                }
                return syncPairs;
            })
                .then((syncPairs) => {
                return ParseStatus.mergeObjectSync(status, syncPairs);
            });
        }
        else {
            return ParseStatus.mergeObjectSync(status, pairs);
        }
    }
    get shape() {
        return this._def.shape();
    }
    strict(message) {
        errorUtil.errToObj;
        return new ZodObject({
            ...this._def,
            unknownKeys: "strict",
            ...(message !== undefined
                ? {
                    errorMap: (issue, ctx) => {
                        var _a, _b, _c, _d;
                        const defaultError = (_c = (_b = (_a = this._def).errorMap) === null || _b === void 0 ? void 0 : _b.call(_a, issue, ctx).message) !== null && _c !== void 0 ? _c : ctx.defaultError;
                        if (issue.code === "unrecognized_keys")
                            return {
                                message: (_d = errorUtil.errToObj(message).message) !== null && _d !== void 0 ? _d : defaultError,
                            };
                        return {
                            message: defaultError,
                        };
                    },
                }
                : {}),
        });
    }
    strip() {
        return new ZodObject({
            ...this._def,
            unknownKeys: "strip",
        });
    }
    passthrough() {
        return new ZodObject({
            ...this._def,
            unknownKeys: "passthrough",
        });
    }
    // const AugmentFactory =
    //   <Def extends ZodObjectDef>(def: Def) =>
    //   <Augmentation extends ZodRawShape>(
    //     augmentation: Augmentation
    //   ): ZodObject<
    //     extendShape<ReturnType<Def["shape"]>, Augmentation>,
    //     Def["unknownKeys"],
    //     Def["catchall"]
    //   > => {
    //     return new ZodObject({
    //       ...def,
    //       shape: () => ({
    //         ...def.shape(),
    //         ...augmentation,
    //       }),
    //     }) as any;
    //   };
    extend(augmentation) {
        return new ZodObject({
            ...this._def,
            shape: () => ({
                ...this._def.shape(),
                ...augmentation,
            }),
        });
    }
    /**
     * Prior to zod@1.0.12 there was a bug in the
     * inferred type of merged objects. Please
     * upgrade if you are experiencing issues.
     */
    merge(merging) {
        const merged = new ZodObject({
            unknownKeys: merging._def.unknownKeys,
            catchall: merging._def.catchall,
            shape: () => ({
                ...this._def.shape(),
                ...merging._def.shape(),
            }),
            typeName: ZodFirstPartyTypeKind.ZodObject,
        });
        return merged;
    }
    // merge<
    //   Incoming extends AnyZodObject,
    //   Augmentation extends Incoming["shape"],
    //   NewOutput extends {
    //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation
    //       ? Augmentation[k]["_output"]
    //       : k extends keyof Output
    //       ? Output[k]
    //       : never;
    //   },
    //   NewInput extends {
    //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation
    //       ? Augmentation[k]["_input"]
    //       : k extends keyof Input
    //       ? Input[k]
    //       : never;
    //   }
    // >(
    //   merging: Incoming
    // ): ZodObject<
    //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
    //   Incoming["_def"]["unknownKeys"],
    //   Incoming["_def"]["catchall"],
    //   NewOutput,
    //   NewInput
    // > {
    //   const merged: any = new ZodObject({
    //     unknownKeys: merging._def.unknownKeys,
    //     catchall: merging._def.catchall,
    //     shape: () =>
    //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
    //     typeName: ZodFirstPartyTypeKind.ZodObject,
    //   }) as any;
    //   return merged;
    // }
    setKey(key, schema) {
        return this.augment({ [key]: schema });
    }
    // merge<Incoming extends AnyZodObject>(
    //   merging: Incoming
    // ): //ZodObject<T & Incoming["_shape"], UnknownKeys, Catchall> = (merging) => {
    // ZodObject<
    //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
    //   Incoming["_def"]["unknownKeys"],
    //   Incoming["_def"]["catchall"]
    // > {
    //   // const mergedShape = objectUtil.mergeShapes(
    //   //   this._def.shape(),
    //   //   merging._def.shape()
    //   // );
    //   const merged: any = new ZodObject({
    //     unknownKeys: merging._def.unknownKeys,
    //     catchall: merging._def.catchall,
    //     shape: () =>
    //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
    //     typeName: ZodFirstPartyTypeKind.ZodObject,
    //   }) as any;
    //   return merged;
    // }
    catchall(index) {
        return new ZodObject({
            ...this._def,
            catchall: index,
        });
    }
    pick(mask) {
        const shape = {};
        util.objectKeys(mask).forEach((key) => {
            if (mask[key] && this.shape[key]) {
                shape[key] = this.shape[key];
            }
        });
        return new ZodObject({
            ...this._def,
            shape: () => shape,
        });
    }
    omit(mask) {
        const shape = {};
        util.objectKeys(this.shape).forEach((key) => {
            if (!mask[key]) {
                shape[key] = this.shape[key];
            }
        });
        return new ZodObject({
            ...this._def,
            shape: () => shape,
        });
    }
    /**
     * @deprecated
     */
    deepPartial() {
        return deepPartialify(this);
    }
    partial(mask) {
        const newShape = {};
        util.objectKeys(this.shape).forEach((key) => {
            const fieldSchema = this.shape[key];
            if (mask && !mask[key]) {
                newShape[key] = fieldSchema;
            }
            else {
                newShape[key] = fieldSchema.optional();
            }
        });
        return new ZodObject({
            ...this._def,
            shape: () => newShape,
        });
    }
    required(mask) {
        const newShape = {};
        util.objectKeys(this.shape).forEach((key) => {
            if (mask && !mask[key]) {
                newShape[key] = this.shape[key];
            }
            else {
                const fieldSchema = this.shape[key];
                let newField = fieldSchema;
                while (newField instanceof ZodOptional) {
                    newField = newField._def.innerType;
                }
                newShape[key] = newField;
            }
        });
        return new ZodObject({
            ...this._def,
            shape: () => newShape,
        });
    }
    keyof() {
        return createZodEnum(util.objectKeys(this.shape));
    }
}
ZodObject.create = (shape, params) => {
    return new ZodObject({
        shape: () => shape,
        unknownKeys: "strip",
        catchall: ZodNever.create(),
        typeName: ZodFirstPartyTypeKind.ZodObject,
        ...processCreateParams(params),
    });
};
ZodObject.strictCreate = (shape, params) => {
    return new ZodObject({
        shape: () => shape,
        unknownKeys: "strict",
        catchall: ZodNever.create(),
        typeName: ZodFirstPartyTypeKind.ZodObject,
        ...processCreateParams(params),
    });
};
ZodObject.lazycreate = (shape, params) => {
    return new ZodObject({
        shape,
        unknownKeys: "strip",
        catchall: ZodNever.create(),
        typeName: ZodFirstPartyTypeKind.ZodObject,
        ...processCreateParams(params),
    });
};
class ZodUnion extends ZodType {
    _parse(input) {
        const { ctx } = this._processInputParams(input);
        const options = this._def.options;
        function handleResults(results) {
            // return first issue-free validation if it exists
            for (const result of results) {
                if (result.result.status === "valid") {
                    return result.result;
                }
            }
            for (const result of results) {
                if (result.result.status === "dirty") {
                    // add issues from dirty option
                    ctx.common.issues.push(...result.ctx.common.issues);
                    return result.result;
                }
            }
            // return invalid
            const unionErrors = results.map((result) => new ZodError(result.ctx.common.issues));
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_union,
                unionErrors,
            });
            return INVALID;
        }
        if (ctx.common.async) {
            return Promise.all(options.map(async (option) => {
                const childCtx = {
                    ...ctx,
                    common: {
                        ...ctx.common,
                        issues: [],
                    },
                    parent: null,
                };
                return {
                    result: await option._parseAsync({
                        data: ctx.data,
                        path: ctx.path,
                        parent: childCtx,
                    }),
                    ctx: childCtx,
                };
            })).then(handleResults);
        }
        else {
            let dirty = undefined;
            const issues = [];
            for (const option of options) {
                const childCtx = {
                    ...ctx,
                    common: {
                        ...ctx.common,
                        issues: [],
                    },
                    parent: null,
                };
                const result = option._parseSync({
                    data: ctx.data,
                    path: ctx.path,
                    parent: childCtx,
                });
                if (result.status === "valid") {
                    return result;
                }
                else if (result.status === "dirty" && !dirty) {
                    dirty = { result, ctx: childCtx };
                }
                if (childCtx.common.issues.length) {
                    issues.push(childCtx.common.issues);
                }
            }
            if (dirty) {
                ctx.common.issues.push(...dirty.ctx.common.issues);
                return dirty.result;
            }
            const unionErrors = issues.map((issues) => new ZodError(issues));
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_union,
                unionErrors,
            });
            return INVALID;
        }
    }
    get options() {
        return this._def.options;
    }
}
ZodUnion.create = (types, params) => {
    return new ZodUnion({
        options: types,
        typeName: ZodFirstPartyTypeKind.ZodUnion,
        ...processCreateParams(params),
    });
};
/////////////////////////////////////////////////////
/////////////////////////////////////////////////////
//////////                                 //////////
//////////      ZodDiscriminatedUnion      //////////
//////////                                 //////////
/////////////////////////////////////////////////////
/////////////////////////////////////////////////////
const getDiscriminator = (type) => {
    if (type instanceof ZodLazy) {
        return getDiscriminator(type.schema);
    }
    else if (type instanceof ZodEffects) {
        return getDiscriminator(type.innerType());
    }
    else if (type instanceof ZodLiteral) {
        return [type.value];
    }
    else if (type instanceof ZodEnum) {
        return type.options;
    }
    else if (type instanceof ZodNativeEnum) {
        // eslint-disable-next-line ban/ban
        return Object.keys(type.enum);
    }
    else if (type instanceof ZodDefault) {
        return getDiscriminator(type._def.innerType);
    }
    else if (type instanceof ZodUndefined) {
        return [undefined];
    }
    else if (type instanceof ZodNull) {
        return [null];
    }
    else {
        return null;
    }
};
class ZodDiscriminatedUnion extends ZodType {
    _parse(input) {
        const { ctx } = this._processInputParams(input);
        if (ctx.parsedType !== ZodParsedType.object) {
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_type,
                expected: ZodParsedType.object,
                received: ctx.parsedType,
            });
            return INVALID;
        }
        const discriminator = this.discriminator;
        const discriminatorValue = ctx.data[discriminator];
        const option = this.optionsMap.get(discriminatorValue);
        if (!option) {
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_union_discriminator,
                options: Array.from(this.optionsMap.keys()),
                path: [discriminator],
            });
            return INVALID;
        }
        if (ctx.common.async) {
            return option._parseAsync({
                data: ctx.data,
                path: ctx.path,
                parent: ctx,
            });
        }
        else {
            return option._parseSync({
                data: ctx.data,
                path: ctx.path,
                parent: ctx,
            });
        }
    }
    get discriminator() {
        return this._def.discriminator;
    }
    get options() {
        return this._def.options;
    }
    get optionsMap() {
        return this._def.optionsMap;
    }
    /**
     * The constructor of the discriminated union schema. Its behaviour is very similar to that of the normal z.union() constructor.
     * However, it only allows a union of objects, all of which need to share a discriminator property. This property must
     * have a different value for each object in the union.
     * @param discriminator the name of the discriminator property
     * @param types an array of object schemas
     * @param params
     */
    static create(discriminator, options, params) {
        // Get all the valid discriminator values
        const optionsMap = new Map();
        // try {
        for (const type of options) {
            const discriminatorValues = getDiscriminator(type.shape[discriminator]);
            if (!discriminatorValues) {
                throw new Error(`A discriminator value for key \`${discriminator}\` could not be extracted from all schema options`);
            }
            for (const value of discriminatorValues) {
                if (optionsMap.has(value)) {
                    throw new Error(`Discriminator property ${String(discriminator)} has duplicate value ${String(value)}`);
                }
                optionsMap.set(value, type);
            }
        }
        return new ZodDiscriminatedUnion({
            typeName: ZodFirstPartyTypeKind.ZodDiscriminatedUnion,
            discriminator,
            options,
            optionsMap,
            ...processCreateParams(params),
        });
    }
}
function mergeValues(a, b) {
    const aType = getParsedType(a);
    const bType = getParsedType(b);
    if (a === b) {
        return { valid: true, data: a };
    }
    else if (aType === ZodParsedType.object && bType === ZodParsedType.object) {
        const bKeys = util.objectKeys(b);
        const sharedKeys = util
            .objectKeys(a)
            .filter((key) => bKeys.indexOf(key) !== -1);
        const newObj = { ...a, ...b };
        for (const key of sharedKeys) {
            const sharedValue = mergeValues(a[key], b[key]);
            if (!sharedValue.valid) {
                return { valid: false };
            }
            newObj[key] = sharedValue.data;
        }
        return { valid: true, data: newObj };
    }
    else if (aType === ZodParsedType.array && bType === ZodParsedType.array) {
        if (a.length !== b.length) {
            return { valid: false };
        }
        const newArray = [];
        for (let index = 0; index < a.length; index++) {
            const itemA = a[index];
            const itemB = b[index];
            const sharedValue = mergeValues(itemA, itemB);
            if (!sharedValue.valid) {
                return { valid: false };
            }
            newArray.push(sharedValue.data);
        }
        return { valid: true, data: newArray };
    }
    else if (aType === ZodParsedType.date &&
        bType === ZodParsedType.date &&
        +a === +b) {
        return { valid: true, data: a };
    }
    else {
        return { valid: false };
    }
}
class ZodIntersection extends ZodType {
    _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        const handleParsed = (parsedLeft, parsedRight) => {
            if (isAborted(parsedLeft) || isAborted(parsedRight)) {
                return INVALID;
            }
            const merged = mergeValues(parsedLeft.value, parsedRight.value);
            if (!merged.valid) {
                addIssueToContext(ctx, {
                    code: ZodIssueCode.invalid_intersection_types,
                });
                return INVALID;
            }
            if (isDirty(parsedLeft) || isDirty(parsedRight)) {
                status.dirty();
            }
            return { status: status.value, value: merged.data };
        };
        if (ctx.common.async) {
            return Promise.all([
                this._def.left._parseAsync({
                    data: ctx.data,
                    path: ctx.path,
                    parent: ctx,
                }),
                this._def.right._parseAsync({
                    data: ctx.data,
                    path: ctx.path,
                    parent: ctx,
                }),
            ]).then(([left, right]) => handleParsed(left, right));
        }
        else {
            return handleParsed(this._def.left._parseSync({
                data: ctx.data,
                path: ctx.path,
                parent: ctx,
            }), this._def.right._parseSync({
                data: ctx.data,
                path: ctx.path,
                parent: ctx,
            }));
        }
    }
}
ZodIntersection.create = (left, right, params) => {
    return new ZodIntersection({
        left: left,
        right: right,
        typeName: ZodFirstPartyTypeKind.ZodIntersection,
        ...processCreateParams(params),
    });
};
class ZodTuple extends ZodType {
    _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        if (ctx.parsedType !== ZodParsedType.array) {
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_type,
                expected: ZodParsedType.array,
                received: ctx.parsedType,
            });
            return INVALID;
        }
        if (ctx.data.length < this._def.items.length) {
            addIssueToContext(ctx, {
                code: ZodIssueCode.too_small,
                minimum: this._def.items.length,
                inclusive: true,
                exact: false,
                type: "array",
            });
            return INVALID;
        }
        const rest = this._def.rest;
        if (!rest && ctx.data.length > this._def.items.length) {
            addIssueToContext(ctx, {
                code: ZodIssueCode.too_big,
                maximum: this._def.items.length,
                inclusive: true,
                exact: false,
                type: "array",
            });
            status.dirty();
        }
        const items = [...ctx.data]
            .map((item, itemIndex) => {
            const schema = this._def.items[itemIndex] || this._def.rest;
            if (!schema)
                return null;
            return schema._parse(new ParseInputLazyPath(ctx, item, ctx.path, itemIndex));
        })
            .filter((x) => !!x); // filter nulls
        if (ctx.common.async) {
            return Promise.all(items).then((results) => {
                return ParseStatus.mergeArray(status, results);
            });
        }
        else {
            return ParseStatus.mergeArray(status, items);
        }
    }
    get items() {
        return this._def.items;
    }
    rest(rest) {
        return new ZodTuple({
            ...this._def,
            rest,
        });
    }
}
ZodTuple.create = (schemas, params) => {
    if (!Array.isArray(schemas)) {
        throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
    }
    return new ZodTuple({
        items: schemas,
        typeName: ZodFirstPartyTypeKind.ZodTuple,
        rest: null,
        ...processCreateParams(params),
    });
};
class ZodRecord extends ZodType {
    get keySchema() {
        return this._def.keyType;
    }
    get valueSchema() {
        return this._def.valueType;
    }
    _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        if (ctx.parsedType !== ZodParsedType.object) {
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_type,
                expected: ZodParsedType.object,
                received: ctx.parsedType,
            });
            return INVALID;
        }
        const pairs = [];
        const keyType = this._def.keyType;
        const valueType = this._def.valueType;
        for (const key in ctx.data) {
            pairs.push({
                key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, key)),
                value: valueType._parse(new ParseInputLazyPath(ctx, ctx.data[key], ctx.path, key)),
            });
        }
        if (ctx.common.async) {
            return ParseStatus.mergeObjectAsync(status, pairs);
        }
        else {
            return ParseStatus.mergeObjectSync(status, pairs);
        }
    }
    get element() {
        return this._def.valueType;
    }
    static create(first, second, third) {
        if (second instanceof ZodType) {
            return new ZodRecord({
                keyType: first,
                valueType: second,
                typeName: ZodFirstPartyTypeKind.ZodRecord,
                ...processCreateParams(third),
            });
        }
        return new ZodRecord({
            keyType: ZodString.create(),
            valueType: first,
            typeName: ZodFirstPartyTypeKind.ZodRecord,
            ...processCreateParams(second),
        });
    }
}
class ZodMap extends ZodType {
    _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        if (ctx.parsedType !== ZodParsedType.map) {
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_type,
                expected: ZodParsedType.map,
                received: ctx.parsedType,
            });
            return INVALID;
        }
        const keyType = this._def.keyType;
        const valueType = this._def.valueType;
        const pairs = [...ctx.data.entries()].map(([key, value], index) => {
            return {
                key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, [index, "key"])),
                value: valueType._parse(new ParseInputLazyPath(ctx, value, ctx.path, [index, "value"])),
            };
        });
        if (ctx.common.async) {
            const finalMap = new Map();
            return Promise.resolve().then(async () => {
                for (const pair of pairs) {
                    const key = await pair.key;
                    const value = await pair.value;
                    if (key.status === "aborted" || value.status === "aborted") {
                        return INVALID;
                    }
                    if (key.status === "dirty" || value.status === "dirty") {
                        status.dirty();
                    }
                    finalMap.set(key.value, value.value);
                }
                return { status: status.value, value: finalMap };
            });
        }
        else {
            const finalMap = new Map();
            for (const pair of pairs) {
                const key = pair.key;
                const value = pair.value;
                if (key.status === "aborted" || value.status === "aborted") {
                    return INVALID;
                }
                if (key.status === "dirty" || value.status === "dirty") {
                    status.dirty();
                }
                finalMap.set(key.value, value.value);
            }
            return { status: status.value, value: finalMap };
        }
    }
}
ZodMap.create = (keyType, valueType, params) => {
    return new ZodMap({
        valueType,
        keyType,
        typeName: ZodFirstPartyTypeKind.ZodMap,
        ...processCreateParams(params),
    });
};
class ZodSet extends ZodType {
    _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        if (ctx.parsedType !== ZodParsedType.set) {
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_type,
                expected: ZodParsedType.set,
                received: ctx.parsedType,
            });
            return INVALID;
        }
        const def = this._def;
        if (def.minSize !== null) {
            if (ctx.data.size < def.minSize.value) {
                addIssueToContext(ctx, {
                    code: ZodIssueCode.too_small,
                    minimum: def.minSize.value,
                    type: "set",
                    inclusive: true,
                    exact: false,
                    message: def.minSize.message,
                });
                status.dirty();
            }
        }
        if (def.maxSize !== null) {
            if (ctx.data.size > def.maxSize.value) {
                addIssueToContext(ctx, {
                    code: ZodIssueCode.too_big,
                    maximum: def.maxSize.value,
                    type: "set",
                    inclusive: true,
                    exact: false,
                    message: def.maxSize.message,
                });
                status.dirty();
            }
        }
        const valueType = this._def.valueType;
        function finalizeSet(elements) {
            const parsedSet = new Set();
            for (const element of elements) {
                if (element.status === "aborted")
                    return INVALID;
                if (element.status === "dirty")
                    status.dirty();
                parsedSet.add(element.value);
            }
            return { status: status.value, value: parsedSet };
        }
        const elements = [...ctx.data.values()].map((item, i) => valueType._parse(new ParseInputLazyPath(ctx, item, ctx.path, i)));
        if (ctx.common.async) {
            return Promise.all(elements).then((elements) => finalizeSet(elements));
        }
        else {
            return finalizeSet(elements);
        }
    }
    min(minSize, message) {
        return new ZodSet({
            ...this._def,
            minSize: { value: minSize, message: errorUtil.toString(message) },
        });
    }
    max(maxSize, message) {
        return new ZodSet({
            ...this._def,
            maxSize: { value: maxSize, message: errorUtil.toString(message) },
        });
    }
    size(size, message) {
        return this.min(size, message).max(size, message);
    }
    nonempty(message) {
        return this.min(1, message);
    }
}
ZodSet.create = (valueType, params) => {
    return new ZodSet({
        valueType,
        minSize: null,
        maxSize: null,
        typeName: ZodFirstPartyTypeKind.ZodSet,
        ...processCreateParams(params),
    });
};
class ZodFunction extends ZodType {
    constructor() {
        super(...arguments);
        this.validate = this.implement;
    }
    _parse(input) {
        const { ctx } = this._processInputParams(input);
        if (ctx.parsedType !== ZodParsedType.function) {
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_type,
                expected: ZodParsedType.function,
                received: ctx.parsedType,
            });
            return INVALID;
        }
        function makeArgsIssue(args, error) {
            return makeIssue({
                data: args,
                path: ctx.path,
                errorMaps: [
                    ctx.common.contextualErrorMap,
                    ctx.schemaErrorMap,
                    getErrorMap(),
                    errorMap,
                ].filter((x) => !!x),
                issueData: {
                    code: ZodIssueCode.invalid_arguments,
                    argumentsError: error,
                },
            });
        }
        function makeReturnsIssue(returns, error) {
            return makeIssue({
                data: returns,
                path: ctx.path,
                errorMaps: [
                    ctx.common.contextualErrorMap,
                    ctx.schemaErrorMap,
                    getErrorMap(),
                    errorMap,
                ].filter((x) => !!x),
                issueData: {
                    code: ZodIssueCode.invalid_return_type,
                    returnTypeError: error,
                },
            });
        }
        const params = { errorMap: ctx.common.contextualErrorMap };
        const fn = ctx.data;
        if (this._def.returns instanceof ZodPromise) {
            return OK(async (...args) => {
                const error = new ZodError([]);
                const parsedArgs = await this._def.args
                    .parseAsync(args, params)
                    .catch((e) => {
                    error.addIssue(makeArgsIssue(args, e));
                    throw error;
                });
                const result = await fn(...parsedArgs);
                const parsedReturns = await this._def.returns._def.type
                    .parseAsync(result, params)
                    .catch((e) => {
                    error.addIssue(makeReturnsIssue(result, e));
                    throw error;
                });
                return parsedReturns;
            });
        }
        else {
            return OK((...args) => {
                const parsedArgs = this._def.args.safeParse(args, params);
                if (!parsedArgs.success) {
                    throw new ZodError([makeArgsIssue(args, parsedArgs.error)]);
                }
                const result = fn(...parsedArgs.data);
                const parsedReturns = this._def.returns.safeParse(result, params);
                if (!parsedReturns.success) {
                    throw new ZodError([makeReturnsIssue(result, parsedReturns.error)]);
                }
                return parsedReturns.data;
            });
        }
    }
    parameters() {
        return this._def.args;
    }
    returnType() {
        return this._def.returns;
    }
    args(...items) {
        return new ZodFunction({
            ...this._def,
            args: ZodTuple.create(items).rest(ZodUnknown.create()),
        });
    }
    returns(returnType) {
        return new ZodFunction({
            ...this._def,
            returns: returnType,
        });
    }
    implement(func) {
        const validatedFunc = this.parse(func);
        return validatedFunc;
    }
    strictImplement(func) {
        const validatedFunc = this.parse(func);
        return validatedFunc;
    }
    static create(args, returns, params) {
        return new ZodFunction({
            args: (args
                ? args
                : ZodTuple.create([]).rest(ZodUnknown.create())),
            returns: returns || ZodUnknown.create(),
            typeName: ZodFirstPartyTypeKind.ZodFunction,
            ...processCreateParams(params),
        });
    }
}
class ZodLazy extends ZodType {
    get schema() {
        return this._def.getter();
    }
    _parse(input) {
        const { ctx } = this._processInputParams(input);
        const lazySchema = this._def.getter();
        return lazySchema._parse({ data: ctx.data, path: ctx.path, parent: ctx });
    }
}
ZodLazy.create = (getter, params) => {
    return new ZodLazy({
        getter: getter,
        typeName: ZodFirstPartyTypeKind.ZodLazy,
        ...processCreateParams(params),
    });
};
class ZodLiteral extends ZodType {
    _parse(input) {
        if (input.data !== this._def.value) {
            const ctx = this._getOrReturnCtx(input);
            addIssueToContext(ctx, {
                received: ctx.data,
                code: ZodIssueCode.invalid_literal,
                expected: this._def.value,
            });
            return INVALID;
        }
        return { status: "valid", value: input.data };
    }
    get value() {
        return this._def.value;
    }
}
ZodLiteral.create = (value, params) => {
    return new ZodLiteral({
        value: value,
        typeName: ZodFirstPartyTypeKind.ZodLiteral,
        ...processCreateParams(params),
    });
};
function createZodEnum(values, params) {
    return new ZodEnum({
        values: values,
        typeName: ZodFirstPartyTypeKind.ZodEnum,
        ...processCreateParams(params),
    });
}
class ZodEnum extends ZodType {
    _parse(input) {
        if (typeof input.data !== "string") {
            const ctx = this._getOrReturnCtx(input);
            const expectedValues = this._def.values;
            addIssueToContext(ctx, {
                expected: util.joinValues(expectedValues),
                received: ctx.parsedType,
                code: ZodIssueCode.invalid_type,
            });
            return INVALID;
        }
        if (this._def.values.indexOf(input.data) === -1) {
            const ctx = this._getOrReturnCtx(input);
            const expectedValues = this._def.values;
            addIssueToContext(ctx, {
                received: ctx.data,
                code: ZodIssueCode.invalid_enum_value,
                options: expectedValues,
            });
            return INVALID;
        }
        return OK(input.data);
    }
    get options() {
        return this._def.values;
    }
    get enum() {
        const enumValues = {};
        for (const val of this._def.values) {
            enumValues[val] = val;
        }
        return enumValues;
    }
    get Values() {
        const enumValues = {};
        for (const val of this._def.values) {
            enumValues[val] = val;
        }
        return enumValues;
    }
    get Enum() {
        const enumValues = {};
        for (const val of this._def.values) {
            enumValues[val] = val;
        }
        return enumValues;
    }
    extract(values) {
        return ZodEnum.create(values);
    }
    exclude(values) {
        return ZodEnum.create(this.options.filter((opt) => !values.includes(opt)));
    }
}
ZodEnum.create = createZodEnum;
class ZodNativeEnum extends ZodType {
    _parse(input) {
        const nativeEnumValues = util.getValidEnumValues(this._def.values);
        const ctx = this._getOrReturnCtx(input);
        if (ctx.parsedType !== ZodParsedType.string &&
            ctx.parsedType !== ZodParsedType.number) {
            const expectedValues = util.objectValues(nativeEnumValues);
            addIssueToContext(ctx, {
                expected: util.joinValues(expectedValues),
                received: ctx.parsedType,
                code: ZodIssueCode.invalid_type,
            });
            return INVALID;
        }
        if (nativeEnumValues.indexOf(input.data) === -1) {
            const expectedValues = util.objectValues(nativeEnumValues);
            addIssueToContext(ctx, {
                received: ctx.data,
                code: ZodIssueCode.invalid_enum_value,
                options: expectedValues,
            });
            return INVALID;
        }
        return OK(input.data);
    }
    get enum() {
        return this._def.values;
    }
}
ZodNativeEnum.create = (values, params) => {
    return new ZodNativeEnum({
        values: values,
        typeName: ZodFirstPartyTypeKind.ZodNativeEnum,
        ...processCreateParams(params),
    });
};
class ZodPromise extends ZodType {
    unwrap() {
        return this._def.type;
    }
    _parse(input) {
        const { ctx } = this._processInputParams(input);
        if (ctx.parsedType !== ZodParsedType.promise &&
            ctx.common.async === false) {
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_type,
                expected: ZodParsedType.promise,
                received: ctx.parsedType,
            });
            return INVALID;
        }
        const promisified = ctx.parsedType === ZodParsedType.promise
            ? ctx.data
            : Promise.resolve(ctx.data);
        return OK(promisified.then((data) => {
            return this._def.type.parseAsync(data, {
                path: ctx.path,
                errorMap: ctx.common.contextualErrorMap,
            });
        }));
    }
}
ZodPromise.create = (schema, params) => {
    return new ZodPromise({
        type: schema,
        typeName: ZodFirstPartyTypeKind.ZodPromise,
        ...processCreateParams(params),
    });
};
class ZodEffects extends ZodType {
    innerType() {
        return this._def.schema;
    }
    sourceType() {
        return this._def.schema._def.typeName === ZodFirstPartyTypeKind.ZodEffects
            ? this._def.schema.sourceType()
            : this._def.schema;
    }
    _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        const effect = this._def.effect || null;
        if (effect.type === "preprocess") {
            const processed = effect.transform(ctx.data);
            if (ctx.common.async) {
                return Promise.resolve(processed).then((processed) => {
                    return this._def.schema._parseAsync({
                        data: processed,
                        path: ctx.path,
                        parent: ctx,
                    });
                });
            }
            else {
                return this._def.schema._parseSync({
                    data: processed,
                    path: ctx.path,
                    parent: ctx,
                });
            }
        }
        const checkCtx = {
            addIssue: (arg) => {
                addIssueToContext(ctx, arg);
                if (arg.fatal) {
                    status.abort();
                }
                else {
                    status.dirty();
                }
            },
            get path() {
                return ctx.path;
            },
        };
        checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);
        if (effect.type === "refinement") {
            const executeRefinement = (acc
            // effect: RefinementEffect<any>
            ) => {
                const result = effect.refinement(acc, checkCtx);
                if (ctx.common.async) {
                    return Promise.resolve(result);
                }
                if (result instanceof Promise) {
                    throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
                }
                return acc;
            };
            if (ctx.common.async === false) {
                const inner = this._def.schema._parseSync({
                    data: ctx.data,
                    path: ctx.path,
                    parent: ctx,
                });
                if (inner.status === "aborted")
                    return INVALID;
                if (inner.status === "dirty")
                    status.dirty();
                // return value is ignored
                executeRefinement(inner.value);
                return { status: status.value, value: inner.value };
            }
            else {
                return this._def.schema
                    ._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx })
                    .then((inner) => {
                    if (inner.status === "aborted")
                        return INVALID;
                    if (inner.status === "dirty")
                        status.dirty();
                    return executeRefinement(inner.value).then(() => {
                        return { status: status.value, value: inner.value };
                    });
                });
            }
        }
        if (effect.type === "transform") {
            if (ctx.common.async === false) {
                const base = this._def.schema._parseSync({
                    data: ctx.data,
                    path: ctx.path,
                    parent: ctx,
                });
                if (!isValid(base))
                    return base;
                const result = effect.transform(base.value, checkCtx);
                if (result instanceof Promise) {
                    throw new Error(`Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.`);
                }
                return { status: status.value, value: result };
            }
            else {
                return this._def.schema
                    ._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx })
                    .then((base) => {
                    if (!isValid(base))
                        return base;
                    return Promise.resolve(effect.transform(base.value, checkCtx)).then((result) => ({ status: status.value, value: result }));
                });
            }
        }
        util.assertNever(effect);
    }
}
ZodEffects.create = (schema, effect, params) => {
    return new ZodEffects({
        schema,
        typeName: ZodFirstPartyTypeKind.ZodEffects,
        effect,
        ...processCreateParams(params),
    });
};
ZodEffects.createWithPreprocess = (preprocess, schema, params) => {
    return new ZodEffects({
        schema,
        effect: { type: "preprocess", transform: preprocess },
        typeName: ZodFirstPartyTypeKind.ZodEffects,
        ...processCreateParams(params),
    });
};
class ZodOptional extends ZodType {
    _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType === ZodParsedType.undefined) {
            return OK(undefined);
        }
        return this._def.innerType._parse(input);
    }
    unwrap() {
        return this._def.innerType;
    }
}
ZodOptional.create = (type, params) => {
    return new ZodOptional({
        innerType: type,
        typeName: ZodFirstPartyTypeKind.ZodOptional,
        ...processCreateParams(params),
    });
};
class ZodNullable extends ZodType {
    _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType === ZodParsedType.null) {
            return OK(null);
        }
        return this._def.innerType._parse(input);
    }
    unwrap() {
        return this._def.innerType;
    }
}
ZodNullable.create = (type, params) => {
    return new ZodNullable({
        innerType: type,
        typeName: ZodFirstPartyTypeKind.ZodNullable,
        ...processCreateParams(params),
    });
};
class ZodDefault extends ZodType {
    _parse(input) {
        const { ctx } = this._processInputParams(input);
        let data = ctx.data;
        if (ctx.parsedType === ZodParsedType.undefined) {
            data = this._def.defaultValue();
        }
        return this._def.innerType._parse({
            data,
            path: ctx.path,
            parent: ctx,
        });
    }
    removeDefault() {
        return this._def.innerType;
    }
}
ZodDefault.create = (type, params) => {
    return new ZodDefault({
        innerType: type,
        typeName: ZodFirstPartyTypeKind.ZodDefault,
        defaultValue: typeof params.default === "function"
            ? params.default
            : () => params.default,
        ...processCreateParams(params),
    });
};
class ZodCatch extends ZodType {
    _parse(input) {
        const { ctx } = this._processInputParams(input);
        // newCtx is used to not collect issues from inner types in ctx
        const newCtx = {
            ...ctx,
            common: {
                ...ctx.common,
                issues: [],
            },
        };
        const result = this._def.innerType._parse({
            data: newCtx.data,
            path: newCtx.path,
            parent: {
                ...newCtx,
            },
        });
        if (isAsync(result)) {
            return result.then((result) => {
                return {
                    status: "valid",
                    value: result.status === "valid"
                        ? result.value
                        : this._def.catchValue({
                            get error() {
                                return new ZodError(newCtx.common.issues);
                            },
                            input: newCtx.data,
                        }),
                };
            });
        }
        else {
            return {
                status: "valid",
                value: result.status === "valid"
                    ? result.value
                    : this._def.catchValue({
                        get error() {
                            return new ZodError(newCtx.common.issues);
                        },
                        input: newCtx.data,
                    }),
            };
        }
    }
    removeCatch() {
        return this._def.innerType;
    }
}
ZodCatch.create = (type, params) => {
    return new ZodCatch({
        innerType: type,
        typeName: ZodFirstPartyTypeKind.ZodCatch,
        catchValue: typeof params.catch === "function" ? params.catch : () => params.catch,
        ...processCreateParams(params),
    });
};
class ZodNaN extends ZodType {
    _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.nan) {
            const ctx = this._getOrReturnCtx(input);
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_type,
                expected: ZodParsedType.nan,
                received: ctx.parsedType,
            });
            return INVALID;
        }
        return { status: "valid", value: input.data };
    }
}
ZodNaN.create = (params) => {
    return new ZodNaN({
        typeName: ZodFirstPartyTypeKind.ZodNaN,
        ...processCreateParams(params),
    });
};
const BRAND = Symbol("zod_brand");
class ZodBranded extends ZodType {
    _parse(input) {
        const { ctx } = this._processInputParams(input);
        const data = ctx.data;
        return this._def.type._parse({
            data,
            path: ctx.path,
            parent: ctx,
        });
    }
    unwrap() {
        return this._def.type;
    }
}
class ZodPipeline extends ZodType {
    _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        if (ctx.common.async) {
            const handleAsync = async () => {
                const inResult = await this._def.in._parseAsync({
                    data: ctx.data,
                    path: ctx.path,
                    parent: ctx,
                });
                if (inResult.status === "aborted")
                    return INVALID;
                if (inResult.status === "dirty") {
                    status.dirty();
                    return DIRTY(inResult.value);
                }
                else {
                    return this._def.out._parseAsync({
                        data: inResult.value,
                        path: ctx.path,
                        parent: ctx,
                    });
                }
            };
            return handleAsync();
        }
        else {
            const inResult = this._def.in._parseSync({
                data: ctx.data,
                path: ctx.path,
                parent: ctx,
            });
            if (inResult.status === "aborted")
                return INVALID;
            if (inResult.status === "dirty") {
                status.dirty();
                return {
                    status: "dirty",
                    value: inResult.value,
                };
            }
            else {
                return this._def.out._parseSync({
                    data: inResult.value,
                    path: ctx.path,
                    parent: ctx,
                });
            }
        }
    }
    static create(a, b) {
        return new ZodPipeline({
            in: a,
            out: b,
            typeName: ZodFirstPartyTypeKind.ZodPipeline,
        });
    }
}
const custom = (check, params = {}, 
/*
 * @deprecated
 *
 * Pass `fatal` into the params object instead:
 *
 * ```ts
 * z.string().custom((val) => val.length > 5, { fatal: false })
 * ```
 *
 */
fatal) => {
    if (check)
        return ZodAny.create().superRefine((data, ctx) => {
            var _a, _b;
            if (!check(data)) {
                const p = typeof params === "function"
                    ? params(data)
                    : typeof params === "string"
                        ? { message: params }
                        : params;
                const _fatal = (_b = (_a = p.fatal) !== null && _a !== void 0 ? _a : fatal) !== null && _b !== void 0 ? _b : true;
                const p2 = typeof p === "string" ? { message: p } : p;
                ctx.addIssue({ code: "custom", ...p2, fatal: _fatal });
            }
        });
    return ZodAny.create();
};
const late = {
    object: ZodObject.lazycreate,
};
var ZodFirstPartyTypeKind;
(function (ZodFirstPartyTypeKind) {
    ZodFirstPartyTypeKind["ZodString"] = "ZodString";
    ZodFirstPartyTypeKind["ZodNumber"] = "ZodNumber";
    ZodFirstPartyTypeKind["ZodNaN"] = "ZodNaN";
    ZodFirstPartyTypeKind["ZodBigInt"] = "ZodBigInt";
    ZodFirstPartyTypeKind["ZodBoolean"] = "ZodBoolean";
    ZodFirstPartyTypeKind["ZodDate"] = "ZodDate";
    ZodFirstPartyTypeKind["ZodSymbol"] = "ZodSymbol";
    ZodFirstPartyTypeKind["ZodUndefined"] = "ZodUndefined";
    ZodFirstPartyTypeKind["ZodNull"] = "ZodNull";
    ZodFirstPartyTypeKind["ZodAny"] = "ZodAny";
    ZodFirstPartyTypeKind["ZodUnknown"] = "ZodUnknown";
    ZodFirstPartyTypeKind["ZodNever"] = "ZodNever";
    ZodFirstPartyTypeKind["ZodVoid"] = "ZodVoid";
    ZodFirstPartyTypeKind["ZodArray"] = "ZodArray";
    ZodFirstPartyTypeKind["ZodObject"] = "ZodObject";
    ZodFirstPartyTypeKind["ZodUnion"] = "ZodUnion";
    ZodFirstPartyTypeKind["ZodDiscriminatedUnion"] = "ZodDiscriminatedUnion";
    ZodFirstPartyTypeKind["ZodIntersection"] = "ZodIntersection";
    ZodFirstPartyTypeKind["ZodTuple"] = "ZodTuple";
    ZodFirstPartyTypeKind["ZodRecord"] = "ZodRecord";
    ZodFirstPartyTypeKind["ZodMap"] = "ZodMap";
    ZodFirstPartyTypeKind["ZodSet"] = "ZodSet";
    ZodFirstPartyTypeKind["ZodFunction"] = "ZodFunction";
    ZodFirstPartyTypeKind["ZodLazy"] = "ZodLazy";
    ZodFirstPartyTypeKind["ZodLiteral"] = "ZodLiteral";
    ZodFirstPartyTypeKind["ZodEnum"] = "ZodEnum";
    ZodFirstPartyTypeKind["ZodEffects"] = "ZodEffects";
    ZodFirstPartyTypeKind["ZodNativeEnum"] = "ZodNativeEnum";
    ZodFirstPartyTypeKind["ZodOptional"] = "ZodOptional";
    ZodFirstPartyTypeKind["ZodNullable"] = "ZodNullable";
    ZodFirstPartyTypeKind["ZodDefault"] = "ZodDefault";
    ZodFirstPartyTypeKind["ZodCatch"] = "ZodCatch";
    ZodFirstPartyTypeKind["ZodPromise"] = "ZodPromise";
    ZodFirstPartyTypeKind["ZodBranded"] = "ZodBranded";
    ZodFirstPartyTypeKind["ZodPipeline"] = "ZodPipeline";
})(ZodFirstPartyTypeKind || (ZodFirstPartyTypeKind = {}));
const instanceOfType = (
// const instanceOfType = <T extends new (...args: any[]) => any>(
cls, params = {
    message: `Input not instance of ${cls.name}`,
}) => custom((data) => data instanceof cls, params);
const stringType = ZodString.create;
const numberType = ZodNumber.create;
const nanType = ZodNaN.create;
const bigIntType = ZodBigInt.create;
const booleanType = ZodBoolean.create;
const dateType = ZodDate.create;
const symbolType = ZodSymbol.create;
const undefinedType = ZodUndefined.create;
const nullType = ZodNull.create;
const anyType = ZodAny.create;
const unknownType = ZodUnknown.create;
const neverType = ZodNever.create;
const voidType = ZodVoid.create;
const arrayType = ZodArray.create;
const objectType = ZodObject.create;
const strictObjectType = ZodObject.strictCreate;
const unionType = ZodUnion.create;
const discriminatedUnionType = ZodDiscriminatedUnion.create;
const intersectionType = ZodIntersection.create;
const tupleType = ZodTuple.create;
const recordType = ZodRecord.create;
const mapType = ZodMap.create;
const setType = ZodSet.create;
const functionType = ZodFunction.create;
const lazyType = ZodLazy.create;
const literalType = ZodLiteral.create;
const enumType = ZodEnum.create;
const nativeEnumType = ZodNativeEnum.create;
const promiseType = ZodPromise.create;
const effectsType = ZodEffects.create;
const optionalType = ZodOptional.create;
const nullableType = ZodNullable.create;
const preprocessType = ZodEffects.createWithPreprocess;
const pipelineType = ZodPipeline.create;
const ostring = () => stringType().optional();
const onumber = () => numberType().optional();
const oboolean = () => booleanType().optional();
const coerce = {
    string: ((arg) => ZodString.create({ ...arg, coerce: true })),
    number: ((arg) => ZodNumber.create({ ...arg, coerce: true })),
    boolean: ((arg) => ZodBoolean.create({
        ...arg,
        coerce: true,
    })),
    bigint: ((arg) => ZodBigInt.create({ ...arg, coerce: true })),
    date: ((arg) => ZodDate.create({ ...arg, coerce: true })),
};
const NEVER = INVALID;

var z = /*#__PURE__*/Object.freeze({
    __proto__: null,
    defaultErrorMap: errorMap,
    setErrorMap: setErrorMap,
    getErrorMap: getErrorMap,
    makeIssue: makeIssue,
    EMPTY_PATH: EMPTY_PATH,
    addIssueToContext: addIssueToContext,
    ParseStatus: ParseStatus,
    INVALID: INVALID,
    DIRTY: DIRTY,
    OK: OK,
    isAborted: isAborted,
    isDirty: isDirty,
    isValid: isValid,
    isAsync: isAsync,
    get util () { return util; },
    get objectUtil () { return objectUtil; },
    ZodParsedType: ZodParsedType,
    getParsedType: getParsedType,
    ZodType: ZodType,
    ZodString: ZodString,
    ZodNumber: ZodNumber,
    ZodBigInt: ZodBigInt,
    ZodBoolean: ZodBoolean,
    ZodDate: ZodDate,
    ZodSymbol: ZodSymbol,
    ZodUndefined: ZodUndefined,
    ZodNull: ZodNull,
    ZodAny: ZodAny,
    ZodUnknown: ZodUnknown,
    ZodNever: ZodNever,
    ZodVoid: ZodVoid,
    ZodArray: ZodArray,
    ZodObject: ZodObject,
    ZodUnion: ZodUnion,
    ZodDiscriminatedUnion: ZodDiscriminatedUnion,
    ZodIntersection: ZodIntersection,
    ZodTuple: ZodTuple,
    ZodRecord: ZodRecord,
    ZodMap: ZodMap,
    ZodSet: ZodSet,
    ZodFunction: ZodFunction,
    ZodLazy: ZodLazy,
    ZodLiteral: ZodLiteral,
    ZodEnum: ZodEnum,
    ZodNativeEnum: ZodNativeEnum,
    ZodPromise: ZodPromise,
    ZodEffects: ZodEffects,
    ZodTransformer: ZodEffects,
    ZodOptional: ZodOptional,
    ZodNullable: ZodNullable,
    ZodDefault: ZodDefault,
    ZodCatch: ZodCatch,
    ZodNaN: ZodNaN,
    BRAND: BRAND,
    ZodBranded: ZodBranded,
    ZodPipeline: ZodPipeline,
    custom: custom,
    Schema: ZodType,
    ZodSchema: ZodType,
    late: late,
    get ZodFirstPartyTypeKind () { return ZodFirstPartyTypeKind; },
    coerce: coerce,
    any: anyType,
    array: arrayType,
    bigint: bigIntType,
    boolean: booleanType,
    date: dateType,
    discriminatedUnion: discriminatedUnionType,
    effect: effectsType,
    'enum': enumType,
    'function': functionType,
    'instanceof': instanceOfType,
    intersection: intersectionType,
    lazy: lazyType,
    literal: literalType,
    map: mapType,
    nan: nanType,
    nativeEnum: nativeEnumType,
    never: neverType,
    'null': nullType,
    nullable: nullableType,
    number: numberType,
    object: objectType,
    oboolean: oboolean,
    onumber: onumber,
    optional: optionalType,
    ostring: ostring,
    pipeline: pipelineType,
    preprocess: preprocessType,
    promise: promiseType,
    record: recordType,
    set: setType,
    strictObject: strictObjectType,
    string: stringType,
    symbol: symbolType,
    transformer: effectsType,
    tuple: tupleType,
    'undefined': undefinedType,
    union: unionType,
    unknown: unknownType,
    'void': voidType,
    NEVER: NEVER,
    ZodIssueCode: ZodIssueCode,
    quotelessJson: quotelessJson,
    ZodError: ZodError
});




/***/ })

},
/******/ __webpack_require__ => { // webpackRuntimeModules
/******/ var __webpack_exec__ = (moduleId) => (__webpack_require__(__webpack_require__.s = moduleId))
/******/ __webpack_require__.O(0, [859,940,728], () => (__webpack_exec__(44648)));
/******/ var __webpack_exports__ = __webpack_require__.O();
/******/ }
]);