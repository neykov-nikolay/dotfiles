{"mappings":"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","sources":["<anon>","src/defaultOrigins.ts","src/index.ts"],"sourcesContent":["(() => {\n\nfunction $parcel$export(e, n, v, s) {\n  Object.defineProperty(e, n, {get: v, set: s, enumerable: true, configurable: true});\n}\n\n      var $parcel$global = globalThis;\n    \nvar $parcel$modules = {};\nvar $parcel$inits = {};\n\nvar parcelRequire = $parcel$global[\"parcelRequire4cfd\"];\n\nif (parcelRequire == null) {\n  parcelRequire = function(id) {\n    if (id in $parcel$modules) {\n      return $parcel$modules[id].exports;\n    }\n    if (id in $parcel$inits) {\n      var init = $parcel$inits[id];\n      delete $parcel$inits[id];\n      var module = {id: id, exports: {}};\n      $parcel$modules[id] = module;\n      init.call(module.exports, module, module.exports);\n      return module.exports;\n    }\n    var err = new Error(\"Cannot find module '\" + id + \"'\");\n    err.code = 'MODULE_NOT_FOUND';\n    throw err;\n  };\n\n  parcelRequire.register = function register(id, init) {\n    $parcel$inits[id] = init;\n  };\n\n  $parcel$global[\"parcelRequire4cfd\"] = parcelRequire;\n}\n\nvar parcelRegister = parcelRequire.register;\nparcelRegister(\"cg86O\", function(module, exports) {\n\n$parcel$export(module.exports, \"DEFAULT_ORIGIN_LIST\", () => $40edc2589855dfe4$export$90f2c8d1f20401a);\nconst $40edc2589855dfe4$export$90f2c8d1f20401a = [\n    \"https://hoppscotch.io\"\n];\n\n});\n\n\nvar $cg86O = parcelRequire(\"cg86O\");\nlet $c2848ebcf924d7cd$var$abortController = new AbortController();\nconst $c2848ebcf924d7cd$var$convertAxiosHeadersIntoFetchHeaders = (headers)=>Object.entries(headers).reduce((fetchHeaders, [key, value])=>{\n        // setting content-type when using fetch will break the upload unless we provide a proper boundary.\n        // but we omit that header and browser will set the correct boundary itself.\n        return key == \"content-type\" && headers[key] == \"multipart/form-data\" ? {\n            ...fetchHeaders\n        } : {\n            ...fetchHeaders,\n            [key]: value.toString()\n        };\n    }, {});\nasync function $c2848ebcf924d7cd$var$fetchUsingAxiosConfig(axiosConfig) {\n    const fetchHeaders = $c2848ebcf924d7cd$var$convertAxiosHeadersIntoFetchHeaders(axiosConfig.headers);\n    const requestMeta = {\n        timeData: {}\n    };\n    requestMeta.timeData.startTime = new Date().getTime();\n    const params = axiosConfig.params;\n    if (params) try {\n        const searchParams = new URLSearchParams(axiosConfig.url.split(\"?\")[1]);\n        Object.keys(params).forEach((key)=>{\n            searchParams.append(key, params[key]);\n        });\n        axiosConfig.url = axiosConfig.url.split(\"?\")[0] + `?${searchParams.toString()}`;\n    } catch (_) {}\n    // TODO: check different examples with axios body\n    const res = await fetch(axiosConfig.url, {\n        headers: {\n            ...fetchHeaders\n        },\n        method: axiosConfig.method,\n        // Ignore the body for GET and HEAD requests to prevent error with axios\n        body: [\n            \"get\",\n            \"head\"\n        ].includes(axiosConfig.method?.toLowerCase()) ? undefined : axiosConfig.data,\n        signal: $c2848ebcf924d7cd$var$abortController.signal\n    });\n    requestMeta.timeData.endTime = new Date().getTime();\n    return [\n        res,\n        requestMeta\n    ];\n}\nfunction $c2848ebcf924d7cd$var$errorToObject(e) {\n    if (e.response && e.response.data) try {\n        e.response.data = $c2848ebcf924d7cd$var$bufferToBase64(e.response.data);\n    } catch (_e) {}\n    // This mess below is a hack to go around Firefox's memory bounding system\n    return {\n        // Standard\n        message: e.message ? JSON.parse(JSON.stringify(e.message)) : undefined,\n        name: e.name ? JSON.parse(JSON.stringify(e.name)) : undefined,\n        // Mozilla\n        fileName: e.fileName ? JSON.parse(JSON.stringify(e.fileName)) : undefined,\n        lineNumber: e.lineNumber ? JSON.parse(JSON.stringify(e.lineNumber)) : undefined,\n        columnNumber: e.columnNumber ? JSON.parse(JSON.stringify(e.columnNumber)) : undefined,\n        stack: e.stack ? JSON.parse(JSON.stringify(e.stack)) : undefined,\n        // Axios\n        response: e.response ? JSON.parse(JSON.stringify(e.response)) : undefined\n    };\n}\nconst $c2848ebcf924d7cd$var$convertDataURLToBlob = (dataurl)=>{\n    const arr = dataurl.split(\",\");\n    const mime = arr[0].match(/:(.*?);/)[1];\n    const bstr = atob(arr[1]);\n    let n = bstr.length;\n    const u8arr = new Uint8Array(n);\n    while(n--)u8arr[n] = bstr.charCodeAt(n);\n    const blob = new Blob([\n        u8arr\n    ], {\n        type: mime\n    });\n    return blob;\n};\nconst $c2848ebcf924d7cd$var$parseCookieString = (str)=>str.split(\";\").map((value)=>value.split(\"=\")).reduce((acc, curr)=>{\n        if (!!curr[0] && !!curr[1]) acc[decodeURIComponent(curr[0].trim())] = decodeURIComponent(curr[1].trim());\n        return acc;\n    }, {});\n// keep track of the cookies we have to delete after the request is made\nlet $c2848ebcf924d7cd$var$cookiesToDelete = {};\nconst $c2848ebcf924d7cd$var$removeRequestCookies = async ()=>{\n    if (!!$c2848ebcf924d7cd$var$cookiesToDelete.url && !!$c2848ebcf924d7cd$var$cookiesToDelete.cookies) {\n        for (const name of $c2848ebcf924d7cd$var$cookiesToDelete.cookies)await chrome.cookies.remove({\n            url: $c2848ebcf924d7cd$var$cookiesToDelete.url,\n            name: name\n        });\n        $c2848ebcf924d7cd$var$cookiesToDelete = {};\n    }\n};\nconst $c2848ebcf924d7cd$var$processRequestCookies = async (reqConfig)=>{\n    const cookie = Object.entries(reqConfig.headers || {}).find(([header])=>header.toLowerCase() === \"cookie\");\n    if (!!cookie && !!reqConfig.url && typeof cookie[1] === \"string\") {\n        $c2848ebcf924d7cd$var$cookiesToDelete = {\n            url: reqConfig.url,\n            cookies: []\n        };\n        const parsedCookies = $c2848ebcf924d7cd$var$parseCookieString(cookie[1]);\n        for (const [name, value] of Object.entries(parsedCookies)){\n            await chrome.cookies.set({\n                url: reqConfig.url,\n                name: name,\n                value: value\n            });\n            $c2848ebcf924d7cd$var$cookiesToDelete.cookies.push(name);\n        }\n    }\n    return reqConfig;\n};\nconst $c2848ebcf924d7cd$var$processRequestFormData = (reqConfig)=>{\n    if (reqConfig.formData || reqConfig.formFiles) {\n        const form = new FormData();\n        reqConfig.formFiles.forEach(({ key: key, value: value, filename: filename })=>{\n            form.append(key, $c2848ebcf924d7cd$var$convertDataURLToBlob(value), filename);\n        });\n        reqConfig.formData.forEach(({ key: key, value: value })=>{\n            form.append(key, value);\n        });\n        reqConfig.data = form;\n        reqConfig.formFiles = null;\n        reqConfig.formData = null;\n    }\n    return reqConfig;\n};\nconst $c2848ebcf924d7cd$var$processRequest = async (reqConfig)=>{\n    await $c2848ebcf924d7cd$var$processRequestCookies(reqConfig);\n    return $c2848ebcf924d7cd$var$processRequestFormData(reqConfig);\n};\nfunction $c2848ebcf924d7cd$var$bufferToBase64(buffer) {\n    return btoa(new Uint8Array(buffer).reduce((data, byte)=>{\n        return data + String.fromCharCode(byte);\n    }, \"\"));\n}\nconst $c2848ebcf924d7cd$var$processDataBasedOnContentType = async (data, contentTypeHeader)=>{\n    if (contentTypeHeader && (contentTypeHeader.startsWith(\"application/json\") || contentTypeHeader.startsWith(\"application/vnd.api+json\") || contentTypeHeader.startsWith(\"application/hal+json\"))) try {\n        data = JSON.parse(data);\n    } catch (e) {}\n};\nconst $c2848ebcf924d7cd$var$getAllFetchResponseHeaders = (fetchHeaders)=>{\n    const headers = {};\n    fetchHeaders.forEach((value, key)=>{\n        headers[key] = value;\n    });\n    return headers;\n};\nconst $c2848ebcf924d7cd$var$handleSendRequestMessage = async (config)=>{\n    try {\n        const processedConfig = await $c2848ebcf924d7cd$var$processRequest(config);\n        if (config.wantsBinary) {\n            const [r, requestMeta] = await $c2848ebcf924d7cd$var$fetchUsingAxiosConfig({\n                ...processedConfig,\n                responseType: \"arraybuffer\",\n                validateStatus: ()=>true\n            });\n            let headers = $c2848ebcf924d7cd$var$getAllFetchResponseHeaders(r.headers);\n            return {\n                messageType: \"recv-req\",\n                data: {\n                    response: {\n                        status: r.status,\n                        statusText: r.statusText,\n                        headers: headers,\n                        responseURL: r.url,\n                        data: $c2848ebcf924d7cd$var$bufferToBase64(await r.arrayBuffer()),\n                        timeData: requestMeta.timeData\n                    },\n                    isBinary: true,\n                    error: null\n                }\n            };\n        } else {\n            const [res, requestMeta] = await $c2848ebcf924d7cd$var$fetchUsingAxiosConfig({\n                ...processedConfig\n            });\n            const resText = await res.text();\n            const contentTypeHeader = res.headers.get(\"content-type\");\n            const data = await $c2848ebcf924d7cd$var$processDataBasedOnContentType(resText, contentTypeHeader);\n            let headers = $c2848ebcf924d7cd$var$getAllFetchResponseHeaders(res.headers);\n            return {\n                messageType: \"recv-req\",\n                data: {\n                    response: {\n                        status: res.status,\n                        statusText: res.statusText,\n                        headers: headers,\n                        responseURL: res.url,\n                        data: data,\n                        timeData: requestMeta.timeData\n                    },\n                    isBinary: false,\n                    error: null\n                }\n            };\n        }\n    } catch (e) {\n        return {\n            messageType: \"recv-req\",\n            data: {\n                response: null,\n                error: $c2848ebcf924d7cd$var$errorToObject(e)\n            }\n        };\n    } finally{\n        // remove the cookies set for this request\n        await $c2848ebcf924d7cd$var$removeRequestCookies();\n    }\n};\nconst $c2848ebcf924d7cd$var$cancelRequest = ()=>{\n    $c2848ebcf924d7cd$var$abortController.abort();\n    // reset the abort controller for the next request\n    $c2848ebcf924d7cd$var$abortController = new AbortController();\n};\nchrome.runtime.onMessage.addListener((message, _sender, sendResponse)=>{\n    if (message.messageType === \"send-req\") {\n        $c2848ebcf924d7cd$var$handleSendRequestMessage(message.data).then(sendResponse);\n        return true;\n    } else if (message.messageType === \"cancel-req\") {\n        $c2848ebcf924d7cd$var$cancelRequest();\n        return true;\n    }\n});\nlet $c2848ebcf924d7cd$var$originList = [];\nchrome.storage.sync.get((items)=>{\n    $c2848ebcf924d7cd$var$originList = JSON.parse(items[\"originList\"]);\n});\nchrome.storage.onChanged.addListener((changes, _areaName)=>{\n    if (changes.originList && changes.originList.newValue) $c2848ebcf924d7cd$var$originList = JSON.parse(changes.originList.newValue);\n});\nchrome.tabs.onUpdated.addListener((_id, _info, tab)=>{\n    if (tab.status !== \"loading\") chrome.tabs.sendMessage(tab.id, {\n        action: \"__POSTWOMAN_EXTENSION_PING__\"\n    }, (_response)=>{\n        if (chrome.runtime.lastError) chrome.scripting.executeScript({\n            target: {\n                tabId: tab.id\n            },\n            files: [\n                \"contentScript.js\"\n            ]\n        });\n        else console.log(\"Already hooked\");\n    });\n});\nchrome.runtime.onInstalled.addListener(()=>{\n    chrome.storage.sync.get((items)=>{\n        if (!items.originList) chrome.storage.sync.set({\n            originList: JSON.stringify((0, $cg86O.DEFAULT_ORIGIN_LIST))\n        }, ()=>{});\n    });\n});\nchrome.runtime.onMessage.addListener((message, sender)=>{\n    if (message.type && message.type == \"execute_hook\" && sender.tab.id) {\n        const files = message.origin_type == \"VALID_ORIGIN\" ? [\n            \"hookContent.js\"\n        ] : [\n            \"hookContentInvalidOrigin.js\"\n        ];\n        chrome.scripting.executeScript({\n            target: {\n                tabId: sender.tab.id\n            },\n            files: files,\n            world: \"MAIN\"\n        });\n    }\n});\n\n})();\n//# sourceMappingURL=index.js.map\n","export const DEFAULT_ORIGIN_LIST = [\"https://hoppscotch.io\"]\n","import { AxiosRequestConfig, AxiosRequestHeaders } from \"axios\"\nimport { DEFAULT_ORIGIN_LIST } from \"./defaultOrigins\"\n\ntype HoppExtensionRequestMeta = {\n  timeData?: {\n    startTime?: number\n    endTime?: number\n  }\n}\n\nlet abortController = new AbortController()\n\nconst convertAxiosHeadersIntoFetchHeaders = (headers: AxiosRequestHeaders) =>\n  Object.entries(headers).reduce((fetchHeaders, [key, value]): HeadersInit => {\n    // setting content-type when using fetch will break the upload unless we provide a proper boundary.\n    // but we omit that header and browser will set the correct boundary itself.\n    return key == \"content-type\" && headers[key] == \"multipart/form-data\"\n      ? { ...fetchHeaders }\n      : {\n          ...fetchHeaders,\n          [key]: value.toString(),\n        }\n  }, <HeadersInit>{})\n\nasync function fetchUsingAxiosConfig(\n  axiosConfig: AxiosRequestConfig<any>\n): Promise<[Response, HoppExtensionRequestMeta]> {\n  const fetchHeaders = convertAxiosHeadersIntoFetchHeaders(axiosConfig.headers)\n\n  const requestMeta: HoppExtensionRequestMeta = { timeData: {} }\n  requestMeta.timeData.startTime = new Date().getTime()\n\n  const params = axiosConfig.params\n\n  if (params) {\n    try {\n      const searchParams = new URLSearchParams(axiosConfig.url.split(\"?\")[1])\n      Object.keys(params).forEach((key) => {\n        searchParams.append(key, params[key])\n      })\n\n      axiosConfig.url =\n        axiosConfig.url.split(\"?\")[0] + `?${searchParams.toString()}`\n    } catch (_) {}\n  }\n\n  // TODO: check different examples with axios body\n  const res = await fetch(axiosConfig.url, {\n    headers: {\n      ...fetchHeaders,\n    },\n    method: axiosConfig.method,\n\n    // Ignore the body for GET and HEAD requests to prevent error with axios\n    body: ([\"get\", \"head\"].includes(axiosConfig.method?.toLowerCase())) ? undefined : axiosConfig.data,\n    signal: abortController.signal,\n  })\n\n  requestMeta.timeData.endTime = new Date().getTime()\n\n  return [res, requestMeta]\n}\n\nfunction errorToObject(e: any) {\n  if (e.response && e.response.data) {\n    try {\n      e.response.data = bufferToBase64(e.response.data)\n    } catch (_e) {}\n  }\n\n  // This mess below is a hack to go around Firefox's memory bounding system\n  return {\n    // Standard\n    message: e.message ? JSON.parse(JSON.stringify(e.message)) : undefined,\n    name: e.name ? JSON.parse(JSON.stringify(e.name)) : undefined,\n    // Mozilla\n    fileName: e.fileName ? JSON.parse(JSON.stringify(e.fileName)) : undefined,\n    lineNumber: e.lineNumber\n      ? JSON.parse(JSON.stringify(e.lineNumber))\n      : undefined,\n    columnNumber: e.columnNumber\n      ? JSON.parse(JSON.stringify(e.columnNumber))\n      : undefined,\n    stack: e.stack ? JSON.parse(JSON.stringify(e.stack)) : undefined,\n    // Axios\n    response: e.response ? JSON.parse(JSON.stringify(e.response)) : undefined,\n  }\n}\n\ninterface PWChromeMessage<T> {\n  messageType: \"send-req\" | \"recv-req\" | \"cancel-req\"\n  data: T\n}\n\ninterface RecvRequestMessageData {\n  response: any\n  error: any | null\n  isBinary: boolean\n}\n\nconst convertDataURLToBlob = (dataurl: string) => {\n  const arr = dataurl.split(\",\")\n  const mime = arr[0].match(/:(.*?);/)[1]\n  const bstr = atob(arr[1])\n  let n = bstr.length\n  const u8arr = new Uint8Array(n)\n\n  while (n--) {\n    u8arr[n] = bstr.charCodeAt(n)\n  }\n\n  const blob = new Blob([u8arr], { type: mime })\n  return blob\n}\n\nconst parseCookieString: (str: string) => { [property: string]: string } = (\n  str\n) =>\n  str\n    .split(\";\")\n    .map((value) => value.split(\"=\"))\n    .reduce((acc, curr) => {\n      if (!!curr[0] && !!curr[1]) {\n        acc[decodeURIComponent(curr[0].trim())] = decodeURIComponent(\n          curr[1].trim()\n        )\n      }\n      return acc\n    }, {} as { [property: string]: string })\n\n// keep track of the cookies we have to delete after the request is made\nlet cookiesToDelete: { url?: string; cookies?: string[] } = {}\nconst removeRequestCookies: () => Promise<void> = async () => {\n  if (!!cookiesToDelete.url && !!cookiesToDelete.cookies) {\n    for (const name of cookiesToDelete.cookies) {\n      await chrome.cookies.remove({\n        url: cookiesToDelete.url,\n        name,\n      })\n    }\n\n    cookiesToDelete = {}\n  }\n}\n\nconst processRequestCookies: (\n  reqConfig: any\n) => Promise<AxiosRequestConfig> = async (reqConfig) => {\n  const cookie = Object.entries(reqConfig.headers || {}).find(\n    ([header]) => header.toLowerCase() === \"cookie\"\n  )\n\n  if (!!cookie && !!reqConfig.url && typeof cookie[1] === \"string\") {\n    cookiesToDelete = { url: reqConfig.url, cookies: [] }\n    const parsedCookies = parseCookieString(cookie[1])\n\n    for (const [name, value] of Object.entries(parsedCookies)) {\n      await chrome.cookies.set({\n        url: reqConfig.url,\n        name,\n        value,\n      })\n      cookiesToDelete.cookies.push(name)\n    }\n  }\n\n  return reqConfig\n}\n\nconst processRequestFormData: (reqConfig: any) => AxiosRequestConfig = (\n  reqConfig\n) => {\n  if (reqConfig.formData || reqConfig.formFiles) {\n    const form = new FormData()\n\n    reqConfig.formFiles.forEach(\n      ({\n        key,\n        value,\n        filename,\n      }: {\n        key: string\n        value: string\n        filename: string\n      }) => {\n        form.append(key, convertDataURLToBlob(value), filename)\n      }\n    )\n\n    reqConfig.formData.forEach(\n      ({ key, value }: { key: string; value: string }) => {\n        form.append(key, value)\n      }\n    )\n\n    reqConfig.data = form\n    reqConfig.formFiles = null\n    reqConfig.formData = null\n  }\n\n  return reqConfig as AxiosRequestConfig\n}\n\nconst processRequest: (reqConfig: any) => Promise<AxiosRequestConfig> = async (\n  reqConfig\n) => {\n  await processRequestCookies(reqConfig)\n  return processRequestFormData(reqConfig)\n}\n\nfunction bufferToBase64(buffer: any) {\n  return btoa(\n    new Uint8Array(buffer).reduce((data, byte) => {\n      return data + String.fromCharCode(byte)\n    }, \"\")\n  )\n}\n\nconst processDataBasedOnContentType = async (\n  data: string,\n  contentTypeHeader: string\n) => {\n  if (\n    contentTypeHeader &&\n    (contentTypeHeader.startsWith(\"application/json\") ||\n      contentTypeHeader.startsWith(\"application/vnd.api+json\") ||\n      contentTypeHeader.startsWith(\"application/hal+json\"))\n  ) {\n    try {\n      data = JSON.parse(data)\n    } catch (e) {}\n  }\n}\n\nconst getAllFetchResponseHeaders = (\n  fetchHeaders: Headers\n): Record<string, string> => {\n  const headers: Record<string, string> = {}\n\n  fetchHeaders.forEach((value, key) => {\n    headers[key] = value\n  })\n\n  return headers\n}\n\nconst handleSendRequestMessage = async (config: any) => {\n  try {\n    const processedConfig = await processRequest(config)\n\n    if (config.wantsBinary) {\n      const [r, requestMeta] = await fetchUsingAxiosConfig({\n        ...processedConfig,\n        responseType: \"arraybuffer\",\n        validateStatus: () => true,\n      })\n\n      let headers = getAllFetchResponseHeaders(r.headers)\n\n      return <PWChromeMessage<RecvRequestMessageData>>{\n        messageType: \"recv-req\",\n        data: {\n          response: {\n            status: r.status,\n            statusText: r.statusText,\n            headers,\n            responseURL: r.url,\n            data: bufferToBase64(await r.arrayBuffer()),\n            timeData: requestMeta.timeData,\n          },\n          isBinary: true,\n          error: null,\n        },\n      }\n    } else {\n      const [res, requestMeta] = await fetchUsingAxiosConfig({\n        ...processedConfig,\n      })\n\n      const resText = await res.text()\n      const contentTypeHeader = res.headers.get(\"content-type\")\n\n      const data = await processDataBasedOnContentType(\n        resText,\n        contentTypeHeader\n      )\n\n      let headers = getAllFetchResponseHeaders(res.headers)\n\n      return <PWChromeMessage<RecvRequestMessageData>>{\n        messageType: \"recv-req\",\n        data: {\n          response: {\n            status: res.status,\n            statusText: res.statusText,\n            headers,\n            responseURL: res.url,\n            data: data,\n            timeData: requestMeta.timeData,\n          },\n          isBinary: false,\n          error: null,\n        },\n      }\n    }\n  } catch (e) {\n    return <PWChromeMessage<RecvRequestMessageData>>{\n      messageType: \"recv-req\",\n      data: {\n        response: null,\n        error: errorToObject(e),\n      },\n    }\n  } finally {\n    // remove the cookies set for this request\n    await removeRequestCookies()\n  }\n}\n\nconst cancelRequest = () => {\n  abortController.abort()\n\n  // reset the abort controller for the next request\n  abortController = new AbortController()\n}\n\nchrome.runtime.onMessage.addListener(\n  (message: PWChromeMessage<any>, _sender, sendResponse) => {\n    if (message.messageType === \"send-req\") {\n      handleSendRequestMessage(message.data).then(sendResponse)\n      return true\n    } else if (message.messageType === \"cancel-req\") {\n      cancelRequest()\n      return true\n    }\n  }\n)\n\nlet originList: string[] = []\n\nchrome.storage.sync.get((items) => {\n  originList = JSON.parse(items[\"originList\"])\n})\n\nchrome.storage.onChanged.addListener((changes, _areaName) => {\n  if (changes.originList && changes.originList.newValue) {\n    originList = JSON.parse(changes.originList.newValue)\n  }\n})\n\nchrome.tabs.onUpdated.addListener((_id, _info, tab) => {\n  if (tab.status !== \"loading\") {\n    chrome.tabs.sendMessage(\n      tab.id,\n      {\n        action: \"__POSTWOMAN_EXTENSION_PING__\",\n      },\n      (_response: boolean) => {\n        if (chrome.runtime.lastError) {\n          chrome.scripting.executeScript({\n            target: { tabId: tab.id },\n            files: [\"contentScript.js\"],\n          })\n        } else {\n          console.log(\"Already hooked\")\n        }\n      }\n    )\n  }\n})\n\nchrome.runtime.onInstalled.addListener(() => {\n  chrome.storage.sync.get((items) => {\n    if (!items.originList) {\n      chrome.storage.sync.set(\n        {\n          originList: JSON.stringify(DEFAULT_ORIGIN_LIST),\n        },\n        () => {}\n      )\n    }\n  })\n})\n\nchrome.runtime.onMessage.addListener((message, sender) => {\n  if (message.type && message.type == \"execute_hook\" && sender.tab.id) {\n    const files =\n      message.origin_type == \"VALID_ORIGIN\"\n        ? [\"hookContent.js\"]\n        : [\"hookContentInvalidOrigin.js\"]\n\n    chrome.scripting.executeScript({\n      target: {\n        tabId: sender.tab.id,\n      },\n      files,\n      world: \"MAIN\",\n    })\n  }\n})\n"],"names":["$parcel$global","globalThis","$parcel$modules","$parcel$inits","parcelRequire","id","exports","init","module","call","err","Error","code","register","parcelRegister","Object","defineProperty","get","$40edc2589855dfe4$export$90f2c8d1f20401a","set","s","enumerable","configurable","$cg86O","$c2848ebcf924d7cd$var$abortController","AbortController","$c2848ebcf924d7cd$var$convertAxiosHeadersIntoFetchHeaders","headers","entries","reduce","fetchHeaders","key","value","toString","$c2848ebcf924d7cd$var$fetchUsingAxiosConfig","axiosConfig","requestMeta","timeData","startTime","Date","getTime","params","searchParams","URLSearchParams","url","split","keys","forEach","append","_","res","fetch","method","body","includes","toLowerCase","undefined","data","signal","endTime","$c2848ebcf924d7cd$var$convertDataURLToBlob","dataurl","arr","mime","match","bstr","atob","n","length","u8arr","Uint8Array","charCodeAt","blob","Blob","type","$c2848ebcf924d7cd$var$parseCookieString","str","map","acc","curr","decodeURIComponent","trim","$c2848ebcf924d7cd$var$cookiesToDelete","$c2848ebcf924d7cd$var$removeRequestCookies","cookies","name","chrome","remove","$c2848ebcf924d7cd$var$processRequestCookies","reqConfig","cookie","find","header","parsedCookies","push","$c2848ebcf924d7cd$var$processRequestFormData","formData","formFiles","form","FormData","filename","$c2848ebcf924d7cd$var$processRequest","$c2848ebcf924d7cd$var$bufferToBase64","buffer","btoa","byte","String","fromCharCode","$c2848ebcf924d7cd$var$processDataBasedOnContentType","contentTypeHeader","startsWith","JSON","parse","e","$c2848ebcf924d7cd$var$getAllFetchResponseHeaders","$c2848ebcf924d7cd$var$handleSendRequestMessage","config","processedConfig","wantsBinary","r","responseType","validateStatus","messageType","response","status","statusText","responseURL","arrayBuffer","isBinary","error","resText","text","$c2848ebcf924d7cd$var$errorToObject","_e","message","stringify","fileName","lineNumber","columnNumber","stack","$c2848ebcf924d7cd$var$cancelRequest","abort","runtime","onMessage","addListener","_sender","sendResponse","then","storage","sync","items","onChanged","changes","_areaName","originList","newValue","tabs","onUpdated","_id","_info","tab","sendMessage","action","_response","lastError","scripting","executeScript","target","tabId","files","console","log","onInstalled","DEFAULT_ORIGIN_LIST","sender","origin_type","world"],"version":3,"file":"index.js.map"}